===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"üóÇ CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "‚úÖ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("‚úÖ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("üóë Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("‚ö†Ô∏è Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "üíæ Tree saved to versioned file.".postln;
} {
    "‚ö†Ô∏è No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "‚úÖ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "‚ùå Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("‚úÖ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"üíæ Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandNode test.scd =====
(
// Set a fixed random seed for reproducibility
thisThread.randSeed = 12345;

// Global node counter and limit
~nodeLimit = 50;
~nodeCount = 1;
~fixedChildren = 3;

// Create root node
~root = MDCommandNode.new("root", 0);

// Breadth-first queue
~nodeQueue = List[~root];

// Build tree
while {
    (~nodeQueue.notEmpty and: { ~nodeCount < ~nodeLimit })
} {
    var parent = ~nodeQueue.removeAt(0);
    ("Adding " ++ ~fixedChildren ++ " children to " ++ parent.name).postln;

    ~fixedChildren.do {
        if (~nodeCount < ~nodeLimit) {
            var childName = parent.name ++ "_" ++ ~nodeCount;
            var child = MDCommandNode.new(childName, ~nodeCount);
            parent.addChild(child);
            ~nodeQueue.add(child);
            ("Created node: " ++ child.name ++ " | Total nodes: " ++ ~nodeCount).postln;
            ~nodeCount = ~nodeCount + 1;
        };
    };
};

// Print tree
"Generated Tree Structure:".postln;
~root.printTreePretty("", true);

// Check integrity
"Running integrity check...".postln;
~root.checkIntegrity;

// Count total nodes
~countNodes = { |node|
    var count = 1;
    node.children.do { |c|
        count = count + ~countNodes.(c);
    };
    ^count;
};

("‚úÖ Total nodes in tree: " ++ ~countNodes.(~root)).postln;
"Tree printed.".postln;
"end".postln;
)


b = MDCommandTree("root", 0);

===== CommandTree/MDCommandNodeTest20250731.scd =====
(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 3);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 11);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 7);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 5);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 11);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 11);


// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;

)



/////////////////////
/// BUILD A TREE - older version.
/////////////////////

(
// Setup
var tree, root, lvl1A, lvl1B, lvl2A, lvl2B, lvl3A, lvl3B, lvl3C;
var printSummary;

// üå± Initialize tree and root
tree = MDCommandTree.new("root", 0, 1);
root = tree.root;

// üß© Level 1
lvl1A = tree.addNode(root.id, "Branch A", 2);
lvl1B = tree.addNode(root.id, "Branch B", 3);

// üß© Level 2
lvl2A = tree.addNode(lvl1A.id, "SubBranch A1", 4);
lvl2B = tree.addNode(lvl1B.id, "SubBranch B1", 5);

// üß© Level 3
lvl3A = tree.addNode(lvl2A.id, "Twig A1a", 6);
lvl3B = tree.addNode(lvl2A.id, "Twig A1b", 7);
lvl3C = tree.addNode(lvl2B.id, "Twig B1a", 8);

// üè∑Ô∏è Tag depth from root
tree.root.tagByDepth(0);

// üìã Node Summary
printSummary = {
    tree.nodeMap.values.do { |node|
        (node.name ++ " ‚Üí depthTag: " ++ node.depthTag ++ ", getDepth: " ++ node.getDepth).postln;
    };
};

// üñºÔ∏è Print results
printSummary.();
tree.printTreePretty;

tree.getNodeByName("Twig A1b").printPathToRoot;

)

===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/out/MDCommandNodeTest20250728.scd =====
// MDCommandNodeTest20250728.scd


(
var root = MDCommandNode.new("root", 0);
var a = root.createChild("a", 1, 1);
var b = root.createChild("b", 2, 1);

a.createChild("c", 3, 1);
a.createChild("d", 4, 1);
b.createChild("e", 5, 1);

// Audit structure
("Children of root: " ++ root.children.collect(_.name)).postln;
("Children of a: " ++ a.children.collect(_.name)).postln;
("Children of b: " ++ b.children.collect(_.name)).postln;

root.printTreePretty;
)

/////////////////

(
var tree, root, a, b;

// Create tree manager
tree = MDCommandTree.new;
tree.nodeMap = IdentityDictionary.new;
tree.nodeCount = 0;

// Create root node and register it
root = MDCommandNode.new("root", 0, 0);
tree.nodeMap.put(0, root);

// Add nodes using safe syntax
a = tree.addNode(0, "a", 1);
b = tree.addNode(0, "b", 1);

// Optional: continue only if valid
if (a.notNil) {
    tree.addNode(a.id, "c", 1);
    tree.addNode(a.id, "d", 1);
};
if (b.notNil) {
    tree.addNode(b.id, "e", 1);
};

// Audit and print
("Children of root: " ++ root.children.collect(_.name)).postln;
("Children of a: " ++ (a.notNil.if { a.children.collect(_.name) } { "‚ùå 'a' missing" })).postln;
("Children of b: " ++ (b.notNil.if { b.children.collect(_.name) } { "‚ùå 'b' missing" })).postln;

("Tree:").postln;
root.printTreePretty;

"".postln;
"Tree class:".postln;
tree.class;

tree.removeNode(5);
tree.swapNodes;
)


===== CommandTree/out/MDCommandNodeTest20250731_bu1352.scd =====
(
// üß± Declare all vars up front
var leafA, leafB, leafC, node1, node2, root;
var testNodeMethods;

// üåø Construct tree
leafA = MDCommandNode.new;
leafB = MDCommandNode.new;
leafC = MDCommandNode.new;
node1 = MDCommandNode.new;
node2 = MDCommandNode.new;
root = MDCommandNode.new;

node1.children = [leafA, leafB];       // node1 has two leaves
node2.children = [leafC];              // node2 has one leaf
root.children = [node1, node2];        // root has two intermediate nodes

// üîç Testing function for nodes
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();  // if implemented
    depth = node.getDepth();

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    "---".postln;
};

// üöÄ Run tests
[
    testNodeMethods.(leafA, "Leaf A"),
    testNodeMethods.(node1, "Node 1"),
    testNodeMethods.(node2, "Node 2"),
    testNodeMethods.(root, "Root Node")
];
)

===== CommandTree/out/MDCommandSystemTest20250811.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/test_circularSaves20250826.scd =====
// test_circularSaves20250826.scd
// MD



(
// Step 1: Load the latest saved tree version
~tree = MDCommandTree.new("root");
~loaded = ~tree.loadLatestVersion;

if (~loaded) {
    "Latest tree loaded.".postln;
    "Tree before modification:".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved tree found. Starting with empty tree.".postln;
};
)

(
// Step 2: Save current version for comparison
~originalJSON = ~tree.saver.latestVersion;
)

(
// Step 3: Modify the tree
~newNode = ~tree.addNode(0, "NewNode", 99);

if (~newNode.notNil) {
    "New node added.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add new node.".postln;
};
)

(
// Step 4: Save the modified tree as a new version
~tree.saveVersioned;
)

(
// Step 5: Compare original and new JSON
~newJSON = ~tree.saver.latestVersion;

if (~originalJSON != ~newJSON) {
    "Change confirmed: tree content has been updated.".postln;
} {
    "‚ö†Ô∏è No change detected between versions.".postln;
};
)













// (
// // Step 1: Create a new tree
// ~tree = MDCommandTree.new("root");
//
// // Step 2: Add some nodes
// ~tree.addNode(0, "A", 1);
// ~tree.addNode(1, "B", 2);
// ~tree.addNode(2, "C", 3);
// "‚úÖ Nodes added.".postln;
// ~tree.printTreePretty;
// )
//
// (
// // Step 3: Save the tree using CircularFileSave
// ~tree.saveVersioned;
// )
//
// (
// // Step 4: List saved versions
// ~tree.listSavedVersions;
// )
//
// (
// // Step 5: Load the latest saved version
// ~tree.loadLatestVersion;
// )
//
// (
// // Step 6: Print the tree to confirm it was restored
// "‚úÖ Tree after loading latest version:".postln;
// ~tree.printTreePretty;
// )

===== CommandTree/testCircularSave_20250819.scd =====
// Create a saver
~saver = CircularFileSave.new("myTree");

// Save a version
~saver.saveVersion("This is version " ++ Date.getDate.stamp);

// List saved versions
~saver.listVersions;

// Load a specific version
~saver.loadVersion(0).postln;

===== CommandTree/Tests/TestLogging_CommandBuilder.scd =====
TestLogging_CommandBuilder.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var jsonPath, tree, builder;

MDMiniLogger.get.setverbosity(3); // DEBUG

jsonPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
tree = MDCommandTree.new("root");
tree.importJSONFile(jsonPath);

builder = MDCommandBuilder.new(tree);
builder.printChildren;
builder.navigateByName(nil, "SomeChildName"); // INFO/WARN depending on your tree
builder.resetNavigation;
builder.printfretPath;
)

===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path ‚Üí " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) ‚Äî informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic ‚Äî print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' ‚Üí " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported ‚Üí " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("‚ö†Ô∏è Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== CommandTree/Tests/TestLogging_FullBringUp.scd =====
TestLogging_FullBringUp.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var lps;
MDMiniLogger.get.setverbosity(2); // INFO

lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;

// Switch to DEBUG if you want more detail for a moment
MDMiniLogger.get.setverbosity(3);

lps.commandManager.setStatus("Sanity check: status via MDMiniLogger");
)

===== CommandTree/TestUserDisplay.scd =====
(
~displayTest = UserDisplay.new;

~displayTest.display(\state, "üß≠ State: treeNav");
~displayTest.display(\queue, "üìã Queue: audio ‚Üí noise ‚Üí 100");
~displayTest.display(\lastCommand, "üïò Last Command: 100");
~displayTest.display(\choices, "üéö Choices:\nFret 7: noise\nFret 9: oscillators");
)

===== CommandTree/testVerbosity.scd =====
// temp

(
// üß™ Set verbosity level to 0 (errors only)
Verbosity.setLevel(0);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 2 (up to input/output)
Verbosity.setLevel(2);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 4 (everything)
Verbosity.setLevel(4);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");
)

Verbosity.help;
===== LivePedalboardSystem/CommandTreeStructureDiagram.scd =====
// updated 20250922-2147

root
‚îú‚îÄ‚îÄ audio (string 6, fret 1)
‚îÇ   ‚îú‚îÄ‚îÄ source      (string 5, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ testmelody (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sine       (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ noise      (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ timebased   (string 5, fret 5)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delay     (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ multitap  (string 3, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pingpong  (string 3, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chorus    (string 4, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ modulation (string 5, fret 7)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tremolo   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phaser    (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ flanger   (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ filter (string 5, fret 9)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lowpass   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ highpass  (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bandpass  (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ reverb (string 5, fret 11)
‚îÇ   ‚îî‚îÄ‚îÄ drive  (string 5, fret 13)

‚îú‚îÄ‚îÄ chain (string 6, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ add         (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ remove      (string 5, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ swap        (string 5, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ bypass      (string 5, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ clear       (string 5, fret 11)
‚îÇ   ‚îú‚îÄ‚îÄ setsource   (string 5, fret 13)
‚îÇ   ‚îî‚îÄ‚îÄ print       (string 5, fret 15)

‚îú‚îÄ‚îÄ switch (string 6, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ crossfade         (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ crossfade_custom  (string 5, fret 5)

‚îú‚îÄ‚îÄ preset (string 6, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ save        (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ load        (string 5, fret 5)

‚îú‚îÄ‚îÄ system (string 6, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ reset       (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ healthcheck (string 5, fret 5)
‚îÇ   ‚îî‚îÄ‚îÄ status      (string 5, fret 7)
===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue‚Üíadapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ‚Üê ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil ‚Üí class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;

        //New: install the queue‚Üíadapter bridge (SHORT canonicals ‚Üí MPB)
        ~system.installAdapterBridge;
    }.defer;
)


===== LivePedalboardSystem/Tests/Demo_Today_Playbook_FallbackOnly.scd =====
// Demo_Today_Playbook_FallbackOnly.scd
// v0.1.3
// MD 2025-09-22 23:45 BST

/* Purpose
   - Hardware-independent fallback to demonstrate MagicPedalboardNew.
   - Applies canonical commands in sequence, EVEN IF hardware is connected.
   - If your adapter (~ct_applyOSCPathToMPB) is present, it is used; otherwise
     this script calls MagicPedalboardNew methods directly for /add, /setSource,
/switch, /bypass commands.
   - Uses generated audio only (no SoundIn) and enforces Option A exclusivity.

   Style
   - tilde vars ok at top level; var-first in every function/closure.
   - lowercase method names; no server.sync; Server.default.bind for Ndef ops.
   - AppClock-only UI updates; no caret returns in deferred closures.
*/

(

var gapSeconds, playlistA, playlistB,
    systemReady, pedalboardReady,
    logMessage, showGuiHint,
    ensureGeneratedSources,
    tryEnsureAdapter, adapterAvailable, applyViaAdapter,
    applyDirectToPedalboard, applyOneCommand,
    runPlaylist, stopPlaylist, startGeneration;

"[FALLBACK] entered".postln;
thisProcess.nowExecutingPath.postln;  // helps confirm you ran the right file

// ‚îÄ‚îÄ settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gapSeconds = 0.60;
playlistA  = [ "/add/delay", "/switch" ];
playlistB  = [ "/bypass/delay/on", "/bypass/delay/off", "/switch" ];

// ‚îÄ‚îÄ guards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
systemReady     = ~system.notNil;
pedalboardReady = systemReady and: { ~system.pedalboard.notNil };


if(systemReady.not) {
    "‚ö†Ô∏è  Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B)".warn;
    ^nil;
};

// ‚îÄ‚îÄ logging + GUI hint ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logMessage = { |text| ("[FALLBACK] " ++ text).postln };
showGuiHint = { |text|
    var canShow;
    canShow = (~system.notNil)
        and: { ~system.statusDisplay.notNil }
        and: { ~system.statusDisplay.respondsTo(\showExpectation) };
    if(canShow) { ~system.statusDisplay.showExpectation(text, 0) };
};

// ‚îÄ‚îÄ audio sources + option A exclusivity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ensureGeneratedSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, frequencySeq, freq, env, pan;
                trig         = Impulse.kr(3.2);
                frequencySeq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq         = Demand.kr(trig, 0, frequencySeq);
                env          = Decay2.kr(trig, 0.01, 0.35);
                pan          = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    if(~mpb.notNil) {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.setSource(\testmelody);
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
    };
};

// ‚îÄ‚îÄ try to use your adapter (~ct_applyOSCPathToMPB) if available ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tryEnsureAdapter = {
    var scriptFolderPath, candidateNames, found;
    if(~ct_applyOSCPathToMPB.notNil) { ^true };

    scriptFolderPath = PathName(thisProcess.nowExecutingPath).pathOnly;
    candidateNames = [
        "adapter_CommandTree_to_MagicPedalboard.scd",
        "adapter_commandtree_to_magicpedalboard.scd"
    ];
    found = candidateNames.detect({ |leaf|
        var fullPath = scriptFolderPath +/+ leaf;
        File.exists(fullPath).if({ fullPath.load; true }, { false })
    });

    (~ct_applyOSCPathToMPB.notNil)
};
adapterAvailable = tryEnsureAdapter.();

applyViaAdapter = { |canonicalPath|
    var guiRef;
    guiRef = ~system.statusDisplay;
    // signature from your existing adapter: (path, mpb, gui)
    ~ct_applyOSCPathToMPB.(canonicalPath, ~system.pedalboard, guiRef);
};

// ‚îÄ‚îÄ direct mapping for the demo verbs if adapter is absent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyDirectToPedalboard = { |canonicalPath|
    var pathSegments, verbName, effectSymbol, sourceSymbol,
        onOffString, bypassState, pedalboardRef;

    pedalboardRef = ~system.pedalboard;
    if(pedalboardRef.isNil) { logMessage.("pedalboard missing"); ^nil };

    pathSegments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(pathSegments.size == 0) { ^nil };
    verbName = pathSegments[0].asString;

    switch(verbName,

        "add", {
            if(pathSegments.size >= 2) {
                effectSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(effectSymbol);
                }{
                    logMessage.("no pedalboard.add; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /add path: " ++ canonicalPath);
            };
        },

        "setSource", {
            if(pathSegments.size >= 2) {
                sourceSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\setSource)) {
                    pedalboardRef.setSource(sourceSymbol);
                }{
                    logMessage.("no pedalboard.setSource; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /setSource path: " ++ canonicalPath);
            };
        },

        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                pedalboardRef.switchChain(0.12);
            }{
                logMessage.("no pedalboard.switchChain; skipped: " ++ canonicalPath);
            };
        },

        "bypass", {
            if(pathSegments.size >= 3) {
                effectSymbol = pathSegments[1].asSymbol;
                onOffString  = pathSegments[2].asString.toLower;
                bypassState  = (onOffString == "on") or: { onOffString == "true" } or: { onOffString == "1" };
                // for demo: act on CURRENT; your adapter usually controls NEXT
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(effectSymbol, bypassState);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        pedalboardRef.bypass(effectSymbol, bypassState);
                    }{
                        logMessage.("no pedalboard.bypass; skipped: " ++ canonicalPath);
                    };
                };
            }{
                logMessage.("bad /bypass path: " ++ canonicalPath);
            };
        },

        { // default
            logMessage.("unhandled verb: " ++ verbName ++ " (path=" ++ canonicalPath ++ ")");
        }
    );
};

// ‚îÄ‚îÄ unified apply: prefer adapter; fall back to direct mapping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyOneCommand = { |canonicalPath|
    logMessage.("apply ‚Üí " ++ canonicalPath);
    if(adapterAvailable) { applyViaAdapter.(canonicalPath) } { applyDirectToPedalboard.(canonicalPath) };
    if(~procHud_update.notNil) { ~procHud_update.() }; // optional HUD refresh
};

// ‚îÄ‚îÄ sequenced playlist runner (AppClock; cancel-safe via generation id) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
runPlaylist = { |listOfCanonicalPaths, gap = 0.6|
    var myGeneration, indexCounter, totalCount, stepOnce, scheduleNext;

    // bump global generation to cancel older chains
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    myGeneration = ~fallback_gen;

    indexCounter = 0;
    totalCount   = listOfCanonicalPaths.size;

    stepOnce = {
        if(~fallback_gen != myGeneration) { ^nil }; // cancelled
        applyOneCommand.( listOfCanonicalPaths[indexCounter] );
        indexCounter = indexCounter + 1;
        if(indexCounter < totalCount) { scheduleNext.() } { logMessage.("done.") };
    };

    scheduleNext = {
        var delaySeconds;
        delaySeconds = gap ? 0.6;
        AppClock.sched(delaySeconds, {
            if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
        });
    };

    AppClock.sched(0.0, {
        if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
    });

    ^myGeneration;
};

// ‚îÄ‚îÄ hard stop utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
stopPlaylist = {
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    logMessage.("stopped.");
};

// ‚îÄ‚îÄ go ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showGuiHint.(
    "Fallback-only demo (adapter=" ++ adapterAvailable ++ "):\n" ++
    "A: " ++ playlistA.asString ++ "\n" ++
    "B: " ++ playlistB.asString
);
ensureGeneratedSources.();
startGeneration = runPlaylist.(playlistA, gapSeconds);

// queue playlist B after A with a tail margin
AppClock.sched((playlistA.size * gapSeconds + 1.0).max(1.0), {
    if(~fallback_gen == startGeneration) {
        runPlaylist.(playlistB, gapSeconds);
    };
    nil
});
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail_Delayed.scd =====
// Fallback_Acceptance_PassFail_Delayed.scd
// v0.1.3
// MD 20250923-1534


/*
Purpose
- Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
- Verify A XOR B only AFTER crossfade settles (avoid false FAIL during fade).
- Extra diagnostics: print plan.size, first path, and every step index.
Style
- var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.
- Generated audio only; Option A enforced if available.
*/

(
var say, trace, assertXorAfter;
var ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne;
var plan, idx, gap, settle, runStep, kickOff;

/* logging helpers */
say   = { |msg| ("[ACCEPT] " ++ msg).postln };
trace = { |msg| ("[TRACE] "  ++ msg).postln };

/* delayed assertion to avoid crossfade overlap */
assertXorAfter = { |expectA, expectB, label, delaySeconds|
    var doCheck, delay;
    delay = delaySeconds ? 0.35; // default settle > 0.12 crossfade
    doCheck = {
        var a, b, okFlag, tag;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        okFlag = (a == expectA) and: { b == expectB };
        tag = if(okFlag) { "PASS" }{ "FAIL" };
        (tag ++ " ‚Äî " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    };
    AppClock.sched(delay, { doCheck.value; nil });
};

/* guards */
ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)"); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

/* ensure generated sources & Option A */
ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

/* application modes */
applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

/* plan: Events with optional verify on switch */
plan = [
    ( idx: 1, total: 5, path: "/add/delay" ),
    ( idx: 2, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: false, expectB: true,  label: "after first switch" ),
    ( idx: 3, total: 5, path: "/bypass/delay/on" ),
    ( idx: 4, total: 5, path: "/bypass/delay/off" ),
    ( idx: 5, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: true,  expectB: false, label: "after second switch" )
];

/* extra instrumentation to confirm the plan really exists */
trace.("plan.size = " ++ plan.size);
if(plan.size > 0) {
    trace.("plan[0].path = " ++ plan[0][\path].asString);
} {
    say.("‚ö†Ô∏è plan is empty ‚Äî aborting to avoid a no-op run."); ^nil;
};

idx    = 0;
gap    = 0.60;
settle = 0.35;

/* run one step, then re-schedule next */
runStep = {
    var step, path, haveVerify, label, eA, eB, vd;
    if(idx >= plan.size) { say.("done."); ^nil; };

    step = plan[idx];
    trace.("step " ++ step[\idx] ++ " / " ++ step[\total]);

    path = step[\path].asString;
    applyOne.value(path);

    haveVerify = step.includesKey(\verifyDelay);
    if(haveVerify) {
        vd   = step[\verifyDelay] ? settle;
        eA   = step[\expectA];
        eB   = step[\expectB];
        label= step[\label].asString;
        assertXorAfter.value(eA, eB, label, vd);
        AppClock.sched(vd.max(gap), { idx = idx + 1; runStep.value; nil });
    }{
        AppClock.sched(gap, { idx = idx + 1; runStep.value; nil });
    };
};

/* go */
ensureSources.value;
kickOff = {
    var scheduled;
    trace.("scheduling kickoff in 0.03s on AppClock‚Ä¶");
    scheduled = AppClock.sched(0.03, { runStep.value; nil });
    ("[TRACE] AppClock.sched ‚Üí " ++ scheduled.asString).postln;
};
kickOff.value;
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 ‚Äî 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " ‚Äî " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== Magicpedalboard/_archive/2025-09-20/CT_SafeSmoke_NoDupes.scd =====
// CT_SafeSmoke_NoDupes.scd
// v0.1.1
// MD 2025-09-18 11:30 BST

// Purpose:
// - Safe CommandTree-mimic smoke: add exactly one \delay to NEXT, ensure NEXT source is \testmelody,
//   then switch once and verify exclusivity with audio.
// Style:
// - tilde vars; var-first in functions/closures; lowercase names; no server.sync;
// - server ops inside Server.default.bind only when creating/updating Ndefs.

(
var log, countKey, assertOnce, printChainsShort, ensureAdapterOnce, ensureSource;
log = { arg s; ("[CT] " ++ s).postln };
countKey = { arg array, key; var c=0; array.do({ arg k; if(k == key) { c = c + 1 } }); c };
assertOnce = { arg list, key, label;
    var n; n = countKey.(list, key);
    ("[ASSERT] " ++ label ++ " ‚Äî '" ++ key.asString ++ "' count=" ++ n).postln;
    if(n != 1) { ("[ASSERT] expected exactly 1; got " ++ n).warn };
};
printChainsShort = {
    var cur = ~mpb.effectiveCurrent, nxt = ~mpb.effectiveNext;
    ("[CHAINS] CURRENT=" ++ cur).postln;
    ("[CHAINS] NEXT   =" ++ nxt).postln;
};
ensureAdapterOnce = {
    if(~ct_applyOSCPathToMPB.isNil) {
        "adapter_commandtree_to_magicpedalboard.scd".loadRelative;
        log.("adapter loaded");
    }{
        log.("adapter already present");
    };
};
ensureSource = {
    // Ensure \testmelody exists (stereo). Cheap and idempotent.
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(3.2);
                var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                var f = Demand.kr(trig, 0, seq);
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
};

// --- run the safe smoke ---
ensureAdapterOnce.();
ensureSource.();

// 0) Baseline visibility
~mpb.printChains;

// 1) Clean NEXT
~mpb.clearChain;
~mpb.printChains;

// 2) Add exactly one delay to NEXT via adapter
~ct_applyOSCPathToMPB.("/add/delay", ~mpb, ~gui);

// 3) Ensure NEXT source is audible BEFORE switching  <<‚Äî‚Äî added fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// Inspect NEXT; assert only one 'delay'
printChainsShort.();
assertOnce.(~mpb.effectiveNext, \delay, "after /add/delay + /setSource/testmelody");


//fix
~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);

// 4) Switch once with a short fade; CURRENT should now include \delay and end with \testmelody
~mpb.switchChain(0.12);

// 5) Post-switch checks
AppClock.sched(0.40, {
    printChainsShort.();
    ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    nil
});
)

===== Magicpedalboard/_archive/2025-09-20/CT_TokenQueue_Manual_Milestone.scd =====
// CT_TokenQueue_Manual_Milestone.scd
// v0.1.1
// MD 2025-09-18 15:19 BST

// Purpose:
// - Prove that MagicPedalboardNew responds to CommandTree-like *tokens* today,
//   without any Routine/Task runners (no chance of resume errors).
// - Steps: ensure sources (idempotent) -> apply tokens in order -> single tail verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - server ops inside Server.default.bind only where needed; GUI on AppClock.

(
var log, ensureSources, guardSwitchAudible, applyPath, verifyTail, ok;

log = { arg s; var t; t = "[TOKENS] " ++ s; t.postln };

// quick guards
ok = (~mpb.isNil.not) and: { ~gui.isNil.not } and: { ~ct_applyOSCPathToMPB.notNil };
if(ok.not) {
    "[TOKENS] Missing ~mpb/~gui or adapter. Run StartHere... and adapter_*.scd first.".warn;
    ^nil;
};

// define generated sources if needed (no SoundIn)
ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
    });
};

// ensure NEXT isn‚Äôt silent before switching
guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        log.("guard: NEXT tail \\ts0 -> injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// tiny wrapper around your adapter path applier (for logging)
applyPath = { arg path;
    var p;
    p = path;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
};

// verify once after fades
verifyTail = {
    AppClock.sched(0.8, {
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        ~mpb.printChains;
        nil
    });
};

// ---- run steps synchronously (no Routine/Task) ----
ensureSources.();

// 1) Make both chains end with \testmelody once (idempotent), and keep Option A:
if(~mpb.effectiveCurrent.last != \testmelody) { ~mpb.setSourceCurrent(\testmelody) };
if(~mpb.effectiveNext   .last != \testmelody) { ~mpb.setSource(\testmelody) };
~mpb.enforceExclusiveCurrentOptionA(0.1);

// 2) Mimic CommandTree tokens via canonical adapter paths:

// ["insert","delay"]  -> "/add/delay"  (applies to NEXT)
applyPath.("/add/delay");

// ["switch"] -> "/switch"  (guard ensures audible NEXT)
guardSwitchAudible.();
applyPath.("/switch");

// ["bypass","delay","on"]  -> "/bypass/delay/on"  (acts on NEXT chain in your adapter semantics)
applyPath.("/bypass/delay/on");

// ["bypass","delay","off"] -> "/bypass/delay/off"
applyPath.("/bypass/delay/off");

// ["switch"] -> "/switch" (again)
guardSwitchAudible.();
applyPath.("/switch");

// 3) One final verification print (PLAY flags + chains)
verifyTail.();
)

===== Magicpedalboard/_archive/2025-09-20/CT_TokenQueue_Milestone.scd =====
// CT_TokenQueue_Milestone_ClockChain.scd
// v0.3.0
// MD 2025-09-18 15:08 BST

// Purpose:
// - Demonstrate (audibly & with logs) that MagicPedalboardNew responds to CommandTree-like
//   *token* queues today, sequenced without Routine/Task (AppClock-only, chain scheduling).
// - Flow: ensure sources -> load adapter via absolute path -> prime sources -> token playlist -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock;
// - NodeProxy connections remain inside class rebuilds using the exact <<> operator.

(
var here, loadLocal, log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible;
var applyOneTokens, startClockChain, stopClockChain, verifyAtEnd, startDemo;
var playlist, gap, gen;

// --- path helper: load sibling files from this script's folder ---
here = PathName(thisProcess.nowExecutingPath).pathOnly;
loadLocal = { arg leafName;
    var full;
    full = here +/+ leafName;
    full.load;
};

// --- logging helper ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (requires bring-up so ~mpb / ~gui exist) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- load adapter robustly (absolute path) ---
if(~ct_applyOSCPathToMPB.isNil) {
    loadLocal.value("adapter_CommandTree_to_MagicPedalboard.scd");
    log.("adapter loaded");
} {
    log.("adapter already present");
};

// --- token -> canonical path mapping (what the adapter expects) ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// --- apply one token step via the adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    log.("apply " ++ tokens.asString ++ "  -> " ++ path);
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// --- STOP any previous chain by bumping a generation counter ---
stopClockChain = {
    var old;
    old = ~ctq_gen ? 0;
    ~ctq_gen = old + 1;
    log.("chain stopped (gen=" ++ ~ctq_gen ++ ")");
};

// --- Start a playlist using AppClock chaining; no Routine/Task involved ---
startClockChain = { arg listOfTokenLists, gapSeconds = 0.6;
    var startGen, total, stepFn, scheduleNext, index;

    // bump generation to cancel older scheduled callbacks
    stopClockChain.value;

    startGen = ~ctq_gen;
    total = listOfTokenLists.size;
    index = 0;

    stepFn = {
        var tokens, stillMine;
        tokens = listOfTokenLists[index];
        stillMine = (~ctq_gen == startGen);
        if(stillMine.not) { ^nil }; // cancelled

        applyOneTokens.value(tokens);

        index = index + 1;
        if(index < total) {
            scheduleNext.value;
        }{
            log.("done.");
        };
    };

    scheduleNext = {
        var delay;
        delay = gapSeconds ? 0.6;
        AppClock.sched(delay, {
            var stillMine;
            stillMine = (~ctq_gen == startGen);
            if(stillMine) { stepFn.value } { nil };
        });
    };

    // kick off immediately
    AppClock.sched(0.0, {
        var stillMine;
        stillMine = (~ctq_gen == startGen);
        if(stillMine) { stepFn.value } { nil };
    });

    ^startGen
};

// --- verify tail ---
verifyAtEnd = {
    var a, b;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(a, b)).postln;
    ~mpb.printChains;
};

// --- end-to-end run ---
startDemo = {
    var ok, runGen, tailDelay;
    ok = need.value;
    if(ok.not) { ^nil };

    ensureSources.value;

    // For today: both chains end with \testmelody; NEXT remains silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];
    gap = 0.60;

    runGen = startClockChain.value(playlist, gap);

    // verify near the end; computed tail = steps * gap + small margin
    tailDelay = playlist.size * gap + 0.9;
    AppClock.sched(tailDelay, {
        var stillMine;
        stillMine = (~ctq_gen == runGen);
        if(stillMine) { verifyAtEnd.value };
        nil
    });
};

// --- go ---
startDemo.value;
)

===== Magicpedalboard/_archive/2025-09-20/CT_TokenQueueHarness.scd =====
// CT_TokenQueueHarness.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Minimal harness that accepts CommandTree-like token arrays (e.g. ["insert","delay"])
  and maps them to canonical OSC-style paths understood by your existing adapter
  (~ct_applyOSCPathToMPB). Adds a guard so "/switch" never lands on a silent NEXT.

Style
- tilde vars allowed at top level.
- var-first in every function/closure; lowercase method names.
- no server.sync; all server ops inside Server.default.bind.
- This file does not manipulate Ndefs directly; MagicPedalboardNew handles audio and <<>.
*/

(
// Public factory: ~ctq_makeHarness.(mpb, gui, secondsBetween)
// Returns an IdentityDictionary with keys:
//  - \applyOneTokens : { |tokens| ... }         // tokens = ["insert","delay"] etc.
//  - \runPlaylist    : { |listOfTokenLists, gapSeconds| ... }
//  - \tokensToPath   : { |tokens| ... }         // mapping only
//  - \stop           : { ... }                  // stop current run (if any)

var makeHarness;
makeHarness = { arg mpb, gui, secondsBetween = 0.5;
    var state, log, ensureAdapter, tokensToPath, isNextSilent, guardSwitchAudible;
    var applyOneTokens, runPlaylist, stop, runner;

    log = { arg s;
        var msg;
        msg = "[CTQ] " ++ s;
        msg.postln;
    };

    ensureAdapter = {
        var loadedAlready;
        loadedAlready = (~ct_applyOSCPathToMPB.notNil);
        if(loadedAlready.not) {
            "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
            log.("adapter loaded");
        }{
            log.("adapter already present");
        };
    };

    tokensToPath = { arg tokensIn;
        var tokens, verb, args, result, lowerOnOff;
        tokens = tokensIn.collect({ arg t; t.asString });
        if(tokens.size <= 0) { ^nil };
        verb = tokens[0].toLower;
        args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
        result = nil;

        if(verb == "insert" or: { verb == "add" }) {
            if(args.size >= 1) { result = "/add/" ++ args[0] };
        }{
            if(verb == "bypass") {
                if(args.size >= 1) {
                    lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                    lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                        if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                    },{
                        "on"
                    });
                    result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
                };
            }{
                if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                    if(args.size >= 1) { result = "/setSource/" ++ args[0] };
                }{
                    if(verb == "switch" or: { verb == "commit" }) {
                        result = "/switch";
                    }{
                        if(verb == "removeat") {
                            if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                        }{
                            if(verb == "swap") {
                                if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                            }{
                                result = nil;
                            };
                        };
                    };
                };
            };
        };
        ^result;
    };

    isNextSilent = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        ^(last == \ts0);
    };

    guardSwitchAudible = {
        var needed;
        needed = isNextSilent.();
        if(needed) {
            log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", mpb, gui);
        };
    };

    applyOneTokens = { arg tokens;
        var path;
        path = tokensToPath.(tokens);
        if(path.isNil) {
            log.("unmapped tokens: " ++ tokens.asString);
            ^nil;
        };
        if(path == "/switch") { guardSwitchAudible.() };
        ~ct_applyOSCPathToMPB.(path, mpb, gui);
    };

    runPlaylist = { arg listOfTokenLists, gapSeconds;
        var gapLocal, routineLocal;
        gapLocal = gapSeconds ? secondsBetween;
        routineLocal = Routine({
            var i, step;
            i = 0;
            while({ i < listOfTokenLists.size }, {
                step = listOfTokenLists[i];
                log.("apply " ++ step.asString);
                applyOneTokens.(step);
                gapLocal.wait;
                i = i + 1;
            });
            log.("done.");
        });
        runner = routineLocal.play(AppClock);
        ^runner;
    };

    stop = {
        if(runner.notNil) { runner.stop; runner = nil };
        log.("stopped.");
    };

    ensureAdapter.();
    state = IdentityDictionary[
        \applyOneTokens -> applyOneTokens,
        \runPlaylist    -> runPlaylist,
        \tokensToPath   -> tokensToPath,
        \stop           -> stop
    ];
    ^state;
};

~ctq_makeHarness = makeHarness;
)

===== Magicpedalboard/_archive/2025-09-20/CTQ_HardStop_All_Runners.scd =====
// CTQ_HardStop_All_Runners.scd
// v0.1.1
// MD 2025-09-18 15:18 BST

// Purpose:
// - Stop any leftover Routine/Task and cancel any pending AppClock chain (generation bump).
// Style:
// - var-first; lowercase; no server.sync.

(
var hadRunner, hadTask, oldGen;
hadRunner = (~ctq_runner.notNil) and: { ~ctq_runner.isPlaying };
hadTask   = (~ctq_task.notNil)   and: { ~ctq_task.isPlaying };

if(hadRunner) { ~ctq_runner.stop };
if(hadTask)   { ~ctq_task.stop };

~ctq_runner = nil;
~ctq_task   = nil;

oldGen = ~ctq_gen ? 0;
~ctq_gen = oldGen + 1;

("[TOKENS] HARD STOP ‚Äî runner=% task=% gen=%"
    .format(hadRunner, hadTask, ~ctq_gen)).postln;
)

===== Magicpedalboard/_archive/2025-09-20/CTQ_MinHarness_Inline.scd =====
// CTQ_MinHarness_Inline.scd
// v0.1.0
// MD 2025-09-18 14:05 BST

/*Purpose
- Minimal, reliable inline harness to drive MagicPedalboardNew from CommandTree-like token queues
  without relying on a returned dictionary. Good for today's milestone demo.
Style
- tilde vars; var-first in every function/closure; lowercase method names; no server.sync;
  GUI on AppClock; Ndef connections happen inside class code with exact <<> operator.*/


(
// 0) Preconditions and adapter
var need;

need = {
    if(~mpb.isNil or: { ~gui.isNil }) {
        "[CTQ] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
        ^false
    }; ^true
};

if(need.().not) { ^nil };

// load adapter once (defines ~ct_applyOSCPathToMPB)
if(~ct_applyOSCPathToMPB.isNil) {
    "adapter_CommandTree_to_MagicPedalboard.scd".loadRelative;
    "[CTQ] adapter loaded".postln;
} {
    "[CTQ] adapter already present".postln;
};

// 1) Token ‚Üí path mapper (safe subset for today)
~ctq_tokensToPath = { arg tokensIn;
    var tokens, verb, args, lowerOnOff, result;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    } {
        if(verb == "bypass") {
            if(args.size >= 1) {
                lowerOnOff = if(args.size >= 2) { args[1].toLower } { "on" };
                lowerOnOff = (["on","off","true","false","1","0"].includes(lowerOnOff)).if({
                    if((lowerOnOff == "true") or: { lowerOnOff == "1" }) { "on" } { lowerOnOff }
                }, { "on" });
                result = "/bypass/" ++ args[0] ++ "/" ++ lowerOnOff;
            };
        } {
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            } {
                if(verb == "switch" or: { verb == "commit" }) {
                    result = "/switch";
                } {
                    if(verb == "removeat") {
                        if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                    } {
                        if(verb == "swap") {
                            if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                        } {
                            result = nil; // unmapped today
                        };
                    };
                };
            };
        };
    };
    ^result;
};

// 2) Guard so /switch never lands on \ts0
~ctq_guardSwitchAudible = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    if(last == \ts0) {
        "[CTQ] NEXT ends with \\ts0; injecting /setSource/testmelody before /switch".postln;
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
};

// 3) Apply a single token array
~ctq_applyOneTokens = { arg tokens;
    var path;
    path = ~ctq_tokensToPath.(tokens);
    if(path.isNil) {
        ("[CTQ] unmapped tokens: " ++ tokens.asString).postln; ^nil
    };
    if(path == "/switch") { ~ctq_guardSwitchAudible.() };
    ("[CTQ] apply " ++ tokens.asString ++ " -> " ++ path).postln;
    ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
};

// 4) Run a playlist of token arrays with a gap (Routine on AppClock)
~ctq_runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var routineLocal, gap;
    gap = gapSeconds ? 0.6;
    routineLocal = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            ~ctq_applyOneTokens.( listOfTokenLists[i] );
            gap.wait;
            i = i + 1;
        });
        "[CTQ] done.".postln;
    });
    routineLocal.play(AppClock);
    ^routineLocal
};

// 5) Quick prime (today we want audible switches using \testmelody)
~ctq_primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

"[CTQ] inline harness ready".postln;
)

===== Magicpedalboard/_archive/2025-09-20/Demo_CommandTree_TokenQueues.scd =====
// Demo_CommandTree_TokenQueues.scd
// v0.1.1
// MD 2025-09-18 13:56 BST

/*
Purpose
- Demonstrate MagicPedalboardNew responding to CommandTree-like token queues, via
  CT_TokenQueueHarness (tokens -> adapter paths -> pedalboard).

Style
- Requires that StartHere_CleanBoot_OneWindow_BringUp.scd has run (so ~mpb, ~gui exist).
- var-first; lowercase; no server.sync; server ops inside Server.default.bind; GUI on AppClock.
*/

(
var ensureSources, primeSources, gap, h, playlistA, playlistB, after;

if(~mpb.isNil or: { ~gui.isNil }) {
    "[DEMO] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

primeSources = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
};

gap = 0.60;
"CT_TokenQueueHarness.scd".loadRelative;
h = ~ctq_makeHarness.(~mpb, ~gui, gap);

// Example token playlists
playlistA = [
    ["insert","delay"],
    ["switch"]
];

playlistB = [
    ["bypass","delay","on"],
    ["bypass","delay","off"],
    ["switch"]
];

ensureSources.();
primeSources.();

h[\runPlaylist].(playlistA, gap);
after = (playlistA.size * gap + 1.0).max(1.0);
AppClock.sched(after, {
    h[\runPlaylist].(playlistB, gap);
    nil
});
)

===== Magicpedalboard/_archive/2025-09-20/MagicDisplayGUI_ProcessorsHUD_TopLeft.scd =====
// MagicDisplayGUI_ProcessorsHUD_TopLeft.scd
// v0.3.2
// MD 20250919-08:25 BST

/*
Purpose
- Install a compact Processors HUD inside the existing MagicDisplayGUI window.
- Anchored top-left; no FlowLayout; adequate height so the "NEXT" line never truncates.
- Reflows width on update; safe to evaluate multiple times.
- If ~mpb is available, shows CURRENT/NEXT processor tails; otherwise shows placeholders.

Style
- var-first; lowercase; AppClock-only GUI ops; no caret returns in AppClock closures; no server.sync.
*/

(
var findGuiWindow, ensureHud, renderHud, makeRect, summarize, extractTail, clipStr, posCorner;

posCorner = \topLeft;

// helpers
findGuiWindow = {
    var windowsList, targetWindow;
    windowsList = Window.allWindows.select({ arg w;
        var nameStr, isMagic;
        nameStr = w.tryPerform(\name);
        isMagic = nameStr.notNil and: { nameStr.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    targetWindow = windowsList.last;
    targetWindow
};

makeRect = { arg parentRect;
    var margin, minWidth, panelWidth, panelHeight, xPos, yPos;
    margin = 10;
    minWidth = 220;
    panelHeight = 60; // title (16) + line (16) + line (16) + padding
    panelWidth  = (parentRect.width - (margin * 2)).clip(minWidth, 10000);
    xPos = if(posCorner == \topRight) { (parentRect.width - margin - panelWidth) } { margin };
    yPos = margin;
    Rect(xPos, yPos, panelWidth, panelHeight)
};

clipStr = { arg anyString, maxChars = 84;
    var s;
    s = anyString.asString;
    if(s.size > maxChars) { s.copyRange(0, maxChars-3) ++ "‚Ä¶" } { s }
};

extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

summarize = { arg syms;
    var namesArr, joined;
    namesArr = syms.collect(_.asString);
    joined = namesArr.join(" -> ");
    clipStr.value(joined, 84)
};

// installer
ensureHud = {
    AppClock.sched(0, {
        var win, rootView, boxView, titleText, lineCurrent, lineNext, rect, exists;
        win = findGuiWindow.value;
        if(win.notNil) {
            rootView = win.view;
            exists = (~procHud.notNil) and: { ~procHud[\view].notNil } and: { ~procHud[\view].isClosed.not };
            if(exists.not) {
                rect = makeRect.value(rootView.bounds);
                boxView = CompositeView(rootView, rect).background_(Color(0.12, 0.12, 0.12, 0.90));
                titleText = StaticText(boxView, Rect(8, 6, rect.width - 16, 16))
                    .string_("Processors")
                    .stringColor_(Color(0.95, 0.95, 0.95));
                lineCurrent = StaticText(boxView, Rect(8, 24, rect.width - 16, 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.90, 0.90, 0.90));
                lineNext = StaticText(boxView, Rect(8, 42, rect.width - 16, 16)) // 42 avoids clipping
                    .string_("NEXT: -")
                    .stringColor_(Color(0.80, 0.80, 0.80));
                ~procHud = IdentityDictionary[
                    \view -> boxView,
                    \lineCurrent -> lineCurrent,
                    \lineNext -> lineNext
                ];
                "[HUD] installed (top-left)".postln;
            };
        }{
            "[HUD] MagicDisplayGUI not found yet".postln;
        };
        nil
    });
};

// renderer
renderHud = {
    AppClock.sched(0, {
        var win, rootView, alive, rect, lineCurrent, lineNext;
        var currentArr, nextArr, currentTail, nextTail, currentStr, nextStr, haveMpb;

        win = findGuiWindow.value;
        if(win.notNil) {
            rootView = win.view;
            alive = (~procHud.notNil) and: { ~procHud[\view].notNil } and: { ~procHud[\view].isClosed.not };
            if(alive.not) {
                ensureHud.value;
                AppClock.sched(0.08, { renderHud.value; nil });
            }{
                rect = makeRect.value(rootView.bounds);
                ~procHud[\view].bounds = rect;

                haveMpb = (~mpb.notNil);
                if(haveMpb) {
                    currentArr = ~mpb.effectiveCurrent;
                    nextArr    = ~mpb.effectiveNext;
                    currentTail= extractTail.value(currentArr);
                    nextTail   = extractTail.value(nextArr);
                    currentStr = summarize.value(currentTail);
                    nextStr    = summarize.value(nextTail);
                }{
                    currentStr = "-";
                    nextStr    = "-";
                };

                lineCurrent = ~procHud[\lineCurrent];
                lineNext    = ~procHud[\lineNext];
                if(lineCurrent.notNil) {
                    lineCurrent.bounds = Rect(8, 24, rect.width - 16, 16);
                    lineCurrent.string = "CURRENT: " ++ currentStr;
                };
                if(lineNext.notNil) {
                    lineNext.bounds = Rect(8, 42, rect.width - 16, 16);
                    lineNext.string = "NEXT: " ++ nextStr;
                };
                ~procHud[\view].front;
            };
        }{
            "[HUD] no MagicDisplayGUI; cannot render".postln;
        };
        nil
    });
};

// public API
~procHud_install  = { ensureHud.value };
~procHud_update   = { renderHud.value };
~procHud_relocate = { arg cornerSymbol;
    var corner;
    corner = cornerSymbol ? \topLeft;
    posCorner = ([\topLeft, \topRight].includes(corner)).if({ corner }, { \topLeft });
    renderHud.value;
};

// install & draw once
~procHud_install.();
AppClock.sched(0.10, { ~procHud_update.(); nil });
)

===== Magicpedalboard/_archive/2025-09-20/MagicDisplayGUI_ProcessorsHUD.scd =====
// MagicDisplayGUI_ProcessorsHUD.scd
// v0.2.1
// MD 20250918-21:05 BST

/*
Purpose
- Add a lightweight "Processors HUD" to the existing MagicDisplayGUI window.
- Shows CURRENT and NEXT processor tails (symbols). Updates via ~procHud_update.

Style
- var-first in every function/closure; lowercase names; no server.sync; AppClock for GUI only;
- one window only (install into the existing MagicDisplayGUI* window).
*/

(
var symbolsToString, extractTail, findGuiWindow, clampRect, hudInstall, hudRender;

/********** helpers **********/
symbolsToString = { arg syms;
    var namesArray, joined;
    namesArray = syms.collect(_.asString);
    joined = namesArray.join(" \u2192 "); // arrow
    joined
};

extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

findGuiWindow = {
    var wins, target;
    wins = Window.allWindows.select({ arg w;
        var nm, isMagic;
        nm = w.tryPerform(\name);
        isMagic = nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    target = wins.last;
    target
};

clampRect = { arg parentRect;
    var x, y, w, h;
    x = 10;
    w = (parentRect.width - 20).max(160);
    h = 46;
    y = (parentRect.height - (h + 10)).max(10);
    Rect(x, y, w, h)
};

/********** installer (explicit bounds; no FlowLayout; no caret returns) **********/
hudInstall = {
    AppClock.sched(0, {
        var win, root, r, box, title, lineA, lineB, exists;

        win = findGuiWindow.value;
        if(win.notNil) {
            root = win.view;

            exists = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(exists.not) {
                r = clampRect.value(root.bounds);

                box = CompositeView(root, r)
                    .background_(Color(0.12, 0.12, 0.12, 0.88));

                title = StaticText(box, Rect(8, 6, (r.width - 16).max(80), 16))
                    .string_("Processors HUD")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineA = StaticText(box, Rect(8, 22, (r.width - 16).max(80), 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineB = StaticText(box, Rect(8, 38, (r.width - 16).max(80), 16))
                    .string_("NEXT:    -")
                    .stringColor_(Color(0.8,0.8,0.8));

                ~procHud = IdentityDictionary[
                    \view        -> box,
                    \lineCurrent -> lineA,
                    \lineNext    -> lineB
                ];

                "[HUD] installed into MagicDisplayGUI".postln;
            };
        }{
            "[HUD] MagicDisplayGUI window not found yet (install will retry on update)".postln;
        };
        nil
    });
};

/********** renderer (safe guards; no caret returns) **********/
hudRender = {
    AppClock.sched(0, {
        var ok, curArr, nextArr, curTail, nextTail, curStr, nextStr, lineA, lineB, alive;

        ok = (~mpb.notNil);
        if(ok) {
            alive = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(alive.not) {
                hudInstall.value;
                AppClock.sched(0.07, { hudRender.value; nil });
            }{
                curArr  = ~mpb.effectiveCurrent;
                nextArr = ~mpb.effectiveNext;

                curTail = extractTail.value(curArr);
                nextTail = extractTail.value(nextArr);

                curStr = if(curTail.size > 0) { symbolsToString.value(curTail) } { "-" };
                nextStr = if(nextTail.size > 0) { symbolsToString.value(nextTail) } { "-" };

                lineA = ~procHud[\lineCurrent];
                lineB = ~procHud[\lineNext];

                if(lineA.notNil) { lineA.string = "CURRENT: " ++ curStr };
                if(lineB.notNil) { lineB.string = "NEXT:    " ++ nextStr };
            };
        }{
            "[HUD] cannot render (no ~mpb)".postln;
        };
        nil
    });
};

/********** public API **********/
~procHud_install = { hudInstall.value };
~procHud_update  = { hudRender.value };

// install & draw once
~procHud_install.();
AppClock.sched(0.10, { ~procHud_update.(); nil });
)

===== Magicpedalboard/_archive/2025-09-20/MagicStart_Fixes_Inline.scd =====
// MagicStart_Prelude_SelfRun
// v0.4.9
// 2025-09-17 14:48 BST (MD)
//
// Purpose:
// - Self-running top-of-file prelude to start from a known-good state.
// - Avoid quit/boot races by reusing a healthy server + init tree + clear default group.
// - Define busMeterA / busMeterB with a COMPILE-TIME channel count to prevent In.ar errors.
// - Mix meters to mono internally to avoid language-level max comparisons on UGens.
// Style:
// - tilde vars only, var-first inside functions, no server.sync,
//   Server.default.bind for server ops, GUI-safe (AppClock), your SC coding rules respected.

(
var numChannelsConst;

// --- Decide a compile-time channel count for the meter synths ----------------
// If you already set ~defaultNumChannels elsewhere (Integer > 0), we use it; otherwise fall back to 2.
numChannelsConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// --- Helpers -----------------------------------------------------------------
~closeMagicDisplayGUIWindows = {
    var windows;
    windows = Window.allWindows.select { |w|
        var name;
        name = w.tryPerform(\name);
        name.notNil and: { name.asString.beginsWith("MagicDisplayGUI") }
    };
    windows.do { |w| w.close };
    "[START] closed any existing MagicDisplayGUI windows".postln;
};

~ensureServerReady = {
    var s;
    s = Server.default;

    if (s.serverRunning) {
        "[START] server already running ‚Üí reusing".postln;
    } {
        if (s.booting) {
            "[START] server already booting ‚Üí waiting‚Ä¶".postln;
        } {
            "[START] booting server‚Ä¶".postln;
            s.boot;
        };
        s.waitForBoot;
    };

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    "[START] tree inited + default group cleared".postln;
};

~ensureMeterDefs = {
    var needA, needB;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if (needA or: { needB }) {
        ("[START] (re)defining meter synths with numChannelsConst=" ++ numChannelsConst).postln;

        // Capture numChannelsConst at SynthDef build time (literal inside the UGen graph).
        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                // choose an index: \bus if >=0 else \in (control-rate comparator is fine for Select)
                useBus = Select.kr(bus >= 0, [in, bus]);
                // read exactly numChannelsConst channels (compile-time integer)
                sig    = In.ar(useBus, numChannelsConst);
                // mix to mono to avoid language-level max across arrays of UGens
                mono   = Mix(sig);
                // meters
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, numChannelsConst);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// Optional: quick chain channel sanity check (posted if chains already exist)
~checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels ‚Üí A:% , B:%".format(a, b).postln;
    };
};

// --- Execute preflight now (self-running) ------------------------------------
~closeMagicDisplayGUIWindows.value;
~ensureServerReady.value;
~ensureMeterDefs.value;
~checkChainChannels.value;   // harmless if chains don't exist yet
"[READY] MagicStart prelude complete ‚Äî continue with your runner code below.".postln;
)

===== Magicpedalboard/_archive/2025-09-20/OneShot_Acceptance_CommandDriven.scd =====
// OneShot_Acceptance_CommandDriven.scd
// v0.2.3
// MD 20250917-1312
//
// Purpose: Robust, non-intrusive acceptance using your adapter.
//          - Waits for server + ~mpb + adapter
//          - Disables meters only during ops (to avoid attach races)
//          - Pins stereo shape with mold(2,\audio) (does NOT overwrite sink sources)
//          - Enforces Option A at source level; hard-drops NEXT monitor with .end
//            (does NOT replace NEXT‚Äôs source), so flags match audio
//          - Drives: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
//          - Asserts A XOR B after each step and prints a summary
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI AppClock only; one window.

(
var log, step, t,
    ready, disableMeters, enableMeters,
    pinStereoSinks, ensureSources, baselineExclusive,
    enforceOptionA_EndNext, assertXor, apply, runScenario;

var passCount, failCount;
passCount = 0; failCount = 0;

// helpers
log  = { arg s; ("[ACCEPT] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( prep:0.00, baseline:0.25, add:0.45, sw1:0.75, byOn:1.05, byOff:1.30, sw2:1.60, meters:1.90, sum:2.10 );

// readiness
ready = {
    if(Server.default.serverRunning.not) { Server.default.boot };
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
    if(~ct_applyOSCPathToMPB.isNil) {
        "[ACCEPT] adapter missing: eval adapter_commandtree_to_magicpedalboard.scd, then rerun.".warn;
        ^false
    };
    true
};

// meters control (non-intrusive)
disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        log.("meters disabled");
    };
};
enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);
        log.("meters enabled");
    };
};

// non-destructive stereo pin (NO source overwrite)
pinStereoSinks = {
    Server.default.bind({
        Ndef(\chainA).mold(2, \audio);
        Ndef(\chainB).mold(2, \audio);
        // NOTE: no Ndef(\chainX, { \in.ar(2) }) here; class manages sources.
    });
    log.("sinks pinned: mold(2,audio) (non-destructive)");
};

// sources (safe to define)
ensureSources = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        }); Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
    log.("sources ensured (\\testmelody, \\ts0)");
};

// enforce Option A at source level + drop NEXT monitor only (NO source overwrite)
enforceOptionA_EndNext = {
    var nextSink = ~mpb.nextChain[0];
    ~mpb.enforceExclusiveCurrentOptionA(0.1);    // class silences NEXT at source
    Server.default.bind({
        Ndef(nextSink).end;                      // drop monitor/flag
        // do NOT change next sink‚Äôs source here; class manages it
        Ndef(nextSink).mold(2, \audio);         // keep shape pinned
    });
    log.("Option A enforced + NEXT ended (monitor dropped)");
};

// baseline: CURRENT <- \testmelody
baselineExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    enforceOptionA_EndNext.value;
};

// A XOR B assert
assertXor = { arg expectA, expectB, label;
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying, ok;
    ok = (a == expectA) and: { b == expectB };
    ((ok.if({"PASS"},{"FAIL"})) ++ " ‚Äî " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    if(ok) { passCount = passCount + 1 } { failCount = failCount + 1 };
    ok
};

// adapter apply
apply = { arg pathString; ~ct_applyOSCPathToMPB.(pathString, ~mpb, ~gui) };

// scenario
runScenario = {
    if(ready.value.not) { ^nil };

    disableMeters.value;
    pinStereoSinks.value;
    ensureSources.value;

    baselineExclusive.value;
    ~mpb.printChains;
    assertXor.value(true, false, "baseline: CURRENT audible; NEXT silent");

    apply.value("/add/delay");
    ~mpb.printChains;
    assertXor.value(true, false, "after add/delay (NEXT) ‚Äî exclusivity holds");

    apply.value("/switch");               // A->B
    step.value(0.35, {
        enforceOptionA_EndNext.value;     // drop NEXT flag only (no source changes)
        ~mpb.printChains;
        assertXor.value(false, true, "after first switch ‚Äî NEXT‚ÜíCURRENT");

        apply.value("/bypass/delay/on");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass on (CURRENT)");

        apply.value("/bypass/delay/off");
        ~mpb.printChains;
        assertXor.value(false, true, "after bypass off (CURRENT)");

        apply.value("/switch");           // B->A
        step.value(0.35, {
            enforceOptionA_EndNext.value;
            ~mpb.printChains;
            assertXor.value(true, false, "after second switch ‚Äî back to A");

            enableMeters.value;
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
            nil
        });
        nil
    });
};

// run
runScenario.value;
)

===== Magicpedalboard/_archive/2025-09-20/OneShot_Acceptance_SwitchDelay.scd =====
// OneShot_Acceptance_SwitchDelay.scd
// v0.1
// MD 20250916-1618

// Purpose: Automated acceptance: baseline -> add \delay to NEXT -> switch (0.12s) -> verify exclusive playback and chain contents; includes basic PASS/FAIL counting and GUI meter retarget.
// Style: tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var log, passCount, failCount, assertTrue, step, timePlan, ensureSinks, ensureGuiMpb, ensureSource, ensureDelayProc, verifyExclusive, runScenario;

log = { arg s; ("[ACCEPT] " ++ s).postln };

passCount = 0; failCount = 0;
assertTrue = { arg cond, label;
    var text;
    text = if(cond) { "PASS" } { "FAIL" };
    ("[ACCEPT] " ++ text ++ " ‚Äî " ++ label).postln;
    if(cond) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

timePlan = ( sinks:0.05, gui:0.10, source:0.20, meters:0.30, baseline:0.45, add:0.60, switch:0.80, verify2:1.10, bypassOn:1.30, bypassOff:1.50, switchBack:1.70, summary:1.95 );

// 1) Robust sinks (consumes \in) + AR buses
ensureSinks = {
    log.("ensure sinks robust + audio-rate");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// 2) GUI + MPB
ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

// 3) Known-good internal source
ensureSource = {
    log.("define \\testmelody");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// 4) Ensure proc (\delay) exists (stereo)
ensureDelayProc = {
    log.("ensure \\delay processor exists");
    Server.default.bind({
        Ndef(\delay, { |time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01,2.0), time * (fb.clip(0,0.95)*6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\delay).ar(2);
    });
};

// helper: verify exclusive CURRENT (A XOR B playing)
verifyExclusive = { arg expectAPlaying, expectBPlaying, label;
    var a, b, match;
    a = Ndef(\chainA).isPlaying;
    b = Ndef(\chainB).isPlaying;
    match = (a == expectAPlaying) and: { b == expectBPlaying };
    assertTrue.(match, label ++ " (A=" ++ a ++ " B=" ++ b ++ ")");
};

// 5) Scenario: baseline -> add \delay (NEXT) -> switch -> verify -> bypass current on/off -> switch back
runScenario = {
    log.("baseline: CURRENT <- \\testmelody; play A, stop B; meters reattach");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };

    ~mpb.printChains;
    verifyExclusive.(true, false, "baseline exclusive: A=true, B=false");

    log.("add \\delay to NEXT, then switch (0.12s)");
    ~mpb.add(\delay);
    ~mpb.printChains;
    ~mpb.switchChain(0.12);

    // verify after fade
    step.(0.25, {
        verifyExclusive.(false, true, "after switch: A=false, B=true");
        ~mpb.printChains;

        log.("bypassCurrent(\\delay, true) then false");
        ~mpb.bypassCurrent(\delay, true);
        ~mpb.printChains;
        ~mpb.bypassCurrent(\delay, false);
        ~mpb.printChains;

        log.("switch back to A");
        ~mpb.switchChain(0.12);

        step.(0.25, {
            verifyExclusive.(true, false, "after switch-back: A=true, B=false");
            ("[ACCEPT] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount).postln;
        });
    });
};

// --- run sequence (no server.sync; AppClock timing) ---
Server.default.boot;
step.(timePlan[\sinks], { ensureSinks.value });
step.(timePlan[\gui],   { ensureGuiMpb.value });
step.(timePlan[\source],{ ensureSource.value });
step.(timePlan[\meters],{ if(~gui.notNil, { ~gui.enableMeters(false); ~gui.enableMeters(true) }) });
step.(timePlan[\baseline], { runScenario.value });

)

===== Magicpedalboard/_archive/2025-09-20/OneShot_BringUp_MagicPedalboardNew_GUI_Meters.scd =====
// OneShot_BringUp_MagicPedalboardNew_GUI_Meters.scd
// v0.2.1
// MD 20250917-1208
//
// Purpose: Deterministic bring-up: disable meters early; stereo sinks (\in.ar(2)); \ts0 stereo Silent;
//          define \testmelody; play CURRENT; enforce Option A; then explicitly pause NEXT so
//          isPlaying=B=false; enable meters; verify A XOR B.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind. GUI on AppClock only; one window.

(
var log, step, t,
    doBoot, ensureGuiMpb_disableMetersEarly, ensureSinksStereo, ensureTs0SilentStereo,
    ensureTestMelody, startCurrent_enforceExclusive, forceNextPauseFlag, enableMetersClean, verifyState;

log  = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings (seconds)
t = (
    boot:     0.00,
    guiMpb:   0.35,
    sinks:    0.50,
    ts0:      0.65,
    source:   0.80,
    current:  1.00,
    nextPause:1.05,   // tiny step after Option A
    meters:   1.20,
    verify:   1.40
);

doBoot = {
    log.("boot audio");
    Server.default.boot;
};

ensureGuiMpb_disableMetersEarly = {
    log.("ensure GUI + pedalboard; disable meters early");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    // proactively disable meters twice (beats any queued enable)
    AppClock.sched(0.00, { ~gui.enableMeters(false); nil });
    AppClock.sched(0.05, { ~gui.enableMeters(false); nil });

    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSinksStereo = {
    log.("robust sinks: \\in.ar(2) + ar(2)");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { \in.ar(2) }); Ndef(\chainB).ar(2);
    });
};

ensureTs0SilentStereo = {
    log.("define \\ts0 as stereo Silent (for NEXT)");
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureTestMelody = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

startCurrent_enforceExclusive = {
    log.("CURRENT <- \\testmelody; play + enforce Option A");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                         // MPB enforces Option A after play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces: NEXT hard-silenced + stop
};

forceNextPauseFlag = {
    // Ensure NEXT.isPlaying == false (state aligns with Option A audio silence)
    var nextSink;
    nextSink = ~mpb.nextChain[0];             // sink symbol (chainB if A is current)
    Server.default.bind({ Ndef(nextSink).pause });
    log.("NEXT paused (flag B=false)");
};

enableMetersClean = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("enable meters (guards + re-sends SynthDefs)");
        ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

log.("start deterministic bring-up");
step.(t[\boot],     { doBoot.value });
step.(t[\guiMpb],   { ensureGuiMpb_disableMetersEarly.value });
step.(t[\sinks],    { ensureSinksStereo.value });
step.(t[\ts0],      { ensureTs0SilentStereo.value });
step.(t[\source],   { ensureTestMelody.value });
step.(t[\current],  { startCurrent_enforceExclusive.value });
step.(t[\nextPause],{ forceNextPauseFlag.value });   // <-- NEW tiny step
step.(t[\meters],   { enableMetersClean.value });
step.(t[\verify],   { verifyState.value });
)

===== Magicpedalboard/_archive/2025-09-20/OneShot_BringUp_MinimalOnly.scd =====
// OneShot_BringUp_MinimalOnly.scd
// v0.1
// MD 20250916-1608

(
// =========================================================

// Purpose: bring up to a clean audible baseline (no FX demo);
//          robust sinks; retarget meters; verify.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

// =========================================================

var log, step, t, doBoot, ensureSinks, ensureGuiMpb, ensureSource,
    enforceExclusiveCurrent, ensureMetersOk, verifyState;

log = { arg s; ("[BRINGUP] " ++ s).postln };
step = { arg sec, fn; AppClock.sched(sec, { fn.value; nil }) };

// timings
t = ( boot:0.00, sinks:0.40, guiMpb:0.55, source:0.75, current:0.95, meters:1.15, verify:1.35 );

doBoot = { log.("boot audio"); Server.default.boot; };

ensureSinks = {
    log.("ensure sinks robust + AR");
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);          Ndef(\chainB).ar(2);
    });
};

ensureGuiMpb = {
    log.("ensure GUI + MPB");
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};

ensureSource = {
    log.("define \\testmelody (stereo)");
    Server.default.bind({
        Ndef(\testmelody, {
            var trig=Impulse.kr(3.2), seq=Dseq([220,277.18,329.63,392,329.63,277.18,246.94],inf);
            var f=Demand.kr(trig,0,seq), env=Decay2.kr(trig,0.01,0.35);
            var tone=SinOsc.ar(f)*env*0.25, pan=ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

enforceExclusiveCurrent = {
    log.("CURRENT <- \\testmelody; play A, stop B");
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    Server.default.bind({
        if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
        if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
    });
};

ensureMetersOk = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        log.("meters retarget");
        ~gui.enableMeters(false); ~gui.enableMeters(true);
    };
};

verifyState = {
    log.("verify");
    ~mpb.printChains;
    AppClock.sched(0.15, {
        "[PLAY] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)
        .postln; nil
    });
};

log.("starting bring‚Äëup (minimal)");
step.(t[\boot],    { doBoot.value });
step.(t[\sinks],   { ensureSinks.value });
step.(t[\guiMpb],  { ensureGuiMpb.value });
step.(t[\source],  { ensureSource.value });
step.(t[\current], { enforceExclusiveCurrent.value });
step.(t[\meters],  { ensureMetersOk.value });
step.(t[\verify],  { verifyState.value });

)

===== Magicpedalboard/_archive/2025-09-20/OneShot_ResetToCleanBaseline.scd =====
// OneShot_ResetToCleanBaseline.scd
// v0.6
// MD 20250916-1708

//
// Purpose: Reset to a clean, audible baseline and GUARANTEE exclusivity by silencing NEXT.
//          Ensures robust sinks (\in.ar(2)), defines \testmelody, uses MPB.reset, then enforces
//          CURRENT-only by muting NEXT at the sink source; retargets meters and prints final state.
// Style:   tilde vars; var-first; lowercase names; no server.sync; Server.default.bind for server ops.

(
var log, ensureSinksRobust, ensureSource, ensureGuiMpb, doMpbReset,
    setCurrent, enforceExclusiveBySilence, retargetMeters, verify;

log = { arg s; ("[RESET] " ++ s).postln; };

// Robust sinks + AR
ensureSinksRobust = {
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) });
        Ndef(\chainB, { \in.ar(2) });
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
};

// Internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
            f    = Demand.kr(trig,0,seq);
            env  = Decay2.kr(trig,0.01,0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
};

// GUI + MPB and reset
ensureGuiMpb = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };
};
doMpbReset = { ~mpb.reset };

// CURRENT <- testmelody; play
setCurrent = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
};

// Silencing strategy: mute NEXT sink‚Äôs source (hard silence), keep CURRENT robust+playing
enforceExclusiveBySilence = {
    var currentSink, nextSink;
    currentSink = ~mpb.effectiveCurrent[0];
    nextSink    = ~mpb.effectiveNext[0];

    Server.default.bind({
        // CURRENT robust + playing
        Ndef(currentSink, { \in.ar(2) });
        Ndef(currentSink).ar(2);
        Ndef(currentSink).fadeTime_(0.05);
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };

        // NEXT silenced at source (even if its monitor claims 'playing', it contributes 0 audio)
        Ndef(nextSink, { Silent.ar(2) });
        Ndef(nextSink).ar(2);
        Ndef(nextSink).fadeTime_(0.01);
        Ndef(nextSink).stop;
    });
    log.("exclusive enforced by silencing NEXT " ++ nextSink.asString);
};

// meters after AR
retargetMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        ~gui.enableMeters(true);
    };
};

// final print
verify = {
    ~mpb.printChains;
    AppClock.sched(0.25, {
        ("[PLAY] A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

log.("start");
Server.default.boot;

ensureSinksRobust.value;
ensureGuiMpb.value;
doMpbReset.value;
ensureSource.value;
setCurrent.value;
enforceExclusiveBySilence.value;
retargetMeters.value;
verify.value;
)

===== Magicpedalboard/_archive/2025-09-20/StartHere_CleanBoot_OneWindow_BringUp.scd =====
// StartHere_CleanBoot_OneWindow_BringUp.scd
// v0.6
// MD 20250917-1616
//
// Purpose:
//   Known-state bring-up with one MagicDisplayGUI window, CURRENT=\testmelody
//   audible, NEXT silent (Option A), meters on, and verify A=true B=false.
//   Handles the case where GUI/MPB init quits and reboots the server mid-sequence
//   by detecting the reboot, waiting for it, and re-publishing the graph afterward.
//
// Style:
//   - tilde vars only
//   - var-first in every block
//   - lowercase names
//   - no server.sync
//   - server ops inside Server.default.bind
//   - GUI via AppClock (single window named ‚ÄúMagicDisplayGUI‚Ä¶‚Äù)

(
var log, s, numChConst,
    closeGuiWindows, freshBoot, ensureMeterDefs, checkChainChannels,
    clearOldNdefs, buildAudio, makeGuiAndMpb,
    waitForServerDownThenUp, baselinePlayWithRetry, metersOn, verify,
    runSequence,waitOnMpbReady;

log = { arg msg; ("[START] " ++ msg).postln };
s   = Server.default;

// channel constant everywhere (respects your global default if set)
numChConst = (
    ~defaultNumChannels.isKindOf(Integer) and: { ~defaultNumChannels > 0 }
).if({ ~defaultNumChannels }, { 2 });

// 1) Close any MagicDisplayGUI windows (singleton)
closeGuiWindows = {
    var wins;
    wins = Window.allWindows
        .select({ arg w; (w.name ? "").asString.beginsWith("MagicDisplayGUI") });
    wins.do(_.close);
    log.("closed any existing MagicDisplayGUI windows");
};

// 2) Force a FRESH server (quit if running, then boot), then clean the tree
freshBoot = {
    var t0, timeout, keepWait;
    timeout = 5.0;

    if(s.serverRunning) {
        log.("server running ‚Üí quitting for clean boot");
        s.quit;
        t0 = Main.elapsedTime;
        keepWait = true;
        while({ s.serverRunning and: { keepWait } }, {
            0.05.wait;
            if((Main.elapsedTime - t0) > timeout) {
                "[WARN] timeout waiting for server to quit".postln;
                keepWait = false;
            };
        });
    };

    log.("booting server‚Ä¶");
    s.boot;
    s.waitForBoot;

    Server.default.bind({
        s.initTree;
        s.defaultGroup.freeAll;
    });
    log.("tree inited + default group cleared");
};

// 3) Ensure meter SynthDefs exist (compile-time channel count; mono mix inside)
ensureMeterDefs = {
    var needA, needB, n;
    n = numChConst;
    needA = SynthDescLib.global.at(\busMeterA).isNil;
    needB = SynthDescLib.global.at(\busMeterB).isNil;

    if(needA or: { needB }) {
        ("[START] (re)defining meter synths with numChConst=" ++ n).postln;

        Server.default.bind({
            SynthDef(\busMeterA, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);  // prefer \bus if set; else \in
                sig    = In.ar(useBus, n);                // compile-time literal
                mono   = Mix(sig);                        // stable single-channel level
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterA", [rms, peak]);
            }).add;

            SynthDef(\busMeterB, { |bus = -1, in = 0, rate = 15, attack = 0.01, release = 0.3|
                var useBus, sig, mono, trig, rms, peak;
                useBus = Select.kr(bus >= 0, [in, bus]);
                sig    = In.ar(useBus, n);
                mono   = Mix(sig);
                rms    = Amplitude.kr(mono, attack, release);
                peak   = PeakFollower.kr(mono, release);
                trig   = Impulse.kr(rate);
                SendReply.kr(trig, "/meterB", [rms, peak]);
            }).add;
        });
    };
};

// 4) Optional: print A/B channel counts if chains already exist
checkChainChannels = {
    var a, b;
    a = Ndef(\chainA).tryPerform(\numChannels);
    b = Ndef(\chainB).tryPerform(\numChannels);
    if(a.notNil or: { b.notNil }) {
        "[CHECK] Ndef chain channels ‚Üí A:% , B:%".format(a, b).postln;
    };
};

// 5) Clear any previous proxies to avoid channel wrapping warnings
clearOldNdefs = {
    Server.default.bind({
        if(Ndef(\chainA).notNil) { Ndef(\chainA).clear(0) };
        if(Ndef(\chainB).notNil) { Ndef(\chainB).clear(0) };
        if(Ndef(\ts0).notNil)    { Ndef(\ts0).clear(0) };
        if(Ndef(\testmelody).notNil) { Ndef(\testmelody).clear(0) };
    });
};


// 6) Build sinks and sources (server ops)
buildAudio = {
    Server.default.bind({
        // Sinks: read \in.ar(defaultNumChannels)
        Ndef(\chainA, { \in.ar(numChConst) }); Ndef(\chainA).ar(numChConst);
        Ndef(\chainB, { \in.ar(numChConst) }); Ndef(\chainB).ar(numChConst);

        // Sources: NEXT-safe silent + generated test melody
        Ndef(\ts0, { Silent.ar(numChConst) }); Ndef(\ts0).ar(numChConst);

        Ndef(\testmelody, {
            var trig, seq, f, env, tone, pan;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(numChConst);
    });
    log.("sinks + sources defined");
};

// 7) Create GUI + MPB (meters OFF initially). (We call this inside AppClock Routine)
makeGuiAndMpb = {
    ~gui = MagicDisplayGUI.new;
    ~mpb = MagicPedalboardNew.new(~gui);
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(false) };
    if(~pedalboard.isNil and: { ~mpb.notNil }) { ~pedalboard = ~mpb };
    log.("GUI + MPB created (meters off)");
};

// 8) Detect a **server restart** after MPB creation; wait for it and re-publish graph
waitForServerDownThenUp = {
    var sawDown, t0, timeout, bootKickSent, stableCount, stableNeeded;
    sawDown = false;
    t0 = Main.elapsedTime;
    timeout = 10.0;
    bootKickSent = false;
    stableCount = 0;
    stableNeeded = 5; // 5 * 0.2s = 1.0s of stable running

    // Observe the server for up to 10 seconds; if it goes down, wait until it comes back
    while({
        (Main.elapsedTime - t0) < timeout and: { stableCount < stableNeeded }
    }, {
        0.20.wait;

        if(s.serverRunning.not) {
            sawDown = true;
            stableCount = 0;

            // If it doesn't auto-boot within ~1s, kick a boot
            if((Main.elapsedTime - t0) > 1.0 and: { bootKickSent.not }) {
                "WARNING: server not running ‚Üí booting server‚Ä¶".postln;
                s.boot;
                bootKickSent = true;
            };
        }{
            // server is running now
            stableCount = stableCount + 1;
        };
    });

    if(sawDown) {
        // If it was down during the window, make sure it's fully up
        if(s.serverRunning.not) {
            "WARNING: waiting for server to come up‚Ä¶".postln;
            s.boot;  // safe to call even if already booting
            s.waitForBoot;
        }{
            // give it a tiny settle and request notifications (optional but nice)
            0.20.wait;
            s.notify;
        };

        // Re-publish meter defs and audio graph after the reboot
        ensureMeterDefs.value;
        clearOldNdefs.value;
        buildAudio.value;

        // Give MPB a chance to rebuild its server tree if it does so lazily
        0.20.wait;
        if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
        0.20.wait;
    };
};


// 9) Baseline + robust play with retry (ensures MPB has built server groups)
baselinePlayWithRetry = {
    var attempts, ok;
    attempts = 0;
    ok = false;

    while({ (attempts < 4) and: { ok.not } }, {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.playCurrent;
        ~mpb.enforceExclusiveCurrentOptionA(0.1);  // NEXT silenced at source (Option A)

        0.30.wait; // allow bundles to land
        ok = Ndef(\chainA).isPlaying;

        attempts = attempts + 1;
        if(ok) {
            log.("baseline set: CURRENT=\\testmelody (Option A)");
        }{
            ("[RETRY] playCurrent attempt % failed; retrying‚Ä¶".format(attempts)).postln;
            if(~mpb.respondsTo(\rebuild)) { ~mpb.rebuild(\current) };
            0.30.wait;
        };
    });

    if(ok.not) {
        "[WARN] playCurrent did not report Ndef(\\chainA).isPlaying=true after retries".postln;
    };
};

// 10) Meters ON (ensure defs just-in-time)
metersOn = {
    ensureMeterDefs.value; // idempotent safety
    if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };
    log.("meters enabled");
};

// 11) Verify final state
verify = {
    ~mpb.printChains;
    ("[PLAY] A=% B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    checkChainChannels.value;
};

// 11b) Wait for MPB "ready" and then do meters + verify (no fixed sleeps)
waitOnMpbReady = {
    var onReady;  // var-first in outer function

    onReady = {
        var a, b;  // var-first in inner function/closure

        // meters on only when sinks are AR and CURRENT is playing
        if(~gui.respondsTo(\enableMeters)) { ~gui.enableMeters(true) };

        ~mpb.printChains;

        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // channel sanity print
        a = Ndef(\chainA).tryPerform(\numChannels);
        b = Ndef(\chainB).tryPerform(\numChannels);
        ("[CHECK] Ndef chain channels ‚Üí A:% , B:%".format(a, b)).postln;
    };

    // use the new class helper; no sleeps here
    ~mpb.waitUntilReady(2.5, 0.05, onReady);
};


// --- Execute clean sequence in one AppClock Routine --------------------------
runSequence = {
    var waitPreGUI, waitAfterMPB;
    waitPreGUI  = 0.05; // small settle between bundles
    waitAfterMPB = 0.15; // short window for GUI-created side effects

    Routine({
        // 0) Hygiene
        closeGuiWindows.value;

        // 1) Fresh boot + clean tree
        freshBoot.value;

        // 2) Predefine meter SynthDefs post-boot (safe re-add)
        // ensureMeterDefs.value;
		MagicDisplay.setMeterChannels(numChConst);

        // 3) Start clean, then build audio graph
        clearOldNdefs.value;
        buildAudio.value;

        // 4) Create GUI + MPB (this may quit the server in its init)
        waitPreGUI.wait;
        makeGuiAndMpb.value;

        // 5) Watch for server going down and coming back; then re-publish defs/graph
        waitAfterMPB.wait;    // allow immediate /quit to show up
        waitForServerDownThenUp.value;
// 6) Baseline + robust play (kept, since it launches CURRENT deterministically)
baselinePlayWithRetry.value;
// 7‚Äì8) Wait on a real MPB condition, then meters + verify (no fixed sleeps)
waitOnMpbReady.value;

    }).play(AppClock);
};

// Kick off the sequence
runSequence.value;
)

===== Magicpedalboard/_archive/2025-09-20/StartHere_Milestone_BringUpAndRun.scd =====
// StartHere_Milestone_BringUpAndRun.scd
// v0.1.5b
// MD 20250918-18:36 BST

/*
Purpose
- Clean, deterministic bring-up (fresh boot) + today's CommandTree-mimic milestone playlist.
- Simpler, robust boot sequencing: poll 'serverRunning'/'booting' (no doWhenBooted), so it proceeds
  even if the server is already booting. Extra step logs to confirm progression.

Style
- tilde vars at top-level; var-first in every function/closure; lowercase method names; no server.sync;
- server ops inside Server.default.bind; GUI ops on AppClock; JITLib operator exactly "<<>";
- generated audio only (no SoundIn); sinks/processors read from \in.ar(2).
*/

(
var log, step, pollUntil, freshBoot, makeGui, makeMpb, ensureSources;
var settleBeforeMeters, loadAdapterRobust, installInlineAdapter;
var waitOnMpbReadyThen, enableMetersAfterReady, runMilestone, runAll;
var gapSeconds, meterDelaySec;

// ---------- capture this script's directory once (for absolute loads) ----------
~scriptDir = ~scriptDir ?? {
    var pathString, dirString;
    pathString = thisProcess.nowExecutingPath;
    dirString = if(pathString.notNil) { PathName(pathString).pathOnly } { thisProcess.cwd };
    dirString
};
("[DEBUG] scriptDir=" ++ ~scriptDir).postln;

// ---------- small logger ----------
log = { arg messageString;
    var lineText;
    lineText = "[RUN] " ++ messageString;
    lineText.postln;
};

// terse step tagger
step = { arg tag; ("[STEP] " ++ tag).postln };

// ---------- generic AppClock poll (no server.sync) ----------
pollUntil = { arg conditionFunc, everySeconds = 0.05, onOkFunc;
    var tickFunc, secondsLocal, condFuncLocal, onOkLocal;
    condFuncLocal = conditionFunc;
    secondsLocal = everySeconds ? 0.05;
    onOkLocal = onOkFunc ? { nil };
    tickFunc = {
        var okNow;
        okNow = condFuncLocal.value;
        if(okNow) { onOkLocal.value; nil } { AppClock.sched(secondsLocal, tickFunc) }
    };
    AppClock.sched(0, tickFunc);
};

// ---------- reset globals before start ----------
~gui = nil;
~mpb = nil;

// ---------- 0) Fresh boot (polling): quit -> wait down -> boot -> wait up -> initTree ----------
freshBoot = {
    var serverRef, waitDown, waitUp, doInitTree;
    serverRef = Server.default;

    doInitTree = {
        var ignore;
        ignore = nil;
        Server.default.bind({
            serverRef.initTree;
            serverRef.defaultGroup.freeAll;
        });
        MagicDisplay.setMeterChannels(2); // compile-time meter defs to 2ch
        log.("server tree inited; meter defs set to 2ch");
    };

    waitUp = {
        var cond;
        cond = { serverRef.serverRunning };
        pollUntil.value(cond, 0.05, {
            doInitTree.value;
        });
    };

    waitDown = {
        var cond;
        cond = { serverRef.serverRunning.not and: { serverRef.booting.not } };
        pollUntil.value(cond, 0.05, {
            log.("fresh boot: starting server‚Ä¶");
            serverRef.boot;
            waitUp.value;
        });
    };

    if(serverRef.serverRunning or: { serverRef.booting }) {
        log.("fresh boot: quitting current server‚Ä¶");
        serverRef.quit;
        // give the server a moment to start going down, then poll until fully down
        AppClock.sched(0.05, { waitDown.value; nil });
    }{
        log.("fresh boot: starting server‚Ä¶");
        serverRef.boot;
        waitUp.value;
    };
};

// ---------- 1) GUI: close old MagicDisplayGUI and create a fresh one ----------
makeGui = {
    var closeOldFunc;
    closeOldFunc = {
        var windowsList;
        windowsList = Window.allWindows.select({ arg w;
            var nameString, isMagic;
            nameString = w.tryPerform(\name);
            isMagic = nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") };
            isMagic
        });
        windowsList.do({ arg w; w.close });
        log.("closed any existing MagicDisplayGUI windows");
    };
    AppClock.sched(0, {
        closeOldFunc.value;
        ~gui = MagicDisplayGUI.new;
        nil
    });
};

// ---------- 2) MPB: create AFTER GUI exists ----------
makeMpb = {
    pollUntil.value({ ~gui.notNil }, 0.05, {
        AppClock.sched(0, {
            ~mpb = MagicPedalboardNew.new(~gui);
            log.("MagicPedalboardNew created");
            nil
        });
    });
};

// ---------- 3) Sources (generated only) ----------
ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, freqSig, envAmp, panPos, outSig;
                trig    = Impulse.kr(3.2);
                seq     = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freqSig = Demand.kr(trig, 0, seq);
                envAmp  = Decay2.kr(trig, 0.01, 0.35);
                panPos  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                outSig  = Pan2.ar(SinOsc.ar(freqSig) * envAmp * 0.25, panPos);
                outSig
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });
        Ndef(\ts0).ar(2);
    });
    log.("sources ensured (\\testmelody stereo; \\ts0 silent stereo)");
};

// ---------- 4) Settle BEFORE meters: Option A + pin sinks (NO setSourcesBoth here) ----------
settleBeforeMeters = {
    pollUntil.value({ ~mpb.notNil }, 0.05, {
        ~mpb.playCurrent;                         // deterministic CURRENT audible
        ~mpb.enforceExclusiveCurrentOptionA(0.1); // NEXT silent at source

        Server.default.bind({
            Ndef(\chainA).mold(2, \audio);
            Ndef(\chainB).mold(2, \audio);
        });

        ~mpb.printChains;
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    });
};

// ---------- 5) Adapter: absolute-load robustly; fallback to inline mini-adapter ----------
installInlineAdapter = {
    if(~ct_applyOSCPathToMPB.isNil) {
        ~ct_applyOSCPathToMPB = { arg pathString, mpb, gui;
            var tokens, normalized, verbLower, argsList, onOffStr, procSym, idxA, idxB, lastTail;
            tokens = pathString.asString.split($/).reject({ arg t; t.isEmpty }).collect(_.asString);
            normalized = if(tokens.size > 0 and: { tokens[0] == "commands" }) { tokens.copyRange(1, tokens.size - 1) } { tokens };
            verbLower = (normalized.size > 0).if({ normalized[0].toLower }, { "" });
            argsList  = (normalized.size > 1).if({ normalized.copyRange(1, normalized.size - 1) }, { [] });

            switch(verbLower,
                "add",      { if(argsList.size >= 1) { procSym = argsList[0].asSymbol; mpb.add(procSym) } },
                "bypass",   {
                    if(argsList.size >= 2) {
                        procSym  = argsList[0].asSymbol;
                        onOffStr = argsList[1].toLower;
                        onOffStr = (["on","off","true","false","1","0"].includes(onOffStr)).if({
                            if((onOffStr=="true") or: { onOffStr=="1" }) { "on" } { onOffStr }
                        }, { "on" });
                        mpb.bypass(procSym, onOffStr=="on");
                    };
                },
                "removeat", { if(argsList.size >= 1) { mpb.removeAt(argsList[0].asInteger) } },
                "swap",     { if(argsList.size >= 2) { idxA=argsList[0].asInteger; idxB=argsList[1].asInteger; mpb.swap(idxA, idxB) } },
                "setsource",{ if(argsList.size >= 1) { mpb.setSource(argsList[0].asSymbol) } },
                "switch",   {
                    lastTail = mpb.effectiveNext.last;
                    if(lastTail == \ts0) { mpb.setSource(\testmelody) }; // guard
                    mpb.switchChain(0.12);
                },
                { /* ignore unknown */ }
            );
        };
        log.("inline mini-adapter installed (fallback)");
    };
};

loadAdapterRobust = {
    var adapterFileLower, adapterFileCamel, existsLower, existsCamel;
    if(~ct_applyOSCPathToMPB.notNil) {
        log.("adapter already present");
        ^this;
    };
    adapterFileLower = (~scriptDir +/+ "adapter_commandtree_to_magicpedalboard.scd").standardizePath;
    adapterFileCamel = (~scriptDir +/+ "adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    existsLower = File.exists(adapterFileLower);
    existsCamel = File.exists(adapterFileCamel);

    if(existsLower) {
        adapterFileLower.load; log.("adapter loaded: " ++ adapterFileLower);
    }{
        if(existsCamel) {
            adapterFileCamel.load; log.("adapter loaded: " ++ adapterFileCamel);
        }{
            log.("adapter file not found near script; installing fallback");
            installInlineAdapter.value;
        };
    };
};

// ---------- 6) Readiness gate only after ~mpb exists ----------
waitOnMpbReadyThen = { arg onReadyFunc;
    var onOkLocal;
    onOkLocal = onReadyFunc ? { nil };
    pollUntil.value({ ~mpb.notNil }, 0.05, {
        ~mpb.waitUntilReady(2.5, 0.05, {
            ("[PLAY] A=% B=%"
                .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            onOkLocal.value;
        });
    });
};

// ---------- 7) Re-enforce Option A and enable meters AFTER readiness (with a short delay) ----------
enableMetersAfterReady = {
    var postDelay;
    postDelay = meterDelaySec ? 0.25; // small settle delay

    AppClock.sched(postDelay, {
        ~mpb.enforceExclusiveCurrentOptionA(0.1); // re-check exclusivity before meters

        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            log.("meters enabled after readiness");
        };
        ("[CHECK] Ndef chain channels -> A:% , B:%"
            .format(Ndef(\chainA).tryPerform(\numChannels), Ndef(\chainB).tryPerform(\numChannels))).postln;
        nil
    });
};

// ---------- 8) Milestone playlist (single prime sets sources) ----------
runMilestone = {
    var gapLocal, applyPathFunc, primeFunc, playlistArray, stepIndex, stepCount, stepFunc;
    gapLocal = 0.60;

    applyPathFunc = { arg pathString;
        var lineText;
        lineText = "[TOKENS] apply -> " ++ pathString;
        lineText.postln;
        ~ct_applyOSCPathToMPB.(pathString, ~mpb, ~gui);
    };

    primeFunc = {
        ~mpb.setSourcesBoth(\testmelody);     // single place we set both tails today
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        ~mpb.printChains;
        ("[PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    playlistArray = [
        "/add/delay",
        "/switch",
        "/bypass/delay/on",
        "/bypass/delay/off",
        "/switch"
    ];
    stepIndex = 0;
    stepCount = playlistArray.size;

    stepFunc = {
        var doneNow;
        doneNow = (stepIndex >= stepCount);
        if(doneNow) {
            AppClock.sched(0.9, {
                ("[PLAY] A=% B=%"
                    .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
                ~mpb.printChains;
                nil
            });
            ^nil
        };
        applyPathFunc.value(playlistArray[stepIndex]);
        stepIndex = stepIndex + 1;
        AppClock.sched(gapLocal, stepFunc);
    };

    primeFunc.value;
    AppClock.sched(gapLocal, stepFunc);
};

// ---------- 9) Orchestrate strictly in order ----------
runAll = {
    var proceedAfterBoot;
    proceedAfterBoot = {
        makeGui.value;           step.("GUI");
        makeMpb.value;           step.("MPB create");
        ensureSources.value;     step.("sources");
        settleBeforeMeters.value;step.("settle-before-meters");
        loadAdapterRobust.value; step.("adapter");
        waitOnMpbReadyThen.value({
            enableMetersAfterReady.value; step.("meters");
            runMilestone.value;          step.("playlist");
        });
    };
    log.("orchestration start");
    freshBoot.value;             step.("boot-in-progress");
    // Continue once server is really running and tree initialized
    pollUntil.value({ Server.default.serverRunning }, 0.05, {
        // a tiny guard in case initTree hasn't run yet
        AppClock.sched(0.10, { proceedAfterBoot.value; nil });
    });
};

gapSeconds    = 0.60;
meterDelaySec = 0.25;

// fire
runAll.value;
)

===== Magicpedalboard/_archive/2025-09-20/Switch_VerifyCurrentAudible_OptionA.scd =====
// Switch_VerifyCurrentAudible_OptionA.scd
// v0.1
// MD 20250917-1320
//
// Purpose: After switching, ensure CURRENT sink is audibly playing and NEXT is ended,
//          without altering any sink sources. Non-intrusive.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, enforce;

log = { arg s; ("[SWCHK] " ++ s).postln };

enforce = {
    var cur = ~mpb.currentChain[0], nxt = ~mpb.nextChain[0];
    Server.default.bind({
        // Make CURRENT audible
        Ndef(cur).mold(2, \audio);
        if(Ndef(cur).isPlaying.not) { Ndef(cur).play(numChannels: 2) };

        // Make NEXT cleanly inactive (flag false), keep stereo shape
        Ndef(nxt).end;
        Ndef(nxt).mold(2, \audio);
    });
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
        ("[SWCHK] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

enforce.value;
)

===== Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation‚Äôs audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through ‚Äúprocessor‚Äù that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) ‚Üí short delay ‚Üí mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through ‚Äúprocessor‚Äù you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== Magicpedalboard/Adapter_UIHook_Install.scd =====
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)

===== Magicpedalboard/bootstrap_audio_and_fx_min.scd =====
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) ‚Äì guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) ‚Äì matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)

===== Magicpedalboard/demo_apply_after_fix.scd =====
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== Magicpedalboard/demo_commandtree_apply_hotfix.scd =====
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON ‚Üí OFF ‚Üí final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== Magicpedalboard/demo_commandtree_apply_now.scd =====
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)

===== Magicpedalboard/demo_commandtree_milestone.scd =====
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)

===== Magicpedalboard/demo_commandtree_preformed_queues.scd =====
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <‚Äî Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)

===== Magicpedalboard/Demo_Install_MinProcessors.scd =====
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)

===== Magicpedalboard/Diag_BusChannel_Map.scd =====
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2‚Üí1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)

===== Magicpedalboard/discarded/Runner_MagicDisplayGUI_DebugPatch.scd =====
/* Runner_MagicDisplayGUI_DebugPatch.scd
   Adds diagnostics + a force-create fallback for windowless runs.
   Style: tilde vars, var-first, lowercase names, no server.sync, no single-letter locals.
*/

(
// 0) quick AppClock sanity
~md_appClockCheck = {
    AppClock.sched(0, { "[CHECK] AppClock tick ok".postln; nil });
    { "[CHECK] defer ok".postln }.defer;
    "[CHECK] scheduled checks (AppClock + defer)".postln;
};

// 1) force-create: make a brand-new GUI + MPB on AppClock, no reuse
~md_forceCreateWindow = {
    AppClock.sched(0, {
        var guiObj, board, winReady;

        "[FORCE] Creating MagicDisplayGUI‚Ä¶".postln;
        guiObj = MagicDisplayGUI.new;
        guiObj.enableMeters(false);
        ~gui = guiObj;

        "[FORCE] Creating MagicPedalboardNew‚Ä¶".postln;
        board = MagicPedalboardNew(guiObj);
        ~mpb = board;

        AppClock.sched(0.05, {
            winReady = ~gui.tryPerform(\window);
            if(winReady.notNil) {
                "[FORCE] Window ready ‚Äî fronting.".postln;
                winReady.front;
            }{
                "[FORCE] Window not yet ready.".postln;
            };
            if(~refreshView.notNil) { ~refreshView.("force-create") };
            nil
        });

        nil
    });
};

// 2) robust ‚Äúis window alive?‚Äù
~md_isWindowAlive = {
    var winObj, wasRemoved, isClosed, viewObj, ok;
    if(~gui.isNil) { ^false };
    winObj = ~gui.tryPerform(\window);
    if(winObj.isNil) { ^false };
    viewObj = winObj.tryPerform(\view);
    wasRemoved = viewObj.tryPerform(\wasRemoved);
    if(wasRemoved.isNil) { wasRemoved = false };
    isClosed = winObj.tryPerform(\isClosed);
    if(isClosed.isNil) { isClosed = false };
    ok = (wasRemoved == false) and: (isClosed == false);
    ok
};

// 3) redefine reset: clear ~gui only if window is not alive, with explicit note
~md_resetSession = {
    var hadTask, hadBootTask, alive;
    hadTask = ~mdgTask.notNil;
    hadBootTask = ~bootTask.notNil;

    hadTask.if({ ~mdgTask.stop; ~mdgTask = nil; });
    hadBootTask.if({ ~bootTask.stop; ~bootTask = nil; });

    alive = ~md_isWindowAlive.();
    if(alive.not) { ~gui = nil };

    ~mpb = nil;
    ~magicDisplay = nil;

    ("[RUNNER] Reset: tasks stopped; references cleared."
        ++ (alive.not.if({ " (~gui cleared: window not alive)" }, { "" }))).postln;
};

// 4) instrumented ~bootGuiV6: logs every step inside AppClock so we can see where it stops
~bootGuiV6 = {
    var myToken;
    ~md_resetSession.();

    ~md_bootToken = (~md_bootToken ? 0) + 1;
    myToken = ~md_bootToken;

    "[BOOT] Enter".postln;
    "Booting GUI (meters disabled). Waiting for window‚Ä¶".postln;

    AppClock.sched(0, {
        var winOk, existingWin, guiObj, board;

        ("[BOOT/AC] token=" ++ myToken.asString ++ " current=" ++ ~md_bootToken.asString).postln;
        if(~md_bootToken != myToken) { "[BOOT/AC] stale token; abort".postln; ^nil };

        winOk = ~md_isWindowAlive.();
        ("[BOOT/AC] windowAlive=" ++ winOk.asString).postln;

        if(winOk) {
            existingWin = ~gui.tryPerform(\window);
            "[BOOT/AC] reusing window ‚Üí front".postln;

            if(~mpb.isNil) {
                "[BOOT/AC] ~mpb missing ‚Üí creating‚Ä¶".postln;
                board = MagicPedalboardNew(~gui);
                ~mpb = board;
                "[BOOT/AC] ~mpb created".postln;
            };

            existingWin.front;
            if(~refreshView.notNil) { ~refreshView.("boot (reuse)") };
            ^nil
        };

        "[BOOT/AC] creating GUI‚Ä¶".postln;
        guiObj = MagicDisplayGUI.new;
        guiObj.enableMeters(false);
        ~gui = guiObj;

        "[BOOT/AC] creating MPB‚Ä¶".postln;
        board = MagicPedalboardNew(guiObj);
        ~mpb = board;

        AppClock.sched(0.05, {
            var winReady;
            "[BOOT/AC] post-create tick".postln;
            if(~md_bootToken != myToken) { "[BOOT/AC] stale token in post-create; abort".postln; ^nil };
            winReady = ~gui.tryPerform(\window);
            if(winReady.notNil) {
                "[BOOT/AC] window ready ‚Üí front".postln;
                winReady.front;
            }{
                "[BOOT/AC] window not yet available".postln;
            };
            if(~refreshView.notNil) { ~refreshView.("boot") };
            nil
        });

        nil
    });
};
)

===== Magicpedalboard/discarded/scenarios.scd =====
// scenarios.scd v.0.1
// MD 20250914



/////////////////////////////////
// [0] Run this at the beginning
(
// Minimal processor bootstrap so the symbols exist (stereo-safe).
// Each processor reads from \in.ar(2) to guarantee 2 channels.

var defineProxy;

// Wrapper that defines/overwrites an Ndef and ensures it's audio & 2ch.
defineProxy = { arg key, func;
    var canRun;
    canRun = Server.default.serverRunning;
    if(canRun) {
        Server.default.bind({
            Ndef(key, func);  // set function
            Ndef(key).ar(2);  // ensure 2ch bus
        });
    } {
        "Server not running; start the server first.".postln;
    };
};

// Source tap (ts0) ‚Äì default source (stereo)
defineProxy.(\ts0, {
    var inputSignal;
    inputSignal = SoundIn.ar([0, 1]);  // explicit L/R
    inputSignal
});

// Simple delay (stereo-safe)
defineProxy.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar(2);             // <-- force stereo
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

// Tremolo (stereo-safe)
defineProxy.(\tremolo, {
    var inputSignal, rate, depth, lfo;
    inputSignal = \in.ar(2);
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    lfo   = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * lfo
});

// Reverb (stereo-safe without indexing)
defineProxy.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar(2);
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    // FreeVerb.ar preserves channel count; avoids input[0]/input[1] indexing
    FreeVerb.ar(inputSignal, mix, room, damp)
});

// Chorus (stereo-safe)
defineProxy.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar(2);
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

// Gentle drive (stereo-safe)
defineProxy.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar(2);
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Create the pedalboard (no display for now)
~pedalboard = MagicPedalboardNew.new;

// Quick sanity
~pedalboard.printChains;
)






/////////////////////////////////
// [1] Build, switch, clone, replace

(
// ensure clean baseline
var processors, currentProcs, delayIndex;

// 1) reset to source-only on both lanes
~pedalboard.reset;
~pedalboard.printChains;

// 2) add a delay to NEXT (before source) and inspect
~pedalboard.add(\delay);
~pedalboard.printChains;

// 3) go live with NEXT (crossfade ~100 ms)
~pedalboard.switchChain(0.1);

// 4) clone CURRENT‚Äôs processors into NEXT (same order), same source
//    (CURRENT is now Lane A)
processors = ~pedalboard.effectiveCurrent;
currentProcs = if(processors.size > 2) { processors.copyRange(1, processors.size-2) } { [] };
~pedalboard.clearChain;
currentProcs.do({ arg key; ~pedalboard.add(key) });
~pedalboard.setSource(processors.last);
~pedalboard.printChains;

// 5) add a reverb after the delay in NEXT and inspect
~pedalboard.add(\reverb);
~pedalboard.printChains;

// 6) switch to NEXT (now has delay -> reverb)
~pedalboard.switchChain(0.12);

// 7) replace delay with tremolo in NEXT
//    find the index of \delay (processors start at index 1)
processors = ~pedalboard.effectiveNext;
delayIndex = processors.indexOf(\delay); // this is in the effective list
if(delayIndex.notNil and: { delayIndex > 0 and: { delayIndex < (processors.size-1) } }) {
    // translate from effective index to chain index (same here since only processors differ)
    ~pedalboard.removeAt(delayIndex);          // remove \delay
    ~pedalboard.addAt(\tremolo, delayIndex);   // add \tremolo in the same position
};
~pedalboard.printChains;

// 8) switch again: we should now hear tremolo -> reverb
~pedalboard.switchChain(0.1);
)

/////////////////////////////////
// [2] Bypass, swap order, fine‚Äëtune fades
(
// Assumes Scenario 1 ran. We'll work on NEXT for safe edits.
var procs;

// 1) build NEXT as: tremolo -> chorus -> delay -> reverb
~pedalboard.clearChain;
~pedalboard.add(\tremolo);
~pedalboard.add(\chorus);
~pedalboard.add(\delay);
~pedalboard.add(\reverb);
~pedalboard.printChains;

// 2) temporarily bypass chorus and reverb in NEXT
~pedalboard.bypass(\chorus, true);
~pedalboard.bypass(\reverb, true);
~pedalboard.printChains;

// 3) A/B with a gentle crossfade (200 ms clamp)
~pedalboard.switchChain(0.25); // will clamp to 0.2 inside the method

// 4) bring chorus back, keep reverb bypassed
~pedalboard.bypass(\chorus, false);
~pedalboard.printChains;

// 5) swap order of tremolo and chorus (indexes 1 and 2 among processors)
~pedalboard.swap(1, 2);
~pedalboard.printChains;

// 6) longer musical crossfade (still clamped internally)
~pedalboard.switchChain(0.5);

// 7) un-bypass reverb and switch again
~pedalboard.bypass(\reverb, false);
~pedalboard.switchChain(0.1);
)


/////////////////////////////////
// [3] Live tweaks on CURRENT while playing
(
// Starting from Scenario 2‚Äôs end, we‚Äôll tweak CURRENT safely.

var currentEff, lastProcIndex;

// 1) print current live lane and effective chain
~pedalboard.printChains;

// 2) bypass the first processor in CURRENT (index 1)
~pedalboard.bypassAtCurrent(1, true);
~pedalboard.printChains;

// 3) un-bypass it
~pedalboard.bypassAtCurrent(1, false);

// 4) change the source feeding CURRENT to \ts0 (explicit, even if it's already so)
~pedalboard.setSourceCurrent(\ts0);

// 5) quickly A/B to NEXT and back with short fades
~pedalboard.switchChain(0.1);
~pedalboard.switchChain(0.1);

// 6) remove the last processor in NEXT and insert drive before it
currentEff = ~pedalboard.effectiveNext;
lastProcIndex = currentEff.size - 2;
if(lastProcIndex >= 1) {
    ~pedalboard.removeAt(lastProcIndex);
    ~pedalboard.addAt(\drive, lastProcIndex);
};
~pedalboard.printChains;

// 7) take it live
~pedalboard.switchChain(0.1);
)

/////////////////////////////////
// [4] Build a larger chain, then re‚Äëorder granularly
(
// We'll target NEXT, build: drive -> tremolo -> chorus -> delay -> reverb

// 1) reset NEXT to empty (sink, source)
~pedalboard.clearChain;

// 2) add a stack
~pedalboard.add(\drive);
~pedalboard.add(\tremolo);
~pedalboard.add(\chorus);
~pedalboard.add(\delay);
~pedalboard.add(\reverb);

// 3) check
~pedalboard.printChains;

// 4) move reverb before delay (swap processor positions)
~pedalboard.swap(4, 3);  // indexes within processor band (1..n)

// 5) bring chorus to the front (swap it up twice)
~pedalboard.swap(3, 2);
~pedalboard.swap(2, 1);
~pedalboard.printChains;

// 6) A/B in
~pedalboard.switchChain(0.1);

// 7) try removing tremolo and adding it back at the end
~pedalboard.removeAt(2);
~pedalboard.add(\tremolo);
~pedalboard.printChains;

// 8) switch again
~pedalboard.switchChain(0.1);
)

/////////////////////////////////
// [5] Panic‚Äësafe reset and rebuild both lanes
(
// 1) full safe reset
~pedalboard.reset;

// 2) build NEXT quickly: delay -> reverb
~pedalboard.add(\delay);
~pedalboard.add(\reverb);

// 3) go live
~pedalboard.switchChain(0.1);

// 4) copy CURRENT to NEXT, add chorus, bypass delay
var eff, procs;
eff = ~pedalboard.effectiveCurrent;
procs = if(eff.size > 2) { eff.copyRange(1, eff.size-2) } { [] };
~pedalboard.clearChain;
procs.do({ arg key; ~pedalboard.add(key) });
~pedalboard.add(\chorus);
~pedalboard.bypass(\delay, true);
~pedalboard.printChains;

// 5) set a different source for NEXT (still \ts0 here, but shows how)
~pedalboard.setSource(\ts0);

// 6) A/B in
~pedalboard.switchChain(0.1);

// 7) final inspection
~pedalboard.printChains;
)

===== Magicpedalboard/discarded/TEST_overlayHotFix.scd =====
// TEST_overlayHotFix.scd

(
// v0.10.6: self-contained, deterministic flow
// - One window (token-gated boot on AppClock)
// - No programmatic window closing (avoid Qt races)
// - No watchers, no queueUi patching
// - Includes fallbacks for ~refreshGuiFromMpb and ~probeGuiV3
// - Fast AppClock scenario (works regardless of internal UI queue)

// ---------------------------
// 0) utilities + boot token
// ---------------------------
~md_bootToken = (~md_bootToken ? 0);

~md_log = { |messageString| ("[RUNNER] " ++ messageString).postln };

// ---------------------------
// 1) minimal reset (no closing)
// ---------------------------
~md_resetSession = {
    var hadTask, hadBootTask;
    hadTask = ~mdgTask.notNil;
    hadBootTask = ~bootTask.notNil;

    hadTask.if({ ~mdgTask.stop; ~mdgTask = nil; });
    hadBootTask.if({ ~bootTask.stop; ~bootTask = nil; });

    // Don't touch windows; just clear refs we own
    ~mpb = nil;
    ~magicDisplay = nil;

    ~md_log.("Reset: tasks stopped; references cleared.");
};

// -------------------------------------------
// 2) single, idempotent boot on AppClock only
// -------------------------------------------
~bootGuiV6 = {
    var myToken;
    ~md_resetSession.();

    ~md_bootToken = ~md_bootToken + 1;
    myToken = ~md_bootToken;

    "Booting GUI (meters disabled). Waiting for window‚Ä¶".postln;

    AppClock.sched(0, {
        var existingWin, guiObj, board;

        if(~md_bootToken != myToken) { ^nil }; // newer boot superseded us

        // Reuse existing window if available
        if(~gui.notNil) {
            existingWin = ~gui.tryPerform(\window);
            if(existingWin.notNil) {
                "Window found ‚Äî reusing and fronting.".postln;
                existingWin.front;
                if(~refreshView.notNil) { ~refreshView.("boot (reuse)") };
                ^nil
            };
        };

        guiObj = MagicDisplayGUI.new;
        guiObj.enableMeters(false);
        ~gui = guiObj;

        board = MagicPedalboardNew(guiObj);
        ~mpb = board;

        AppClock.sched(0.05, {
            var winReady;
            if(~md_bootToken != myToken) { ^nil };
            winReady = ~gui.tryPerform(\window);
            if(winReady.notNil) {
                "Window ready ‚Äî fronting and drawing columns.".postln;
                winReady.front;
            }{
                "Window not yet available; will front on next GUI call.".postln;
            };
            if(~refreshView.notNil) { ~refreshView.("boot") };
            nil
        });

        nil
    });
};

// ------------------------------------------------------
// 3) fallbacks if your monolithic helpers aren‚Äôt loaded
// ------------------------------------------------------
~refreshGuiFromMpb = ~refreshGuiFromMpb ? {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "[FALLBACK] Run ~bootGuiV6.() first.".warn; ^nil };
    curr = ~mpb.currentChain; nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent; eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~probeGuiV3 = ~probeGuiV3 ? {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;
    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV6.() first.".warn; ^nil };
    hasWin = ~gui.tryPerform(\window).notNil;
    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    ~gui.showExpectation("Command: PROBE FRAME", 0);

    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock‚Ä¶".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });
    "Probe queued. Expect 'PROBE FRAME' + AAA/BBB/CCC/DDD in lists.".postln;
};

// ------------------------------------------------------
// 4) fast scenario: each step runs on AppClock directly
// ------------------------------------------------------
~scenario1v6_fast = {
    var paceSeconds, steps, controllerRoutine, totalSteps, stepIndex;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV6.() first.".warn; ^nil };

    paceSeconds = 0.8;
    steps = [
        { "[SC] init".postln; ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { "[SC] add flanger".postln; ~gui.showExpectation("Command: add flanger", 0); ~mpb.add(\flanger); ~refreshGuiFromMpb.() },
        { "[SC] bypass flanger true".postln; ~gui.showExpectation("Command: bypass flanger true", 0); ~mpb.bypass(\flanger, true); ~refreshGuiFromMpb.() },
        { "[SC] add delay".postln; ~gui.showExpectation("Command: add delay", 0); ~mpb.add(\delay); ~refreshGuiFromMpb.() },
        { "[SC] clear NEXT".postln; ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    totalSteps = steps.size;

    ~mdgTask.notNil.if({ ~mdgTask.stop; ~mdgTask = nil });

    controllerRoutine = Routine({
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            AppClock.sched(0, { steps[stepIndex].value; nil });
            paceSeconds.wait; // pacing on SystemClock
            stepIndex = stepIndex + 1;
        });
    });
    ~mdgTask = controllerRoutine.play(SystemClock);
    ~mdgTask
};

// ------------------------------------------------------
// 5) single-button: reset ‚Üí boot ‚Üí probe ‚Üí fast scenario
// ------------------------------------------------------
~md_bootProbeScenario = {
    var runnerTask;
    runnerTask = Task({
        ~md_log.("Starting: reset ‚Üí boot ‚Üí probe ‚Üí scenario");
        ~bootGuiV6.();

        // allow the window to build & front
        0.9.wait;

        ~md_log.("Probe‚Ä¶");
        ~probeGuiV3.();

        0.3.wait;

        ~md_log.("Scenario (fast)‚Ä¶");
        ~scenario1v6_fast.();
    });
    runnerTask.start;
    runnerTask
};

// optional: quick window inspector
~md_checkWindows = {
    AppClock.sched(0, {
        var wins;
        wins = Window.allWindows ? [];
        ("[CHECK] window count = " ++ wins.size).postln;
        wins.do({ |w, idx| ("[CHECK] w" ++ idx ++ " title=" ++ w.name.asString).postln });
        nil
    });
};

"Ready. Run: ~md_bootProbeScenario.();  (or step-by-step: ~bootGuiV6.(); ~probeGuiV3.(); ~scenario1v6_fast.(); )".postln;
)

===== Magicpedalboard/docs and references/cheatsheet.scd =====
// cheatsheet.cd
// MD 20250913-1037

// Inspect
~pedalboard.printChains;            // or use your display adaptor

// Build NEXT non-destructively
~pedalboard.add(\delay);
~pedalboard.bypass(\delay, true);
~pedalboard.swap(1, 2);

// Go live with a short crossfade
~pedalboard.switchChain(0.1);

// Adjust CURRENT temporarily
~pedalboard.bypassAtCurrent(1, false);

// Change sources
~pedalboard.setSource(\ts1);
~pedalboard.setSourceCurrent(\ts2);

// Panic-safe reset
~pedalboard.reset;

===== Magicpedalboard/docs and references/usingLibraryWithMagicPedalboard.scd =====
// usingLibraryWithMagicPedalboard.scd
// MD 20250915-0914


(
// If you‚Äôve loaded MagicProcessorLibrary_defs.scd already:
~procLib.ensureMany([\ts0, \delay, \tremolo, \reverb, \chorus, \drive], 2);

// Then (re)build your pedalboard chains knowing those symbols resolve:
~pedalboard.reset;
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
)

===== Magicpedalboard/editor_commandtree_add_demo_verbs.scd =====
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "‚úÖ Loaded tree for editing.".postln;
} {
    "‚ùå Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)

===== Magicpedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects ‚Äì same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== Magicpedalboard/Manage_MagicDisplayGUI_Singleton.scd =====
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_CloseRecreateBind_GUI_GridDemo.scd =====
// MPBTest_CloseRecreateBind_GUI_GridDemo.scd
// v0.1.0
// MD 20250920-1919
(
var closeExisting, createGrid, bindAndFill;

closeExisting = {
    AppClock.sched(0.00, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            var nm = w.tryPerform(\name) ? "";
            nm.asString.beginsWith("MagicDisplayGUI")
        });
        wins.do(_.close);
        nil
    });
};

createGrid = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
        nil
    });
};

bindAndFill = {
    AppClock.sched(0.10, {
        if(~mpb.notNil and: { ~gui.notNil }) {
            ~mpb.setDisplay(~gui);
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            ~mpb.printChains;
            ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
        }{
            "[REBIND] ~mpb or ~gui missing".warn;
        };
        nil
    });
};

closeExisting.value;
createGrid.value;
bindAndFill.value;
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd =====
// MPBTest_FreshBootBringUp_Now.scd
// v0.1.1
// MD 20250920-1642

(
var s, startBoot, afterBoot, waitDown, doFreshBoot;

s = Server.default;

afterBoot = {
    AppClock.sched(0.00, {
        ~bring = MPBTest_BringUp.new(true, 2, 0.40, true); // use loud test source & publish tildes
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };
        nil
    })
};

startBoot = {
    s.doWhenBooted({ afterBoot.value });
    if(s.serverRunning.not) { s.boot };
};

waitDown = {
    if(s.serverRunning.not) { startBoot.value; nil } {
        AppClock.sched(0.05, waitDown)
    }
};

doFreshBoot = {
    if(s.serverRunning) {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };
        s.quit;
        AppClock.sched(0.05, waitDown);
    }{
        startBoot.value;
    };
};

doFreshBoot.value;
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_RebindAndFillGUI.scd =====
// MPBTest_RebindAndFillGUI.scd
// v0.1.0
// MD 20250920-1919

(
var need;

// 0) Precondition: we want ~mpb and ~gui alive
need = (~mpb.notNil) && (~gui.notNil);
if(need.not) {
    "[REBIND] need ~mpb and ~gui; run MPBTest_BringUp first.".warn;
    ^nil;
};

// 1) If the GUI was created after MPB, bind it now
if(~mpb.display.isNil or: { ~mpb.display !== ~gui }) {
    ~mpb.setDisplay(~gui);
    "[REBIND] bound ~gui to ~mpb".postln;
};

// 2) Make sure it‚Äôs in front (and visible)
AppClock.sched(0.02, {
    var w;
    w = ~gui.tryPerform(\window);
    if(w.notNil) { w.front; w.alwaysOnTop_(true) };
    nil
});

// 3) Reattach meters (guards inside GUI)
AppClock.sched(0.04, {
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
    nil
});

// 4) Fill the chains view now
AppClock.sched(0.06, {
    ~mpb.printChains; // drives showChainsDetailed when a display is bound
    // highlight current column for good measure
    ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
    nil
});
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_Record_WorkingState.scd =====
// MPBTest_Record_WorkingState.scd
// v0.1.1
// MD 20250920-1930

(
var now, stamp, docDir, mdPath, jsonPath, mkDir;
var s, o, outDev, sr, blk, scv, lines, md, js;
var v_mpbtest_bring, v_mpbtest_scen, v_mpbtest_suites, v_mpbtest_assert;
var v_mpb, v_md, v_mdgui, v_mdgrid;
var fileList, classPaths;

/*// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930
docDir = PathName(thisProcess.nowExecutingPath ?? thisProcess.cwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;*/

// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930

// Use script location if available, else current working directory
docDir = PathName(thisProcess.nowExecutingPath ? File.getcwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;


mkDir = { |p|
    var pn = PathName(p);
    if(pn.isFolder.not) {
        File.mkdir(p);
    };
};


// 1) Ensure docs dir
mkDir.(docDir);

// 2) Environment
s  = Server.default;
o  = s.options;
outDev = o.outDevice ? "default";
sr  = s.sampleRate ? 0;
blk = o.blockSize;
/*scv = Main.scVersionString ? Main.scVersion;*/
/*scv = Platform.version.asString;*/
scv = thisProcess.interpreter.version;


// 3) Versions
v_mpbtest_bring  = (MPBTest_BringUp.respondsTo(\version)).if({ MPBTest_BringUp.version },{ "unknown" });
v_mpbtest_scen   = (MPBTest_Scenario.respondsTo(\version)).if({ MPBTest_Scenario.version },{ "unknown" });
v_mpbtest_suites = (MPBTest_AcceptanceSuites.respondsTo(\version)).if({ MPBTest_AcceptanceSuites.version },{ "unknown" });
v_mpbtest_assert = (MPBTest_Assertions.respondsTo(\version)).if({ MPBTest_Assertions.version },{ "unknown" });

v_mpb    = (MagicPedalboardNew.respondsTo(\version)).if({ MagicPedalboardNew.version },{ "unknown" });
v_md     = (MagicDisplay.respondsTo(\version)).if({ MagicDisplay.version },{ "unknown" });
v_mdgui  = (MagicDisplayGUI.respondsTo(\version)).if({ MagicDisplayGUI.version },{ "unknown" });
v_mdgrid = (MagicDisplayGUI_GridDemo.respondsTo(\version)).if({ MagicDisplayGUI_GridDemo.version },{ "unknown" });

// 4) Class file paths (confirm there‚Äôs only one of each)
classPaths = Class.allClasses
    .select({ |c| ["MPBTest_BringUp","MPBTest_Scenario","MPBTest_AcceptanceSuites","MPBTest_Assertions"].includes(c.name.asString) })
    .collect(_.filenameSymbol.asString);

// 5) Chain snapshot
~mpb = ~mpb ?? { nil };
fileList = if(~mpb.notNil, {
    var effC = ~mpb.effectiveCurrent, effN = ~mpb.effectiveNext;
    [
        "CURRENT=" ++ effC.asString,
        "NEXT   =" ++ effN.asString,
        "[PLAY] A=" ++ Ndef(\chainA).isPlaying ++ " B=" ++ Ndef(\chainB).isPlaying
    ]
}, { ["no ~mpb"] });

// 6) Write Markdown + JSON
mdPath   = docDir +/+ ("WorkingState_" ++ stamp ++ ".md");
jsonPath = docDir +/+ ("WorkingState_" ++ stamp ++ ".json");

// Markdown
md = String.new;
md = md
++ "# MagicPedalboard ‚Äì Working State (" ++ stamp ++ ")\n\n"
++ "## Versions\n"
++ "- MPBTest_BringUp: "   ++ v_mpbtest_bring  ++ "\n"
++ "- MPBTest_Scenario: "  ++ v_mpbtest_scen   ++ "\n"
++ "- MPBTest_AcceptanceSuites: " ++ v_mpbtest_suites ++ "\n"
++ "- MPBTest_Assertions: "++ v_mpbtest_assert ++ "\n"
++ "- MagicPedalboardNew: "++ v_mpb ++ "\n"
++ "- MagicDisplay: "      ++ v_md  ++ "\n"
++ "- MagicDisplayGUI: "   ++ v_mdgui  ++ "\n"
++ "- MagicDisplayGUI_GridDemo: " ++ v_mdgrid ++ "\n\n"
++ "## Environment\n"
++ "- sclang: " ++ scv ++ "\n"
++ "- output device: " ++ outDev ++ "\n"
++ "- sample rate: " ++ sr ++ "\n"
++ "- block size: " ++ blk ++ "\n\n"
++ "## Class Files\n- " ++ classPaths.join("\n- ") ++ "\n\n"
++ "## Chain Snapshot\n- " ++ fileList.join("\n- ") ++ "\n";

File.writeText(mdPath, md);

// JSON (minimal)
js = (
    timestamp: stamp,
    versions: (
        MPBTest_BringUp: v_mpbtest_bring, MPBTest_Scenario: v_mpbtest_scen,
        MPBTest_AcceptanceSuites: v_mpbtest_suites, MPBTest_Assertions: v_mpbtest_assert,
        MagicPedalboardNew: v_mpb, MagicDisplay: v_md,
        MagicDisplayGUI: v_mdgui, MagicDisplayGUI_GridDemo: v_mdgrid
    ),
    environment: (
        sclang: scv, outDevice: outDev, sampleRate: sr, blockSize: blk
    ),
    classFiles: classPaths
).asCompileString;

File.writeText(jsonPath, js);

("[RECORD] wrote\n- " ++ mdPath ++ "\n- " ++ jsonPath).postln;
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== Magicpedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== Magicpedalboard/obsolete/ Test_MagicPedalboardNew_v0_15_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_GUI_Operations.scd
// Visual ops list + expectation + 3s countdown + meters in GUI
// MD 20250912-1511

(
s.waitForBoot({
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 0) Preflight (safe, no s.freeAll; var-first)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var preflightCleanup;
	    var m, gui, setHear, ops, doStep;

    preflightCleanup = {
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;
        Ndef.all.keysValuesDo { arg keySym, proxyRef;
            if(proxyRef.isPlaying) { ("[CLEAN] stop " ++ keySym).postln; proxyRef.stop };
            proxyRef.clear;
        };
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { arg serverRef, proxySpace;
                if(proxySpace.notNil) { ("[CLEAN] ProxySpace on " ++ serverRef).postln; proxySpace.clear };
            };
        };
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };
        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) Minimal sources / processors
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Ndef(\ts0,  { Silent.ar(2) });
    Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

    Ndef(\tremolo, { arg rate = 4, depth = 0.8;
        var x;
        x = \in.ar(2);
        x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    Ndef(\lofi, { arg bits = 6, rate = 6000;
        var x;
        x = \in.ar(2);
        Decimator.ar(x, rate, bits)
    });

    Ndef(\atten, { arg gain = 0.25;
        var x;
        x = \in.ar(2);
        x * gain
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 2) Pedalboard + GUI setup
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // Start from a known silent baseline on CURRENT
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    // Enable meters (embedded)
    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 3) Define operations (strings + actions)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);       // lofi before atten
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // Bind operations and "Next" button
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            // Run on a SystemClock Routine to allow waits inside actions
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun; doStep.(indexToRun) });

    // Provide an initial hint
    gui.showExpectation("Press 'Next' to begin. The next action will run after a 3-second visual countdown.", 0);
});
)

===== Magicpedalboard/obsolete/acceptanceStepsTest.scd =====
// acceptanceStepsTest.scd
// v0.1
// MD 20250916

// [1] Add delay to NEXT (B while A is current)
~mpb.add(\delay);
~mpb.printChains;

// [2] Switch (A -> B) with a short fade
~mpb.switchChain(0.12);
("After switch: A.playing=" ++ Ndef(\chainA).isPlaying ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;

// [3] Bypass ON (CURRENT)
~mpb.bypassCurrent(\delay, true);
~mpb.printChains;

// [4] Bypass OFF (CURRENT)
~mpb.bypassCurrent(\delay, false);
~mpb.printChains;

// [5] Switch back (B -> A)
~mpb.switchChain(0.12);
("Final: A.playing=" ++ Ndef(\chainA).isPlaying
 ++ "  B.playing=" ++ Ndef(\chainB).isPlaying).postln;
~mpb.printChains;

===== Magicpedalboard/obsolete/audibleSanity.scd =====
// audibleSanity.scd
// v0.2
// MD 20250916

(
// --- A) Boot and define an internal source (stereo) ---
var ensureAudio, defineTestSource, overrideTs0, ensureGuiAndPedalboard, startCurrent, verify;

ensureAudio = {
    Server.default.boot;
};

defineTestSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

// --- B) Force ts0 to be internal (NOT SoundIn) for all tests today ---
overrideTs0 = {
    Server.default.bind({
        Ndef(\ts0, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.0);
            seq  = Dseq([196, 246.94, 329.63, 261.63, 329.63, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.40);
            tone = Pulse.ar(f, 0.5) * env * 0.20;
            panPos = LFTri.kr(0.1).linlin(-1, 1, -0.5, 0.5);
            Pan2.ar(tone, panPos)
        });
        Ndef(\ts0).ar(2);
    });
};

// --- C) GUI + Pedalboard, sinks ar(2), meters on ---
ensureGuiAndPedalboard = {
    ~gui = ~gui ?? { MagicDisplayGUI.new };
    ~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // toggle meters cleanly once (your enableMeters now guards for audio-rate + server)
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
};

// --- D) Set CURRENT source to internal generator and play ---
startCurrent = {
    ~mpb.setSourceCurrent(\testmelody); // generated source
    ~mpb.playCurrent;
};

// --- E) Verify status ---
verify = {
    ~mpb.printChains;
    ("[sanity] chainA.isPlaying=% chainB.isPlaying=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

ensureAudio.value;
defineTestSource.value;
overrideTs0.value;
ensureGuiAndPedalboard.value;
startCurrent.value;
verify.value;
)

===== Magicpedalboard/obsolete/Audio sync + reliable GUI front.scd =====
// quickpatch.scd
// Quick Patch ‚Äî GUI/Audio sync + reliable GUI front
// v0.1.0
// MD 20250919-10:10 BST

(

/*
Purpose
- Keep MagicDisplayGUI columns/headers in sync with the actual CURRENT (A/B).
- Remember the NEXT effect symbol so the right column shows something useful.
- Wrap ~switchNow to refresh the GUI automatically after audio toggles.
- Bring GUI window to the front; keep the grey UserDisplay behind.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

var installGuiSync;

installGuiSync = {
    var ensureGuiFront, refreshFromState, wrapSwitch, hookApply;

    ensureGuiFront = {
        var gwin;
        ~gui = ~gui ?? { MagicDisplayGUI_GridDemo.new };
        if(~gui.respondsTo(\window)) {
            gwin = ~gui.window;
            if(gwin.notNil) { gwin.front; gwin.alwaysOnTop_(true) };
        };
        if(~ct.notNil and: { ~ct.display.notNil and: { ~ct.display.window.notNil } }) {
            ~ct.display.window.alwaysOnTop_(false);
        };
        if(~gui.notNil) { ~gui.showExpectation("GUI ready; syncing with audio state‚Ä¶", 0) };
        nil
    };

    refreshFromState = {
        var current, next, effC, effN, bA, bB, effSym, nowA;
        bA = []; bB = [];
        effSym = ~nextEffectSym ? \delay;   // default if none chosen yet
        nowA = (~currentIsA ? true);

        if(~gui.isNil) { ^nil };

        if(nowA) {
            // CURRENT=A, NEXT=B
            current = [\chainA, \testmelody];
            next    = [\chainB, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainA);
        }{
            // CURRENT=B, NEXT=A
            current = [\chainB, \testmelody];
            next    = [\chainA, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainB);
        };
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
        nil
    };

    wrapSwitch = {
        // decorate ~switchNow so it always refreshes the GUI after toggling
        if(~switchNow.notNil) {
            ~switchNow_raw = ~switchNow;
            ~switchNow = {
                ~switchNow_raw.();
                AppClock.sched(0.02, { refreshFromState.value; nil });
            };
        };
        nil
    };

    hookApply = {
        // provide a helper the bridge (or you) can call that both applies FX and refreshes
        ~applyCTEffect = { arg effSym;
            ~nextEffectSym = effSym;
            if(~applyToNext.notNil) { ~applyToNext.(effSym) };
            AppClock.sched(0.02, { refreshFromState.value; nil });
        };
        nil
    };

    ensureGuiFront.value;
    wrapSwitch.value;
    hookApply.value;

    // initial fill so the columns aren‚Äôt empty
    AppClock.sched(0.01, { refreshFromState.value; nil });

    "[PATCH] GUI sync installed".postln;
    nil
};

AppClock.sched(0.0, { installGuiSync.value; nil });
)

===== Magicpedalboard/obsolete/diag_dump_effective_state.scd =====
// diag_dump_effective_state.scd
// v0.1
// MD 20250916

(


var aPlaying, bPlaying, line;

~mpb.printChains;

aPlaying = Ndef(\chainA).isPlaying;
bPlaying = Ndef(\chainB).isPlaying;
line = "[diag] A.isPlaying=%  B.isPlaying=%".format(aPlaying, bPlaying);
line.postln;
)

===== Magicpedalboard/obsolete/diag_fix_current_source_now.scd =====
// diag_fix_current_source_now.scd
// v0.1
// MD 20250916-1030

(
var log, ensureSource;

log = { arg msg; ("[FIX] " ++ msg).postln };

// Ensure a musical internal source exists (reuse if already defined)
ensureSource = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
    });
};

ensureSource.value;

// One GUI window (runner)
~md_bootProbeScenario.();

// Ensure GUI + Pedalboard, then set CURRENT source and start it
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };

~pedalboard.reset;
~pedalboard.setSourceCurrent(\testmelody);   // <-- CURRENT, not NEXT
~pedalboard.playCurrent;                     // <-- start CURRENT so you hear it
~pedalboard.printChains;

log.("CURRENT should now be audible from \\testmelody.");
)

===== Magicpedalboard/obsolete/diag_list_playing_ndefs.scd =====
// diag_list_playing_ndefs.scd
// v0.1
// MD 20250916-1016

(
var names, reportRows, indexCounter, totalCount;

names = [\toneTest, \testmelody, \chainA, \chainB, \delay, \chorus];
reportRows = names.collect({ arg oneName; [oneName, Ndef(oneName).isPlaying] });

indexCounter = 0;
totalCount = reportRows.size;
while({ indexCounter < totalCount }, {
    var row;
    row = reportRows[indexCounter];
    ("[PLAY] " ++ row[0] ++ " = " ++ row[1]).postln;
    indexCounter = indexCounter + 1;
});
)

===== Magicpedalboard/obsolete/diag_manual_chain_patch.scd =====
// diag_manual_chain_patch.scd
// v0.2 fixes <<>
// v0.1
// MD 20250916-1018

(
var log;

log = { arg msg; ("[DIAG] " ++ msg).postln };

Server.default.bind({
    // ensure a sink for chainA that passes its input
    Ndef(\chainA, { \in.ar(2) });

    // patch toneTest -> chainA and play chainA
    Ndef(\chainA) <<> Ndef(\toneTest);
    Ndef(\chainA).play;
});

log.("Manual patch: chainA <<> toneTest; chainA.play ‚Äî you should hear steady tone now.");
)

===== Magicpedalboard/obsolete/diag_more_state.scd =====
// diag_more_state.scd
// v0.1

(
~mpb.printChains;

[
    [\testmelody,  Ndef(\testmelody).source.notNil,  Ndef(\testmelody).isPlaying],
    [\delay,       Ndef(\delay).source.notNil,       Ndef(\delay).isPlaying],
    [\chainA,      Ndef(\chainA).source.notNil,      Ndef(\chainA).isPlaying],
    [\chainB,      Ndef(\chainB).source.notNil,      Ndef(\chainB).isPlaying]
].do({ arg row;
    ("[NODE] " ++ row[0] ++ " source?=" ++ row[1] ++ " playing?=" ++ row[2]).postln;
});
)

===== Magicpedalboard/obsolete/diag_mpb_audio_path.scd =====
// diag_mpb_audio_path.scd
// v0.1
// MD 20250916-1012

(
var log, ensureAudio, playDirect, patchChainManually, patchViaPedalboard;

log = { arg msg; ("[DIAG] " ++ msg).postln };

// A) Boot audio + define a clearly audible test source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\toneTest, {
            var sig;
            sig = Saw.ar([120, 180]) * 0.15; // steady tone, obvious
            sig
        });
        Ndef(\toneTest).ar(2);
    });
    log.("Audio booted and \\toneTest defined.");
};

// B) Direct play (bypass chain) ‚Äî you MUST hear a steady tone
playDirect = {
    Ndef(\toneTest).play;
    log.("Direct play \\toneTest ‚Äî you should hear steady tone now.");
};

// C) Manual chain patch: route \\toneTest -> \\chainA (no pedalboard API)
// Expectation: you still hear tone via \\chainA after .play
patchChainManually = {
    // ensure chainA exists
    Ndef(\chainA, { \in.ar(2) });
    Ndef(\chainA) <<> Ndef(\toneTest);
    Ndef(\chainA).play;
    log.("Manual patch: chainA <<> toneTest; chainA.play ‚Äî you should still hear tone.");
};

// D) Pedalboard flow: reset -> setSource -> **playCurrent** (explicit) -> print
patchViaPedalboard = {
    ~gui = ~gui ?? { MagicDisplayGUI.new() };
    ~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
    ~pedalboard.reset;              // clean chains
    ~pedalboard.setSource(\toneTest);
    ~pedalboard.playCurrent;        // explicit start of CURRENT
    ~pedalboard.printChains;
    log.("Pedalboard: reset -> setSource toneTest -> playCurrent ‚Äî you should hear tone.");
};

// --- run steps ---
ensureAudio.value;
playDirect.value;

// comment out the direct play once you confirm sound, then test the next steps:
// Ndef(\toneTest).stop;  // uncomment to stop direct play

// patchChainManually.value;  // uncomment to test manual chain route
// Ndef(\chainA).stop;        // stop manual chain when done

// patchViaPedalboard.value;  // uncomment to test pedalboard path (preferred for demo)
)

===== Magicpedalboard/obsolete/diag_pedalboard_current_play.scd =====
// diag_pedalboard_current_play.scd
// v0.1
// MD 20250916-1019

(
var log;

log = { arg msg; ("[DIAG] " ++ msg).postln };

// Bring up a single GUI window (your runner), then ensure pedalboard exists
~md_bootProbeScenario.();   // one window + PROBE FRAME (GUI ops on AppClock)

// Create or reuse GUI + Pedalboard
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };

// Clean and start CURRENT audibly
~pedalboard.reset;
~pedalboard.setSource(\toneTest);
~pedalboard.playCurrent;    // <-- critical for immediate audibility
~pedalboard.printChains;

log.("Pedalboard: reset -> setSource toneTest -> playCurrent ‚Äî you should hear steady tone now.");
)

===== Magicpedalboard/obsolete/Diag_Probe_Sinks_A_B.scd =====
// Diag_Probe_Sinks_A_B.scd
// v0.1
// MD 20250917-1146
//
// Purpose: Inspect both sinks safely: source object/class, playing/paused,
// monitor present? Helps detect if NEXT is still monitored or sourcing non-silent audio.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var probe;

probe = { arg key;
    var nx = Ndef(key), srcObj, srcClass, srcCode, mon, playing, paused;
    srcObj  = nx.source;
    srcClass= srcObj.class;
    srcCode = srcObj.tryPerform(\asCompileString);
    mon     = nx.monitor;
    playing = nx.isPlaying;
    paused  = nx.paused ? false;
    ("[PROBE] key=% class=% playing=% paused=% hasMonitor=%"
        .format(key, srcClass, playing, paused, mon.notNil)).postln;
    if(srcCode.notNil) {
        "[PROBE] source asCompileString:".postln;
        srcCode.postln;
    }{
        "[PROBE] (no asCompileString) printing .source:".postln;
        srcObj.postln;
    };
};

probe.(\chainA);
probe.(\chainB);
)

===== Magicpedalboard/obsolete/diag_verify_chain_and_defs.scd =====
// diag_verify_chain_and_defs.scd
// v0.1

(
var listOne, listTwo, lastIndex, checkList, report;

if(~mpb.isNil) { "[DIAG] ~mpb is nil".warn; ^nil };

checkList = { arg label, chainList;
    var idx, last, missing;
    if(chainList.isNil) { ("[DIAG] " ++ label ++ ": chain is nil").postln; ^nil };
    last = chainList.size - 1;
    missing = Array.new;
    idx = 1; // processors are 1 .. last-1
    while({ idx < last }, {
        var key = chainList[idx];
        var hasDef = Ndef(key).source.notNil;  // <- definition present?
        if(hasDef.not) { missing = missing.add(key) };
        idx = idx + 1;
    });
    ("[DIAG] " ++ label ++ " = " ++ chainList).postln;
    if(missing.isEmpty) { "[DIAG] all processors have sources".postln }
    { ("[DIAG] missing sources for: " ++ missing).warn };
};

listOne = ~mpb.effectiveCurrent;
listTwo = ~mpb.effectiveNext;

checkList.("CURRENT", listOne);
checkList.("NEXT   ", listTwo);

"[[PLAY]] A=%  B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying).postln;
)

===== Magicpedalboard/obsolete/Enforce_ExclusiveBySilencingNext.scd =====
// Enforce_ExclusiveBySilencingNext.scd
// v0.2
// MD 20250916-1714

//
// Purpose: Guarantee audible exclusivity immediately by silencing the NEXT sink‚Äôs source.
//          CURRENT remains { \in.ar(2) } and audible; NEXT is set to Silent.ar(2). This avoids
//          NodeProxy monitor tail/race issues where isPlaying may remain true on NEXT.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, getCurrentNextSinks, silenceNextSink, ensureCurrentAudible, retargetMeters, verify, sinks;

log = { arg messageString; ("[XONLY] " ++ messageString).postln; };

// Identify sink symbols for CURRENT and NEXT from ~mpb
getCurrentNextSinks = {
    if(~mpb.isNil) {
        "[XONLY] ~mpb is nil".warn;
        ^nil
    };
    ^(
        current: ~mpb.effectiveCurrent[0],   // \chainA or \chainB
        next:    ~mpb.effectiveNext[0]       // the other one
    )
};

// Replace NEXT sink source with silence; keep bus AR so meters won‚Äôt warn
silenceNextSink = { arg nextSinkSym;
    Server.default.bind({
        Ndef(nextSinkSym, { Silent.ar(2) });  // hard silence at the sink
        Ndef(nextSinkSym).ar(2);
        Ndef(nextSinkSym).fadeTime_(0.01);
        Ndef(nextSinkSym).stop;               // stop its monitor quickly (optional)
    });
    log.("NEXT " ++ nextSinkSym.asString ++ " silenced");
};

// Ensure CURRENT uses robust sink source and is playing
ensureCurrentAudible = { arg currentSinkSym;
    Server.default.bind({
        Ndef(currentSinkSym, { \in.ar(2) });
        Ndef(currentSinkSym).ar(2);
        Ndef(currentSinkSym).fadeTime_(0.05);
        if(Ndef(currentSinkSym).isPlaying.not) {
            Ndef(currentSinkSym).play(numChannels: 2);
        };
    });
    log.("CURRENT " ++ currentSinkSym.asString ++ " robust+playing");
};

// Reattach meters safely after AR guarantee
retargetMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(false);
        ~gui.enableMeters(true);
    };
};

// Post final state a moment later
verify = {
    ~mpb.printChains;
    AppClock.sched(0.25, {
        var aPlaying, bPlaying, lineText;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        lineText = "[PLAY] A=%  B=%".format(aPlaying, bPlaying);
        lineText.postln;
        nil
    });
};

// --- run ---
sinks = getCurrentNextSinks.value;
if(sinks.notNil) {
    ensureCurrentAudible.(sinks[\current]);
    silenceNextSink.(sinks[\next]);
    retargetMeters.value;
    verify.value;
};
)

===== Magicpedalboard/obsolete/Enforce_OptionA_PauseFlagNow.scd =====
// Enforce_OptionA_PauseFlagNow.scd
// v0.3
// MD 20250917-1216
//
// Purpose: Deterministic exclusivity for both audio *and* flags.
//          - mold sinks to stereo
//          - set NEXT source to Silent.ar(2)
//          - stop + pause NEXT to drop monitor flag
//          - small retry loop (max 6) with short waits
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, curSink, nextSink, tries, maxTries, waitS, dropFlag;

log = { arg s; ("[X-ENFORCE] " ++ s).postln };

if(~mpb.isNil) { "[X-ENFORCE] ~mpb is nil".warn; ^nil };

curSink  = ~mpb.currentChain[0];
nextSink = ~mpb.nextChain[0];
tries    = 0; maxTries = 6; waitS = 0.08;

log.("meters off (if GUI present)");
if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
    AppClock.sched(0.00, { ~gui.enableMeters(false); nil });
    AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
};

// pin stereo + enforce Option A once
Server.default.bind({
    // shape first
    Ndef(curSink ).mold(2, \audio); Ndef(nextSink).mold(2, \audio);

    // robust CURRENT
    Ndef(curSink,  { \in.ar(2) }); Ndef(curSink ).ar(2); Ndef(curSink ).fadeTime_(0.10);
    if(Ndef(curSink).isPlaying.not) { Ndef(curSink).play(numChannels: 2) };

    // NEXT: hard silence at source + stop
    Ndef(nextSink, { Silent.ar(2) }); Ndef(nextSink).ar(2); Ndef(nextSink).fadeTime_(0.01);
    Ndef(nextSink).stop;
});

// retry loop: if NEXT still reports playing, clear->reset Silent, pause, re-check
Routine({
    var still;
    dropFlag = {
        Server.default.bind({
            Ndef(nextSink).clear(0);            // drop any lingering node
            Ndef(nextSink, { Silent.ar(2) });   // re-assert Silent source
            Ndef(nextSink).ar(2);
            Ndef(nextSink).pause;               // ensure monitor flag false
        });
    };
    while({
        still = Ndef(nextSink).isPlaying;
        (still and: { tries < maxTries })
    }, {
        tries = tries + 1;
        dropFlag.();
        waitS.wait;
    });

    // meters back on
    AppClock.sched(0.00, {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };
        ("[X-ENFORCE] [PLAY] A=% B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
}).play(SystemClock);
)

===== Magicpedalboard/obsolete/Enforce_OptionA_Strict_KillNextMonitor.scd =====
// Enforce_OptionA_Strict_KillNextMonitor.scd
// v0.1
// MD 20250917-1155
//
// Purpose: Deterministically silence NEXT and drop its monitor (pause+stop+end),
// while keeping CURRENT audible. Avoids GUI/server races by disabling meters first.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, disableMeters, getSinks, killNextHard, ensureCurrent, enableMeters, verify, sinks;

log = { arg s; ("[X-ENFORCE] " ++ s).postln };

disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

getSinks = {
    // Use effective lists so we match CURRENT/NEXT after any recent switch
    sinks = ( current: ~mpb.effectiveCurrent[0], next: ~mpb.effectiveNext[0] );
    log.("current=" ++ sinks[\current].asString ++ " next=" ++ sinks[\next].asString);
};

killNextHard = {
    var nextSink = sinks[\next];
    Server.default.bind({
        // Source = hard silence, stereo bus; then kill monitor with pause+stop+end
        Ndef(nextSink, { Silent.ar(2) });
        Ndef(nextSink).ar(2);
        Ndef(nextSink).fadeTime_(0.01);
        // Kill monitor by every legal means; safe even if not playing
        Ndef(nextSink).pause;
        Ndef(nextSink).stop;
        Ndef(nextSink).end(0.01);   // fades/ends any residual monitor synth
    });
    log.("NEXT " ++ nextSink.asString ++ " silenced and monitor ended");
};

ensureCurrent = {
    var cur = sinks[\current];
    Server.default.bind({
        Ndef(cur, { \in.ar(2) });
        Ndef(cur).ar(2);
        Ndef(cur).fadeTime_(0.08);
        if(Ndef(cur).isPlaying.not) { Ndef(cur).play(numChannels: 2) };
    });
    log.("CURRENT " ++ cur.asString ++ " robust+playing");
};

enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);   // re-sends meter SynthDefs and guards AR buses
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.35, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[X-ENFORCE] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

// run
disableMeters.value;
getSinks.value;
killNextHard.value;
ensureCurrent.value;
enableMeters.value;
verify.value;
)

===== Magicpedalboard/obsolete/enforceExclusiveCurrentNow.scd =====
// enforceExclusiveCurrentNow.scd
// v0.2
// MD 20250916


(

var listCurrent, listNext, currentSink, nextSink, postStatus, numCh;

if(~mpb.isNil) { "[enforceExclusive] ~mpb is nil".warn; ^nil };

listCurrent = ~mpb.currentChain;
listNext    = ~mpb.nextChain;

currentSink = listCurrent[0];
nextSink    = listNext[0];

numCh = (~mpb.respondsTo(\defaultNumChannels) ? ~mpb.defaultNumChannels) ?? { 2 };

Server.default.bind({
    // Rebuild both chains without resets; wiring via <<>
    ~mpb.rebuildUnbound(listNext);     // should stop NEXT sink
    ~mpb.rebuildUnbound(listCurrent);  // should play CURRENT sink

    // Belt-and-braces: explicitly enforce state
    if(Ndef(nextSink).isPlaying) { Ndef(nextSink).stop };
    if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: numCh) };
});

// Print status a short moment later (no server.sync)
postStatus = {
    AppClock.sched(0.20, {
        var aPlaying, bPlaying, line;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        line = "[status] A.playing=%  B.playing=%".format(aPlaying, bPlaying);
        line.postln;
        nil
    });
};
postStatus.();
)

===== Magicpedalboard/obsolete/fix_chain_current_exclusive.scd =====
// fix_chain_current_exclusive.scd
// v0.1
// MD 20250916-1103

(
var log, ensureStereo, stopSinks, connectEffectiveCurrent;

log = { arg m; ("[FIX] " ++ m).postln };

ensureStereo = { arg keySym;
    // Make sure every Ndef we will touch has a stereo bus
    Ndef(keySym).ar(2);
};

stopSinks = {
    // Stop both sinks so we can relaunch CURRENT cleanly
    if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
    if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
    log.("stopped sinks chainA/chainB");
};

connectEffectiveCurrent = {
    var eff, indexCounter, lastIndex, leftKey, rightKey, sinkKey;

    // Compute CURRENT effective list from your pedalboard
    eff = ~pedalboard.effectiveCurrent;

    // Ensure stereo busses for all nodes involved
    eff.do({ arg k; ensureStereo.(k) });

    // Connect pairwise using the correct JITLib operator you use in this project
    indexCounter = 0;
    lastIndex = eff.size - 1;
    while({ indexCounter < lastIndex }, {
        leftKey  = eff[indexCounter];
        rightKey = eff[indexCounter + 1];
        Server.default.bind({
            Ndef(leftKey) <<> Ndef(rightKey);
        });
        indexCounter = indexCounter + 1;
    });

    // Launch CURRENT sink only
    sinkKey = eff[0];
    Server.default.bind({
        Ndef(sinkKey).play(numChannels: 2);
    });

    log.("reconnected CURRENT: " ++ eff);
};

// --- run the steps ---
stopSinks.();
connectEffectiveCurrent.();
)

===== Magicpedalboard/obsolete/fix_current_exclusive_now.scd =====
// fix_current_exclusive_now.scd
// v0.3
// MD 20250916-1132

(
// 0) Stop any direct-to-out and both sinks first (clean slate)
if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; "[FIX] stopped \\testmelody direct".postln; };
if(Ndef(\chainA).isPlaying)     { Ndef(\chainA).stop;     "[FIX] stopped \\chainA".postln; };
if(Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop;     "[FIX] stopped \\chainB".postln; };

// 1) Ensure stereo busses (cheap no-op if already set)
Ndef(\testmelody).ar(2);
Ndef(\chainA).ar(2);

// 2) Wire CURRENT explicitly with the correct JITLib operator you use in this project,
//    and play CURRENT only (no chainB)
Server.default.bind({
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play(numChannels: 2);
});

// 3) Quick status (target: testmelody=false, chainA=true, chainB=false)
[\testmelody, \chainA, \chainB, \delay, \chorus].do({ arg nm;
    ("[PLAY] " ++ nm ++ " = " ++ Ndef(nm).isPlaying).postln;
});
)

===== Magicpedalboard/obsolete/Fix_ExclusiveCurrent_EnforceNow.scd =====
// Fix_ExclusiveCurrent_EnforceNow.scd
// v0.3
// MD 20250916-1700

//
// Purpose: Force ‚ÄúCURRENT=A playing, NEXT=B stopped‚Äù deterministically, even if a prior crossfade
//          or monitor tail keeps B reporting ‚Äòplaying‚Äô. Handles stop‚Üípause‚Üí(last‚Äëresort) clear+restore.
// Style:   tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var log, phase1_stopWithShortFade, phase2_pauseIfStill, phase3_lastResort, startAIfNeeded, verifyFinal;

log = { arg s; ("[FIX] " ++ s).postln; };

// Phase 1: small fades, stop B (start fade-down)
phase1_stopWithShortFade = {
    Server.default.bind({
        Ndef(\chainA).fadeTime_(0.05);
        Ndef(\chainB).fadeTime_(0.01);
        Ndef(\chainB).stop;
    });
    log.("phase1: set fade A=0.05 B=0.01; B.stop");
};

// Phase 2: after short wait, pause B (hard drop of monitor) and ensure A is playing
phase2_pauseIfStill = {
    AppClock.sched(0.12, {
        Server.default.bind({
            if(Ndef(\chainB).isPlaying) { Ndef(\chainB).pause };  // kills monitor immediately
            if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
        });
        log.("phase2: B.pause (if needed), A.play (if needed)");
        nil
    });
};

// Phase 3: last resort ‚Äî if B still reports playing, clear + restore robust sink source
phase3_lastResort = {
    AppClock.sched(0.26, {
        if(Ndef(\chainB).isPlaying) {
            log.("phase3: B still playing -> clear+restore sink");
            Server.default.bind({
                // Replace B‚Äôs source with robust \in.ar(2) and reassert AR bus
                Ndef(\chainB).clear(0);
                Ndef(\chainB, { \in.ar(2) });
                Ndef(\chainB).ar(2);
            });
        };
        nil
    });
};

// Safety: if A not playing after everything, start it
startAIfNeeded = {
    AppClock.sched(0.30, {
        Server.default.bind({
            if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            // ensure B is not audible
            if(Ndef(\chainB).isPlaying) { Ndef(\chainB).pause };
        });
        nil
    });
};

// Final verification
verifyFinal = {
    AppClock.sched(0.35, {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=%  B=%".format(a, b)).postln;
        nil
    });
};

// Run the phases
phase1_stopWithShortFade.value;
phase2_pauseIfStill.value;
phase3_lastResort.value;
startAIfNeeded.value;
verifyFinal.value;
)

===== Magicpedalboard/obsolete/Fix_ForceStereo_And_Rebuild.scd =====
// Fix_ForceStereo_And_Rebuild.scd
// v0.1
// MD 20250917-1155
//
// Purpose: Force ar(2) on every Ndef in CURRENT and NEXT effective lists,
//          then rebuild both chains (uses <<> internally in your class).
//          Lightweight, no rewiring here beyond your rebuildUnbound.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var ensureStereo, touchAll, rebuildBoth, curEff, nxtEff;

ensureStereo = { arg keySym; Ndef(keySym).ar(2) };

curEff = ~mpb.effectiveCurrent;
nxtEff = ~mpb.effectiveNext;

Server.default.bind({
    curEff.do({ arg k; ensureStereo.(k) });
    nxtEff.do({ arg k; ensureStereo.(k) });
    ~mpb.rebuildUnbound(~mpb.currentChain);  // uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});

// Post quick status afterwards
AppClock.sched(0.25, {
    ("[PLAY] A=% B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    nil
});
)

===== Magicpedalboard/obsolete/Fix_Now_BringUp_Recovery.scd =====
// Fix_Now_BringUp_Recovery.scd
// v0.1
// MD 20250917-1136
//
// Purpose: Recover from early meter attach + channel wraps: disable meters,
// ensure stereo sinks, define stereo ts0 (silent), ensure testmelody, re‚Äëenforce
// Option A exclusivity, then cleanly re‚Äëenable meters.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, ensureServer, disableMetersNow, ensureStereoSinks, defineTs0StereoSilent,
    defineTestMelody, reassertExclusive, enableMetersClean, verify;

log = { arg s; ("[RECOVER] " ++ s).postln };

ensureServer = {
    if(Server.default.serverRunning.not, { Server.default.boot });
};

disableMetersNow = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        // do it twice on AppClock to beat any queued auto-enable
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

ensureStereoSinks = {
    Server.default.bind({
        Ndef(\chainA, { \in.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { \in.ar(2) }); Ndef(\chainB).ar(2);
    });
    log.("sinks set to robust stereo (\\in.ar)");
};

defineTs0StereoSilent = {
    // make NEXT's default source unambiguously stereo to avoid 2‚Üí1 wraps
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) });
        Ndef(\ts0).ar(2);
    });
    log.("\\ts0 defined as stereo Silent");
};

defineTestMelody = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
    log.("\\testmelody (stereo) ensured");
};

reassertExclusive = {
    // Use class-level Option A (CURRENT audible; NEXT hard-silenced)
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    log.("class-level exclusivity reasserted (Option A)");
};

enableMetersClean = {
    // Your GUI‚Äôs enableMeters() re-sends SynthDefs each time
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.25, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

// run
ensureServer.value;
disableMetersNow.value;
ensureStereoSinks.value;
defineTs0StereoSilent.value;
defineTestMelody.value;
reassertExclusive.value;
enableMetersClean.value;
verify.value;
)

===== Magicpedalboard/obsolete/fixChainBSource.scd =====
// fixChainBSource.scd
// v0.1
// MD 20250917-1241

~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
~ct_applyOSCPathToMPB.("/add/delay", ~mpb, ~gui);  // optional FX on NEXT
~ct_applyOSCPathToMPB.("/switch",    ~mpb, ~gui);

===== Magicpedalboard/obsolete/ForceStereoMold_Now.scd =====
// ForceStereoMold_Now.scd
// v0.1
// MD 20250917-1215
//
// Purpose: Pin sinks to 2ch audio using .mold (stronger than .ar)
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
Server.default.bind({
    Ndef(\chainA).mold(2, \audio);
    Ndef(\chainB).mold(2, \audio);
});
)

===== Magicpedalboard/obsolete/helper_recover_if_silent.scd =====
// helper_recover_if_silent.scd
// v0.2

(
~recoverLog = ~recoverLog ?? { arg messageString;
    ("[RECOVER] " ++ messageString).postln;
};

~recoverIfSilent = {
    var ensureStereo, connectPair, connectList, currentEff, nextEff;
    var currentSink, nextSink, indexCounter, lastIndex;

    if(~mpb.isNil) { ~recoverLog.("~mpb is nil"); ^false };

    // Temporarily disable meters to avoid control-rate warnings during repair
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate
    Server.default.bind({
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    // Effective lists from pedalboard
    currentEff = ~mpb.effectiveCurrent;
    nextEff    = ~mpb.effectiveNext;

    ensureStereo = { arg keySymbol; Ndef(keySymbol).ar(2) };

    connectPair = { arg leftKey, rightKey;
        // matches project operator direction: left receives right
        Server.default.bind({ Ndef(leftKey) <<> Ndef(rightKey) });
    };

    connectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            var leftKey, rightKey;
            leftKey  = listSymbols[indexCounter];
            rightKey = listSymbols[indexCounter + 1];
            ensureStereo.(leftKey);
            ensureStereo.(rightKey);
            connectPair.(leftKey, rightKey);
            indexCounter = indexCounter + 1;
        });
    };

    // Rebuild both chains end-to-end
    connectList.(currentEff);
    connectList.(nextEff);

    // Enforce: CURRENT plays, NEXT stopped
    currentSink = currentEff[0];
    nextSink    = nextEff[0];
    Server.default.bind({
        if(Ndef(nextSink).isPlaying)        { Ndef(nextSink).stop };
        if(Ndef(currentSink).isPlaying.not) { Ndef(currentSink).play(numChannels: 2) };
    });

    // Re-enable meters (after AR is guaranteed)
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };

    ~recoverLog.("reconnected. currentEff=" ++ currentEff ++ " nextEff=" ++ nextEff);

    // Status a moment later (no server.sync)
    AppClock.sched(0.20, {
        var aPlaying, bPlaying, line;
        aPlaying = Ndef(\chainA).isPlaying;
        bPlaying = Ndef(\chainB).isPlaying;
        line = "[status] A.playing=% B.playing=%".format(aPlaying, bPlaying);
        line.postln; nil
    });

    true
};
)

===== Magicpedalboard/obsolete/Inline_CT_TokenSmoke.scd =====
// Inline_CT_TokenSmoke.scd
// v0.1.2
// MD 2025-09-18 14:12 BST

// Purpose:
// - Demonstrate that MagicPedalboardNew responds to CommandTree-shaped *token* queues today
//   without external file loads (audible and logged).
// - Flow: ensure sources -> tiny token-harness -> prime sources -> apply tokens -> verify.
// Style:
// - var-first in every function/closure; lowercase names; no server.sync;
// - all server ops inside Server.default.bind; GUI ops on AppClock; NodeProxy connections
//   remain inside class rebuilds using the exact <<> operator.

(
var log, need, ensureSources, tokensToPath, isNextSilent, guardSwitchAudible,
    applyOneTokens, runPlaylist, doRun, playlist, gap;

// --- logging helper (var-first inside) ---
log = { arg s;
    var str;
    str = "[TOKENS] " ++ s;
    str.postln;
};

// --- precondition guard (var-first inside) ---
need = {
    var ok;
    ok = (~mpb.isNil.not) and: { ~gui.isNil.not };
    if(ok.not) {
        "[TOKENS] ~mpb/~gui are nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
    };
    ok
};

// --- ensure generated sources exist (no SoundIn) ---
ensureSources = {
    var define;
    define = {
        var made;
        made = false;
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
            made = true;
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) });  Ndef(\ts0).ar(2);
        made
    };
    Server.default.bind({ define.value; });
};

// --- token -> canonical path mapping understood by the adapter ---
tokensToPath = { arg tokensIn;
    var tokens, verb, args, result, onOff;
    tokens = tokensIn.collect({ arg t; t.asString });
    if(tokens.size <= 0) { ^nil };
    verb = tokens[0].toLower;
    args = if(tokens.size > 1) { tokens.copyRange(1, tokens.size - 1) } { [] };
    result = nil;

    if(verb == "insert" or: { verb == "add" }) {
        if(args.size >= 1) { result = "/add/" ++ args[0] };
    }{
        if(verb == "bypass") {
            onOff = if(args.size >= 2) { args[1].toLower } { "on" };
            onOff = if(#["on","off","true","false","1","0"].includes(onOff)) {
                if((onOff == "true") or: { onOff == "1" }) { "on" } { onOff }
            } { "on" };
            if(args.size >= 1) { result = "/bypass/" ++ args[0] ++ "/" ++ onOff };
        }{
            if(verb == "setsource" or: { verb == "source" } or: { verb == "setsrc" }) {
                if(args.size >= 1) { result = "/setSource/" ++ args[0] };
            }{
                if(verb == "removeat") {
                    if(args.size >= 1) { result = "/removeAt/" ++ args[0] };
                }{
                    if(verb == "swap") {
                        if(args.size >= 2) { result = "/swap/" ++ args[0] ++ "/" ++ args[1] };
                    }{
                        if(verb == "switch" or: { verb == "commit" }) {
                            result = "/switch";
                        }{
                            result = nil;
                        };
                    };
                };
            };
        };
    };
    ^result
};

// --- guard so /switch never lands on a silent NEXT (\ts0 tail) ---
isNextSilent = {
    var effNext, last;
    effNext = ~mpb.effectiveNext;
    last = effNext[effNext.size - 1];
    ^(last == \ts0)
};

guardSwitchAudible = {
    var needed;
    needed = isNextSilent.value;
    if(needed) {
        log.("NEXT ends with \\ts0; injecting /setSource/testmelody before /switch");
        if(~ct_applyOSCPathToMPB.notNil) {
            ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
        }{
            "[TOKENS] adapter missing; cannot auto-fix source".warn;
        };
    };
};

// --- apply one token step via your existing adapter ---
applyOneTokens = { arg tokens;
    var path;
    path = tokensToPath.value(tokens);
    if(path.isNil) {
        log.("unmapped tokens: " ++ tokens.asString);
        ^nil;
    };
    if(path == "/switch") { guardSwitchAudible.value };
    if(~ct_applyOSCPathToMPB.notNil) {
        log.("apply " ++ tokens.asString ++ "  -> " ++ path);
        ~ct_applyOSCPathToMPB.(path, ~mpb, ~gui);
    }{
        ("[TOKENS] adapter missing; would apply " ++ path).warn;
    };
};

// --- run a playlist of token steps with a gap (AppClock) ---
runPlaylist = { arg listOfTokenLists, gapSeconds = 0.6;
    var rt;
    rt = Routine({
        var i;
        i = 0;
        while({ i < listOfTokenLists.size }, {
            applyOneTokens.value(listOfTokenLists[i]);
            gapSeconds.wait;
            i = i + 1;
        });
        log.("done.");
    }).play(AppClock);
    ^rt
};

// --- end-to-end demo: prime sources (today), run, verify ---
doRun = {
    var verify;
    gap = 0.60;

    // For today: both chains end with \testmelody; NEXT stays silent at sink (Option A).
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);

    // Example playlist: insert delay -> switch -> bypass on -> bypass off -> switch back
    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    runPlaylist.value(playlist, gap);

    verify = {
        var a, b;
        a = Ndef(\chainA).isPlaying; b = Ndef(\chainB).isPlaying;
        ("[PLAY] A=% B=%".format(a, b)).postln;
        ~mpb.printChains;
    };

    AppClock.sched(playlist.size * gap + 0.9, { verify.value; nil });
};

// --- go ---
if(need.value) {
    ensureSources.value;
    doRun.value;
};
)

===== Magicpedalboard/obsolete/ix_current_only_now.scd =====
// fix_current_only_now.scd
// v0.1
// MD 20250916-1007

(
var log;

log = { arg m; ("[FIX] " ++ m).postln };

// stop NEXT sink explicitly
if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop; log.("stopped \\chainB"); };

// re-wire CURRENT effective list with the correct operator and play only CURRENT
Server.default.bind({
    // ensure stereo busses (cheap no-op if already set)
    Ndef(\chainA).ar(2);
    Ndef(\testmelody).ar(2);

    // correct embed operator you use in this project:
    Ndef(\chainA) <<> Ndef(\testmelody);

    // play CURRENT sink only
    Ndef(\chainA).play(numChannels: 2);
});

~pedalboard.printChains;
"[FIX] chainA <<> testmelody; chainA.play done.".postln;
)

===== Magicpedalboard/obsolete/Milestone_QueueResponse.scd =====
// Milestone_QueueResponse.scd
// v0.1.1
// MD 2025-09-18 13:56 BST
/*
Purpose
- One-button milestone demo: build the token-harness, run a short token playlist,
  and print concise checks. Use after bring-up.

Style
- var-first; lowercase; no server.sync; GUI on AppClock; audio graph owned by class code.
*/

(
/*("bob").postln;*/
var log, need, ensureSources, verify, run;

log = { arg s; ("[MILESTONE] " ++ s).postln };

need = {
    var ok;
    ok = (~mpb.notNil and: { ~gui.notNil });
    if(ok.not) { "[MILESTONE] ~mpb/~gui are nil. Run the bring-up script first.".warn };
    ^ok;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

verify = { arg tag = "now";
    var aPlaying, bPlaying;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    ("[PLAY] A=% B=%".format(aPlaying, bPlaying)).postln;
    ~mpb.printChains;
    ("[CHECK] " ++ tag).postln;
};

run = {
    var gap, h, playlist;
    gap = 0.60;

    "CT_TokenQueueHarness.scd".loadRelative;
    ~ctq = ~ctq_makeHarness.(~mpb, ~gui, gap);

    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.setSource(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    verify.("after prime");

    playlist = [
        ["insert","delay"],
        ["switch"],
        ["bypass","delay","on"],
        ["bypass","delay","off"],
        ["switch"]
    ];

    ~ctq[\runPlaylist].(playlist, gap);
    AppClock.sched(playlist.size * gap + 0.8, { verify.("after playlist"); nil });
};

if(need.()) {
    ensureSources.();
    run.();
};
)

===== Magicpedalboard/obsolete/mpb_exclusiveReset_now.scd =====
(
// mpb_exclusiveReset_now.scd
// v0.1
// MD 20250916

var reportStatus;

reportStatus = {
    var aPlaying, bPlaying, textOut;
    aPlaying = Ndef(\chainA).isPlaying;
    bPlaying = Ndef(\chainB).isPlaying;
    textOut = "[status] A.playing=%  B.playing=%".format(aPlaying, bPlaying);
    textOut.postln;
};

// Reset MPB: leaves CURRENT playing and NEXT stopped
~mpb.reset;
reportStatus.();
)

===== Magicpedalboard/obsolete/Patch_StartHere_Milestone_BringUpAndRun_freshBoot_Fix.scd =====
// Patch_StartHere_Milestone_BringUpAndRun_freshBoot_Fix.scd
// v0.1.4a
// MD 20250918-18:02 BST

/* Purpose
   Replace the freshBoot step with a doWhenBooted-aware version that proceeds even if
   the server is already booting. Avoids stalls at "already booting". No server.sync.

   Style
   - var-first in every function/closure; lowercase method names; no server.sync
   - server ops inside Server.default.bind; GUI on AppClock
*/

(
var replaceFreshBoot;

replaceFreshBoot = {
    var serverRef, didInitFlag, doInitTreeFunc, safeInitOnceFunc, startBootFunc;

    serverRef = Server.default;
    didInitFlag = false;

    doInitTreeFunc = {
        var ignore;
        if(didInitFlag) { ^nil };
        didInitFlag = true;
        ignore = nil;
        Server.default.bind({
            serverRef.initTree;
            serverRef.defaultGroup.freeAll;
        });
        MagicDisplay.setMeterChannels(2);
        "[RUN] server tree inited; meter defs set to 2ch".postln;
    };

    safeInitOnceFunc = {
        // Guard against multiple signals (doWhenBooted + polls)
        if(serverRef.serverRunning) { doInitTreeFunc.value };
    };

    // Subscribe once; SC clears the function after it fires
    serverRef.doWhenBooted({ AppClock.sched(0, { safeInitOnceFunc.value; nil }) });

    if(serverRef.serverRunning) {
        "[RUN] fresh boot: quitting current server‚Ä¶".postln;
        serverRef.quit;
        AppClock.sched(0.05, {
            var waitDown;
            waitDown = {
                if(serverRef.serverRunning.not and: { serverRef.booting.not }) {
                    serverRef.boot;
                    nil
                }{
                    AppClock.sched(0.05, waitDown)
                }
            };
            waitDown.value;
            nil
        });
    }{
        // server not running
        if(serverRef.booting) {
            "[RUN] server is already booting; will init when boot completes‚Ä¶".postln;
            // doWhenBooted will trigger doInitTreeFunc
        }{
            "[RUN] fresh boot: starting server‚Ä¶".postln;
            serverRef.boot;
        };
    };
};

freshBoot = replaceFreshBoot; // replace original binding in the script runtime
)

===== Magicpedalboard/obsolete/prep_demo_audio_gui_current.scd =====
// prep_demo_audio_gui_current.scd
// v0.1
// MD 20250916-1046

(
var ensureSource;

Server.default.boot;

// ensure a musical internal source
ensureSource = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);
        // simple FX
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig, delayed, bal;
            sig = \in.ar(2);
            delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            bal = (mix.clip(0,1) * 2 - 1);
            XFade2.ar(sig, delayed, bal)
        });
    });
};

// one GUI window via your runner
~md_bootProbeScenario.();

// ensure GUI + pedalboard, and make CURRENT audible
~gui = ~gui ?? { MagicDisplayGUI.new() };
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.reset;
~pedalboard.setSourceCurrent(\testmelody);  // CURRENT, so it's audible immediately
~pedalboard.playCurrent;
~pedalboard.printChains;
)

===== Magicpedalboard/obsolete/Probe_Ndef_SinkState.scd =====
// Probe_Ndef_SinkState.scd
// v0.1
// MD 20250916-1700

//
// Purpose: Safely inspect a sink Ndef‚Äôs current source object and playing/paused/monitor status.
//          Uses .source (not .sourceCode) and prints class + optional asCompileString if available.
// Style:   tilde vars, var-first, lowercase names, no server.sync, Server.default.bind for server ops.

(
var key, nx, srcObj, srcClass, srcCode, mon, playing, paused;

key = \chainA; // change to \chainA if you want to probe A

nx       = Ndef(key);
srcObj   = nx.source;                 // current source object (Function or other)
srcClass = srcObj.class;
srcCode  = srcObj.tryPerform(\asCompileString); // may be nil if not supported
mon      = nx.monitor;                // monitor object (if any)
playing  = nx.isPlaying;
paused   = nx.paused ? false;         // NodeProxy sometimes keeps paused flag internally

("[PROBE] key=%  class=%  playing=%  paused=%  hasMonitor=%"
    .format(key, srcClass, playing, paused, mon.notNil)).postln;

if(srcCode.notNil) {
    "[PROBE] source asCompileString:".postln;
    srcCode.postln;
} {
    "[PROBE] source does not implement asCompileString; printing .source:".postln;
    srcObj.postln;
};
)

===== Magicpedalboard/obsolete/quick_start_audible.scd =====
// quick_start_audible.scd
// v0.1

(
// 0) Recompile classes first (Cmd+Shift+L) if you just edited them.
// 1) GUI + pedalboard
~gui = ~gui ?? { MagicDisplayGUI.new };
~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

// 2) Make CURRENT use our internal melody, play it
~mpb.setSourceCurrent(\testmelody);
~mpb.playCurrent;

// 3) Add delay to NEXT and switch (should hear the echo)
~mpb.add(\delay);
~mpb.switchChain(0.12);

// 4) If you still hear nothing, run the recover helper:
~recoverIfSilent.();

// 5) Inspect
~mpb.printChains;
"[[PLAY]] A=%  B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying).postln;
)

===== Magicpedalboard/obsolete/quickpatch.scd =====
// quickpatch.scd
// Quick Patch ‚Äî GUI/Audio sync + reliable GUI front
// v0.1.0
// MD 20250919-10:10 BST

(

/*
Purpose
- Keep MagicDisplayGUI columns/headers in sync with the actual CURRENT (A/B).
- Remember the NEXT effect symbol so the right column shows something useful.
- Wrap ~switchNow to refresh the GUI automatically after audio toggles.
- Bring GUI window to the front; keep the grey UserDisplay behind.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

var installGuiSync;

installGuiSync = {
    var ensureGuiFront, refreshFromState, wrapSwitch, hookApply;

    ensureGuiFront = {
        var gwin;
        ~gui = ~gui ?? { MagicDisplayGUI_GridDemo.new };
        if(~gui.respondsTo(\window)) {
            gwin = ~gui.window;
            if(gwin.notNil) { gwin.front; gwin.alwaysOnTop_(true) };
        };
        if(~ct.notNil and: { ~ct.display.notNil and: { ~ct.display.window.notNil } }) {
            ~ct.display.window.alwaysOnTop_(false);
        };
        if(~gui.notNil) { ~gui.showExpectation("GUI ready; syncing with audio state‚Ä¶", 0) };
        nil
    };

    refreshFromState = {
        var current, next, effC, effN, bA, bB, effSym, nowA;
        bA = []; bB = [];
        effSym = ~nextEffectSym ? \delay;   // default if none chosen yet
        nowA = (~currentIsA ? true);

        if(~gui.isNil) { ^nil };

        if(nowA) {
            // CURRENT=A, NEXT=B
            current = [\chainA, \testmelody];
            next    = [\chainB, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainA);
        }{
            // CURRENT=B, NEXT=A
            current = [\chainB, \testmelody];
            next    = [\chainA, effSym, \testmelody];
            ~gui.highlightCurrentColumn(\chainB);
        };
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
        nil
    };

    wrapSwitch = {
        // decorate ~switchNow so it always refreshes the GUI after toggling
        if(~switchNow.notNil) {
            ~switchNow_raw = ~switchNow;
            ~switchNow = {
                ~switchNow_raw.();
                AppClock.sched(0.02, { refreshFromState.value; nil });
            };
        };
        nil
    };

    hookApply = {
        // provide a helper the bridge (or you) can call that both applies FX and refreshes
        ~applyCTEffect = { arg effSym;
            ~nextEffectSym = effSym;
            if(~applyToNext.notNil) { ~applyToNext.(effSym) };
            AppClock.sched(0.02, { refreshFromState.value; nil });
        };
        nil
    };

    ensureGuiFront.value;
    wrapSwitch.value;
    hookApply.value;

    // initial fill so the columns aren‚Äôt empty
    AppClock.sched(0.01, { refreshFromState.value; nil });

    "[PATCH] GUI sync installed".postln;
    nil
};

AppClock.sched(0.0, { installGuiSync.value; nil });
)

===== Magicpedalboard/obsolete/quickprep.scd =====
// quickprep.scd
// v0.1
// MD 20250916


(
// ===== Acceptance Prep =====
var linkedDisplay, hasGui, chainAName, chainBName;

linkedDisplay = nil;
hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };
if(hasGui) { linkedDisplay = ~gui };

if(~mpb.isNil) {
    ~mpb = MagicPedalboardNew.new(linkedDisplay);
} {
    if(linkedDisplay.notNil) { ~mpb.setDisplay(linkedDisplay) };
};

// create a simple stereo test melody (safe levels)
Ndef(\testmelody, {
    var freq, lfo, sig;
    lfo = LFTri.kr(0.13).range(0.5, 1.0);
    freq = [220, 330] * lfo;
    sig = SinOsc.ar(freq, 0, 0.08);  // quiet
    sig
});

// set source to \testmelody on both chains (explicit)
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);

// start CURRENT sink (A by default on fresh boot)
~mpb.playCurrent;

// convenience: names for readability
chainAName = \chainA;
chainBName = \chainB;

// status
"Prep done. CURRENT is playing. A.isPlaying=%, B.isPlaying=%"
    .format(Ndef(chainAName).isPlaying, Ndef(chainBName).isPlaying).postln;
)

===== Magicpedalboard/obsolete/RebuildAndRestore_OptionA.scd =====
// RebuildAndRestore_OptionA.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Recover class-managed wiring and Option A without touching sink sources.
// Style: tilde vars, var-first, no server.sync, Server.default.bind.

(
var log;
log = { arg s; ("[RECOVER] " ++ s).postln };

if(~mpb.isNil) { "[RECOVER] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // uses Ndef(left) <<> Ndef(right) internally
    ~mpb.rebuildUnbound(~mpb.nextChain);
});

~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RECOVER] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== Magicpedalboard/obsolete/Run_Milestone_Today_previous.scd =====
// Run_Milestone_Today.scd
// v0.1.0
// MD 20250918-19:40 BST

/* Purpose
   - Run today's milestone playlist via the adapter, assuming runner v0.6 has already succeeded.
   Style
   - var-first in every closure; lowercase; no server.sync; server ops inside adapter/MPB.
*/

(
var ok, log, guard, apply, run, gap, playlist;

log = { arg s; var t; t = "[TOKENS] " ++ s; t.postln };

ok = (~mpb.notNil) and: { ~gui.notNil } and: { ~ct_applyOSCPathToMPB.notNil };
if(ok.not) {
    "[TOKENS] Missing ~mpb/~gui or adapter. Run StartHere_* and load adapter first.".warn;
    ^nil;
};

guard = {
    var last;
    last = ~mpb.effectiveNext.last;
    if(last == \ts0) { log.("guard: NEXT ends with \\ts0 -> /setSource/testmelody"); ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui) };
};

apply = { arg path;
    var p;
    p = path.asString;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
};

run = {
    var idx, count, step;
    ~mpb.setSourcesBoth(\testmelody);
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    ~mpb.printChains;
    ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

    idx = 0; count = playlist.size;
    step = {
        if(idx >= count) {
            AppClock.sched(0.9, {
                ("[PLAY] A=% B=%"
                  .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
                ~mpb.printChains;
                nil
            });
            ^nil
        };
        if(playlist[idx] == "/switch") { guard.value };
        apply.value(playlist[idx]);
        idx = idx + 1;
        AppClock.sched(gap, step);
    };
    AppClock.sched(gap, step);
};

playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

gap = 0.60;
run.value;
)

===== Magicpedalboard/obsolete/Run_Milestone_Today.scd =====
// Run_Milestone_Today.scd
// v0.2.1
// MD 20250918-21:05 BST

/*
Purpose
- Minimal, reliable milestone driver (no boot logic). Run main block once (sets up helpers + HUD),
  then run the one-liners below, in order, to hear/see the expected changes.

Style
- var-first in every function/closure; lowercase methods; no server.sync;
- server ops live inside adapter/MPB; GUI ops on AppClock; one window only; generated audio only;
- JITLib connect operator remains exactly "<<>"; processors/sinks read from \in.ar(2).
*/

(
// ---------- setup ----------

var log, ensureAdapter, symbolsToString, extractTail, findGuiWindow;
var hudInstall, hudRender, hudUpdate, wrapApply, primeToday, guardSwitch, stateLine;

// small logger
log = { arg s;
    var line;
    line = "[TOKENS] " ++ s;
    line.postln;
};

// pretty chain printing
symbolsToString = { arg syms;
    var arr, joined;
    arr = syms.collect(_.asString);
    joined = arr.join(" \u2192 ");
    joined
};

// drop leading \chainA / \chainB
extractTail = { arg chainArray;
    var arr;
    arr = chainArray ? [];
    if(arr.size > 0) { arr.copyRange(1, arr.size - 1) } { [] }
};

// find existing MagicDisplayGUI window
findGuiWindow = {
    var wins, target;
    wins = Window.allWindows.select({ arg w;
        var nm, isMagic;
        nm = w.tryPerform(\name);
        isMagic = nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") };
        isMagic
    });
    target = wins.last;
    target
};

// Ensure adapter is loaded (absolute path, no loadRelative)
ensureAdapter = {
    var scriptDir, fileLower, fileCamel, ok, p, d;
    scriptDir = ~scriptDir ?? {
        p = thisProcess.nowExecutingPath;
        d = if(p.notNil) { PathName(p).pathOnly } { thisProcess.cwd };
        d
    };
    ok = (~ct_applyOSCPathToMPB.notNil);
    if(ok.not) {
        fileLower = (scriptDir +/+ "adapter_commandtree_to_magicpedalboard.scd").standardizePath;
        fileCamel = (scriptDir +/+ "adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
        if(File.exists(fileLower)) { fileLower.load; ok = true } {
            if(File.exists(fileCamel)) { fileCamel.load; ok = true };
        };
    };
    if(ok) { "[RUN] adapter is available".postln } { "[RUN] adapter missing ‚Äî please load adapter file".warn };
    ok
};

// HUD: install into existing MagicDisplayGUI (explicit bounds; no caret returns)
hudInstall = {
    AppClock.sched(0, {
        var win, root, r, box, title, lineA, lineB, exists;

        win = findGuiWindow.value;
        if(win.notNil) {
            root = win.view;

            exists = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(exists.not) {
                r = Rect(10, (root.bounds.height - 56).max(10), (root.bounds.width - 20).max(160), 46);

                box = CompositeView(root, r)
                    .background_(Color(0.12, 0.12, 0.12, 0.88));

                title = StaticText(box, Rect(8, 6, (r.width - 16).max(80), 16))
                    .string_("Processors HUD")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineA = StaticText(box, Rect(8, 22, (r.width - 16).max(80), 16))
                    .string_("CURRENT: -")
                    .stringColor_(Color(0.9,0.9,0.9));

                lineB = StaticText(box, Rect(8, 38, (r.width - 16).max(80), 16))
                    .string_("NEXT:    -")
                    .stringColor_(Color(0.8,0.8,0.8));

                ~procHud = IdentityDictionary[
                    \view        -> box,
                    \lineCurrent -> lineA,
                    \lineNext    -> lineB
                ];

                "[HUD] installed in MagicDisplayGUI".postln;
            };
        }{
            "[HUD] MagicDisplayGUI window not found yet; run bring-up first".postln;
        };
        nil
    });
};

// HUD: render (safe guards; no caret returns)
hudRender = {
    AppClock.sched(0, {
        var alive, curArr, nextArr, curTail, nextTail, curStr, nextStr, lineA, lineB;

        if(~mpb.notNil) {
            alive = (~procHud.notNil)
                and: { ~procHud[\view].notNil }
                and: { ~procHud[\view].isClosed.not };

            if(alive.not) {
                hudInstall.value;
                AppClock.sched(0.07, { hudRender.value; nil });
            }{
                curArr  = ~mpb.effectiveCurrent;
                nextArr = ~mpb.effectiveNext;

                curTail = extractTail.value(curArr);
                nextTail = extractTail.value(nextArr);

                curStr = if(curTail.size > 0) { symbolsToString.value(curTail) } { "-" };
                nextStr = if(nextTail.size > 0) { symbolsToString.value(nextTail) } { "-" };

                lineA = ~procHud[\lineCurrent];
                lineB = ~procHud[\lineNext];

                if(lineA.notNil) { lineA.string = "CURRENT: " ++ curStr };
                if(lineB.notNil) { lineB.string = "NEXT:    " ++ nextStr };
            };
        }{
            "[HUD] cannot render (no ~mpb)".postln;
        };
        nil
    });
};

hudUpdate = { hudRender.value };

// guard: ensure NEXT audible before /switch (avoid switching to \ts0)
guardSwitch = {
    var lastTail;
    lastTail = ~mpb.effectiveNext.last;
    if(lastTail == \ts0) {
        log.("guard: NEXT ends with \\ts0 -> /setSource/testmelody");
        ~ct_applyOSCPathToMPB.("/setSource/testmelody", ~mpb, ~gui);
    };
    hudRender.value;
};

// state print (what you should see)
stateLine = {
    var line;
    ~mpb.printChains;
    line = "[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying);
    line.postln;
    hudRender.value;
};

// prime (for today's demo)
primeToday = {
    var ignore;
    ignore = nil;
    ~mpb.setSourcesBoth(\testmelody); // both tails end with testmelody
    ~mpb.enforceExclusiveCurrentOptionA(0.1);
    stateLine.value;
};

// apply wrapper: call adapter, then HUD update
wrapApply = { arg pathString;
    var p;
    p = pathString.asString;
    log.("apply -> " ++ p);
    ~ct_applyOSCPathToMPB.(p, ~mpb, ~gui);
    hudRender.value;
};

// ---------- publish helpers for your 1-liners ----------
~tok = IdentityDictionary[
    \apply       -> wrapApply,
    \prime       -> primeToday,
    \guardSwitch -> guardSwitch,
    \state       -> stateLine,
    \hudUpdate   -> hudUpdate,
    \hudInstall  -> hudInstall
];

// ---------- sanity + first render ----------
if((~mpb.isNil) or: { ~gui.isNil }) {
    "[RUN] Bring-up not ready (~mpb/~gui). Run StartHere_CleanBoot_OneWindow_BringUp.scd first.".warn;
}{
    if(ensureAdapter.value) {
        hudInstall.value;
        AppClock.sched(0.10, { ~tok.state.(); nil });
    };
};
)

===== Magicpedalboard/obsolete/saveonly_commandtree_current_to_json.scd =====
// saveonly_commandtree_current_to_json.scd
// v0.2
// MD 20250916-0942

(
var saveFolder, savePrefix, jsonPath, jsonString;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";
jsonPath   = (saveFolder +/+ "myTree.json").standardizePath;

// Ensure a saver instance (if nil, create one)
~saver = ~saver ?? { CircularFileSave.new(savePrefix, saveFolder, 10) };

// Serialize current in‚Äëmemory tree to JSON text
jsonString = JSONlib.convertToJSON(~tree.root.asDictRecursively);

// Save a versioned copy and overwrite the live JSON file for CommandManager
~saver.saveVersion(jsonString);
~tree.exportJSONFile(jsonPath);

"üíæ Saved versioned JSON and wrote current tree to: ".postln;
jsonPath.postln;
)

===== Magicpedalboard/obsolete/Strict_Reset_To_Exclusive_Audible.scd =====
// Strict_Reset_To_Exclusive_Audible.scd
// v0.1
// MD 20250917-1145
//
// Purpose: Deterministic recovery: disable meters, hard-reset MPB to A=current/B=next,
// define stereo ts0 (Silent) and testmelody, enforce Option A, re-enable meters,
// verify A XOR B is true.
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, disableMeters, defineStereoTs0, defineTestMelody, doReset, enforceExclusive, enableMeters, verify;

log = { arg s; ("[STRICT] " ++ s).postln };

disableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        log.("meters disabled");
    };
};

defineStereoTs0 = {
    Server.default.bind({
        Ndef(\ts0, { Silent.ar(2) });  // NEXT-safe, stereo
        Ndef(\ts0).ar(2);
    });
    log.("\\ts0 set to stereo Silent");
};

defineTestMelody = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(3.2);
            var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            var f    = Demand.kr(trig, 0, seq);
            var env  = Decay2.kr(trig, 0.01, 0.35);
            var tone = SinOsc.ar(f) * env * 0.25;
            var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, pan)
        });
        Ndef(\testmelody).ar(2);
    });
    log.("\\testmelody ensured (stereo)");
};

doReset = {
    // Reset reinitialises chainA/B lists and calls the class logic that enforces exclusivity at end.
    ~mpb.reset;
    log.("mpb.reset done");
};

enforceExclusive = {
    ~mpb.setSourceCurrent(\testmelody);
    ~mpb.playCurrent;                        // MPB already enforces Option A post-play
    ~mpb.enforceExclusiveCurrentOptionA(0.1); // belt-and-braces
    log.("Option A exclusivity asserted");
};

enableMeters = {
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
        ~gui.enableMeters(true);             // guards for AR buses and re-sends SynthDefs
        log.("meters re-enabled");
    };
};

verify = {
    AppClock.sched(0.30, {
        var a = Ndef(\chainA).isPlaying;
        var b = Ndef(\chainB).isPlaying;
        ("[STRICT] [PLAY] A=% B=%".format(a, b)).postln;
        nil
    });
};

disableMeters.value;
defineStereoTs0.value;
defineTestMelody.value;
doReset.value;
enforceExclusive.value;
enableMeters.value;
verify.value;
)

===== Magicpedalboard/obsolete/Test_CommandTree_To_AudioBridge.scd =====
// Test_CommandTree_To_AudioBridge.scd
// v0.6.2
// MD 20250919-09:16 BST

/*
Purpose
- Bridge Command Tree -> Audio + GUI:
  - Simulate 3‚Äì5‚Äì7 ‚Üí \queue ‚Üí \send (demo).
  - Map OSC tokens (strings; hyphen-safe) to NEXT (B) effect.
  - Ignore trivial paths like "/audio".
  - Passive observer watches ~commandToSend for real SENDs.

Style
- var-first; AppClock-only; no server.sync.
*/

(
var ensureDeps, buildEffectMap, simulatePath_3_5_7, queueAndSend, reflectOsc, startObserver;

ensureDeps = {
    var run;
    run = {
        if(~fx.isNil or: { ~applyToNext.isNil }) {
            "[ERROR] Audio helpers not found. Run Test_MagicAudio_BringUp_A_B.scd first.".warn;
        };
        ~ct = ~ct ?? { CommandManager.new };
        if(~ct.display.notNil and: { ~ct.display.window.notNil }) { ~ct.display.window.front };
        if(~gui.isNil) { "[WARN] ~gui not present (GUI optional). Proceeding‚Ä¶".postln };
        "[CT] CommandManager ready".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

buildEffectMap = {
    var run;
    run = {
        ~ctFxMapS = IdentityDictionary[
            "single-delay" -> \delay,
            "delay"        -> \delay,
            "echo"         -> \delay,
            "freeverb"     -> \reverb,
            "reverb"       -> \reverb,
            "chorus"       -> \chorus,
            "tremolo"      -> \tremolo,
            "flanger"      -> \flanger
        ];
        "[CT] Effect token map (string-keyed) installed".postln;
        nil
    };
    AppClock.sched(0.02, { run.value; nil });
};

reflectOsc = { arg pathStr;
    var run;
    run = {
        var tokens, effTok, effSym, hasMeaning;
        var current, next, effC, effN, bA, bB;

        tokens = pathStr.asString.split($/).reject(_.isEmpty);
        hasMeaning = (tokens.size >= 2); // ignore "/audio" or similar one-token paths
        if(hasMeaning.not) {
            ("[CT] Ignoring trivial path: " ++ pathStr).postln;
        }{
            effTok = tokens.reverse.detect({ arg t; ~ctFxMapS.includesKey(t.asString) });
            effSym = (effTok.isNil).if({ \delay }, { ~ctFxMapS[effTok.asString] });

            ~applyToNext.(effSym);

            if(~gui.notNil) {
                ~gui.showExpectation("CT SEND ‚Üí " ++ pathStr, 0);
                current = [\chainA, \testmelody];
                next    = [\chainB, effSym, \testmelody];
                effC = current; effN = next; bA=[]; bB=[];
                ~gui.showChainsDetailed(current, next, bA, bB, effC, effN);
            };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

simulatePath_3_5_7 = {
    var run;
    run = {
        var mm, gh;
        mm = ~ct.midiManager; gh = mm.guitarHandler;

        mm.setMode(mm.modes[\prog]); // resets nav, starts at string 6
        gh.handleMessage(0, \noteOn, 43); 0.12.wait; // fret 3 on string 6
        gh.handleMessage(1, \noteOn, 50); 0.12.wait; // fret 5 on string 5
        gh.handleMessage(2, \noteOn, 57); 0.08.wait; // fret 7 on string 4

        if(~gui.notNil) { ~gui.showExpectation("CT PROG: 3‚Äì5‚Äì7 reached. Queue when ready.", 0) };
        nil
    };
    Routine({ run.value }).play(AppClock);
};

queueAndSend = {
    var run;
    run = {
        var mm, path;
        mm = ~ct.midiManager;
        mm.setMode(mm.modes[\queue]); 0.08.wait;
        mm.setMode(mm.modes[\send]);  0.08.wait;

        path = ~ct.midiManager.queue.exportAsOSCPath;
        ("[CT] OSC path exported: " ++ path).postln;
        reflectOsc.value(path);

        "[CT] Applied effect to NEXT; call ~switchNow.() to promote".postln;
        nil
    };
    Routine({ run.value }).play(AppClock);
};

startObserver = {
    var run;
    run = {
        var lastSeen;
        lastSeen = "";
        if(~ctObserver.notNil) { AppClock.clear(~ctObserver); ~ctObserver = nil };
        ~ctObserver = AppClock.sched(0.20, {
            var currentStr, tokens, hasMeaning;
            currentStr = (~commandToSend ? "").asString;
            if(currentStr.size > 0 and: { currentStr != lastSeen }) {
                tokens = currentStr.split($/).reject(_.isEmpty);
                hasMeaning = (tokens.size >= 2);
                if(hasMeaning) {
                    ("[CT OBS] detected SEND: " ++ currentStr).postln;
                    reflectOsc.value(currentStr);
                }{
                    ("[CT OBS] ignoring trivial path: " ++ currentStr).postln;
                };
                lastSeen = currentStr;
            };
            0.20  // reschedule
        });
        "[CT] Observer started (listening to ~commandToSend)".postln;
        nil
    };
    AppClock.sched(0.10, { run.value; nil });
};

// ---- run sequence ----
ensureDeps.value;
buildEffectMap.value;

// Demo pass (comment out if using real controller later)
AppClock.sched(0.25, { simulatePath_3_5_7.value; nil });
AppClock.sched(1.10, { queueAndSend.value; nil });

// Passive observer for real SENDs
startObserver.value;
)

===== Magicpedalboard/obsolete/test_editor_commandtree_add_demo_verbs_part_a.scd =====
// test_editor_commandtree_add_demo_verbs_part_a.scd
// v0.1
// MD 20250916-0919

(
var jsonPath, loadOk, tree, getNodeByPath, assert, expectPath, pathsToCheck, passCount, failCount, countAfter, summary;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0;
failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " ‚Äî " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

getNodeByPath = { arg treeRef, nameList;
    var foundNode;
    foundNode = treeRef.getNodeByNamePath(nameList);
    foundNode
};

expectPath = { arg treeRef, nameList;
    var nodeRef, lastName, hasNode, payloadMatches;
    nodeRef = getNodeByPath.(treeRef, nameList);
    lastName = nameList.last;
    hasNode = nodeRef.notNil;
    assert.(hasNode, "exists: " ++ nameList.join(" ‚Üí "));
    if(hasNode) {
        payloadMatches = (nodeRef.payload == lastName);
        assert.(payloadMatches, "payload==name for: " ++ nameList.join(" ‚Üí "));
    };
};

// 1) Load tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON loaded from " ++ jsonPath);

// 2) Expected paths created by the editor script
pathsToCheck = [
    ["commands"],
    ["commands","add","delay"],
    ["commands","add","chorus"],
    ["commands","add","reverb"],
    ["commands","add","tremolo"],
    ["commands","bypass","delay","on"],
    ["commands","bypass","delay","off"],
    ["commands","switch"],
    ["commands","setSource","testmelody"]
];

// 3) Check each path exists and payload==name
pathsToCheck.do({ arg nameList; expectPath.(tree, nameList) });

// 4) Record node map size (for idempotency comparison later)
countAfter = tree.nodeMap.size;
~ct_nodecount_after_first = countAfter;  // store globally for Part B
("[TEST] nodeMap.size after first run = " ++ countAfter).postln;

// 5) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)

===== Magicpedalboard/obsolete/test_editor_commandtree_add_demo_verbs_part_b.scd =====
// test_editor_commandtree_add_demo_verbs_part_b.scd
// v0.1
// MD 20250916-0920

(
var jsonPath, loadOk, tree, countBefore, countAfter, assert, summary, passCount, failCount;

jsonPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
passCount = 0; failCount = 0;

assert = { arg condition, label;
    var statusText;
    statusText = if(condition) { "PASS" } { "FAIL" };
    ("[TEST] " ++ statusText ++ " ‚Äî " ++ label).postln;
    if(condition) { passCount = passCount + 1 } { failCount = failCount + 1 };
};

// 0) Precondition: you just re-ran editor_commandtree_add_demo_verbs.scd
// 1) Reload tree
tree = MDCommandTree.new;
loadOk = tree.importJSONFile(jsonPath);
assert.(loadOk, "JSON reloaded");

// 2) Compare node counts
countBefore = ~ct_nodecount_after_first ? -1;
countAfter  = tree.nodeMap.size;

("[TEST] nodeMap.size first=" ++ countBefore ++ " second=" ++ countAfter).postln;

// Expectation: no new nodes created on second run (idempotent)
assert.(countBefore == countAfter, "idempotent: nodeMap size unchanged after second run");

// 3) Summary
summary = "[TEST] Summary: PASS=" ++ passCount ++ " FAIL=" ++ failCount;
summary.postln;
)

===== Magicpedalboard/obsolete/Test_MagicAudio_BringUp_A_B.scd =====
// Test_MagicAudio_BringUp_A_B.scd
// v0.9.3
// MD 20250919-09:16 BST

/*
Purpose
- Robust audio bring-up (no SoundIn), Option A for NEXT:
  - Atomic build into a dedicated root group (~mpRoot).
  - A audible; B muted at source until switch.
  - FX via Ndef(\chainX).filter dictionary.
  - Helpers: ~applyToNext, ~clearNext, ~switchNow, ~audioReset.

Style
- var-first; lowercase; AppClock-only; no server.sync.
*/

(
var boot, installFxDict, buildOnce, installHelpers, announce;
var s;

boot = {
    var run;
    run = {
        s = Server.default;
        s.waitForBoot({
            Server.default.bind({
                s.initTree;
                s.defaultGroup.freeAll;
            });
            ("[AUDIO] server booted: " ++ s.addr).postln;
        });
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

installFxDict = {
    var run;
    run = {
        ~fx = IdentityDictionary[
            \delay -> { arg in, time=0.35, decay=2.0, max=1.0;
                time = time.clip(0.005, max);
                CombC.ar(in, max, time, decay)
            },
            \reverb -> { arg in, mix=0.20, room=0.60, damp=0.50;
                FreeVerb.ar(in, mix.clip(0,1), room.clip(0,1), damp.clip(0,1))
            },
            \chorus -> { arg in, depth=0.003, rate=0.25;
                var mod;
                mod = SinOsc.kr(rate).range(depth * -1, depth);
                DelayC.ar(in, depth*2 + 0.01, mod + depth + 0.005)
            },
            \tremolo -> { arg in, rate=5, depth=0.6;
                var lfo;
                lfo = LFTri.kr(rate).range(1-depth, 1);
                in * lfo
            }
        ];
        "[FX] dictionary installed (\\delay, \\reverb, \\chorus, \\tremolo)".postln;
        nil
    };
    AppClock.sched(0.02, { run.value; nil });
};

buildOnce = {
    var run;
    run = {
        var lat, atomBuild, stopClear;
        lat = s.latency ? 0.2;

        atomBuild = {
            // stop/clear any prior proxies quietly
            stopClear = { arg name;
                var p = Ndef(name);
                if(p.isPlaying) { p.stop };
                p.clear;
            };
            [\out, \mix, \chainA, \chainB, \srcA, \srcB].do(stopClear);

            // new root group
            if(~mpRoot.notNil) { try { ~mpRoot.free } };
            ~mpRoot = Group.head(s);

            // sources
            Ndef(\srcA).fadeTime = 0.02;
            Ndef(\srcA).source = { arg amp=0.20;
                var t, seq, freq, sig;
                t   = Impulse.kr(2);
                seq = Demand.kr(t, 0, Dseq([220, 277, 247, 294, 330, 262], inf));
                freq= Lag.kr(seq, 0.02);
                sig = Mix.new(VarSaw.ar(freq * [1, 0.501], 0, 0.4)) * 0.35;
                sig = LPF.ar(sig, 6000);
                Pan2.ar(sig, 0) * amp;
            };

            Ndef(\srcB).fadeTime = 0.02;
            Ndef(\srcB).source = { arg amp=0.20, muted=1;
                var t, seq, freq, sig;
                t   = Impulse.kr(2);
                seq = Demand.kr(t, 0, Dseq([196, 233, 262, 220, 294, 247], inf));
                freq= Lag.kr(seq, 0.02);
                sig = Mix.new(VarSaw.ar(freq * [1, 0.503], 0, 0.4)) * 0.35;
                sig = LPF.ar(sig, 5400);
                sig = Pan2.ar(sig, 0) * amp;
                Select.ar(muted.clip(0,1), [sig, Silent.ar(2)])
            };

            // chains
            Ndef(\chainA).fadeTime = 0.02;
            Ndef(\chainA).source = { Ndef(\srcA).ar };

            Ndef(\chainB).fadeTime = 0.02;
            Ndef(\chainB).source = { Ndef(\srcB).ar };

            // mix and out
            Ndef(\mix).fadeTime = 0.02;
            Ndef(\mix).source = { Ndef(\chainA).ar + Ndef(\chainB).ar };

            Ndef(\out).fadeTime = 0.02;
            Ndef(\out).source = { Ndef(\mix).ar };

            // play out into our group (positional group arg #6)
            Ndef(\out).play(0, nil, ~mpRoot, 1.0, 1.0, 0.02, \addToHead);

            // initial params
            Ndef(\srcA).set(\amp, 0.20);
            Ndef(\srcB).set(\amp, 0.20, \muted, 1); // Option A
        };

        s.makeBundle(lat, atomBuild);
        AppClock.sched(lat + 0.05, { "[AUDIO] atomic graph built + out playing".postln; nil });
        nil
    };
    AppClock.sched(0.04, { run.value; nil });
};

installHelpers = {
    var run;
    run = {
        ~currentIsA = true;
        ~ampA = 0.20; ~ampB = 0.20;

        ~applyToNext = { arg fxSym, params = ( );
            var f;
            f = ~fx[fxSym];
            if(f.isNil) {
                ("[FX] unknown: " ++ fxSym).warn;
            }{
                Ndef(\chainB).filter(fxSym, f, params);
                "[FX] applied to NEXT: ".post; fxSym.postln;
            };
        };

        ~clearNext = {
            Ndef(\chainB).clear;
            Ndef(\chainB).source = { Ndef(\srcB).ar };
            "[FX] NEXT cleared".postln;
        };

        ~switchNow = {
            if(~currentIsA) {
                Ndef(\srcA).set(\amp, 0.0);
                Ndef(\srcB).set(\muted, 0, \amp, ~ampB);
                ~currentIsA = false;
                if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainB) };
                "[SWITCH] B is now CURRENT".postln;
            }{
                Ndef(\srcB).set(\amp, 0.0, \muted, 1);
                Ndef(\srcA).set(\amp, ~ampA);
                ~currentIsA = true;
                if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainA) };
                "[SWITCH] A is now CURRENT".postln;
            };
        };

        ~audioReset = {
            var lat, doReset;
            lat = s.latency ? 0.2;
            doReset = {
                [\out, \mix, \chainA, \chainB, \srcA, \srcB].do({ arg k;
                    var p = Ndef(k);
                    if(p.isPlaying) { p.stop };
                    p.clear;
                });
                if(~mpRoot.notNil) { try { ~mpRoot.free } };
            };
            s.makeBundle(lat, doReset);
            AppClock.sched(lat + 0.05, { buildOnce.value; nil });
            "[AUDIO] reset requested".postln;
        };

        // initial GUI hint
        if(~gui.notNil) { ~gui.highlightCurrentColumn(\chainA) };
        nil
    };
    AppClock.sched(0.10, { run.value; nil });
};

announce = {
    var run;
    run = {
        "[READY] Audio up. Helpers: ~applyToNext.(\\delay), ~clearNext.(), ~switchNow.(), ~audioReset.()".postln;
        nil
    };
    AppClock.sched(0.12, { run.value; nil });
};

boot.value;
installFxDict.value;
buildOnce.value;
installHelpers.value;
announce.value;
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_AllInOne_Monolithic.scd =====
/*
 * Test_MagicDisplayGUI_AllInOne_Monolithic.scd v0.10
 * Single top-level block = no "unexpected '('" parse issue.
 *
 * Contents
 *  - Section A: Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
 *  - Section B: Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
 *  - Section C: Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
 *  - Section D: Resilient UI-queue patch + v6 aliases + one-button runner
 *
 * Style respected:
 *  - tilde vars, var-first in each block, lowercase names
 *  - no server.sync, explicit AppClock scheduling for UI work (.defer)
 */

(
// ======================================================================
// Section A ‚Äî Test_MagicDisplayGUI_BootAndScenarios.scd v0.4 (verbatim)
// ======================================================================

// ---------- shared helpers ------------------------------------------------
~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " ‚Üí current=" ++ curr.asString
        ++ "  next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;
    nxt = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA = ~mpb.effectiveCurrent;
    effB = ~mpb.effectiveNext;
    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw ----------------
~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;
    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200; // up to ~10 seconds
    pollDelaySeconds = 0.05;
    routine = Routine {
        var pollCount;
        pollCount = 0;
        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait; // SystemClock here; avoids AppClock contention
        });
        defer({
            if(~gui.window.notNil) {
                "Window ready ‚Äî fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };
    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window‚Ä¶".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -------------
~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.8;
    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },
        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },
        { "[SC1] bypass flanger ‚Üí true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },
        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },
        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play; // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.25;
    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln; ~mpb.add(\chorus); ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln; ~mpb.add(\reverb); ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln; ~mpb.removeAt(2); ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln; ~mpb.add(\phaser); ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln; ~mpb.clearChain; ~refreshView.("SC2/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitSeconds = 0.6;
    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },
        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },
        { "[SC3] bypass bitcrusher ‚Üí false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },
        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },
        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];
    totalSteps = steps.size;
    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };
    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};


// ======================================================================
// Section B ‚Äî Test_MagicDisplayGUI_Scenarios.scd v0.5 (verbatim)
// ======================================================================

~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain; nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent; eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add flanger"); ~gui.showExpectation("Command: add flanger", 0); ~mpb.add(\flanger); ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true"); ~gui.showExpectation("Command: bypass flanger true", 0); ~mpb.bypass(\flanger, true); ~refreshGuiFromMpb.() },
        { ~log.("add delay"); ~gui.showExpectation("Command: add delay", 0); ~mpb.add(\delay); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add chorus"); ~gui.showExpectation("Command: add chorus", 0); ~mpb.add(\chorus); ~refreshGuiFromMpb.() },
        { ~log.("add reverb"); ~gui.showExpectation("Command: add reverb", 0); ~mpb.add(\reverb); ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2"); ~gui.showExpectation("Command: removeAt 2", 0); ~mpb.removeAt(2); ~refreshGuiFromMpb.() },
        { ~log.("add phaser"); ~gui.showExpectation("Command: add phaser", 0); ~mpb.add(\phaser); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init"); ~gui.showExpectation("Command: init", 0); ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher"); ~gui.showExpectation("Command: add bitcrusher", 0); ~mpb.add(\bitcrusher); ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false"); ~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1"); ~gui.showExpectation("Command: removeAt 1", 0); ~mpb.removeAt(1); ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT"); ~gui.showExpectation("Command: clear NEXT", 0); ~mpb.clearChain; ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};


// ======================================================================
// Section C ‚Äî Test_MagicDisplayGUI_InlineInstrument.scd v0.2 (verbatim)
// ======================================================================

~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;
    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };
    hasWin = ~gui.tryPerform(\window).notNil;
    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock‚Ä¶".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};


// ======================================================================
// Section D ‚Äî Patch + v6 Aliases + One-button Runner
// ======================================================================

// Resilient UI-queue patch: make queued UI work run immediately on AppClock
~md_applyQueueUiPatch = {
    var displayCandidates, candidateIndex, candidate, patched, proofFun;

    patched = false;
    displayCandidates = [];

    // Prefer ~magicDisplay if present; fallback to ~gui
    if(~magicDisplay.notNil) { displayCandidates = displayCandidates.add(~magicDisplay) };
    if(~gui.notNil)          { displayCandidates = displayCandidates.add(~gui) };

    if(displayCandidates.isEmpty) {
        "[PATCH] No display object (~magicDisplay or ~gui) yet; run boot first.".postln;
        ^false
    };

    candidateIndex = 0;
    while({ candidateIndex < displayCandidates.size and: { patched.not } }, {
        candidate = displayCandidates[candidateIndex];

        // Try setter first (slot/property on an object)
        if(candidate.respondsTo(\queueUi_)) {
            candidate.queueUi = { |selfArg, fun| fun.defer };  // UI-safe immediate
            patched = true;
        }{
            // Try dictionary/event-like storage
            if(candidate.respondsTo(\atPut)) {
                candidate[\queueUi] = { |ignoredSelf, fun| fun.defer }; // UI-safe immediate
                patched = true;
            };
        };

        candidateIndex = candidateIndex + 1;
    });

    if(patched) {
        "[PATCH] queueUi patched to immediate (.defer)".postln;

        // Proof-of-life
        if(candidate.respondsTo(\queueUi)) {
            candidate.queueUi({ "[CHECK] queueUi immediate hit".postln });
        }{
            if(candidate.respondsTo(\at)) {
                proofFun = candidate[\queueUi];
                if(proofFun.isKindOf(Function)) {
                    proofFun.value(candidate, { "[CHECK] queueUi immediate hit".postln });
                };
            };
        };
        ^true
    }{
        "[PATCH] Display found but exposes neither queueUi_ nor atPut; not patched.".postln;
        ^false
    };
};

// Wait-and-patch helper: polls until a display is available, then applies patch
~md_waitAndPatchQueueUiImmediate = {
    var attempts, maxAttempts, stepSeconds, routineInstance;

    attempts = 0;
    maxAttempts = 200;     // ~10 seconds at 0.05s
    stepSeconds = 0.05;

    routineInstance = Routine({
        "[PATCH] Waiting for display (~magicDisplay or ~gui)‚Ä¶".postln;
        while({ attempts < maxAttempts }, {
            if(~magicDisplay.notNil or: { ~gui.notNil }) {
                if(~md_applyQueueUiPatch.()) {
                    thisThread.stop;
                };
            };
            attempts = attempts + 1;
            stepSeconds.wait;
        });
        "[PATCH] Timed out waiting for display; run ~md_waitAndPatchQueueUiImmediate.() again after boot."
        .postln;
    }).play(AppClock);

    routineInstance
};

// v6-style aliases wrapping your existing definitions
~bootGuiV6 = {
    var booted;
    booted = false;
    if(~bootGuiV4.notNil) {
        ~bootGuiV4.();
        booted = true;
    }{
        "Missing ~bootGuiV4; please check Section A definitions.".warn;
    };

    // Start the wait-and-patch watcher right after boot
    if(booted) {
        ~md_waitAndPatchQueueUiImmediate.();
    };
};

~scenario1v6 = { if(~scenario1v5.notNil) { ~scenario1v5.() }{ if(~scenario1v4.notNil) { ~scenario1v4.() }{ "No scenario1 function found.".warn }} };
~scenario2v6 = { if(~scenario2v5.notNil) { ~scenario2v5.() }{ if(~scenario2v4.notNil) { ~scenario2v4.() }{ "No scenario2 function found.".warn }} };
~scenario3v6 = { if(~scenario3v5.notNil) { ~scenario3v5.() }{ if(~scenario3v4.notNil) { ~scenario3v4.() }{ "No scenario3 function found.".warn }} };

~probeGuiV3 = { if(~probeGuiV2.notNil) { ~probeGuiV2.() }{ "No probe function (~probeGuiV2) found.".warn } };

// One-button runner: boot ‚Üí patch ‚Üí probe ‚Üí scenario
~md_go = {
    var bootTask;
    bootTask = Task({
        "[ALL-IN-ONE] Booting GUI (v6 alias)‚Ä¶".postln;
        ~bootGuiV6.();

        // small wait for "Window ready‚Ä¶" to appear
        0.5.wait;

        if(~probeGuiV3.notNil) {
            "[ALL-IN-ONE] Running probe (~probeGuiV3)‚Ä¶".postln;
            ~probeGuiV3.();
        };

        0.2.wait;

        if(~scenario1v6.notNil) {
            "[ALL-IN-ONE] Running scenario (~scenario1v6)‚Ä¶".postln;
            ~scenario1v6.();
        };
    });
    bootTask.start;
    bootTask
};

// Session banner
"[ALL-IN-ONE] Ready. Typical flow:\n  1) ~bootGuiV6.();\n  2) ~md_waitAndPatchQueueUiImmediate.();\n  3) ~probeGuiV3.();\n  4) ~scenario1v6.();\nOr just run: ~md_go.();"
.postln;

) // <‚Äî single top-level block ends here

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_AllInOne.scd =====
/*
 * Test_MagicDisplayGUI_AllInOne.scd
 * Loads your three existing test files in order, then applies a resilient
 * UI-queue immediate patch so scenarios don‚Äôt stall after [SC] init.
 *
 * Conventions respected:
 * - var-first in every block
 * - tilde interpreter vars with lowercase initial (existing names kept: ~bootGuiV4, ~scenario1v5, ~probeGuiV2)
 * - no single-letter locals
 * - no server.sync; UI work is on AppClock via .defer
 * - convenience aliases expose v6 names for the session
 */

(
// -----------------------------
// section 0: setup + utilities
// -----------------------------
var basePath, fileNames, loaded, loadOne, report,
    waitAndPatchQueueUiImmediate, applyQueueUiPatch,
    makeAliases, goRunner;

basePath = thisProcess.nowExecutingPath.asString.dirname;
fileNames = [
    "Test_MagicDisplayGUI_BootAndScenarios.scd",
    "Test_MagicDisplayGUI_Scenarios.scd",
    "Test_MagicDisplayGUI_InlineInstrument.scd"
];
loaded = IdentityDictionary.new;

report = { |messageString|
    ("[ALL-IN-ONE] " ++ messageString).postln;
};

// Try to load a file by name from the same folder as this script.
loadOne = { |nameString|
    var fullPath, didLoad;
    didLoad = false;
    fullPath = basePath +/+ nameString;
    if(PathName(fullPath).isFile) {
        report.("Loading " ++ nameString ++ " ‚Ä¶");
        thisProcess.interpreter.executeFile(fullPath);
        didLoad = true;
        loaded[nameString] = true;
        report.("Loaded " ++ nameString);
    }{
        report.("NOT FOUND beside this script: " ++ nameString);
    };
    didLoad
};

// -----------------------------------------------
// section 1: load your three files in the order
// -----------------------------------------------
fileNames.do({ |nameString|
    var didLoadLocal, altPath;
    didLoadLocal = loadOne.(nameString);
    if(didLoadLocal.not) {
        // Try also current working directory as a fallback.
        altPath = PathName(nameString);
        if(altPath.isFile) {
            report.("Loading from current dir: " ++ nameString);
            thisProcess.interpreter.executeFile(altPath.fullPath);
            loaded[nameString] = true;
            report.("Loaded " ++ nameString);
        }{
            // Stop early with a clear message; keeps behavior explicit.
            Error(
                "[ALL-IN-ONE] Could not locate required file: " ++ nameString
                ++ "\nPlace this AllInOne file next to your three test files and re-evaluate."
            ).throw;
        };
    };
});

// --------------------------------------------------------------------
// section 2: resilient UI-queue patch helpers
// --------------------------------------------------------------------
applyQueueUiPatch = {
    var applied;
    applied = false;

    if(~magicDisplay.notNil) {
        // Preferred: dictionary-style if it's an Event/Dictionary-like object
        if(~magicDisplay.respondsTo(\atPut)) {
            ~magicDisplay[\queueUi] = { |ignoredSelf, fun| fun.defer };
            applied = true;
        }{
            // Fallback: setter method if the object has a queueUi_ slot
            if(~magicDisplay.respondsTo(\queueUi_)) {
                ~magicDisplay.queueUi = { |selfArg, fun| fun.defer };
                applied = true;
            };
        };

        if(applied) {
            report.("UI patch applied: queueUi now runs immediate on AppClock (.defer).");
            // Small proof-of-life, only if it can be called like a method:
            if(~magicDisplay.respondsTo(\queueUi)) {
                ~magicDisplay.queueUi({ "[CHECK] queueUi immediate hit".postln });
            }{
                // Or if it is dictionary-like:
                if(~magicDisplay.respondsTo(\at)) {
                    var qf;
                    qf = ~magicDisplay[\queueUi];
                    if(qf.isKindOf(Function)) { qf.value(~magicDisplay, { "[CHECK] queueUi immediate hit".postln }); };
                };
            };
        }{
            report.("UI patch: ~magicDisplay exists but exposes neither atPut nor queueUi_. Not patched.");
        };
    }{
        report.("UI patch: ~magicDisplay is nil; boot first.");
    };

    applied
};

waitAndPatchQueueUiImmediate = {
    var attempts, maxAttempts, stepSeconds, routineInstance, applied;

    attempts = 0;
    maxAttempts = 200;     // ~10 seconds total at 0.05s steps
    stepSeconds = 0.05;

    routineInstance = Routine({
        report.("UI patch: waiting for ~magicDisplay ‚Ä¶");
        while({ attempts < maxAttempts }, {
            if(~magicDisplay.notNil) {
                applied = applyQueueUiPatch.();
                if(applied) {
                    // stop the routine cleanly
                    thisThread.stop;
                }{
                    // ~magicDisplay present but no slot yet (maybe constructor still building)
                    // wait a moment and retry
                };
            };
            attempts = attempts + 1;
            stepSeconds.wait;
        });
        report.("UI patch: ~magicDisplay did not appear in time; you can run ~md_waitAndPatchQueueUiImmediate.() again after boot.");
    }).play(AppClock);

    routineInstance
};

// --------------------------------------------------------------
// section 3: convenience aliases and an optional one-button run
// --------------------------------------------------------------
makeAliases = {
    var messages;
    messages = List.new;
    if(thisProcess.interpreter.hasVar(\bootGuiV4)) {
        ~bootGuiV6 = { ~bootGuiV4.value; };
        messages.add("~bootGuiV6 ‚Üí ~bootGuiV4");
    };
    if(thisProcess.interpreter.hasVar(\scenario1v5)) {
        ~scenario1v6 = { ~scenario1v5.value; };
        messages.add("~scenario1v6 ‚Üí ~scenario1v5");
    };
    if(thisProcess.interpreter.hasVar(\probeGuiV2)) {
        ~probeGuiV3 = { ~probeGuiV2.value; };
        messages.add("~probeGuiV3 ‚Üí ~probeGuiV2");
    };

    if(messages.isEmpty) {
        report.("No known functions found to alias. Ensure your three files defined ~bootGuiV4, ~scenario1v5, ~probeGuiV2.");
    }{
        report.("Aliases established: " ++ messages.asArray.join(", "));
    };
};

// Optional: boots GUI, applies patch, runs probe, then scenario.
goRunner = {
    var bootTask;
    bootTask = Task({
        report.("Booting GUI (v6 aliases)‚Ä¶");
        if(thisProcess.interpreter.hasVar(\bootGuiV6)) {
            ~bootGuiV6.(); // your original boot runs here
        }{
            Error("[ALL-IN-ONE] ~bootGuiV6 missing; check that ~bootGuiV4 exists in your loaded files.").throw;
        };

        // Apply the patch as soon as ~magicDisplay is present
        waitAndPatchQueueUiImmediate.();

        // Give the GUI a moment to open and print "Window ready‚Ä¶" (non-blocking)
        0.5.wait;

        if(thisProcess.interpreter.hasVar(\probeGuiV3)) {
            report.("Running probe (~probeGuiV3)‚Ä¶");
            ~probeGuiV3.();
        }{
            report.("Skipping probe; ~probeGuiV3 not defined.");
        };

        // Small gap so probe logs show up clearly
        0.2.wait;

        if(thisProcess.interpreter.hasVar(\scenario1v6)) {
            report.("Running scenario (~scenario1v6)‚Ä¶");
            ~scenario1v6.();
        }{
            report.("Skipping scenario; ~scenario1v6 not defined.");
        };
    });

    bootTask.start;
    bootTask
};

// finalize setup for this session
makeAliases.();
~md_waitAndPatchQueueUiImmediate = waitAndPatchQueueUiImmediate; // expose utility
~md_applyQueueUiPatch = applyQueueUiPatch; // expose direct patch if you need it
~md_go = goRunner; // convenience one-button runner

report.("Ready. Typical flow:\n"++
    "  1) ~bootGuiV6.();\n"++
    "  2) ~md_waitAndPatchQueueUiImmediate.();  // applies as soon as ~magicDisplay exists\n"++
    "  3) ~probeGuiV3.();\n"++
    "  4) ~scenario1v6.();\n"++
    "Or just run: ~md_go.();"
);
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_BootAndScenarios.scd =====
/* Test_MagicDisplayGUI_BootAndScenarios.scd v0.4
   Purpose: Deterministic boot (meters OFF), wait for window, then scenarios that
            clearly post progress AND force GUI redraws every step.

   Style: tilde vars, var-first, lowercase names, no server.sync, no single-letter locals.
*/

(
// ---------- shared helpers ----------------------------------------------------

~postState = { |labelString|
    var curr, nxt;
    curr = ~mpb.tryPerform(\currentChain);
    nxt  = ~mpb.tryPerform(\nextChain);
    ("[STATE] " ++ labelString ++ " ‚Üí current=" ++ curr.asString
        ++ " | next=" ++ nxt.asString).postln;
};

~drawOnce = {
    var curr, nxt, bypassA, bypassB, effA, effB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    curr    = ~mpb.currentChain;
    nxt     = ~mpb.nextChain;
    bypassA = ~mpb.bypassKeysCurrent;
    bypassB = ~mpb.bypassKeysNext;
    effA    = ~mpb.effectiveCurrent;
    effB    = ~mpb.effectiveNext;

    // GUI method that actually updates the lists/labels
    ~gui.showChainsDetailed(curr, nxt, bypassA, bypassB, effA, effB);
};

~refreshView = { |labelString|
    ~postState.(labelString);
    // Console view via MPB (also calls showChainsDetailed under the hood)
    ~mpb.printChains;
    // Explicit GUI redraw (belt-and-braces)
    ~drawOnce.();
};

// ---------- robust boot: wait for window, then first draw --------------------

~bootGuiV4 = {
    var guiObj, board, maxPollCount, pollDelaySeconds, routine;

    // stop any previous tasks
    ~mdgTask.notNil.if { ~mdgTask.stop; ~mdgTask = nil };
    ~bootTask.notNil.if { ~bootTask.stop; ~bootTask = nil };

    // create GUI and disable meters (avoid server dependency)
    guiObj = MagicDisplayGUI.new;
    guiObj.enableMeters(false);

    // create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);
    ~gui = guiObj;
    ~mpb = board;

    // poll for the window (it is built asynchronously on AppClock)
    maxPollCount = 200;          // up to ~10 seconds
    pollDelaySeconds = 0.05;

    routine = Routine {
        var pollCount;
        pollCount = 0;

        while({ (~gui.window.isNil) and: { pollCount < maxPollCount } }, {
            pollCount = pollCount + 1;
            pollDelaySeconds.wait;      // SystemClock here; avoids AppClock contention
        });

        defer({
            if(~gui.window.notNil) {
                "Window ready ‚Äî fronting and drawing columns.".postln;
                ~gui.window.front;
            }{
                "Window did not appear in time (10 s).".warn;
            };
            ~refreshView.("boot");
        });
    };

    ~bootTask = Task(routine, SystemClock).play; // use SystemClock for the polling loop
    "Booting GUI (meters disabled). Waiting for window‚Ä¶".postln;
};

// bring GUI to front later if needed
~frontGui = {
    if(~gui.notNil and: { ~gui.window.notNil }) { ~gui.window.front };
};

// stop any running scenario
~stopScenarios = {
    var runningTask;
    runningTask = ~mdgTask;
    if(runningTask.notNil) { runningTask.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// ---------- Scenarios (run on SystemClock, post step labels) -----------------

~scenario1v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.8;

    steps = [
        { "[SC1] init".postln; ~refreshView.("SC1/init") },

        { "[SC1] add flanger".postln;
          ~mpb.add(\flanger);
          ~refreshView.("SC1/add flanger") },

        { "[SC1] bypass flanger ‚Üí true".postln;
          ~mpb.bypass(\flanger, true);
          ~refreshView.("SC1/bypass flanger true") },

        { "[SC1] add delay".postln;
          ~mpb.add(\delay);
          ~refreshView.("SC1/add delay") },

        { "[SC1] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC1/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;   // SystemClock: robust in headless/server-off
    ~mdgTask
};

~scenario2v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.25;

    steps = [
        { "[SC2] init".postln; ~refreshView.("SC2/init") },
        { "[SC2] add chorus".postln;  ~mpb.add(\chorus);  ~refreshView.("SC2/add chorus") },
        { "[SC2] add reverb".postln;  ~mpb.add(\reverb);  ~refreshView.("SC2/add reverb") },
        { "[SC2] add tremolo".postln; ~mpb.add(\tremolo); ~refreshView.("SC2/add tremolo") },
        { "[SC2] removeAt 2".postln;  ~mpb.removeAt(2);   ~refreshView.("SC2/removeAt 2") },
        { "[SC2] add phaser".postln;  ~mpb.add(\phaser);  ~refreshView.("SC2/add phaser") },
        { "[SC2] clear NEXT".postln;  ~mpb.clearChain;    ~refreshView.("SC2/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};

~scenario3v4 = {
    var routine, waitSeconds, steps, totalSteps;

    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };

    waitSeconds = 0.6;

    steps = [
        { "[SC3] init".postln; ~refreshView.("SC3/init") },

        { "[SC3] add bitcrusher".postln;
          ~mpb.add(\bitcrusher);
          ~refreshView.("SC3/add bitcrusher") },

        { "[SC3] bypass bitcrusher ‚Üí false".postln;
          ~mpb.bypass(\bitcrusher, false);
          ~refreshView.("SC3/bypass bitcrusher false") },

        { "[SC3] removeAt 1 (if exists)".postln;
          ~mpb.removeAt(1);
          ~refreshView.("SC3/removeAt 1") },

        { "[SC3] clear NEXT".postln;
          ~mpb.clearChain;
          ~refreshView.("SC3/clear NEXT") }
    ];

    totalSteps = steps.size;

    routine = Routine {
        var stepIndex;
        stepIndex = 0;
        while({ stepIndex < totalSteps }, {
            steps[stepIndex].value;
            stepIndex = stepIndex + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, SystemClock).play;
    ~mdgTask
};
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_DirectDraw.scd =====
/* Test_MagicDisplayGUI_DirectDraw.scd v0.3
   Purpose: Prove the GUI window and list widgets update without MPB.
*/

(
var gui, maxPollCount, pollDelaySeconds, routine;

gui = MagicDisplayGUI.new;
gui.enableMeters(false);

maxPollCount = 200;      // up to ~10 seconds
pollDelaySeconds = 0.05;

routine = Routine {
    var pollCount;
    pollCount = 0;
    while({ gui.window.isNil and: { pollCount < maxPollCount } }, {
        pollCount = pollCount + 1;
        pollDelaySeconds.wait;
    });

    defer({
        var current, next, bypassA, bypassB, effA, effB;
        if(gui.window.notNil) { gui.window.front };

        current = [\chainA, \flanger, \delay, \ts0];  // [sink, ‚Ä¶, source]
        next    = [\chainB, \chorus,  \reverb, \ts0];

        bypassA = [\delay];
        bypassB = [];
        effA    = [\chainA, \flanger, \ts0];
        effB    = [\chainB, \chorus, \reverb, \ts0];

        gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
    });
};

Task(routine, AppClock).play;
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_InlineInstrument.scd =====
/* Test_MagicDisplayGUI_InlineInstrument.scd v0.2
   Goal: verify that MagicDisplayGUI executes UI updates on AppClock and
         that a single forced frame appears in the lists and "Command:" area.
*/

(
~probeGuiV2 = {
    var hasGui, hasWin, current, next, bypassA, bypassB, effA, effB;

    hasGui = ~gui.notNil;
    if(hasGui.not) { "No ~gui. Run ~bootGuiV4.() first.".warn; ^nil };

    hasWin = ~gui.tryPerform(\window).notNil;

    ["[PROBE] gui exists:", hasGui, "window exists:", hasWin].postln;

    // very distinctive frame so you can spot it instantly
    current = [\chainA, \AAA_debug_one, \BBB_debug_two, \ts0];
    next    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];
    bypassA = [\BBB_debug_two];
    bypassB = [];
    effA    = [\chainA, \AAA_debug_one, \ts0];
    effB    = [\chainB, \CCC_debug_three, \DDD_debug_four, \ts0];

    // make the "Command:" box change as well (immediate visible cue)
    ~gui.showExpectation("Command: PROBE FRAME", 0);

    // schedule list redraw on AppClock (same thread your GUI uses internally)
    AppClock.sched(0, {
        "[PROBE] Calling showChainsDetailed on AppClock‚Ä¶".postln;
        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effA, effB);
        "[PROBE] showChainsDetailed returned.".postln;
        nil
    });

    "Probe queued. Expect 'PROBE FRAME' in the Command area and AAA/BBB/CCC/DDD items in the lists."
    .postln;
};
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_LayoutOnly_v2.scd =====
// Test_MagicDisplayGUI_LayoutOnly_v2.scd
// v0.3.0
// MD 20250919-08:45 BST

/*
Purpose
- Bring up MagicDisplayGUI for visual-only testing and apply a NO-RECOMPILE layout fix:
  1) Move the HUD to the top-right so it doesn't cover the columns.
  2) Hide the Ops panel and reclaim the right-hand third for A/B columns.
  3) Shrink the meters horizontally.
- Populate CURRENT/NEXT with demo data and flip the CURRENT highlight every few seconds.

Style
- var-first; lowercase; AppClock-only GUI ops; no server.sync; one window named "MagicDisplayGUI*".
*/

(
var closeMagicWindows, makeGui, populateListsOnce, cycleCurrentHighlight;
var applyVisualFix, attachResizeFix;

// -- close any existing MagicDisplayGUI* windows to be deterministic
closeMagicWindows = {
    AppClock.sched(0.0, {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do(_.close);
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    });
};

// -- create GUI; explicitly disable meters (no audio today)
makeGui = {
    AppClock.sched(0.05, {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        AppClock.sched(0.0, { ~gui.enableMeters(false); nil });
        AppClock.sched(0.05, { ~gui.enableMeters(false); nil });
        "[GUI] created; meters disabled".postln;
        nil
    });
};

// -- demo visual data
populateListsOnce = {
    AppClock.sched(0.15, {
        var current, next, effC, effN, bypassA, bypassB, ops;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus];
        bypassB = [];
        effC = current; effN = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only layout test. No audio. No meters.", 0);

            // Fill ops list so we can immediately hide it in the fix thereafter.
            ops = ["insert delay", "switch", "bypass delay on", "bypass delay off", "switch"];
            if(~gui.respondsTo(\setOperations)) {
                ~gui.setOperations(ops);
                ~gui.setNextAction({ arg idx; ("[ops] next index " ++ idx).postln; });
            };
        };
        "[GUI] lists populated".postln;
        nil
    });
};

// -- flip current highlight every 3s (visual only)
cycleCurrentHighlight = {
    AppClock.sched(0.30, {
        var isA, step;
        isA = true;
        step = {
            if(~gui.notNil) {
                if(isA) {
                    ~gui.highlightCurrentColumn(\chainA);
                    ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                }{
                    ~gui.highlightCurrentColumn(\chainB);
                    ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                };
            };
            isA = isA.not;
        };
        Routine({ 8.do({ step.value; 3.0.wait; }) }).play(AppClock);
        nil
    });
};

// ---- NO-RECOMPILE VISUAL FIX ----
// Hide Ops panel, expand columns, shrink meters, park HUD top-right.
// This works by walking the window's view tree (no need to access class ivars).
applyVisualFix = {
    AppClock.sched(0.25, {
        var win, root, pad, colGap, metersH, expH, expGap, countH;
        var winRect, colW, colH, leftX, rightX;

        var compositeChildren, staticTexts, textViews, userViews, listViews, buttons, levelIndicators;

        var guessPanels, isPanelColumn, headerString, leftPanelView, rightPanelView;
        var expectationTextView, countdownLabelView, countdownBarView, metersGroupView;

        // 0) grab window
        win = Window.allWindows.detect({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        if(win.isNil) {
            "[FIX] MagicDisplayGUI window not found; skip.".postln; ^nil
        };
        root = win.view;

        // 1) classify direct children
        compositeChildren = root.children.select(_.isKindOf(CompositeView));
        staticTexts       = root.children.select(_.isKindOf(StaticText));
        textViews         = root.children.select(_.isKindOf(TextView));
        userViews         = root.children.select(_.isKindOf(UserView));
        listViews         = root.children.select(_.isKindOf(ListView));
        buttons           = root.children.select(_.isKindOf(Button));

        // 2) heuristics to identify parts
        //    - left/right panels are CompositeViews that contain a ListView (their list)
        //      and a StaticText header "CURRENT" / "NEXT"
        isPanelColumn = { arg panel;
            var hasList, hasHeader;
            hasList = panel.children.any(_.isKindOf(ListView));
            hasHeader = panel.children.any({ arg v;
                (v.isKindOf(StaticText)) and: {
                    headerString = v.tryPerform(\string);
                    headerString.notNil and: {
                        var s = headerString.asString.toUpper;
                        (s.contains("CURRENT") or: { s.contains("NEXT") })
                    }
                }
            });
            hasList and: { hasHeader }
        };
        guessPanels = compositeChildren.select(isPanelColumn);
        if(guessPanels.size >= 1) {
            // pick the two widest as left/right
            guessPanels = guessPanels.sortBy({ arg v; v.bounds.left });
            leftPanelView  = guessPanels.first;
            rightPanelView = (guessPanels.size > 1).if({ guessPanels.last }, { nil });
        };

        // expectation text = the only TextView child (class file creates one)
        expectationTextView = textViews.first;

        // countdown label = StaticText under expectation (we just move it with bounds)
        countdownLabelView = staticTexts.detect({ arg st;
            var y = st.bounds.top;
            var txt = st.tryPerform(\string);
            (txt.notNil) and: { y > ((expectationTextView.notNil).if({ expectationTextView.bounds.bottom }, { 0 })) }
        });

        // countdown bar = only UserView child (class file creates one)
        countdownBarView = userViews.first;

        // meters group = CompositeView child that contains LevelIndicator(s)
        levelIndicators = root.children.select(_.isKindOf(LevelIndicator)); // not direct parent; we need group
        metersGroupView = compositeChildren.detect({ arg cv;
            cv.children.any(_.isKindOf(LevelIndicator))
        });

        // 3) compute new geometry
        pad     = 10;
        colGap  = 40;
        metersH = 86;
        expH    = 52;
        expGap  = 6;
        countH  = 20;

        winRect = root.bounds;
        // hide the Ops list/button/status (these live directly under root)
        listViews.do(_.visible_(false));
        buttons.do(_.visible_(false));
        staticTexts.do({ arg st;
            var txt = st.tryPerform(\string);
            if(txt.notNil and: { txt.asString.beginsWith("Next:") }) { st.visible_(false) };
        });

        // recompute full-width (reclaim right third)
        colW = ((winRect.width - (2 * pad) - colGap) / 2).max(220);
        colH = (winRect.height
            - (2 * pad)   // top + bottom
            - metersH
            - expH
            - expGap
            - countH
            - 12).max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        // 4) apply bounds if we found the views
        if(leftPanelView.notNil)  { leftPanelView.bounds  = Rect(leftX,  pad, colW, colH) };
        if(rightPanelView.notNil) { rightPanelView.bounds = Rect(rightX, pad, colW, colH) };

        if(expectationTextView.notNil) {
            expectationTextView.bounds = Rect(leftX, leftPanelView.bounds.bottom + 6, colW * 2 + colGap, expH)
        };
        if(countdownLabelView.notNil and: { expectationTextView.notNil }) {
            countdownLabelView.bounds = Rect(leftX, expectationTextView.bounds.bottom + expGap, 120, 20)
        };
        if(countdownBarView.notNil and: { expectationTextView.notNil }) {
            countdownBarView.bounds = Rect(leftX + 130, expectationTextView.bounds.bottom + expGap,
                (colW * 2 + colGap) - 140, 20)
        };

        // shrink meters width (e.g., 65% of columns span) and align left
        if(metersGroupView.notNil) {

            var groupLeft, groupTop, groupW, labelW, barW;
			var bars;
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = ((colW * 2 + colGap) * 0.65).clip(260, winRect.width - 2*pad);
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            // child bars inside group (two rows)
            labelW = 60;
            barW   = groupW - labelW - 10;

            // find the two LevelIndicator children and set their bounds
            // (order is deterministic in your build: A first row, B second row)
            bars = metersGroupView.children.select(_.isKindOf(LevelIndicator));
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4, barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
        };

        // park HUD top-right so it doesn't cover the columns
        if(~procHud_relocate.notNil) {
            ~procHud_relocate.(\topRight);
            AppClock.sched(0.05, { if(~procHud_update.notNil) { ~procHud_update.() }; nil });
        };

        "[FIX] visual-only layout applied (ops hidden, columns expanded, meters shrunk, HUD top-right)".postln;
        nil
    });
};

// re-apply the layout fix on window resize
attachResizeFix = {
    AppClock.sched(0.28, {
        var win;
        win = Window.allWindows.detect({ arg w;
            var nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        if(win.notNil) {
            win.onResize = { applyVisualFix.value };
        };
        nil
    });
};

// ---- Run sequence ----
closeMagicWindows.value;
makeGui.value;
populateListsOnce.value;
cycleCurrentHighlight.value;

// If you already evaluated the Top-Left HUD file earlier, it will be moved to top-right.
// If not, this fix still works without HUD.
applyVisualFix.value;
attachResizeFix.value;
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_LayoutOnly_v3.scd =====
// Test_MagicDisplayGUI_LayoutOnly_v3.scd
// v0.3.3
// MD 20250919-09:05 BST

/*
Purpose
- Visual-only formatting test for MagicDisplayGUI (no audio, no meters).
- Robustly wait for the window to be created (AppClock poll) before any layout tweaks.
- Fixes you asked for:
  1) Move HUD to top-right (so it doesn't cover columns).
  2) Reclaim right-hand empty area by hiding ops panel if present.
  3) Shrink meters horizontally.

Style
- var-first in every function/closure; lowercase method names; AppClock-only for GUI; no server.sync.
- One window whose name begins with "MagicDisplayGUI".
*/

(
var closeMagicWindows, makeGui, waitForGuiWindow, bringToFront,
    populateListsOnce, cycleCurrentHighlight, applyVisualFix, attachResizeFix;

// ---- A) Close pre-existing windows (deterministic start) ----
closeMagicWindows = {
    var run;
    run = {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do({ arg w; w.close });
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- B) Create GUI and keep meters disabled (visual-only) ----
makeGui = {
    var run;
    run = {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        // keep meters off (no audio)
        ~gui.enableMeters(false);
        ("[GUI] created; meters disabled").postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

// ---- C) Wait until the MagicDisplayGUI window exists (AppClock poll) ----
waitForGuiWindow = { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
    var startTime, poll;
    startTime = Main.elapsedTime;
    poll = {
        var win, have;
        win = Window.allWindows.detect({ arg w;
            var nm;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        have = win.notNil;
        if(have) {
            if(onReadyFunc.notNil) { onReadyFunc.value(win) };
            nil
        }{
            if((Main.elapsedTime - startTime) > timeoutSec) {
                "[WAIT] MagicDisplayGUI window not found (timeout)".warn;
                nil
            }{
                AppClock.sched(pollSec, poll)
            }
        }
    };
    AppClock.sched(0.00, { poll.value; nil });
    ^this
};

// ---- D) Bring the window to the front (belt-and-braces) ----
bringToFront = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.front;
            win.alwaysOnTop_(true);
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- E) Populate CURRENT/NEXT lists visually (no audio) ----
populateListsOnce = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB, ops;
        current  = [\chainA, \delay, \chorus, \testmelody];
        next     = [\chainB, \reverb, \testmelody];
        bypassA  = [\chorus];
        bypassB  = [];
        effC     = current;
        effN     = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only layout test. No audio. No meters.", 0);
            // Provide text for the ops list (non-interactive); may not exist on your build
            ops = ["insert delay", "switch", "bypass delay on", "bypass delay off", "switch"];
            if(~gui.respondsTo(\setOperations)) {
                ~gui.setOperations(ops);
                ~gui.setNextAction({ arg idx; ("[ops] next index " ++ idx).postln; });
            };
        };
        ("[GUI] lists populated").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- F) Flip CURRENT highlight every ~3 seconds (visual only) ----
cycleCurrentHighlight = {
    var run;
    run = {
        var isA;
        isA = true;
        Routine({
            8.do({
                if(~gui.notNil) {
                    if(isA) {
                        ~gui.highlightCurrentColumn(\chainA);
                        ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                    }{
                        ~gui.highlightCurrentColumn(\chainB);
                        ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                    };
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    AppClock.sched(0.25, { run.value; nil });
};

// ---- G) Visual fix: reclaim right space, shrink meters, move HUD top-right ----
applyVisualFix = { arg win;
    var run;
    run = {
        var root, pad, colGap, metersH, expH, expGap, countH;
        var winRect, colW, colH, leftX, rightX;
        var compositeChildren, staticTexts, textViews, userViews, listViews, buttons, levelIndicators;
        var guessPanels, isPanelColumn, headerString, leftPanelView, rightPanelView;
        var expectationTextView, countdownLabelView, countdownBarView, metersGroupView;

        // guard
        if(win.isNil) { ^nil };

        root  = win.view;
        pad   = 10;
        colGap= 40;
        metersH = 86;
        expH    = 52;
        expGap  = 6;
        countH  = 20;

        winRect = root.bounds;

        // classify children (direct)
        compositeChildren = root.children.select({ arg v; v.isKindOf(CompositeView) });
        staticTexts       = root.children.select({ arg v; v.isKindOf(StaticText) });
        textViews         = root.children.select({ arg v; v.isKindOf(TextView) });
        userViews         = root.children.select({ arg v; v.isKindOf(UserView) });
        listViews         = root.children.select({ arg v; v.isKindOf(ListView) });
        buttons           = root.children.select({ arg v; v.isKindOf(Button) });
        levelIndicators   = root.children.select({ arg v; v.isKindOf(LevelIndicator) }); // probably empty; bars live under meters group

        // locate left/right column panels via heuristics
        isPanelColumn = { arg panel;
            var hasList, hasHeader;
            hasList   = panel.children.any({ arg c; c.isKindOf(ListView) });
            hasHeader = panel.children.any({ arg c;
                var t;
                t = (c.isKindOf(StaticText)).if({ c.tryPerform(\string) }, { nil });
                t.notNil and: {
                    var s;
                    s = t.asString.toUpper;
                    s.contains("CURRENT") or: { s.contains("NEXT") }
                }
            });
            hasList and: { hasHeader }
        };
        guessPanels = compositeChildren.select(isPanelColumn).sortBy({ arg v; v.bounds.left });
        leftPanelView  = (guessPanels.size >= 1).if({ guessPanels[0] }, { nil });
        rightPanelView = (guessPanels.size >= 2).if({ guessPanels[1] }, { nil });

        expectationTextView = textViews.first;         // created in class
        countdownBarView    = userViews.first;         // created in class
        countdownLabelView  = staticTexts.detect({ arg st;
            var lbok, txt, y, expBottom;
            txt = st.tryPerform(\string);
            y   = st.bounds.top;
            expBottom = (expectationTextView.notNil).if({ expectationTextView.bounds.bottom }, { 0 });
            lbok = txt.notNil and: { y > expBottom };
            lbok
        });

        // hide ops area if present
        listViews.do({ arg lv; lv.visible_(false) });
        buttons.do({ arg b; b.visible_(false) });
        staticTexts.do({ arg st;
            var txt;
            txt = st.tryPerform(\string);
            if(txt.notNil and: { txt.asString.beginsWith("Next:") }) { st.visible_(false) };
        });

        // recompute two column geometry across full width
        colW = ((winRect.width - (2 * pad) - colGap) / 2).max(220);
        colH = (winRect.height - (2 * pad) - metersH - expH - expGap - countH - 12).max(120);
        leftX  = pad;
        rightX = pad + colW + colGap;

        if(leftPanelView.notNil)  { leftPanelView.bounds  = Rect(leftX,  pad, colW, colH) };
        if(rightPanelView.notNil) { rightPanelView.bounds = Rect(rightX, pad, colW, colH) };

        if(expectationTextView.notNil and: { leftPanelView.notNil }) {
            expectationTextView.bounds = Rect(leftX, leftPanelView.bounds.bottom + 6, colW * 2 + colGap, expH)
        };
        if(countdownLabelView.notNil and: { expectationTextView.notNil }) {
            countdownLabelView.bounds = Rect(leftX, expectationTextView.bounds.bottom + expGap, 120, 20)
        };
        if(countdownBarView.notNil and: { expectationTextView.notNil }) {
            countdownBarView.bounds = Rect(leftX + 130, expectationTextView.bounds.bottom + expGap,
                (colW * 2 + colGap) - 140, 20)
        };

        // locate meters group: CompositeView child that contains LevelIndicators
        metersGroupView = compositeChildren.detect({ arg cv;
            cv.children.any({ arg c; c.isKindOf(LevelIndicator) })
        });

        // shrink meters width to 60% of columns span and align left
        if(metersGroupView.notNil) {
            var groupLeft, groupTop, groupW, labelW, barW, bars;
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = ((colW * 2 + colGap) * 0.60).clip(240, winRect.width - 2*pad);
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            // child indicators (two rows: A/B)
            labelW = 60;
            barW   = groupW - labelW - 10;
            bars   = metersGroupView.children.select({ arg v; v.isKindOf(LevelIndicator) });
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4,  barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
        };

        // move HUD to top-right (if the helpers exist)
        if(~procHud_relocate.notNil) {
            ~procHud_relocate.(\topRight);
            AppClock.sched(0.05, { if(~procHud_update.notNil) { ~procHud_update.() }; nil });
        };

        "[FIX] visual-only layout applied (ops hidden if present, columns expanded, meters shrunk, HUD top-right)".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- H) Reapply fix on window resize ----
attachResizeFix = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.onResize = { applyVisualFix.value(win) };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- Sequence ----
closeMagicWindows.value;
makeGui.value;

waitForGuiWindow.value(
    3.0, 0.05,
    { arg win;
        bringToFront.value(win);
        populateListsOnce.value;
        cycleCurrentHighlight.value;
        applyVisualFix.value(win);
        attachResizeFix.value(win);
    }
);
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_LayoutOnly_v4.scd =====
// Test_MagicDisplayGUI_LayoutOnly_v4.scd
// v0.4.0
// MD 20250919-09:25 BST

/*
Purpose
- Visual-only formatting test for MagicDisplayGUI with a bottom-docked "Processors" panel.
- Resizes the main window to ~1340 px width (and taller), disables meters, and uses GridLayout
  to render CURRENT/NEXT processor strings at the bottom (no overlap with columns).
- Narrows meters group width to avoid wasting the right third.

Style
- var-first in every function/closure; lowercase names; AppClock-only GUI ops; no server.sync.
- One window whose name begins with "MagicDisplayGUI".
*/

(
var closeMagicWindows, makeGui, waitForWindow, bringToFront,
    populateLists, buildBottomHud, refreshBottomHud, shrinkMeters, attachResize,
    winWantedW, winWantedH, hudH;

// ---- configuration ----
winWantedW = 1340;   // your requested width
winWantedH = 900;    // a bit taller to make room for the bottom panel
hudH       = 88;     // bottom panel height (dark grey)

closeMagicWindows = {
    var run;
    run = {
        var wins, count;
        wins = Window.allWindows.select({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do({ arg w; w.close });
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

makeGui = {
    var run;
    run = {
        ~gui = ~gui ?? { MagicDisplayGUI.new };
        // Visual-only = meters off
        ~gui.enableMeters(false);
        "[GUI] created; meters disabled".postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

waitForWindow = { arg timeoutSec = 3.0, pollSec = 0.05, onReadyFunc = nil;
    var startTime, poll;
    startTime = Main.elapsedTime;
    poll = {
        var win, have;
        win = Window.allWindows.detect({ arg w;
            var nm; nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        have = win.notNil;
        if(have) {
            if(onReadyFunc.notNil) { onReadyFunc.value(win) };
            nil
        }{
            if((Main.elapsedTime - startTime) > timeoutSec) {
                "[WAIT] MagicDisplayGUI window not found (timeout)".warn; nil
            }{
                AppClock.sched(pollSec, poll)
            }
        }
    };
    AppClock.sched(0.00, { poll.value; nil });
    ^this
};

bringToFront = { arg win;
    var run;
    run = {
        var x, y;
        if(win.notNil) {
            // Set to requested size; keep top-left where it is
            x = win.bounds.left; y = win.bounds.top;
            win.bounds = Rect(x, y, winWantedW, winWantedH);
            win.front; win.alwaysOnTop_(true);
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Populate column lists with visual-only demo text
populateLists = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB;
        current  = [\chainA, \delay, \chorus, \testmelody];
        next     = [\chainB, \reverb, \testmelody];
        bypassA  = [\chorus];
        bypassB  = [];
        effC = current; effN = next;
        if(~gui.notNil) {
            ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
            ~gui.highlightCurrentColumn(\chainA);
            ~gui.showExpectation("Visual-only: bottom Processors panel (GridLayout), meters disabled.", 0);
        };
        "[GUI] lists populated".postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Build bottom-docked Processors panel using GridLayout
// Exposes ~bottomHud and ~bottomHud_update
buildBottomHud = { arg win;
    var run;
    run = {
        var root, pad, panelRect, hud, grid, title, curLabel, curText, nextLabel, nextText;
        var boundsNow;
        if(win.isNil) { ^nil };
        root = win.view;
        pad  = 10;
        boundsNow = root.bounds;

        panelRect = Rect(
            pad,
            boundsNow.height - hudH - pad,   // dock at bottom
            boundsNow.width  - (2 * pad),
            hudH
        );

        // Create once; reuse if present
        if(~bottomHud.notNil and: { ~bottomHud.isClosed.not }) {
            ~bottomHud.bounds = panelRect;
        }{
            hud = CompositeView(root, panelRect)
                .background_(Color(0.12, 0.12, 0.12, 0.92));
            // Use GridLayout for clean alignment and stretching:
            // We'll make 2 columns: [label][content], 3 rows: title (span 2 cols), current, next.
            grid = GridLayout.new;
            hud.layout = grid;

            title     = StaticText(hud).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
            curLabel  = StaticText(hud).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
            curText   = StaticText(hud).string_("‚Äì").stringColor_(Color(0.90, 0.90, 0.90));
            nextLabel = StaticText(hud).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
            nextText  = StaticText(hud).string_("‚Äì").stringColor_(Color(0.80, 0.80, 0.80));

            // Place items (row, col, rows, cols); stretch right column
            grid.add(title,     0, 0, 1, 2);  // span 2 columns
            grid.add(curLabel,  1, 0);
            grid.add(curText,   1, 1);
            grid.add(nextLabel, 2, 0);
            grid.add(nextText,  2, 1);
            grid.setColumnStretch(1, 1);  // right column grows
            grid.setRowStretch(0, 0);     // title fixed
            grid.setRowStretch(1, 1);     // rows get space if needed
            grid.setRowStretch(2, 1);
            grid.hSpacing = 10; grid.vSpacing = 4;

            // remember components for future updates
            ~bottomHud = IdentityDictionary[
                \view     -> hud,
                \curText  -> curText,
                \nextText -> nextText
            ];
            "[HUD] bottom (GridLayout) installed".postln;
        };

        // Provide updater function
        ~bottomHud_update = {
            var getTail, summarize, curArr, nxtArr, curTail, nxtTail, curStr, nxtStr;
            getTail = { arg arr; if(arr.isNil or: { arr.size < 2 }) { [] } { arr.copyRange(1, arr.size-1) } };
            summarize = { arg syms;
                var names, joined;
                names = syms.collect(_.asString);
                joined = names.join("  ->  ");
                if(joined.size > 96) { joined.copyRange(0, 93) ++ "‚Ä¶" } { joined }
            };
            if(~mpb.notNil) {
                curArr = ~mpb.effectiveCurrent;
                nxtArr = ~mpb.effectiveNext;
                curTail = getTail.value(curArr);
                nxtTail = getTail.value(nxtArr);
                curStr = summarize.value(curTail);
                nxtStr = summarize.value(nxtTail);
            }{
                // Visual demo fallback
                curStr = "delay  ->  chorus  ->  testmelody";
                nxtStr = "reverb ->  testmelody";
            };
            if(~bottomHud.notNil) {
                (~bottomHud[\curText]).string = curStr;
                (~bottomHud[\nextText]).string = nxtStr;
            };
        };

        // first fill
        AppClock.sched(0.00, { ~bottomHud_update.value; nil });
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Narrow the meters group width so it doesn‚Äôt force a wide layout
shrinkMeters = { arg win;
    var run;
    run = {
        var root, pad, metersH, winRect, compositeChildren, metersGroupView, groupLeft, groupTop, groupW, labelW, barW, bars;
        if(win.isNil) { ^nil };
        root     = win.view;
        pad      = 10;
        metersH  = 86;
        winRect  = root.bounds;
        compositeChildren = root.children.select({ arg v; v.isKindOf(CompositeView) });
        // meters group: CompositeView child that contains LevelIndicators
        metersGroupView = compositeChildren.detect({ arg cv; cv.children.any({ arg c; c.isKindOf(LevelIndicator) }) });
        if(metersGroupView.notNil) {
            groupLeft = pad;
            groupTop  = winRect.height - metersH - pad;
            groupW    = (winRect.width * 0.55).clip(240, winRect.width - 2*pad); // ~55% width
            metersGroupView.bounds = Rect(groupLeft, groupTop, groupW, metersH);

            labelW = 60;
            barW   = groupW - labelW - 10;
            bars   = metersGroupView.children.select({ arg v; v.isKindOf(LevelIndicator) });
            if(bars.size >= 1) { bars[0].bounds = Rect(labelW + 6, 4,  barW, 20) };
            if(bars.size >= 2) { bars[1].bounds = Rect(labelW + 6, 42, barW, 20) };
            "[METERS] narrowed".postln;
        }{
            "[METERS] group not found (ok on some builds)".postln;
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// Re-apply on resize (keeps HUD docked at bottom & meters narrow)
attachResize = { arg win;
    var run;
    run = {
        if(win.notNil) {
            win.onResize = {
                var x, y, w, h, root, pad, hud;
                // keep width near your requested target if you resize huge
                root = win.view; pad = 10;
                w = win.bounds.width; h = win.bounds.height;
                // reposition HUD
                if(~bottomHud.notNil) {
                    hud = ~bottomHud[\view];
                    if(hud.notNil and: { hud.isClosed.not }) {
                        hud.bounds = Rect(pad, root.bounds.height - hudH - pad, root.bounds.width - (2*pad), hudH);
                    };
                };
                // keep meters narrow
                shrinkMeters.value(win);
                // refresh strings (if ~mpb present)
                if(~bottomHud_update.notNil) {
                    AppClock.sched(0.00, { ~bottomHud_update.value; nil });
                };
            };
        };
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

// ---- run sequence ----
closeMagicWindows.value;
makeGui.value;

waitForWindow.value(
    3.0, 0.05,
    { arg win;
        bringToFront.value(win);
        populateLists.value;
        buildBottomHud.value(win);
        shrinkMeters.value(win);
        attachResize.value(win);
    }
);
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_LayoutOnly.scd =====
// Test_MagicDisplayGUI_LayoutOnly.scd
// v0.3.9
// MD 20250919-10:46 BST

/*
Purpose
- Visual-only demo for MagicDisplayGUI_GridDemo with debug guides & row rects.

Style
- var-first; AppClock-only; no server.sync.
*/

(
var closeWindows, makeGui, populate, flipCurrent, showDebug, wins, count;

closeWindows = {
    var run;
    run = {
        var nm;
        wins = Window.allWindows.select({ arg w;
            nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        count = wins.size;
        wins.do(_.close);
        ("[GUI] closed " ++ count ++ " MagicDisplayGUI windows").postln;
        nil
    };
    AppClock.sched(0.00, { run.value; nil });
};

makeGui = {
    var run;
    run = {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.enableMeters(false);
        "[GUI] created (GridDemo); meters disabled".postln;
        nil
    };
    AppClock.sched(0.05, { run.value; nil });
};

populate = {
    var run;
    run = {
        var current, next, effC, effN, bypassA, bypassB;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus]; bypassB = [];
        effC = current; effN = next;

        ~gui.showChainsDetailed(current, next, bypassA, bypassB, effC, effN);
        ~gui.highlightCurrentColumn(\chainA);
        ~gui.showExpectation("Row0 two columns; rows 1‚Äì4 full-width (addSpanning); meters fixed to 30 px.", 0);
        "[GUI] lists populated".postln;
        nil
    };
    AppClock.sched(0.12, { run.value; nil });
};

showDebug = {
    var run;
    run = {
        ~gui.debugGuides(true);
        AppClock.sched(0.05, { ~gui.postLayoutReport; nil });
        nil
    };
    AppClock.sched(0.20, { run.value; nil });
};

flipCurrent = {
    var run;
    run = {
        var isA;
        isA = false;
        Routine({
            6.do({
                if(isA) {
                    ~gui.highlightCurrentColumn(\chainA);
                    ~gui.showExpectation("CURRENT: A (visual highlight only)", 0);
                }{
                    ~gui.highlightCurrentColumn(\chainB);
                    ~gui.showExpectation("CURRENT: B (visual highlight only)", 0);
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    AppClock.sched(0.25, { run.value; nil });
};

closeWindows.value;
makeGui.value;
populate.value;
// showDebug.value; // turn on/off red debug outlines
flipCurrent.value;
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_LayoutOnlySelfContained.scd =====
// Test_MagicDisplayGUI_LayoutOnlySelfContained.scd
// v0.4.0
// MD 20250919-09:45 BST

/*
Purpose
- Visual-only GUI demonstration using GridLayout (no audio, meters disabled).
- Window ~1340x900; top row: CURRENT/NEXT columns; middle rows: expectation + countdown;
  row below: meters (narrowed, left-anchored); bottom row: dark-grey "Processors" panel.
- No user interaction required.

Style
- var-first in every closure; lowercase method names; AppClock-only GUI ops; no server.sync.
*/

(
var pad, win, root, rootLayout,
    leftPanel, leftGrid, leftHeader, leftList, leftEff,
    rightPanel, rightGrid, rightHeader, rightList, rightEff,
    expectationText, countdownHolder, countdownGrid, countdownLabel, countdownBar,
    meterGroup, meterGrid, labelA, labelB, meterA, meterB, meterSpacer,
    bottomHud, bottomGrid, bottomTitle, bottomCurLabel, bottomCurText, bottomNextLabel, bottomNextText,
    populateDemo, cycleCurrent, wins, closedCount;

AppClock.sched(0.0, {
    // Close any existing MagicDisplayGUI* windows (deterministic)
    var nm;
    wins = Window.allWindows.select({ arg w;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    closedCount = wins.size;
    wins.do(_.close);
    ("[GUI] closed " ++ closedCount ++ " MagicDisplayGUI windows").postln;

    // Build main window
    pad = 10;
    win = Window("MagicDisplayGUI ‚Äì GridDemo (Visual)", Rect(120, 80, 1340, 900))
        .front
        .alwaysOnTop_(true);
    root = win.view;

    // Root GridLayout
    rootLayout = GridLayout.new;
    root.layout = rootLayout;

    // === Row 0: two columns (CURRENT / NEXT) =================================
    leftPanel = CompositeView(root).background_(Color(0.92, 0.92, 0.92));
    leftGrid = GridLayout.new; leftPanel.layout = leftGrid;
    leftHeader = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
    leftList   = ListView(leftPanel).items_([]);
    leftEff    = StaticText(leftPanel).string_("eff: ‚Äî").align_(\center);
    leftGrid.add(leftHeader, 0, 0);
    leftGrid.add(leftList,   1, 0);
    leftGrid.add(leftEff,    2, 0);
    leftGrid.setRowStretch(0, 0);
    leftGrid.setRowStretch(1, 1);
    leftGrid.setRowStretch(2, 0);

    rightPanel = CompositeView(root).background_(Color(0.92, 0.92, 0.92));
    rightGrid = GridLayout.new; rightPanel.layout = rightGrid;
    rightHeader = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
    rightList   = ListView(rightPanel).items_([]);
    rightEff    = StaticText(rightPanel).string_("eff: ‚Äî").align_(\center);
    rightGrid.add(rightHeader, 0, 0);
    rightGrid.add(rightList,   1, 0);
    rightGrid.add(rightEff,    2, 0);
    rightGrid.setRowStretch(0, 0);
    rightGrid.setRowStretch(1, 1);
    rightGrid.setRowStretch(2, 0);

    rootLayout.add(leftPanel,  0, 0);
    rootLayout.add(rightPanel, 0, 1);
    rootLayout.setColumnStretch(0, 1);
    rootLayout.setColumnStretch(1, 1);
    rootLayout.setRowStretch(0, 6); // top row dominates height

    // === Row 1: expectation text (spans 2 columns) ===========================
    expectationText = TextView(root)
        .background_(Color(1, 1, 0.9))
        .string_("Command:");
    rootLayout.add(expectationText, 1, 0, 1, 2);
    rootLayout.setRowStretch(1, 0);

    // === Row 2: countdown (label + bar) spanning 2 columns ===================
    countdownHolder = CompositeView(root);
    countdownGrid   = GridLayout.new; countdownHolder.layout = countdownGrid;
    countdownLabel  = StaticText(countdownHolder).string_("Ready");
    countdownBar    = UserView(countdownHolder);
    countdownGrid.add(countdownLabel, 0, 0);
    countdownGrid.add(countdownBar,   0, 1);
    countdownGrid.setColumnStretch(0, 0);
    countdownGrid.setColumnStretch(1, 1);
    rootLayout.add(countdownHolder, 2, 0, 1, 2);
    rootLayout.setRowStretch(2, 0);

    // === Row 3: meters (left) + spacer (right) to keep meters narrow =========
    meterGroup = CompositeView(root).background_(Color(0.96, 0.96, 0.96));
    meterGrid  = GridLayout.new; meterGroup.layout = meterGrid;
    labelA = StaticText(meterGroup).string_("chainA");
    meterA = LevelIndicator(meterGroup);
    labelB = StaticText(meterGroup).string_("chainB");
    meterB = LevelIndicator(meterGroup);
    meterGrid.add(labelA, 0, 0);
    meterGrid.add(meterA, 0, 1);
    meterGrid.add(labelB, 1, 0);
    meterGrid.add(meterB, 1, 1);
    meterGrid.setColumnStretch(0, 0);
    meterGrid.setColumnStretch(1, 1);

    meterSpacer = CompositeView(root); // empty filler; absorbs right-space
    rootLayout.add(meterGroup,  3, 0);
    rootLayout.add(meterSpacer, 3, 1);
    // columns: 0 minimal (meters), 1 stretches (spacer)
    rootLayout.setColumnStretch(0, 0);
    rootLayout.setColumnStretch(1, 1);
    rootLayout.setRowStretch(3, 1);

    // === Row 4: bottom Processors panel (dark grey; spans 2 columns) ========
    bottomHud  = CompositeView(root).background_(Color(0.12, 0.12, 0.12, 0.92));
    bottomGrid = GridLayout.new; bottomHud.layout = bottomGrid;
    bottomTitle     = StaticText(bottomHud).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
    bottomCurLabel  = StaticText(bottomHud).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
    bottomCurText   = StaticText(bottomHud).string_("‚Äì").stringColor_(Color(0.90, 0.90, 0.90));
    bottomNextLabel = StaticText(bottomHud).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
    bottomNextText  = StaticText(bottomHud).string_("‚Äì").stringColor_(Color(0.80, 0.80, 0.80));

    bottomGrid.add(bottomTitle,     0, 0, 1, 2); // span 2 columns
    bottomGrid.add(bottomCurLabel,  1, 0);
    bottomGrid.add(bottomCurText,   1, 1);
    bottomGrid.add(bottomNextLabel, 2, 0);
    bottomGrid.add(bottomNextText,  2, 1);
    bottomGrid.setColumnStretch(0, 0);
    bottomGrid.setColumnStretch(1, 1);
    bottomGrid.hSpacing = 10; bottomGrid.vSpacing = 4;

    rootLayout.add(bottomHud, 4, 0, 1, 2);
    rootLayout.setRowStretch(4, 1);

    // Attach resize to the VIEW (not the Window). GridLayout handles sizing.
    root.onResize = { nil };

    // ---- Populate demo content ------------------------------------------------
    populateDemo = {
        var current, next, effC, effN, bypassA, bypassB, formatList, effCText, effNText;
        current = [\chainA, \delay, \chorus, \testmelody];
        next    = [\chainB, \reverb, \testmelody];
        bypassA = [\chorus]; bypassB = [];
        effC = current; effN = next;

        formatList = { arg listRef, bypassKeys, effList;
            var out, lastIdx, procs, idx;
            out = Array.new;
            lastIdx = listRef.size - 1;
            out = out.add("src : " ++ listRef[lastIdx]);
            if(listRef.size > 2) {
                out = out.add("procs:");
                procs = listRef.copyRange(1, lastIdx - 1).reverse;
                idx = 1;
                procs.do({ arg key;
                    var byp, badge, line;
                    byp = bypassKeys.includes(key);
                    badge = byp.if({ "[BYP]" }, { "[ON]" });
                    line = " [" ++ idx ++ "] " ++ key ++ " " ++ badge;
                    out = out.add(line);
                    idx = idx + 1;
                });
            }{
                out = out.add("procs: (none)");
            };
            out = out.add("sink : " ++ listRef[0]);
            out
        };

        leftList.items_(formatList.value(current, bypassA, effC));
        rightList.items_(formatList.value(next,    bypassB, effN));

        effCText = "eff: " ++ effC.join(" -> ");
        effNText = "eff: " ++ effN.join(" -> ");
        leftEff.string_(effCText);
        rightEff.string_(effNText);

        // headers + highlight
        leftHeader.string_("CHAIN A ACTIVE");
        rightHeader.string_("CHAIN B NEXT");
        leftPanel.background_(Color(0.85, 1.0, 0.85));
        rightPanel.background_(Color(0.92, 0.92, 0.92));

        // bottom HUD strings
        bottomCurText.string_((" " ++ effC.copyRange(1, effC.size - 1).join(" -> ")).trim);
        bottomNextText.string_((" " ++ effN.copyRange(1, effN.size - 1).join(" -> ")).trim);

        expectationText.string_("Visual-only: GridLayout; bottom Processors panel; meters narrowed (left).");
        countdownLabel.string_("Ready");
        nil
    };
    populateDemo.value;

    // ---- Flip CURRENT highlight every ~3s (visual only) ----------------------
    cycleCurrent = {
        var isA;
        isA = false;
        Routine({
            8.do({
                if(isA) {
                    leftPanel.background_(Color(0.85, 1.0, 0.85));
                    rightPanel.background_(Color(0.92, 0.92, 0.92));
                    leftHeader.string_("CHAIN A ACTIVE");
                    rightHeader.string_("CHAIN B NEXT");
                    expectationText.string_("CURRENT: A (visual highlight only)");
                }{
                    leftPanel.background_(Color(0.92, 0.92, 0.92));
                    rightPanel.background_(Color(0.85, 1.0, 0.85));
                    leftHeader.string_("CHAIN A NEXT");
                    rightHeader.string_("CHAIN B ACTIVE");
                    expectationText.string_("CURRENT: B (visual highlight only)");
                };
                isA = isA.not;
                3.0.wait;
            });
        }).play(AppClock);
        nil
    };
    cycleCurrent.value;

    nil
});
)

===== Magicpedalboard/obsolete/Test_MagicDisplayGUI_Scenarios.scd =====
/* Test_MagicDisplayGUI_Scenarios.scd v0.5
   Very explicit scenarios: log each step, update "Command:", then force GUI redraw.
*/

(
~log = { |msg| ("[SC] " ++ msg).postln };

~refreshGuiFromMpb = {
    var curr, nxt, bA, bB, eA, eB;
    if(~gui.isNil or: { ~mpb.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    curr = ~mpb.currentChain;  nxt = ~mpb.nextChain;
    bA = ~mpb.bypassKeysCurrent; bB = ~mpb.bypassKeysNext;
    eA = ~mpb.effectiveCurrent;  eB = ~mpb.effectiveNext;
    ~gui.showChainsDetailed(curr, nxt, bA, bB, eA, eB);
};

~scenario1v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.8;
    steps = [
        { ~log.("init");               ~gui.showExpectation("Command: init", 0);               ~refreshGuiFromMpb.() },
        { ~log.("add flanger");        ~gui.showExpectation("Command: add flanger", 0);        ~mpb.add(\flanger);       ~refreshGuiFromMpb.() },
        { ~log.("bypass flanger true");~gui.showExpectation("Command: bypass flanger true", 0);~mpb.bypass(\flanger, true);~refreshGuiFromMpb.() },
        { ~log.("add delay");          ~gui.showExpectation("Command: add delay", 0);          ~mpb.add(\delay);         ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");         ~gui.showExpectation("Command: clear NEXT", 0);         ~mpb.clearChain;          ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario2v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.25;
    steps = [
        { ~log.("init");        ~gui.showExpectation("Command: init", 0);        ~refreshGuiFromMpb.() },
        { ~log.("add chorus");  ~gui.showExpectation("Command: add chorus", 0);  ~mpb.add(\chorus);     ~refreshGuiFromMpb.() },
        { ~log.("add reverb");  ~gui.showExpectation("Command: add reverb", 0);  ~mpb.add(\reverb);     ~refreshGuiFromMpb.() },
        { ~log.("add tremolo"); ~gui.showExpectation("Command: add tremolo", 0); ~mpb.add(\tremolo);    ~refreshGuiFromMpb.() },
        { ~log.("removeAt 2");  ~gui.showExpectation("Command: removeAt 2", 0);  ~mpb.removeAt(2);      ~refreshGuiFromMpb.() },
        { ~log.("add phaser");  ~gui.showExpectation("Command: add phaser", 0);  ~mpb.add(\phaser);     ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");  ~gui.showExpectation("Command: clear NEXT", 0);  ~mpb.clearChain;       ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};

~scenario3v5 = {
    var routine, waitS, steps;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGuiV4.() first.".warn; ^nil };
    waitS = 0.6;
    steps = [
        { ~log.("init");                 ~gui.showExpectation("Command: init", 0);                 ~refreshGuiFromMpb.() },
        { ~log.("add bitcrusher");       ~gui.showExpectation("Command: add bitcrusher", 0);       ~mpb.add(\bitcrusher);  ~refreshGuiFromMpb.() },
        { ~log.("bypass bitcrusher false");~gui.showExpectation("Command: bypass bitcrusher false", 0); ~mpb.bypass(\bitcrusher, false); ~refreshGuiFromMpb.() },
        { ~log.("removeAt 1");          ~gui.showExpectation("Command: removeAt 1", 0);           ~mpb.removeAt(1);       ~refreshGuiFromMpb.() },
        { ~log.("clear NEXT");           ~gui.showExpectation("Command: clear NEXT", 0);           ~mpb.clearChain;        ~refreshGuiFromMpb.() }
    ];
    routine = Routine {
        var i = 0;
        while({ i < steps.size }, { steps[i].value; i = i + 1; waitS.wait; });
    };
    ~mdgTask.notNil.if { ~mdgTask.stop };
    ~mdgTask = Task(routine, SystemClock).play;
};
)

===== Magicpedalboard/obsolete/Test_MagicPedalboardNew_v0_13_QA_PauseResume_GUI.scd =====
// Test_MagicPedalboardNew_v0_13_QA_PauseResume_GUI.scd // WORKING right at 13:41
// MD 20250912-1325

(
// Run only after the server is booted.
s.waitForBoot({

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // var-first: declare everything used in this block up front
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var preflightCleanup;
    var m, setCurrent, setNext, forceSilentBaseline;
    var qa;
    var win, infoText, noteField, btnReport, btnSubmit, btnResume;
    var say, countdown, show, snapshot, setActiveStep, pushStep, absorbPending, waitIfPaused;
    var runRoutine;
    var before, after;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 0) Preflight: clear old JITLib state; keep the default group
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    preflightCleanup = {
        "[QA] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        // Stop & clear any lingering Ndefs from older sessions
        Ndef.all.keysValuesDo { |key, proxy|
            if(proxy.isPlaying) { ("[CLEAN] stop " ++ key).postln; proxy.stop };
            proxy.clear;
        };

        // Clear any ProxySpaces we can see (class may not expose .all on some builds)
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) { ("[CLEAN] ProxySpace on " ++ srv).postln; ps.clear };
            };
        };

        // If the *current* environment is a ProxySpace, pop it
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };

        // Safe server-tree reset (no s.freeAll): keep Group 1 so Ndef/JITLib can attach
        s.initTree;
        s.defaultGroup.freeAll;

        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) Minimal test sources / processors
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var x;
        x = \in.ar(2);
        x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    Ndef(\lofi, { |bits = 4, rate = 4000|
        var x;
        x = \in.ar(2);
        Decimator.ar(x, rate, bits)
    });

    Ndef(\atten, { |gain = 0.25|
        var x;
        x = \in.ar(2);
        x * gain
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 2) Pedalboard + hard silent baseline
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    m = MagicPedalboardNew.new;
    m.reset;

    setCurrent = { |key|
        if(m.respondsTo(\setSourceCurrent)) { m.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(m.respondsTo(\setSource)) { m.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    forceSilentBaseline = {
        "[QA] Force silent baseline‚Ä¶".postln;
        m.reset;
        setCurrent.(\ts0);
        setNext.(\ts0);

        m.clearChain;            // clear NEXT
        m.switchChain;
        m.clearChain;            // clear previous CURRENT (now NEXT)
        m.switchChain;

        Ndef(\chainA).play(numChannels: 2);
        Ndef(\chainB).stop;

        "[QA] Baseline set. Expect: silence now.".postln;
    };
    forceSilentBaseline.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 3) QA state (pause controller, steps, issues)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    qa = (
        steps: Array.new,
        issues: Array.new,
        currentStep: nil,
        pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
        pauseRequested: false,
        pauseCondition: Condition.new
    );

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 4) GUI (AppClock). Window shows PAUSED state & toggles buttons.
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    win = Window("MPBNew QA ‚Äì press X to pause; Enter to submit; Esc to resume",
                 Rect(100, 100, 740, 230)).front.alwaysOnTop_(true);
    infoText = StaticText(win, Rect(10, 10, 720, 44)).string_("Step: (pending)");
    noteField = TextField(win, Rect(10, 60, 720, 24)).string_("Type your note here‚Ä¶");

    btnReport = Button(win, Rect(10, 100, 230, 30))
        .states_([["Report Issue (Pause)", Color.white, Color.red]])
        .action_({
            qa[\pauseRequested] = true; "[QA] pause requested".postln;
            AppClock.sched(0, {
                infoText.string = "PAUSED: type a note, then Submit or Resume.";
                win.name = "MPBNew QA ‚Äì PAUSED";
                btnReport.enabled = false; btnSubmit.enabled = true; btnResume.enabled = true; nil
            });
        });

    btnSubmit = Button(win, Rect(250, 100, 230, 30))
        .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
        .action_({
            var noteTxt, stepIdLocal, reasonTxt;
            noteTxt = noteField.string;
            reasonTxt = "user report (paused)";
            stepIdLocal = qa[\currentStep].notNil.if({ qa[\currentStep][\id] }, { "unknown-" ++ Main.elapsedTime.round(0.01) });
            qa[\pendingIssues][stepIdLocal] = (reason: reasonTxt, note: noteTxt);
            ("[QA] issue submitted for " ++ stepIdLocal).postln;
            if(noteTxt.notNil and: { noteTxt != "" }) { ("[QA] note: " ++ noteTxt).postln };
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Captured issue for " ++ stepIdLocal ++ ". Resuming‚Ä¶";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    btnResume = Button(win, Rect(490, 100, 230, 30))
        .states_([["Resume (No Issue)", Color.white, Color.gray]])
        .action_({
            "[QA] resume (no issue)".postln;
            qa[\pauseRequested] = false; qa[\pauseCondition].signal;
            AppClock.sched(0, {
                infoText.string = "Resuming without logging an issue‚Ä¶";
                win.name = "MPBNew QA";
                btnReport.enabled = true; btnSubmit.enabled = false; btnResume.enabled = false; nil
            });
        })
        .enabled_(false);

    // keyboard shortcuts
    win.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
        if(char == $x or: { char == $X }) { btnReport.action.value };
        if(keycode == 36 or: { keycode == 52 }) { btnSubmit.action.value }; // Enter / keypad Enter
        if(keycode == 53) { btnResume.action.value };                       // Esc
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 5) Helpers (SystemClock-safe)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    say = { |txt| txt.asString.postln };

    countdown = { |n = 3|
        var i;
        i = n;
        while { i > 0 } {
            waitIfPaused.();
            (i.asString ++ "...").postln;
            1.wait;  // SystemClock wait
            i = i - 1;
        };
        waitIfPaused.();
        "Now.".postln;
    };

    waitIfPaused = {
        var t0;
        if(qa[\pauseRequested]) { "[QA] waiting (paused)".postln };
        t0 = Main.elapsedTime;
        while { qa[\pauseRequested] } {
            qa[\pauseCondition].wait;   // signalled by AppClock (GUI buttons)
            if(qa[\pauseRequested] and: { Main.elapsedTime - t0 > 30 }) {
                "[QA] timeout ‚Üí auto-resume".warn;
                qa[\pauseRequested] = false;
                qa[\pauseCondition].signal;
            };
        };
        if(qa[\pauseRequested].not) { "[QA] resumed".postln };
    };

    show = {
        "‚Äî Chains ‚Äî".postln;
        m.printChains;
        "".postln;
    };

    snapshot = {
        (
            time: Main.elapsedTime,
            current: m.currentChain.copy,
            next: m.nextChain.copy,
            effCurrent: m.effectiveCurrent,
            effNext: m.effectiveNext,
            bypassCurrent: m.bypassKeysCurrent,
            bypassNext: m.bypassKeysNext
        )
    };

    setActiveStep = { |id, title, expected|
        qa[\currentStep] = nil;  // will set when pushing the step
        AppClock.sched(0, {
            infoText.string = "Step: " ++ id ++ " ‚Äî " ++ title ++ "\nExpect: " ++ expected;
            win.name = "MPBNew QA";
            nil
        });
    };

    absorbPending = { |id, entry|
        var p;
        p = qa[\pendingIssues][id];
        if(p.notNil) {
            entry[\userFlagged] = true;
            entry[\userReason] = p[\reason];
            entry[\userNote] = p[\note];
            if(qa[\issues].includes(id).not) { qa[\issues] = qa[\issues].add(id) };
            qa[\pendingIssues].removeAt(id);
        };
    };

    pushStep = { |id, title, expected, beforeSnap, afterSnap|
        var e;
        e = (id: id, title: title, expected: expected, before: beforeSnap,
             after: afterSnap, userFlagged: false, userReason: nil, userNote: nil);
        qa[\steps] = qa[\steps].add(e);
        qa[\currentStep] = e;
        absorbPending.(id, e);
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 6) Narrative Routine (RUN ON SystemClock)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    runRoutine = Routine({

        // A) Start silent
        setActiveStep.("A1", "Start silent \\ts0 on CURRENT", "Silence");
        say.("Starting with a silent CURRENT chain. Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\ts0);
        m.playCurrent;
        show.();
        say.("You should hear nothing.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("A1", "silent on CURRENT", "You should hear nothing.", before, after);

        // B) CURRENT ‚Üí Dust
        setActiveStep.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
        say.("Change CURRENT source to Dust(2000). Starting in");
        countdown.(3);
        before = snapshot.();
        setCurrent.(\tsDust);
        show.();
        say.("You should hear irregular noise bursts in stereo.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", before, after);

        // C) NEXT: Saw + Tremolo ‚Üí switch
        setActiveStep.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
        say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
        say.("Setting NEXT source to Saw in");
        countdown.(2);
        before = snapshot.();
        setNext.(\tsSaw);
        m.add(\tremolo);
        show.();
        say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", before, after);

        // D1) Bypass tremolo
        setActiveStep.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
        say.("Bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, true); show.();
        say.("You should hear plain Saw (no tremolo).");
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D1", "bypass tremolo", "Plain Saw", before, after);

        // D2) Un-bypass tremolo
        setActiveStep.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
        say.("Un-bypass CURRENT tremolo. Starting in");
        countdown.(2);
        before = snapshot.();
        m.bypassCurrent(\tremolo, false); show.();
        say.("Tremolo should be back.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", before, after);

        // E) Prepare NEXT: atten + lofi + swap ‚Üí switch
        setActiveStep.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
        say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
        say.("Adding \\atten at index 1 in");
        countdown.(2);
        before = snapshot.();
        m.addAt(\atten, 1); show.();

        say.("Adding \\lofi at index 2 in");
        countdown.(2);
        m.addAt(\lofi, 2); show.();

        say.("Swap NEXT indices 1 and 2 in");
        countdown.(2);
        m.swap(1, 2); show.();

        say.("Switch to NEXT in");
        countdown.(3);
        m.switchChain; show.();
        say.("You should hear Saw with lower level and obvious bitcrush/decimation.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", before, after);

        // F) On NEXT: remove @1, then clear
        setActiveStep.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
        say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
        say.("Removing at index 1 on NEXT in");
        countdown.(2);
        before = snapshot.();
        m.removeAt(1); show.();
        say.("Clear NEXT back to [sink, source] in");
        countdown.(2);
        m.clearChain; show.();
        waitIfPaused.(); 1.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("F1", "remove + clear NEXT", "[sink, source]", before, after);

        // G) NEXT ‚Üí ts0, then switch (silent again)
        setActiveStep.("G1", "Set NEXT source to ts0, then switch", "Silence");
        say.("Set NEXT source to \\ts0 and then switch.");
        say.("Starting in");
        countdown.(3);
        before = snapshot.();
        setNext.(\ts0);
        m.switchChain; show.();
        say.("You should now hear silence.");
        waitIfPaused.(); 2.wait; waitIfPaused.();
        after = snapshot.();
        pushStep.("G1", "switch to ts0", "Silence", before, after);

        // Done
        say.("Done. Stopping."); m.stopCurrent;
    }).play(SystemClock);   // Routine on SystemClock; GUI on AppClock
});
)

===== Magicpedalboard/obsolete/Test_MagicPedalboardNew_v0_14_ParamSweep_Levels.scd =====
// Test_MagicPedalboardNew_v0_14_ParamSweep_Levels.scd
// Crossfade switch + parameter sweeps + GUI meters (no server.sync; safe resets)
// MD 20250912-1451

(
s.waitForBoot({
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 0) Preflight (safe): clear JITLib state, keep default group
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var preflightCleanup;
    var m, gui;
	var meterWin, meterA, meterB, meterSynthA, meterSynthB, busA, busB;

    preflightCleanup = {
        "[-] QA Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;
        Ndef.all.keysValuesDo { arg keySym, proxyRef;
            if(proxyRef.isPlaying) { ("[CLEAN] stop " ++ keySym).postln; proxyRef.stop };
            proxyRef.clear;
        };
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { arg serverRef, proxySpace;
                if(proxySpace.notNil) { ("[CLEAN] ProxySpace on " ++ serverRef).postln; proxySpace.clear };
            };
        };
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };
        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) Minimal sources / processors
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Ndef(\ts0, { Silent.ar(2) });
    Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
    Ndef(\tsSine, { SinOsc.ar(333, 0, 0.22) ! 2 });
    Ndef(\tsDust, { Dust.ar(2000) ! 2 });

    // processors
    Ndef(\tremolo, { arg rate = 4, depth = 0.8;
        var x;
        x = \in.ar(2);
        x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    Ndef(\lofi, { arg bits = 6, rate = 6000;
        var x;
        x = \in.ar(2);
        Decimator.ar(x, rate, bits)
    });

    Ndef(\atten, { arg gain = 0.25;
        var x;
        x = \in.ar(2);
        x * gain
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 2) Pedalboard + GUI
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // start from silence on CURRENT
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain; // NEXT => [sink, source]
    m.switchChain(0.1); // ensure CURRENT is also [sink, ts0]
    m.clearChain;
    m.switchChain(0.1);

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 3) Level meters (SendReply -> OSCdef -> LevelIndicator)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Two synthdefs to avoid dynamic path strings in UGen
    SynthDef(\busMeterA, { arg inBus, rate = 15;
        var sig, amp;
        sig = In.ar(inBus, 2);
        amp = Amplitude.ar(sig).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
    }).add;

    SynthDef(\busMeterB, { arg inBus, rate = 15;
        var sig, amp;
        sig = In.ar(inBus, 2);
        amp = Amplitude.ar(sig).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
    }).add;

    // Meter GUI

    meterWin = Window("Levels ‚Äì chainA / chainB", Rect(100, 500, 460, 120)).front.alwaysOnTop_(true);
    meterA = LevelIndicator(meterWin, Rect(10, 10, 440, 24));
    StaticText(meterWin, Rect(10, 36, 440, 16)).string_("chainA");
    meterB = LevelIndicator(meterWin, Rect(10, 60, 440, 24));
    StaticText(meterWin, Rect(10, 86, 440, 16)).string_("chainB");

    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;

    Server.default.bind({
        meterSynthA = Synth(\busMeterA, [\inBus, busA.index, \rate, 20]);
        meterSynthB = Synth(\busMeterB, [\inBus, busB.index, \rate, 20]);
    });

    OSCdef(\ampA, { arg msg;
        var leftAmp, rightAmp, level;
        leftAmp = msg[3];
        rightAmp = msg[4];
        level = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
        AppClock.sched(0, { meterA.value = level; nil });
    }, '/ampA');

    OSCdef(\ampB, { arg msg;
        var leftAmp, rightAmp, level;
        leftAmp = msg[3];
        rightAmp = msg[4];
        level = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
        AppClock.sched(0, { meterB.value = level; nil });
    }, '/ampB');

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 4) Narrative: crossfades + parameter sweeps
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Routine({
        var sweepSteps, stepIndex, sweepDepths, depthIndex, show;
        var waitShort, waitMed, waitLong;

        show = { m.printChains };
        waitShort = { 1.0.wait };
        waitMed   = { 2.0.wait };
        waitLong  = { 3.0.wait };

        // A) make CURRENT audible with Saw
        m.setSourceCurrent(\tsSaw);
        m.playCurrent;
        show.();
        waitMed.();

        // B) prepare NEXT: Saw + Tremolo (deep), then crossfade switch
        m.setSource(\tsSaw);
        m.add(\tremolo);
        m.bypass(\tremolo, false);
        m.switchChain(0.10); // ~100 ms crossfade
        show.();
        waitMed.();

        // C) Sweep tremolo rate 2 -> 12 Hz and back while listening
        sweepSteps = Array.series(11, 2, 1); // 2..12
        stepIndex = 0;
        "‚Äî Sweeping tremolo rate ‚Äî".postln;
        sweepSteps.do { arg rateValue;
            Ndef(\tremolo).set(\rate, rateValue);
            0.25.wait;
        };
        sweepSteps.reverse.do { arg rateValue;
            Ndef(\tremolo).set(\rate, rateValue);
            0.25.wait;
        };

        // D) Toggle bypass on CURRENT tremolo
        m.bypassCurrent(\tremolo, true);  waitShort.(); m.bypassCurrent(\tremolo, false); waitShort.();

        // E) Prepare NEXT: add atten + lofi near sink; swap; then crossfade switch
        m.addAt(\atten, 1);
        m.addAt(\lofi, 2);
        m.swap(1, 2); // \lofi before \atten
        m.switchChain(0.12); // slightly longer crossfade
        show.();
        waitMed.();

        // F) Sweep lofi params
        "‚Äî Sweeping lofi ‚Äî".postln;
        // bits: 4..10
        (4..10).do { arg bitsValue;
            Ndef(\lofi).set(\bits, bitsValue);
            0.2.wait;
        };
        // rate: 4000..12000
        (4000, 500 .. 12000).do { arg srValue;
            Ndef(\lofi).set(\rate, srValue);
            0.2.wait;
        };

        // G) Return to silence via NEXT -> \ts0 and crossfade
        m.setSource(\ts0);
        m.clearChain; // NEXT to [sink, source]
        m.switchChain(0.10);
        show.();
        waitLong.();

        // done
        "Done. Stopping current.".postln;
        m.stopCurrent;

        // cleanup meters
        Server.default.bind({
            meterSynthA.free;
            meterSynthB.free;
        });
        OSCdef(\ampA).free;
        OSCdef(\ampB).free;

    }).play(SystemClock);
});
)

===== Magicpedalboard/obsolete/Test_MagicPedalboardNew_v0_15_1_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_1_GUI_Operations.scd
// MD 20250912-1517

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets

(

s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 0) Preflight (safe: keep default group)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var isPlayingNow;
            isPlayingNow = proxyRef.isPlaying;
            if(isPlayingNow) { ("[CLEAN] stop " ++ keySym).postln; proxyRef.stop };
            proxyRef.clear;
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { ("[CLEAN] ProxySpace on " ++ serverRef).postln; proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) Sources / processors
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 2) Pedalboard + GUI
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 3) Define operations (labels + actions)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind operations + "Next" button
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== Magicpedalboard/obsolete/Test_MagicPedalboardNew_v0_15_2_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_2_GUI_Operations.scd
// MD 20250912-1523

(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var isPlayingNow;
            isPlayingNow = proxyRef.isPlaying;
            if(isPlayingNow) { ("[CLEAN] stop " ++ keySym).postln; proxyRef.stop };
            proxyRef.clear;
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { ("[CLEAN] ProxySpace on " ++ serverRef).postln; proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            "[CLEAN] Pop current ProxySpace env".postln;
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (safe: MagicDisplayGUI queues updates until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== Magicpedalboard/obsolete/Test_MagicPedalboardRunner.scd =====
// Test_MagicPedalboardRunner.scd
// v0.2.2
// MD 20250919

/*
Purpose:
- Instantiate MagicPedalboardTestRunner and run full bring-up and acceptance test.
- Ensures ~gui and ~mpb are created if nil.
*/

(
// Ensure GUI and pedalboard exist
~gui = ~gui ?? { MagicDisplayGUI.new };
~mpb = ~mpb ?? { MagicPedalboardNew.new(~gui) };

// Instantiate and run the test
~runner = MagicPedalboardTestRunner.new(~mpb, ~gui);
~runner.bringUp;
~runner.audioReset;
~runner.syncGui;
~runner.runAcceptanceTest;
~runner.verifyAudioState;
~runner.help;
)

===== Magicpedalboard/obsolete/testAfterFix.scd =====
// testAfterFix.scd
// v0.1
// MD 20250916

// PRE-RUN REQUIRED:
// 1. Recompile class library after editing MagicPedalboardNew.sc
// 2. Run MagicPedalboardNew.scd (if you have a setup/init script)
// 3. Run MagicDisplayGUI.scd to launch GUI
// 4. Run adapter_commandtree_to_magicpedalboard.scd v0.3

(
// Test sequence: add ‚Üí switch ‚Üí bypass ‚Üí switch
~adapter.applyQueue([
    ["commands/add", "delay"],
    ["commands/switch", "chainB"],
    ["commands/bypass", "delay", true],
    ["commands/bypass", "delay", false],
    ["commands/switch", "chainA"]
]);

// Confirm:
// - Audio is audible at each step
// - GUI columns match chain state
// - chainB is stopped unless switching
)

===== Magicpedalboard/obsolete/TestMagicDisplayGUI.scd =====
// testMagicDisplayGUI.scd newer

(
// GUI-only harness with meters OFF to avoid server/SynthDef errors.

~bootGui = {
    var guiObj, board;

    // Create GUI (window creation is scheduled on AppClock in initGui)
    guiObj = MagicDisplayGUI.new;

    // Disable meters *immediately* so the scheduled init won't try to attach to the server
    guiObj.enableMeters(false);

    // Create pedalboard and attach display
    board = MagicPedalboardNew(guiObj);

    ~gui = guiObj;
    ~mpb = board;

    // After the window has had time to build, draw the lists
    AppClock.sched(0.2, {
        ~mpb.printChains;   // drives showChainsDetailed ‚Üí populates CURRENT/NEXT columns
        nil
    });

    "GUI booted (meters disabled). The window will appear and lists will render shortly.".postln;
};

~stopScenarios = {
    var t;
    t = ~mdgTask;
    if(t.notNil) { t.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// Scenario 1: slow, clear updates
~scenario1 = {
    var routine, steps, waitSeconds;

    if(~mpb.isNil) { "Run ~bootGui.() first.".warn; ^nil };

    waitSeconds = 0.8;

    steps = [
        { ~mpb.printChains },
        { ~mpb.add(\flanger); ~mpb.printChains },
        { ~mpb.bypass(\flanger, true); ~mpb.printChains },
        { ~mpb.add(\delay); ~mpb.printChains },
        { ~mpb.clearChain; ~mpb.printChains }
    ];

    routine = Routine {
        var i, n; i = 0; n = steps.size;
        while({ i < n }, { steps[i].value; i = i + 1; waitSeconds.wait; });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, AppClock).play;
    ~mdgTask
};

// Scenario 2: faster stress updates
~scenario2 = {
    var routine, steps, waitSeconds;

    if(~mpb.isNil) { "Run ~bootGui.() first.".warn; ^nil };

    waitSeconds = 0.25;

    steps = [
        { ~mpb.printChains },
        { ~mpb.add(\chorus); ~mpb.printChains },
        { ~mpb.add(\reverb); ~mpb.printChains },
        { ~mpb.add(\tremolo); ~mpb.printChains },
        { ~mpb.removeAt(2); ~mpb.printChains },
        { ~mpb.add(\phaser); ~mpb.printChains },
        { ~mpb.clearChain; ~mpb.printChains }
    ];

    routine = Routine {
        var i, n; i = 0; n = steps.size;
        while({ i < n }, { steps[i].value; i = i + 1; waitSeconds.wait; });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, AppClock).play;
    ~mdgTask
};
)

===== Magicpedalboard/obsolete/testScenariosGUI.scd =====
// testScenariosGUI.scd

(
// Make sure ~drawOnce and ~checkPlumbing are already evaluated from above.

~stopScenarios = {
    var running;
    running = ~mdgTask;
    if(running.notNil) { running.stop; ~mdgTask = nil; };
    "Stopped scenario task (if any).".postln;
};

// helper to label the command box (uses your GUI‚Äôs expectation area)
~showCmd = { |textString|
    if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
        ~gui.showExpectation(textString, 0);  // no countdown
    };
};

// Scenario 1: clear & readable cadence
~scenario1 = {
    var routine, steps, waitSeconds;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGui.() first.".warn; ^nil };

    waitSeconds = 0.8;

    steps = [
        { ~showCmd.("Init"); ~drawOnce.() },

        { ~showCmd.("add flanger");
          ~mpb.add(\flanger);
          ~drawOnce.() },

        { ~showCmd.("bypass flanger ‚Üí true");
          ~mpb.bypass(\flanger, true);
          ~drawOnce.() },

        { ~showCmd.("add delay");
          ~mpb.add(\delay);
          ~drawOnce.() },

        { ~showCmd.("clear NEXT");
          ~mpb.clearChain;
          ~drawOnce.() }
    ];

    routine = Routine {
        var indexCounter, totalCount;
        indexCounter = 0;
        totalCount = steps.size;
        while({ indexCounter < totalCount }, {
            steps[indexCounter].value;
            indexCounter = indexCounter + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, AppClock).play;
    ~mdgTask
};

// Scenario 2: faster stress
~scenario2 = {
    var routine, steps, waitSeconds;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGui.() first.".warn; ^nil };

    waitSeconds = 0.25;

    steps = [
        { ~showCmd.("Init"); ~drawOnce.() },
        { ~showCmd.("add chorus");  ~mpb.add(\chorus);  ~drawOnce.() },
        { ~showCmd.("add reverb");  ~mpb.add(\reverb);  ~drawOnce.() },
        { ~showCmd.("add tremolo"); ~mpb.add(\tremolo); ~drawOnce.() },
        { ~showCmd.("removeAt 2");  ~mpb.removeAt(2);   ~drawOnce.() },
        { ~showCmd.("add phaser");  ~mpb.add(\phaser);  ~drawOnce.() },
        { ~showCmd.("clear NEXT");  ~mpb.clearChain;    ~drawOnce.() }
    ];

    routine = Routine {
        var indexCounter, totalCount;
        indexCounter = 0;
        totalCount = steps.size;
        while({ indexCounter < totalCount }, {
            steps[indexCounter].value;
            indexCounter = indexCounter + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, AppClock).play;
    ~mdgTask
};

// Scenario 3: edge-ish (no server; structural only)
~scenario3 = {
    var routine, steps, waitSeconds;
    if(~mpb.isNil or: { ~gui.isNil }) { "Run ~bootGui.() first.".warn; ^nil };

    waitSeconds = 0.6;

    steps = [
        { ~showCmd.("Init"); ~drawOnce.() },

        // add a couple, bypass one, then clear
        { ~showCmd.("add bitcrusher"); ~mpb.add(\bitcrusher); ~drawOnce.() },
        { ~showCmd.("bypass bitcrusher ‚Üí false"); ~mpb.bypass(\bitcrusher, false); ~drawOnce.() },
        { ~showCmd.("removeAt 1 (if exists)"); ~mpb.removeAt(1); ~drawOnce.() },

        // reset the NEXT chain to a minimal state via clear
        { ~showCmd.("clear NEXT"); ~mpb.clearChain; ~drawOnce.() }
    ];

    routine = Routine {
        var indexCounter, totalCount;
        indexCounter = 0;
        totalCount = steps.size;
        while({ indexCounter < totalCount }, {
            steps[indexCounter].value;
            indexCounter = indexCounter + 1;
            waitSeconds.wait;
        });
    };

    ~stopScenarios.();
    ~mdgTask = Task(routine, AppClock).play;
    ~mdgTask
};
)

===== Magicpedalboard/obsolete/tool_export_commandtree_with_payloads.scd =====
// tool_export_commandtree_with_payloads.scd
// v0.1
// MD 20250916-0956

(
~ct_nodeToDictWithPayload = { arg nodeRef;
    var childDicts, outDict;
    childDicts = Array.new;
    nodeRef.children.do({ arg childNode;
        childDicts = childDicts.add(~ct_nodeToDictWithPayload.(childNode));
    });
    outDict = (
        id: nodeRef.id,
        name: nodeRef.name,
        fret: nodeRef.fret,
        payload: nodeRef.payload,   // <‚Äî keep payload
        children: childDicts
    );
    outDict
};

~ct_writeJsonWithPayloads = {
    arg treeRef,
        outPath = "/Users/martindupras/CommandTreeSavefiles/myTree.json",
        writeVersioned = true,
        saveFolder = "/Users/martindupras/CommandTreeSavefiles",
        savePrefix = "myTree";

    var topDict, jsonString;

    // Top-level object: include root payload and nodeLimit if available
    topDict = (
        name: treeRef.root.name,
        id: treeRef.root.id,
        nodeLimit: treeRef.nodeLimit ? 200,
        payload: treeRef.root.payload,
        children: treeRef.root.children.collect({ arg child; ~ct_nodeToDictWithPayload.(child) })
    );

    jsonString = JSONlib.convertToJSON(topDict);

    if(writeVersioned) {
        var saver;
        saver = CircularFileSave.new(savePrefix, saveFolder, 10);
        saver.saveVersion(jsonString);  // versioned copy with payloads preserved
    };

    File.use(outPath.standardizePath, "w", { arg f; f.write(jsonString) });
    ("[CT] Wrote JSON with payloads -> " ++ outPath).postln;
};
)

===== Magicpedalboard/obsolete/tool_xml_to_json_commandtree.scd =====
// tool_xml_to_json_commandtree.scd
// v0.1
// MD 20250916-0850

(
~ct_convertXmlToJson = { arg inPath = "~/myTree.xml", outPath = "~/CommandTreeSavefiles/myTree.json";
    var xmlText, lines, stack, rootDict, currentDict, parseOpen, parseClose, parseAttrs, toJSON;

    inPath = inPath.standardizePath;
    outPath = outPath.standardizePath;

    xmlText = File.readAllString(inPath);
    if(xmlText.isNil or: { xmlText.isEmpty }) { "XML empty or unreadable.".warn; ^false };

    // Helpers
    parseAttrs = { arg tagLine;
        var dict, pairs;
        dict = IdentityDictionary.new;
        // crude attribute parse: key="value"
        pairs = tagLine.findAllRegexp("\"([^\"]*)\"");
        // We walk the string: extract id, name, fret, payload if present
        // Better: regex for key="value" tuples
        tagLine.findAllRegexp("(\\w+)\\s*=\\s*\"([^\"]*)\"").do({ arg m;
            var key = m[1].asString.asSymbol;
            var val = m[2].asString;
            dict[key] = val;
        });
        dict
    };

    parseOpen = { arg line;
        var attrs, dict, idNum, fretNum;
        attrs = parseAttrs.(line);
        dict = (
            id: (attrs[\id] ?? { "0" }).asInteger,
            name: (attrs[\name] ?? { "unnamed" }).asString,
            fret: (attrs[\fret] ?? { "0" }).asInteger,
            payload: (attrs[\payload] ?? { nil }),
            children: Array.new
        );
        dict
    };

    parseClose = { arg stackRef;
        if(stackRef.size > 1, {
            var child = stackRef.pop;
            stackRef.last[\children] = stackRef.last[\children].add(child);
        });
    };

    stack = Array.new;

    // Tokenize lines and handle <node .../> self-close and </node>
    lines = xmlText.replace($\t, $ ).replace($\r, $ ).split($\n);
    lines.do({ arg raw;
        var line = raw.trim;
        if(line.isEmpty) { ^nil };

        if(line.beginsWith("<node") and: { line.endsWith("/>") }) {
            var dict = parseOpen.(line);
            if(stack.isEmpty) { stack.push(dict) } { stack.last[\children] = stack.last[\children].add(dict) };
        }{
            if(line.beginsWith("</node")) {
                parseClose.(stack);
            }{
                if(line.beginsWith("<node")) {
                    stack.push(parseOpen.(line));
                };
            };
        };
    });

    // Close remaining nodes
    while({ stack.size > 1 }, { parseClose.(stack) });

    rootDict = if(stack.size == 1) { stack[0] } { nil };
    if(rootDict.isNil) { "Parse failed (no root)".warn; ^false };

    // Build top-level tree dict for MDCommandTree.fromDict
    currentDict = (
        name: rootDict[\name],
        id: rootDict[\id],
        nodeLimit: 200,
        payload: rootDict[\payload],
        children: rootDict[\children]
    );

    // Write JSON (uses JSONlib from your environment)
    File.use(outPath, "w", { arg f; f.write(JSONlib.convertToJSON(currentDict)) });
    ("[CT] Wrote JSON -> " ++ outPath).postln;
    true
};
)

===== Magicpedalboard/obsolete/Utils_MagicDisplayGUI_Checks.scd =====
(
// =========================
// Utils_MagicDisplayGUI_Checks.scd  (single block)
// =========================

~md_checkEnv = {
    var gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles;
    gui_present = ~gui.notNil;
    queue_ok = gui_present and: { ~gui.respondsTo(\queueUi) };
    setter_ok = gui_present and: { ~gui.respondsTo(\queueUi_) };
    atput_ok = gui_present and: { ~gui.respondsTo(\atPut) };
    win_count = (~md_get_gui_windows.notNil).if({ ~md_get_gui_windows.().size }, { 0 });
    win_titles = (win_count > 0).if({ ~md_get_gui_windows.().collect({ |w| w.name.asString }) }, { [] });
    "[ENV] mpb:% gui:% queueUi:% queueUi_:% atPut:% windows:% titles:%"
        .format(~mpb.notNil, gui_present, queue_ok, setter_ok, atput_ok, win_count, win_titles)
        .postln;
};

~md_appclock_ping = {
    AppClock.sched(0.0, { "[AC] ping ok @ % s".format(Main.elapsedTime.round(0.001)).postln; nil });
};

) // end block

===== Magicpedalboard/obsolete/Verify_SetSourcesBoth_Today.scd =====
// Verify_SetSourcesBoth_Today.scd
// v0.2
// MD 2025-09-18 13:46 BST

// Purpose
// - Verify that both chains have \testmelody as their source symbol, without assuming ~mpb exists.
// Style
// - var-first; lowercase; no server.sync; server ops via class methods only.

(
var warn, ensureSources;
warn = { arg s; var msg; msg = "[VERIFY] " ++ s; msg.warn };

if(~mpb.isNil) {
    warn.("~mpb is nil. Run StartHere_CleanBoot_OneWindow_BringUp.scd first.");
    ^nil;
};

ensureSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seq);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        Ndef(\ts0, { Silent.ar(2) }); Ndef(\ts0).ar(2);
    });
};

ensureSources.();
~mpb.setSourceCurrent(\testmelody);
~mpb.setSource(\testmelody);
~mpb.printChains;
"[VERIFY] Both chains point to \\testmelody (CURRENT and NEXT)".postln;
)

===== Magicpedalboard/obsolete/XEnforce_EndAndRecreateSilent_Now.scd =====
// XEnforce_EndAndRecreateSilent_Now.scd
// v0.1
// MD 20250917-1305
//
// Purpose: Deterministically enforce Option A for both audio *and* flags.
//          - CURRENT robust \in.ar(2), playing
//          - NEXT: .end (drops monitor + flag), then recreate Silent.ar(2) + mold(2,\audio)
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, curSink, nextSink;
log = { arg s; ("[XEND] " ++ s).postln };

if(~mpb.isNil) { "[XEND] ~mpb is nil".warn; ^nil };

curSink  = ~mpb.currentChain[0];
nextSink = ~mpb.nextChain[0];

if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };

Server.default.bind({
    // CURRENT: robust + stereo + playing
    Ndef(curSink,  { \in.ar(2) }); Ndef(curSink).mold(2, \audio);
    if(Ndef(curSink).isPlaying.not) { Ndef(curSink).play(numChannels: 2) };

    // NEXT: end monitor -> recreate as silent stereo (no play)
    Ndef(nextSink).end;                              // flag reliably drops
    Ndef(nextSink, { Silent.ar(2) });                // silent source
    Ndef(nextSink).mold(2, \audio);                  // stereo pin
});

log.("enforced; checking in 250ms‚Ä¶");
AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[XEND] [PLAY] A=% B=%".format(a, b)).postln;
    if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(true) };
    nil
});
)

===== Magicpedalboard/old but good/Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd
// MD 20250912-1527

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets; no double /n_free


(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight (avoid double free: only clear Ndefs)
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var exists;
            exists = proxyRef.notNil;
            if(exists) {
                proxyRef.clear; // no proxy.stop here ‚Üí avoids duplicate /n_free
            };
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (GUI queues until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== Magicpedalboard/old/Test_MagicDisplay_wireup_v0_2.scd =====

// Simple sources / processors (stereo)
Ndef(\ts0, { Silent.ar(2) });
Ndef(\tsSaw, { Saw.ar(200, 0.12) ! 2 });
Ndef(\tsDust, { Dust.ar(2000) ! 2 });

Ndef(\tremolo, { |rate = 5, depth = 0.8|
    var inSig = \in.ar(2);
    inSig * SinOsc.kr(rate).range(1 - depth, 1)
});

// Create display + pedalboard
d = MagicDisplay.new(1);          // verbose console
m = MagicPedalboardNew.new(d);    // pass display at construction
// Exercise a few actions
m.setSourceCurrent(\tsSaw);
m.add(\tremolo);
m.printChains;

m.switchChain;
m.setSource(\tsDust);
m.clearChain;
m.printChains;

m.stopCurrent;


===== Magicpedalboard/old/Test_MagicDisplay_wireup_v0_3.scd =====
// Test_MagicDisplay_wireup_v0_3.scd
// MD 20250911-1143


// Simple sources / processors (stereo)
Ndef(\ts0, { Silent.ar(2) });
Ndef(\tsSaw, { Saw.ar(200, 0.12) ! 2 });
Ndef(\tsDust, { Dust.ar(2000) ! 2 });

Ndef(\tremolo, { |rate = 5, depth = 0.8|
    var inSig = \in.ar(2);
    inSig * SinOsc.kr(rate).range(1 - depth, 1)
});

// Create display + pedalboard
d = MagicDisplay.new(1);          // verbose console
m = MagicPedalboardNew.new(d);    // pass display at construction
// Exercise a few actions
m.setSourceCurrent(\tsSaw);
m.add(\tremolo);
m.printChains;

m.switchChain;
m.setSource(\tsDust);
m.clearChain;
m.printChains;

m.stopCurrent;


===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_1.scd =====
/* Test_MagicPedalboardNew_v0_1.scd
   Minimal smoke tests for MagicPedalboardNew.
*/

(
// 1) Toy sources and processors (stereo; processors have named \in)
Ndef(\ts0, { Silent.ar(2) });                    // silent (default)
Ndef(\ts1, { Dust.ar(2000) ! 2 });               // noisy bursts
Ndef(\ts2, { Saw.ar(200, 0.1) ! 2 });            // saw
Ndef(\ts3, { SinOsc.ar(333, 0, 0.2) ! 2 });      // sine

Ndef(\p1, { var inputSignal; inputSignal = \in.ar(2) * 0.5; inputSignal });
Ndef(\p2, { var inputSignal; inputSignal = \in.ar(2) * 0.2; inputSignal });
Ndef(\p3, { var inputSignal; inputSignal = \in.ar(2); inputSignal });

// 2) Instantiate and play current (A)
m = MagicPedalboardNew.new;

// Make sources audible for both chains
m.setSourceCurrent(\ts2); // current chain (A) plays \ts2
m.setSource(\ts3);        // next chain (B) staged with \ts3

m.printChains.postln;
)

// 3) Build up NEXT chain (B): add processors, bypass, then switch
(
m.add(\p1);                 // insert before source
m.addAt(\p2, 1);            // nearer the sink (index 1)
m.addAt(\p3, 2);

m.printChains;

// Preview bypass on NEXT chain
m.bypassAt(1, true);        // bypass whatever sits at index 1 (in B)
m.printChains;

// Switch to make B current and play it
m.switchChain;
)

// 4) Current-chain bypass tweaks and inspection
(
m.bypassAtCurrent(1, false); // un-bypass that slot on current
m.printChains;
)

// 5) Work on NEXT chain again (now A), swap and clear
(
m.swap(1, 2);
m.printChains;

m.clearChain;
m.printChains;
)

// 6) Stop and re‚Äëplay current as a final smoke test
(
m.stopCurrent;
m.playCurrent;
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_10_QA_PauseResume_Fixed.scd =====
/* Test_MagicPedalboardNew_v0_10_QA_PauseResume_Fixed.scd
   Interactive QA demo for MagicPedalboardNew v0.1.5
   - Two-step issue capture:
       [Report Issue (Pause)] -> type note -> [Submit Issue & Resume]  (or [Resume (No Issue)])
   - Routine runs on SystemClock; GUI updates are deferred to AppClock.
   - Robust against missing setSource / setSourceCurrent (uses fallbacks).
*/

(
var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
var waitShortDur, waitMedDur;
var sayFn, countdownFn, showFn;
var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
var setCurrentSourceRobustFn, setNextSourceRobustFn;
var runRoutine;

var beforeDict, afterDict;     // used within the Routine
var activeStepId, activeStepTitle, activeStepExpected;

var pedalboard;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent baseline
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // irregular bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate + reset
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline

// Robust helpers for source setting (handle older class versions)
setCurrentSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSourceCurrent);
    if(hasSetter) {
        pedalboard.setSourceCurrent(key);
    }{
        // fallback: temporarily switch, set NEXT as current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: setSourceCurrent missing; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

setNextSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSource);
    if(hasSetter) {
        pedalboard.setSource(key);
    }{
        // fallback: temporarily switch to make NEXT current, set current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA state (no GUI calls here)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil,                  // after a step is pushed, points to that entry
    pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
    pauseRequested: false,
    pauseCondition: Condition.new
);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

setActiveStepFn = { |stepId, stepTitle, expectedText|
    activeStepId = stepId;
    activeStepTitle = stepTitle;
    activeStepExpected = expectedText;
    AppClock.sched(0, {
        infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        nil
    });
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
    absorbPendingIssueForFn.(stepId, entry);
};

absorbPendingIssueForFn = { |stepId, entry|
    var pending;
    pending = ~qa.pendingIssues[stepId];
    if(pending.notNil) {
        entry[\userFlagged] = true;
        entry[\userReason] = pending[\reason];
        entry[\userNote] = pending[\note];
        if(~qa.issues.includes(stepId).not) {
            ~qa.issues = ~qa.issues.add(stepId);
        };
        ~qa.pendingIssues.removeAt(stepId);
    };
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) Pause / resume workflow
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
requestPauseFn = {
    ~qa.pauseRequested = true;
    AppClock.sched(0, {
        infoText.string = "PAUSED at % ‚Äî %\nType your note, then Submit or Resume."
            .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
        qaWindow.name = "MPBNew QA ‚Äì PAUSED";
        nil
    });
};

waitIfPausedFn = {
    // This is called inside the Routine (on SystemClock now).
    while { ~qa.pauseRequested } {
        ~qa.pauseCondition.wait; // signal comes from AppClock handlers (buttons/keys)
    };
};

submitIssueFn = {
    var noteText, reasonText, stepIdLocal;
    noteText = noteTextField.string;
    reasonText = "user report (paused)";
    stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));

    ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);

    ("[QA] Issue captured for step %".format(stepIdLocal)).postln;
    if(noteText.notNil and: { noteText != "" }) { ("[QA] Note: " ++ noteText).postln };

    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Captured issue for step %.\nResuming‚Ä¶".format(stepIdLocal);
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        nil
    });
};

resumeNoIssueFn = {
    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Resuming without logging an issue‚Ä¶";
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) Console helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
sayFn = { |text|
    var msg;
    msg = text.asString;
    msg.postln;
};

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        waitIfPausedFn.();             // allow pausing mid-countdown
        (remaining.asString ++ "...").postln;
        1.wait;                        // SystemClock wait
        remaining = remaining - 1;
    };
    waitIfPausedFn.();                 // pause again before executing the action
    "Now.".postln;
};

showFn = {
    "‚Äî Chains ‚Äî".postln;
    pedalboard.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 5) QA UI (AppClock-safe GUI)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
qaWindow = Window("MPBNew QA ‚Äì two-step issue capture", Rect(100, 100, 640, 210)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 620, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 620, 24)).string_("Type your note here‚Ä¶");

// left: report (pause). middle: submit & resume. right: resume without logging.
reportButton = Button(qaWindow, Rect(10, 100, 200, 30))
    .states_([["Report Issue (Pause)", Color.white, Color.red]])
    .action_({ requestPauseFn.() });

submitButton = Button(qaWindow, Rect(220, 100, 200, 30))
    .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
    .action_({ submitIssueFn.() });

resumeButton = Button(qaWindow, Rect(430, 100, 200, 30))
    .states_([["Resume (No Issue)", Color.white, Color.gray]])
    .action_({ resumeNoIssueFn.() });

// keyboard: X pauses, Enter submits, Esc resumes without logging
qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { requestPauseFn.() };
    if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
    if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 6) Narrated sequence (RUN ON SystemClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    // A) Start silent on CURRENT
    setActiveStepFn.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    setActiveStepFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    setActiveStepFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSaw);
    pedalboard.add(\tremolo);     // inserts before source
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    setActiveStepFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    setActiveStepFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    setActiveStepFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    setActiveStepFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    setActiveStepFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    setActiveStepFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary (build + copy to clipboard)
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged (submitted during run):".format(~qa.issues.size)).postln;
            ~qa.steps.do { |stepEntry|
                if(stepEntry[\userFlagged] == true) {
                    (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]).postln;
                    ("Expected: " ++ stepEntry[\expected]).postln;
                    ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next).postln;
                    ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next).postln;
                    ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext).postln;
                    if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                        ("Note: " ++ stepEntry[\userNote]).postln;
                    };
                    "".postln;
                };
            };
            if(~qa.pendingIssues.size > 0) {
                "Pending issues captured before step completion:".postln;
                ~qa.pendingIssues.keysValuesDo { |sid, rec|
                    (sid ++ "  (no step snapshot available yet)").postln;
                    ("Note: " ++ rec[\note]).postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |stepEntry|
                    if(stepEntry[\userFlagged] == true) {
                        str << (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]) << Char.nl;
                        str << ("Expected: " ++ stepEntry[\expected]) << Char.nl;
                        str << ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next) << Char.nl;
                        str << ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext) << Char.nl;
                        if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                            str << ("Note: " ++ stepEntry[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
                if(~qa.pendingIssues.size > 0) {
                    str << "Pending issues captured before step completion:" << Char.nl;
                    ~qa.pendingIssues.keysValuesDo { |sid, rec|
                        str << sid << "  (no step snapshot available yet)" << Char.nl;
                        str << ("Note: " ++ rec[\note]) << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(SystemClock);   // <<< IMPORTANT: run on SystemClock (not AppClock)
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_11_QA_PauseResume_Fixed.scd =====
// Test_MagicPedalboardNew_v0_11_QA_PauseResume_Fixed.scd
// MD 20250911-1225

(
var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
var waitShortDur, waitMedDur;
var sayFn, countdownFn, showFn;
var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
var setCurrentSourceRobustFn, setNextSourceRobustFn, forceSilentBaselineFn;
var runRoutine;

var beforeDict, afterDict;
var activeStepId, activeStepTitle, activeStepExpected;
var pedalboard;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate + reset + HARD SILENT BASELINE
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline from the class

// robust helpers for source setting
setCurrentSourceRobustFn = { |key|
    if(pedalboard.respondsTo(\setSourceCurrent)) {
        pedalboard.setSourceCurrent(key);
    }{
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "[QA] ERROR: setSourceCurrent missing; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

setNextSourceRobustFn = { |key|
    if(pedalboard.respondsTo(\setSource)) {
        pedalboard.setSource(key);
    }{
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "[QA] ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// hard silent baseline: both chains => [sink, \ts0], both cleared, only current plays
forceSilentBaselineFn = {
    "[QA] Force silent baseline‚Ä¶".postln;
    pedalboard.reset;                 // resets to [\chainA,\ts0] / [\chainB,\ts0], plays A
    setCurrentSourceRobustFn.(\ts0);  // explicit, even if reset did it
    setNextSourceRobustFn.(\ts0);

    // clear NEXT, then switch/clear to clear CURRENT as well
    pedalboard.clearChain;            // clears NEXT to [sink, source]
    pedalboard.switchChain;
    pedalboard.clearChain;            // clears NEXT (which is previous CURRENT)
    pedalboard.switchChain;

    // make absolutely sure no test Ndefs are playing directly
    [\tsDust, \tsSaw, \tsSine, \tremolo, \lofi, \atten].do { |k|
        if(Ndef(k).isPlaying) { Ndef(k).stop }
    };

    // play current sink, stop next
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    "[QA] Baseline set. Expect: silence.".postln;
};
forceSilentBaselineFn.();

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA state (no GUI calls here)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil,
    pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
    pauseRequested: false,
    pauseCondition: Condition.new
);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

setActiveStepFn = { |stepId, stepTitle, expectedText|
    activeStepId = stepId;
    activeStepTitle = stepTitle;
    activeStepExpected = expectedText;
    AppClock.sched(0, {
        infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        nil
    });
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
    absorbPendingIssueForFn.(stepId, entry);
};

absorbPendingIssueForFn = { |stepId, entry|
    var pending;
    pending = ~qa.pendingIssues[stepId];
    if(pending.notNil) {
        entry[\userFlagged] = true;
        entry[\userReason] = pending[\reason];
        entry[\userNote] = pending[\note];
        if(~qa.issues.includes(stepId).not) { ~qa.issues = ~qa.issues.add(stepId) };
        ~qa.pendingIssues.removeAt(stepId);
    };
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) Pause / resume workflow (Routine on SystemClock; GUI on AppClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
requestPauseFn = {
    "[QA] pause requested".postln;
    ~qa.pauseRequested = true;
    AppClock.sched(0, {
        infoText.string = "PAUSED at % ‚Äî %\nType your note, then Submit or Resume."
            .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
        qaWindow.name = "MPBNew QA ‚Äì PAUSED";
        // enable submit/resume, disable report
        reportButton.enabled = false;
        submitButton.enabled = true;
        resumeButton.enabled = true;
        nil
    });
};

waitIfPausedFn = {
    while { ~qa.pauseRequested } { ~qa.pauseCondition.wait };
};

submitIssueFn = {
    var noteText, reasonText, stepIdLocal;
    noteText = noteTextField.string;
    reasonText = "user report (paused)";
    stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));
    ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);
    ("[QA] issue submitted for step %".format(stepIdLocal)).postln;
    if(noteText.notNil and: { noteText != "" }) { ("[QA] note: " ++ noteText).postln };

    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;
    AppClock.sched(0, {
        infoText.string = "Captured issue for step %.\nResuming‚Ä¶".format(stepIdLocal);
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        // after resume, re-enable report and disable submit/resume
        reportButton.enabled = true;
        submitButton.enabled = false;
        resumeButton.enabled = false;
        nil
    });
};

resumeNoIssueFn = {
    "[QA] resume (no issue)".postln;
    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;
    AppClock.sched(0, {
        infoText.string = "Resuming without logging an issue‚Ä¶";
        qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
        reportButton.enabled = true;
        submitButton.enabled = false;
        resumeButton.enabled = false;
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) Console helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
sayFn = { |text| text.asString.postln };

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        waitIfPausedFn.();
        (remaining.asString ++ "...").postln;
        1.wait; // SystemClock wait
        remaining = remaining - 1;
    };
    waitIfPausedFn.();
    "Now.".postln;
};

showFn = {
    "‚Äî Chains ‚Äî".postln;
    pedalboard.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 5) QA UI (AppClock-safe GUI)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
qaWindow = Window("MPBNew QA ‚Äì two-step issue capture", Rect(100, 100, 700, 220)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 680, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 680, 24)).string_("Type your note here‚Ä¶");

// left: report (pause). middle: submit & resume. right: resume without logging.
reportButton = Button(qaWindow, Rect(10, 100, 220, 30))
    .states_([["Report Issue (Pause)", Color.white, Color.red]])
    .action_({ requestPauseFn.() });

submitButton = Button(qaWindow, Rect(240, 100, 220, 30))
    .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
    .action_({ submitIssueFn.() })
    .enabled_(false);

resumeButton = Button(qaWindow, Rect(470, 100, 220, 30))
    .states_([["Resume (No Issue)", Color.white, Color.gray]])
    .action_({ resumeNoIssueFn.() })
    .enabled_(false);

// keyboard: X pauses, Enter submits, Esc resumes without logging
qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { requestPauseFn.() };
    if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
    if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 6) Narrated sequence (RUN ON SystemClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    // A) Start silent on CURRENT
    setActiveStepFn.("A1", "Start silent \\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    setActiveStepFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    setActiveStepFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSaw);
    pedalboard.add(\tremolo);
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    setActiveStepFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    setActiveStepFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    setActiveStepFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    setActiveStepFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    setActiveStepFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    setActiveStepFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged (submitted during run):".format(~qa.issues.size)).postln;
            ~qa.steps.do { |st|
                if(st[\userFlagged] == true) {
                    (st[\id] ++ " ‚Äî " ++ st[\title]).postln;
                    ("Expected: " ++ st[\expected]).postln;
                    ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next).postln;
                    ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next).postln;
                    ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext).postln;
                    if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                        ("Note: " ++ st[\userNote]).postln;
                    };
                    "".postln;
                };
            };
            if(~qa.pendingIssues.size > 0) {
                "Pending issues captured before step completion:".postln;
                ~qa.pendingIssues.keysValuesDo { |sid, rec|
                    (sid ++ "  (no step snapshot available yet)").postln;
                    ("Note: " ++ rec[\note]).postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |st|
                    if(st[\userFlagged] == true) {
                        str << (st[\id] ++ " ‚Äî " ++ st[\title]) << Char.nl;
                        str << ("Expected: " ++ st[\expected]) << Char.nl;
                        str << ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next) << Char.nl;
                        str << ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ st[\after].bypassCurrent
                            ++ " / " ++ st[\after].bypassNext) << Char.nl;
                        if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                            str << ("Note: " ++ st[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
                if(~qa.pendingIssues.size > 0) {
                    str << "Pending issues captured before step completion:" << Char.nl;
                    ~qa.pendingIssues.keysValuesDo { |sid, rec|
                        str << sid << "  (no step snapshot available yet)" << Char.nl;
                        str << ("Note: " ++ rec[\note]) << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(SystemClock); // Routine on SystemClock
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_12_QA_PauseResume_FixedPreflight.scd =====
// Test_MagicPedalboardNew_v0_12_QA_PauseResume_FixedPreflight.scd
// MD 20250911-1315

(
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// All code is executed only after the server is booted and ready.
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
s.waitForBoot({

    var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
    var waitShortDur, waitMedDur;
    var sayFn, countdownFn, showFn;
    var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
    var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
    var setCurrentSourceRobustFn, setNextSourceRobustFn, forceSilentBaselineFn, preflightCleanupFn;
    var runRoutine;

    var beforeDict, afterDict;
    var activeStepId, activeStepTitle, activeStepExpected;
    var pedalboard;

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 0) Preflight cleanup: stop Ndefs, clear any ProxySpaces, and
    //    re-initialize the default group safely (no s.freeAll).
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    preflightCleanupFn = {
        "[QA] Preflight: checking for stray Ndefs and active ProxySpace‚Ä¶".postln;

        // Stop any Ndefs that might be playing, then clear them
        Ndef.all.keysValuesDo { |key, proxy|
            if(proxy.isPlaying) {
                ("[QA] Stopping stray Ndef: " ++ key).postln;
                proxy.stop;
            };
            proxy.clear;
        };

        // Clear all ProxySpaces known to SC (if exposed):
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) {
                    ("[QA] Clearing ProxySpace on " ++ srv).postln;
                    ps.clear; // frees ~proxies (e.g., ~tsDust, ~tremolo)
                };
            };
        };

        // If the current environment *is* a ProxySpace, pop it
        if(currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" }) {
            "[QA] Active ProxySpace is current env ‚Üí pop it.".postln;
            currentEnvironment.pop;
        } {
            "[QA] No active ProxySpace as current env.".postln;
        };

        // SAFELY reset the server tree: recreate Group 1 then free its children
        s.initTree;                // (re)create default group 1 under root
        s.defaultGroup.freeAll;    // keep group 1, remove its children
    };
    preflightCleanupFn.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1) Sources and processors (stereo; processors use \in)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });

    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var inputSignal, mod;
        inputSignal = \in.ar(2);
        mod = SinOsc.kr(rate).range(1 - depth, 1);
        inputSignal * mod
    });

    Ndef(\lofi, { |bits = 4, rate = 4000|
        var inputSignal;
        inputSignal = \in.ar(2);
        Decimator.ar(inputSignal, rate, bits)
    });

    Ndef(\atten, { |gain = 0.25|
        var inputSignal;
        inputSignal = \in.ar(2) * gain;
        inputSignal
    });

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 2) Instantiate + reset + HARD SILENT BASELINE
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    pedalboard = MagicPedalboardNew.new;
    pedalboard.reset; // canonical baseline from the class

    // robust helpers for source setting
    setCurrentSourceRobustFn = { |key|
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            pedalboard.switchChain;
            if(pedalboard.respondsTo(\setSourceCurrent)) {
                pedalboard.setSourceCurrent(key);
            }{
                "[QA] ERROR: setSourceCurrent missing; cannot set current source.".warn;
            };
            pedalboard.switchChain;
        }
    };

    setNextSourceRobustFn = { |key|
        if(pedalboard.respondsTo(\setSource)) {
            pedalboard.setSource(key);
        }{
            pedalboard.switchChain;
            if(pedalboard.respondsTo(\setSourceCurrent)) {
                pedalboard.setSourceCurrent(key);
            }{
                "[QA] ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
            };
            pedalboard.switchChain;
        }
    };

    // Guarantee silence and a canonical shape on both chains
    forceSilentBaselineFn = {
        "[QA] Force silent baseline‚Ä¶".postln;
        pedalboard.reset;                 // [\chainA,\ts0] + [\chainB,\ts0], plays A
        setCurrentSourceRobustFn.(\ts0);
        setNextSourceRobustFn.(\ts0);

        pedalboard.clearChain;            // clear NEXT
        pedalboard.switchChain;
        pedalboard.clearChain;            // clear previous CURRENT (now NEXT)
        pedalboard.switchChain;

        // ensure only current sink plays
        Ndef(\chainA).play(numChannels: 2);
        Ndef(\chainB).stop;

        "[QA] Baseline set. Expect: silence now.".postln;
    };
    forceSilentBaselineFn.();

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 3) QA state (no GUI calls here)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ~qa = (
        steps: Array.new,
        issues: Array.new,
        currentStep: nil,
        pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
        pauseRequested: false,
        pauseCondition: Condition.new
    );

    snapshotFn = {
        (
            time: Main.elapsedTime,
            current: pedalboard.currentChain.copy,
            next: pedalboard.nextChain.copy,
            effCurrent: pedalboard.effectiveCurrent,
            effNext: pedalboard.effectiveNext,
            bypassCurrent: pedalboard.bypassKeysCurrent,
            bypassNext: pedalboard.bypassKeysNext
        )
    };

    setActiveStepFn = { |stepId, stepTitle, expectedText|
        activeStepId = stepId;
        activeStepTitle = stepTitle;
        activeStepExpected = expectedText;
        AppClock.sched(0, {
            infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
            qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
            nil
        });
    };

    pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
        var entry;
        entry = (
            id: stepId,
            title: stepTitle,
            expected: expectedText,
            before: beforeSnap,
            after: afterSnap,
            userFlagged: false,
            userReason: nil,
            userNote: nil
        );
        ~qa.steps = ~qa.steps.add(entry);
        ~qa.currentStep = entry;
        absorbPendingIssueForFn.(stepId, entry);
    };

    absorbPendingIssueForFn = { |stepId, entry|
        var pending;
        pending = ~qa.pendingIssues[stepId];
        if(pending.notNil) {
            entry[\userFlagged] = true;
            entry[\userReason] = pending[\reason];
            entry[\userNote] = pending[\note];
            if(~qa.issues.includes(stepId).not) { ~qa.issues = ~qa.issues.add(stepId) };
            ~qa.pendingIssues.removeAt(stepId);
        };
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 4) Pause / resume workflow (Routine on SystemClock; GUI on AppClock)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    requestPauseFn = {
        "[QA] pause requested".postln;
        ~qa.pauseRequested = true;
        AppClock.sched(0, {
            infoText.string = "PAUSED at % ‚Äî %\nType your note, then Submit or Resume."
                .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
            qaWindow.name = "MPBNew QA ‚Äì PAUSED";
            reportButton.enabled = false;
            submitButton.enabled = true;
            resumeButton.enabled = true;
            nil
        });
    };

    waitIfPausedFn = {
        while { ~qa.pauseRequested } { ~qa.pauseCondition.wait };
    };

    submitIssueFn = {
        var noteText, reasonText, stepIdLocal;
        noteText = noteTextField.string;
        reasonText = "user report (paused)";
        stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));
        ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);
        ("[QA] issue submitted for step %".format(stepIdLocal)).postln;
        if(noteText.notNil and: { noteText != "" }) { ("[QA] note: " ++ noteText).postln };

        ~qa.pauseRequested = false;
        ~qa.pauseCondition.signal;
        AppClock.sched(0, {
            infoText.string = "Captured issue for step %.\nResuming‚Ä¶".format(stepIdLocal);
            qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
            reportButton.enabled = true;
            submitButton.enabled = false;
            resumeButton.enabled = false;
            nil
        });
    };

    resumeNoIssueFn = {
        "[QA] resume (no issue)".postln;
        ~qa.pauseRequested = false;
        ~qa.pauseCondition.signal;
        AppClock.sched(0, {
            infoText.string = "Resuming without logging an issue‚Ä¶";
            qaWindow.name = "MPBNew QA ‚Äì two-step issue capture";
            reportButton.enabled = true;
            submitButton.enabled = false;
            resumeButton.enabled = false;
            nil
        });
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 5) Console helpers
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    sayFn = { |text| text.asString.postln };

    countdownFn = { |seconds = 3|
        var remaining;
        remaining = seconds;
        while { remaining > 0 } {
            waitIfPausedFn.();
            (remaining.asString ++ "...").postln;
            1.wait; // SystemClock wait
            remaining = remaining - 1;
        };
        waitIfPausedFn.();
        "Now.".postln;
    };

    showFn = {
        "‚Äî Chains ‚Äî".postln;
        pedalboard.printChains;
        "".postln;
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 6) QA UI (AppClock-safe GUI)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    qaWindow = Window("MPBNew QA ‚Äì two-step issue capture", Rect(100, 100, 700, 220)).front.alwaysOnTop_(true);
    infoText = StaticText(qaWindow, Rect(10, 10, 680, 40)).string_("Step: (pending)");
    noteTextField = TextField(qaWindow, Rect(10, 60, 680, 24)).string_("Type your note here‚Ä¶");

    reportButton = Button(qaWindow, Rect(10, 100, 220, 30))
        .states_([["Report Issue (Pause)", Color.white, Color.red]])
        .action_({ requestPauseFn.() });

    submitButton = Button(qaWindow, Rect(240, 100, 220, 30))
        .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
        .action_({ submitIssueFn.() })
        .enabled_(false);

    resumeButton = Button(qaWindow, Rect(470, 100, 220, 30))
        .states_([["Resume (No Issue)", Color.white, Color.gray]])
        .action_({ resumeNoIssueFn.() })
        .enabled_(false);

    // keyboard shortcuts
    qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
        if(char == $x or: { char == $X }) { requestPauseFn.() };
        if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
        if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
    };

    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 7) Narrated sequence (RUN ON SystemClock)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    waitShortDur = 1.8;
    waitMedDur   = 3.0;

    runRoutine = Routine({

        // A) Start silent on CURRENT
        setActiveStepFn.("A1", "Start silent \\ts0 on CURRENT", "Silence");
        sayFn.("Starting with a silent CURRENT chain. Starting in");
        countdownFn.(3);
        beforeDict = snapshotFn.();
        setCurrentSourceRobustFn.(\ts0);
        pedalboard.playCurrent;
        showFn.();
        sayFn.("You should hear nothing.");
        waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
        afterDict = snapshotFn.();
        pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

        // ‚Ä¶ (keep your B/C/D/E/F/G steps unchanged) ‚Ä¶

    }).play(SystemClock);
});
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_2.scd =====
// Test_MagicPedalboardNew_v0_2.scd
// MD 20250911-1639

//  Minimal smoke tests for MagicPedalboardNew (v0.1.2).

(
// 1) Toy sources and processors (stereo; processors have named \in)
Ndef(\ts0, { Silent.ar(2) });                    // silent (default)
Ndef(\ts1, { Dust.ar(2000) ! 2 });               // noisy bursts
Ndef(\ts2, { Saw.ar(200, 0.1) ! 2 });            // saw
Ndef(\ts3, { SinOsc.ar(333, 0, 0.2) ! 2 });      // sine

Ndef(\p1, { var inputSignal; inputSignal = \in.ar(2) * 0.5; inputSignal });
Ndef(\p2, { var inputSignal; inputSignal = \in.ar(2) * 0.2; inputSignal });
Ndef(\p3, { var inputSignal; inputSignal = \in.ar(2); inputSignal });

// 2) Instantiate and play current (A)
m = MagicPedalboardNew.new;

// Make sources audible for both chains
m.setSourceCurrent(\ts2); // current chain (A) plays \ts2
m.setSource(\ts3);        // next chain (B) staged with \ts3

m.printChains.postln;
)

// 3) Build up NEXT chain (B): add processors, bypass, then switch
(
m.add(\p1);                 // insert before source
m.addAt(\p2, 1);            // nearer the sink (index 1)
m.addAt(\p3, 2);

m.printChains;

// Preview bypass on NEXT chain
m.bypassAt(1, true);        // bypass whatever sits at index 1 (in B)
m.printChains;

// Switch to make B current and play it
m.switchChain;
)

// 4) Current-chain bypass tweaks and inspection
(
m.bypassAtCurrent(1, false); // un-bypass that slot on current
m.printChains;
)

// 5) Work on NEXT chain again (now A), swap and clear
(
m.swap(1, 2);
m.printChains;

m.clearChain;
m.printChains;
)

// 6) Stop and re‚Äëplay current as a final smoke test
(
m.stopCurrent;
m.playCurrent;
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_3_1_Sanity_NoGUI.scd =====
// Test_MagicPedalboardNew_v0_3_1_Sanity_NoGUI.scd
// MD 20250912-1345

(
s.waitForBoot({
    var say, countdown, show, preflight, setCurrent, setNext, board, displayAdaptor;

    say = { |txt| txt.asString.postln };
    countdown = { |n = 3| n.do { |k| ((n - k).asString ++ "...").postln; 1.wait }; "Now.".postln; };

    preflight = {
        // safe cleanup
        Ndef.all.keysValuesDo { |key, proxy| if(proxy.isPlaying) { proxy.stop }; proxy.clear };
        if(ProxySpace.respondsTo(\all)) { ProxySpace.all.valuesDo { |ps| if(ps.notNil) { ps.clear } } };
        s.initTree; s.defaultGroup.freeAll;
    };

    show = { "‚Äî Chains (detailed) ‚Äî".postln; board.printChains; "".postln; };

    setCurrent = { |key| if(board.respondsTo(\setSourceCurrent)) { board.setSourceCurrent(key) } };
    setNext    = { |key| if(board.respondsTo(\setSource))        { board.setSource(key)        } };

    preflight.();

    displayAdaptor = MagicDisplay.new(1);
    board = MagicPedalboardNew.new(displayAdaptor);
    board.reset;

    // silent baseline
    setCurrent.(\ts0); setNext.(\ts0);
    board.clearChain; board.switchChain; board.clearChain; board.switchChain;
    Ndef(\chainA).play(numChannels: 2); Ndef(\chainB).stop;

    say.("A1: silent"); show.(); 2.wait;

    say.("B1: CURRENT->Dust"); setCurrent.(\tsDust); show.(); 2.wait;

    say.("C1: NEXT Saw+Trem -> switch");
    setNext.(\tsSaw); board.add(\tremolo); show.();
    countdown.(3); board.switchChain; show.(); 2.wait;

    say.("D1: bypass tremolo"); board.bypassCurrent(\tremolo, true); show.(); 1.wait;
    say.("D2: un-bypass tremolo"); board.bypassCurrent(\tremolo, false); show.(); 2.wait;

    say.("E1: NEXT add atten@1, lofi@2, swap -> switch");
    board.addAt(\atten, 1); board.addAt(\lofi, 2); board.swap(1, 2); show.();
    countdown.(2); board.switchChain; show.(); 2.wait;

    say.("F1: NEXT removeAt(1), clear");
    board.removeAt(1); show.(); board.clearChain; show.(); 1.wait;

    say.("G1: NEXT->ts0, switch");
    setNext.(\ts0); countdown.(2); board.switchChain; show.(); 2.wait;

    say.("Done. Stopping."); board.stopCurrent;
});
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_3_2_Sanity_NoGUI.scd =====
// Test_MagicPedalboardNew_v0_3_2_Sanity_NoGUI.scd
// MD 20250912-1412
(
s.waitForBoot {
    var say, countdown, show, preflight, setCurrent, setNext, board, displayAdaptor;

    say = { |text| text.asString.postln };
    countdown = { |n = 3|
        var k;
        k = n;
        while { k > 0 } {
            (k.asString ++ "...").postln;
            1.wait;
            k = k - 1;
        };
        "Now.".postln;
    };
    preflight = {
        Ndef.all.keysValuesDo { |keySymbol, nodeProxy|
            if(nodeProxy.isPlaying) { nodeProxy.stop };
            nodeProxy.clear;
        };
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |serverKey, proxySpace|
                if(proxySpace.notNil) { proxySpace.clear };
            };
        };
        s.initTree;
        s.defaultGroup.freeAll;
    };
    show = {
        "‚Äî Chains (detailed) ‚Äî".postln;
        board.printChains;
        "".postln;
    };
    setCurrent = { |key|
        if(board.respondsTo(\setSourceCurrent)) {
            board.setSourceCurrent(key)
        } { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(board.respondsTo(\setSource)) {
            board.setSource(key)
        } { "ERROR: setSource missing".warn };
    };

    // go
    preflight.();

    Ndef(\ts0, { Silent.ar(2) });
    Ndef(\tsDust, { Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tremolo, {
        var inputSignal;
        inputSignal = \in.ar(2);
        inputSignal * SinOsc.kr(4).range(0.1, 1)
    });
    Ndef(\lofi, {
        var inputSignal;
        inputSignal = \in.ar(2);
        Decimator.ar(inputSignal, 4000, 4)
    });
    Ndef(\atten, {
        var inputSignal;
        inputSignal = \in.ar(2) * 0.25;
        inputSignal
    });

    displayAdaptor = MagicDisplay.new(1);
    board = MagicPedalboardNew.new(displayAdaptor);
    board.reset;

    setCurrent.(\ts0);
    setNext.(\ts0);
    board.clearChain;
    board.switchChainWithFade;
    board.clearChain;
    board.switchChainWithFade;
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    say.("A1: silent"); show.(); 2.wait;

    say.("B1: CURRENT‚ÜíDust"); setCurrent.(\tsDust); show.(); 2.wait;

    say.("C1: NEXT Saw+Trem ‚Üí switch");
    setNext.(\tsSaw); board.add(\tremolo); show.();
    countdown.(3); board.switchChainWithFade; show.(); 2.wait;

    say.("D1: bypass tremolo"); board.bypassCurrent(\tremolo, true); show.(); 1.wait;
    say.("D2: un-bypass tremolo"); board.bypassCurrent(\tremolo, false); show.(); 2.wait;

    say.("E1: NEXT add atten@1, lofi@2, swap ‚Üí switch");
    board.addAt(\atten, 1); board.addAt(\lofi, 2); board.swap(1, 2); show.();
    countdown.(2); board.switchChainWithFade; show.(); 2.wait;

    say.("F1: NEXT removeAt(1), clear");
    board.removeAt(1); show.(); board.clearChain; show.(); 1.wait;

    say.("G1: NEXT‚Üíts0, switch");
    setNext.(\ts0); countdown.(2); board.switchChainWithFade; show.(); 2.wait;

    say.("Done. Stopping."); board.stopCurrent;
});
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_3_TimedDemo.scd =====
// Test_MagicPedalboardNew_v0_3_TimedDemo.scd
// MD 20250911-1647

/* Test_MagicPedalboardNew_v0_3_TimedDemo.scd
   Comprehensive, narrated demo with countdowns for MagicPedalboardNew v0.1.3.
   It describes what will happen, counts down, performs the action, and prints
   the expected audible result.
*/

(
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Simple sources and processors (stereo; processors read \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0, { Silent.ar(2) });                    // silent (baseline)
Ndef(\tsDust, { Dust.ar(2000) ! 2 });            // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.12) ! 2 });         // bright saw
Ndef(\tsSine, { SinOsc.ar(333, 0, 0.2) ! 2 });   // steady sine
// processors
Ndef(\tremolo, { |rate = 4, depth = 0.6|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 6, rate = 6000|
    var inputSignal;
    inputSignal = \in.ar(2);
    // crude bitcrush + SRR
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.6|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate pedalboard
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
m = MagicPedalboardNew.new;

// Utilities for narration
~say = { |text|
    var msg;
    msg = text.asString;
    msg.postln;
};

~countdown = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

// Helper to display chains compactly
~show = {
    "‚Äî Chains ‚Äî".postln;
    m.printChains;
    "".postln;
};
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) Narrated sequence (Routine)
//    Feel free to tweak the waits if you want faster/slower pacing.
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
Routine({
    var waitShort, waitMed;
    waitShort = 2.0;
    waitMed = 6.0;

    // A) Start silent on current (A)
    ~say.("Starting with a silent chain on current: [\\chainA, \\ts0]. Starting in");
    ~countdown.(3);
    m.setSourceCurrent(\ts0);            // ensure silent on current chain
    m.playCurrent;
    ~show.();
    ~say.("You should hear nothing.");
    waitMed.wait;

    // B) Swap source to Dust on current
    ~say.("Change current source to Dust(2000). Starting in");
    ~countdown.(3);
    m.setSourceCurrent(\tsDust);
    ~show.();
    ~say.("You should hear irregular noise bursts in stereo.");
    waitMed.wait;

    // C) Prepare NEXT chain (B) with Saw, add tremolo near source, and switch
    ~say.("Prepare NEXT: source = Saw, add a tremolo (\\tremolo) before the source, then switch.");
    ~say.("Setting NEXT source to Saw in");
    ~countdown.(2);
    m.setSource(\tsSaw);

    ~say.("Adding tremolo on NEXT just before the source in");
    ~countdown.(2);
    m.add(\tremolo);     // inserts just before source
    ~show.();

    ~say.("Switch to NEXT (so tremolo+Saw becomes current). Starting in");
    ~countdown.(3);
    m.switchChain;
    ~show.();
    ~say.("You should hear a saw tone with amplitude modulation (tremolo).");
    waitMed.wait;

    // D) Bypass tremolo on CURRENT, then un-bypass
    ~say.("Bypass the tremolo on CURRENT in");
    ~countdown.(2);
    // tremolo is likely at index 1 (after sink), but we use name to be explicit:
    m.bypassCurrent(\tremolo, true);
    ~show.();
    ~say.("You should hear plain Saw (no tremolo).");
    waitShort.wait;

    ~say.("Un-bypass tremolo on CURRENT in");
    ~countdown.(2);
    m.bypassCurrent(\tremolo, false);
    ~show.();
    ~say.("Tremolo should be back.");
    waitMed.wait;

    // E) Prepare NEXT: add lofi and atten near sink, then swap positions
    ~say.("Prepare NEXT: add \\lofi near the sink (index 1) and \\atten after it, then swap them.");
    ~say.("Adding \\lofi at index 1 in");
    ~countdown.(2);
    m.addAt(\lofi, 1);
    ~show.();
    waitShort.wait;

    ~say.("Adding \\atten at index 2 in");
    ~countdown.(2);
    m.addAt(\atten, 2);
    ~show.();
    waitShort.wait;

    ~say.("Swap NEXT indices 1 and 2 in");
    ~countdown.(2);
    m.swap(1, 2);
    ~show.();
    ~say.("NEXT is staged with [sink, atten, lofi, source].");
    waitMed.wait;

    // F) Switch to NEXT (A becomes next)
    ~say.("Switch to NEXT so atten+lofi+Saw becomes CURRENT. Starting in");
    ~countdown.(3);
    m.switchChain;
    ~show.();
    ~say.("You should hear Saw going through attenuation and a bitcrush/decimate.");
    waitMed.wait;

    // G) Remove a processor on NEXT and clear
    ~say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear the chain.");
    ~say.("Removing at index 1 on NEXT in");
    ~countdown.(2);
    m.removeAt(1);
    ~show.();
    waitShort.wait;

    ~say.("Clear NEXT back to [sink, source] in");
    ~countdown.(2);
    m.clearChain;
    ~show.();
    waitShort.wait;

    // H) Change NEXT source to Sine and switch
    ~say.("Set NEXT source to Sine and then switch. Starting in");
    ~countdown.(3);
    m.setSource(\tsSine);
    m.switchChain;
    ~show.();
    ~say.("You should now hear a steady sine tone.");
    waitMed.wait;

    // I) Demonstrate bypassAt on CURRENT (no-op if only [sink, source])
    ~say.("Demonstrate bypassAt on CURRENT (if there are no processors, this does nothing). In");
    ~countdown.(2);
    m.bypassAtCurrent(1, true);  // will clamp but have no effect if only [sink, source]
    ~show.();
    waitShort.wait;

    // J) Wrap up
    ~say.("Demo complete. Stopping current chain in");
    ~countdown.(3);
    m.stopCurrent;
    ~say.("All done.");
}).play;
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_4_TimedDemoWithQA.scd =====
/* Test_MagicPedalboardNew_v0_4_TimedDemoWithQA.scd
   Comprehensive, narrated demo with interactive QA for MagicPedalboardNew v0.1.4.

   HOW TO USE:
   - Keep this window focused. When narration says what you SHOULD hear,
     press 'X' if you DON'T hear that. (Or click the red Mark Issue button.)
   - You can add an optional note in the text field before marking the issue.
   - At the end, a diagnostic summary is printed (and copied to clipboard if supported).

   TIP:
   - Re-run this file from the top for a clean session. It calls m.reset at start.
*/

(
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent (baseline)
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

// processors (clear audible effect choices)
Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate and reset pedalboard
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
m = MagicPedalboardNew.new;
m.reset; // clean start every time

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA UI (press X or click the button to mark issue on current step)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
var w, infoView, noteField, markButton, updateInfo;

w = Window("MPBNew QA ‚Äì press X to mark issue", Rect(100, 100, 520, 180)).front.alwaysOnTop_(true);
infoView = StaticText(w, Rect(10, 10, 500, 40)).string_("Step: (pending)");
noteField = TextField(w, Rect(10, 60, 500, 24)).string_("Optional note about mismatch‚Ä¶");
markButton = Button(w, Rect(10, 100, 200, 30))
    .states_([["Mark Issue (X)", Color.white, Color.red]])
    .action_({ ~markIssue.("button") });

w.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { ~markIssue.("key") };
};

updateInfo = { |id, title, expected|
    infoView.string = "Step: % ‚Äî %\nExpect: %"
        .format(id, title, expected);
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) Diagnostics state + helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil
);

~snap = {
    (
        time: Main.elapsedTime,
        current: m.currentChain.copy,
        next: m.nextChain.copy,
        effCurrent: m.effectiveCurrent,
        effNext: m.effectiveNext,
        bypassCurrent: m.bypassKeysCurrent,
        bypassNext: m.bypassKeysNext
    )
};

~pushStep = { |id, title, expected, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: id,
        title: title,
        expected: expected,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
};

~markIssue = { |reason = "user pressed X"|
    var step;
    step = ~qa.currentStep;
    if(step.notNil) {
        step.userFlagged = true;
        step.userReason = reason;
        step.userNote = noteField.string;
        if(~qa.issues.includes(step.id).not) {
            ~qa.issues = ~qa.issues.add(step.id);
        };
        ("[QA] Issue marked at step %: %".format(step.id, reason)).postln;
        if(step.userNote.notNil and: { step.userNote != "" }) {
            ("[QA] Note: " ++ step.userNote).postln;
        };
    }{
        "[QA] No active step to mark yet.".postln;
    };
};

// narration helpers
~say = { |text| text.asString.postln; };
~countdown = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

// convenience: print both chains
~show = {
    "‚Äî Chains ‚Äî".postln;
    m.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) The narrated, interactive sequence
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Routine({
    var waitShort, waitMed, before, after;

    waitShort = 1.8;
    waitMed = 3.0;

    // A) Start silent on current (A)
    updateInfo.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    ~say.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    ~countdown.(3);
    before = ~snap.();
    m.setSourceCurrent(\ts0);
    m.playCurrent;
    ~show.();
    ~say.("You should hear nothing.");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("A1", "silent on CURRENT", "You should hear nothing.", before, after);

    // B) Change CURRENT source to Dust
    updateInfo.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    ~say.("Change CURRENT source to Dust(2000). Starting in");
    ~countdown.(3);
    before = ~snap.();
    m.setSourceCurrent(\tsDust);
    ~show.();
    ~say.("You should hear irregular noise bursts in stereo.");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", before, after);

    // C) Prepare NEXT with Saw + Tremolo, then switch
    updateInfo.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    ~say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    ~say.("Setting NEXT source to Saw in");
    ~countdown.(2);
    before = ~snap.();
    m.setSource(\tsSaw);
    m.add(\tremolo);     // inserts before source
    ~show.();
    ~say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    ~countdown.(3);
    m.switchChain;
    ~show.();
    ~say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", before, after);

    // D) Bypass tremolo on CURRENT, then un-bypass
    updateInfo.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    ~say.("Bypass CURRENT tremolo. Starting in");
    ~countdown.(2);
    before = ~snap.();
    m.bypassCurrent(\tremolo, true);
    ~show.();
    ~say.("You should hear plain Saw (no tremolo).");
    waitShort.wait;
    after = ~snap.();
    ~pushStep.("D1", "bypass tremolo", "Plain Saw", before, after);

    updateInfo.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    ~say.("Un-bypass CURRENT tremolo. Starting in");
    ~countdown.(2);
    before = ~snap.();
    m.bypassCurrent(\tremolo, false);
    ~show.();
    ~say.("Tremolo should be back.");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", before, after);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap order), then switch
    updateInfo.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    ~say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    ~say.("Adding \\atten at index 1 in");
    ~countdown.(2);
    before = ~snap.();
    m.addAt(\atten, 1);
    ~show.();

    ~say.("Adding \\lofi at index 2 in");
    ~countdown.(2);
    m.addAt(\lofi, 2);
    ~show.();

    ~say.("Swap NEXT indices 1 and 2 in");
    ~countdown.(2);
    m.swap(1, 2);
    ~show.();
    ~say.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    ~countdown.(3);
    m.switchChain;
    ~show.();
    ~say.("You should hear Saw with **lower level** and obvious **bitcrush/decimation**.");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", before, after);

    // F) Remove a processor on NEXT and clear
    updateInfo.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    ~say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    ~say.("Removing at index 1 on NEXT in");
    ~countdown.(2);
    before = ~snap.();
    m.removeAt(1);
    ~show.();

    ~say.("Clear NEXT back to [sink, source] in");
    ~countdown.(2);
    m.clearChain;
    ~show.();
    waitShort.wait;
    after = ~snap.();
    ~pushStep.("F1", "remove + clear NEXT", "[sink, source]", before, after);

    // G) Change NEXT source to Sine and switch
    updateInfo.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    ~say.("Set NEXT source to Sine and then switch.");
    ~say.("Starting in");
    ~countdown.(3);
    before = ~snap.();
    m.setSource(\tsSine);
    m.switchChain;
    ~show.();
    ~say.("You should now hear a steady sine tone.");
    waitMed.wait;
    after = ~snap.();
    ~pushStep.("G1", "switch to Sine", "Steady sine tone", before, after);

    // Wrap up
    updateInfo.("Z", "Demo complete", "Nothing playing after stop");
    ~say.("Demo complete. Stopping current chain in");
    ~countdown.(3);
    m.stopCurrent;

    // Summarize results
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged:".format(~qa.issues.size)).postln;
            ~qa.steps.do { |st|
                if(st[\userFlagged] == true) {
                    (st[\id] ++ " ‚Äî " ++ st[\title]).postln;
                    ("Expected: " ++ st[\expected]).postln;
                    ("Before: current=" ++ st[\before].current ++
                        " next=" ++ st[\before].next).postln;
                    ("After : current=" ++ st[\after].current ++
                        " next=" ++ st[\after].next).postln;
                    ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++
                        " / " ++ st[\after].bypassNext).postln;
                    if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                        ("Note: " ++ st[\userNote]).postln;
                    };
                    "".postln;
                };
            };
        };

        // Build a single string and copy to clipboard if possible
        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |st|
                    if(st[\userFlagged] == true) {
                        str << (st[\id] ++ " ‚Äî " ++ st[\title]) << Char.nl;
                        str << ("Expected: " ++ st[\expected]) << Char.nl;
                        str << ("Before: current=" ++ st[\before].current
                            ++ " next=" ++ st[\before].next) << Char.nl;
                        str << ("After : current=" ++ st[\after].current
                            ++ " next=" ++ st[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ st[\after].bypassCurrent
                            ++ " / " ++ st[\after].bypassNext) << Char.nl;
                        if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                            str << ("Note: " ++ st[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play;
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_5_TimedDemoWithQA.scd =====
/* Test_MagicPedalboardNew_v0_5_TimedDemoWithQA.scd
   Comprehensive, narrated demo with interactive QA for MagicPedalboardNew v0.1.5.

   HOW TO USE:
   - Keep the QA window focused. When narration says what you SHOULD hear,
     press 'X' (or click the red Mark Issue button) if you DON'T hear that.
   - You can add an optional note in the text field before marking the issue.
   - At the end, a diagnostic summary is printed (and copied to clipboard if supported).
*/

(
var w, infoView, noteField, markButton, updateInfo;
var waitShort, waitMed, beforeSnap, afterSnap;
var say, countdown, show, pushStep, markIssue, snap;

//////////////////////////////////////////////////////
// 0) Sources and processors (stereo; processors use \in)
//////////////////////////////////////////////////////
Ndef(\ts0,   { Silent.ar(2) });                      // silent (baseline)
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

// processors (clear audible effect choices)
Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

//////////////////////////////////////////////////////
// 1) Instantiate and reset pedalboard
//////////////////////////////////////////////////////
m = MagicPedalboardNew.new;
m.reset; // clean start every time

//////////////////////////////////////////////////////
// 2) QA data + helpers
//////////////////////////////////////////////////////
~qa = (steps: Array.new, issues: Array.new, currentStep: nil);

snap = {
    (
        time: Main.elapsedTime,
        current: m.currentChain.copy,
        next: m.nextChain.copy,
        effCurrent: m.effectiveCurrent,
        effNext: m.effectiveNext,
        bypassCurrent: m.bypassKeysCurrent,
        bypassNext: m.bypassKeysNext
    )
};

pushStep = { |id, title, expected, beforeDict, afterDict|
    var entry;
    entry = (
        id: id,
        title: title,
        expected: expected,
        before: beforeDict,
        after: afterDict,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
};

markIssue = { |reason = "user pressed X"|
    var step;
    step = ~qa.currentStep;
    if(step.notNil) {
        step.userFlagged = true;
        step.userReason = reason;
        step.userNote = noteField.string;
        if(~qa.issues.includes(step.id).not) {
            ~qa.issues = ~qa.issues.add(step.id);
        };
        ("[QA] Issue marked at step %: %".format(step.id, reason)).postln;
        if(step.userNote.notNil and: { step.userNote != "" }) {
            ("[QA] Note: " ++ step.userNote).postln;
        };
    }{
        "[QA] No active step to mark yet.".postln;
    };
};

say = { |text| text.asString.postln; };

countdown = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

show = {
    "‚Äî Chains ‚Äî".postln;
    m.printChains;
    "".postln;
};

//////////////////////////////////////////////////////
// 3) QA UI (press X or click the button to mark issue)
//////////////////////////////////////////////////////
w = Window("MPBNew QA ‚Äì press X to mark issue", Rect(100, 100, 520, 180)).front.alwaysOnTop_(true);
infoView = StaticText(w, Rect(10, 10, 500, 40)).string_("Step: (pending)");
noteField = TextField(w, Rect(10, 60, 500, 24)).string_("Optional note about mismatch‚Ä¶");
markButton = Button(w, Rect(10, 100, 200, 30))
    .states_([["Mark Issue (X)", Color.white, Color.red]])
    .action_({ markIssue.("button") });

w.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { markIssue.("key") };
};

updateInfo = { |id, title, expected|
    infoView.string = "Step: % ‚Äî %\nExpect: %"
        .format(id, title, expected);
};

//////////////////////////////////////////////////////
// 4) The narrated, interactive sequence
//////////////////////////////////////////////////////
waitShort = 1.8;
waitMed   = 3.0;

Routine({
    // A) Start silent on current (A)
    updateInfo.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    say.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdown.(3);
    beforeSnap = snap.();
    m.setSourceCurrent(\ts0);
    m.playCurrent;
    show.();
    say.("You should hear nothing.");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("A1", "silent on CURRENT", "You should hear nothing.", beforeSnap, afterSnap);

    // B) Change CURRENT source to Dust
    updateInfo.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    say.("Change CURRENT source to Dust(2000). Starting in");
    countdown.(3);
    beforeSnap = snap.();
    m.setSourceCurrent(\tsDust);
    show.();
    say.("You should hear irregular noise bursts in stereo.");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", beforeSnap, afterSnap);

    // C) Prepare NEXT with Saw + Tremolo, then switch
    updateInfo.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    say.("Setting NEXT source to Saw in");
    countdown.(2);
    beforeSnap = snap.();
    m.setSource(\tsSaw);
    m.add(\tremolo);     // inserts before source
    show.();
    say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdown.(3);
    m.switchChain;
    show.();
    say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeSnap, afterSnap);

    // D) Bypass tremolo on CURRENT, then un-bypass
    updateInfo.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    say.("Bypass CURRENT tremolo. Starting in");
    countdown.(2);
    beforeSnap = snap.();
    m.bypassCurrent(\tremolo, true);
    show.();
    say.("You should hear plain Saw (no tremolo).");
    waitShort.wait;
    afterSnap = snap.();
    pushStep.("D1", "bypass tremolo", "Plain Saw", beforeSnap, afterSnap);

    updateInfo.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    say.("Un-bypass CURRENT tremolo. Starting in");
    countdown.(2);
    beforeSnap = snap.();
    m.bypassCurrent(\tremolo, false);
    show.();
    say.("Tremolo should be back.");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", beforeSnap, afterSnap);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap order), then switch
    updateInfo.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    say.("Adding \\atten at index 1 in");
    countdown.(2);
    beforeSnap = snap.();
    m.addAt(\atten, 1);
    show.();

    say.("Adding \\lofi at index 2 in");
    countdown.(2);
    m.addAt(\lofi, 2);
    show.();

    say.("Swap NEXT indices 1 and 2 in");
    countdown.(2);
    m.swap(1, 2);
    show.();
    say.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdown.(3);
    m.switchChain;
    show.();
    say.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeSnap, afterSnap);

    // F) Remove a processor on NEXT and clear
    updateInfo.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    say.("Removing at index 1 on NEXT in");
    countdown.(2);
    beforeSnap = snap.();
    m.removeAt(1);
    show.();

    say.("Clear NEXT back to [sink, source] in");
    countdown.(2);
    m.clearChain;
    show.();
    waitShort.wait;
    afterSnap = snap.();
    pushStep.("F1", "remove + clear NEXT", "[sink, source]", beforeSnap, afterSnap);

    // G) Change NEXT source to Sine and switch
    updateInfo.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    say.("Set NEXT source to Sine and then switch.");
    say.("Starting in");
    countdown.(3);
    beforeSnap = snap.();
    m.setSource(\tsSine);
    m.switchChain;
    show.();
    say.("You should now hear a steady sine tone.");
    waitMed.wait;
    afterSnap = snap.();
    pushStep.("G1", "switch to Sine", "Steady sine tone", beforeSnap, afterSnap);

    // Wrap up
    updateInfo.("Z", "Demo complete", "Nothing playing after stop");
    say.("Demo complete. Stopping current chain in");
    countdown.(3);
    m.stopCurrent;

    // Summary
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged:".format(~qa.issues.size)).postln;
            ~qa.steps.do { |st|
                if(st[\userFlagged] == true) {
                    (st[\id] ++ " ‚Äî " ++ st[\title]).postln;
                    ("Expected: " ++ st[\expected]).postln;
                    ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next).postln;
                    ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next).postln;
                    ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext).postln;
                    if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                        ("Note: " ++ st[\userNote]).postln;
                    };
                    "".postln;
                };
            };
        };

        // Build single string and copy to clipboard if possible
        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |st|
                    if(st[\userFlagged] == true) {
                        str << (st[\id] ++ " ‚Äî " ++ st[\title]) << Char.nl;
                        str << ("Expected: " ++ st[\expected]) << Char.nl;
                        str << ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next) << Char.nl;
                        str << ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext) << Char.nl;
                        if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                            str << ("Note: " ++ st[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play;
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_6_TimedDemoWithQA.scd =====
/* Test_MagicPedalboardNew_v0_6_TimedDemoWithQA.scd
   Comprehensive, narrated demo with interactive QA for MagicPedalboardNew v0.1.5.

   HOW TO USE:
   - Keep the QA window focused. When narration says what you SHOULD hear,
     press 'X' (or click the red Mark Issue button) if you DON'T hear that.
   - You can add an optional note in the text field before marking the issue.
   - At the end, a diagnostic summary is printed (and copied to clipboard if supported).
*/

(
var w, infoView, noteField, markButton, updateInfo;
var waitShort, waitMed, beforeSnap, afterSnap;
var say, countdown, show, pushStep, markIssue, snap, run;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent (baseline)
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

// processors (clear audible effect choices)
Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/* 1) Instantiate and reset pedalboard */
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
m = MagicPedalboardNew.new;
m.reset; // clean start every time

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/* 2) QA data + helpers (no GUI calls here) */
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (steps: Array.new, issues: Array.new, currentStep: nil);

snap = {
    (
        time: Main.elapsedTime,
        current: m.currentChain.copy,
        next: m.nextChain.copy,
        effCurrent: m.effectiveCurrent,
        effNext: m.effectiveNext,
        bypassCurrent: m.bypassKeysCurrent,
        bypassNext: m.bypassKeysNext
    )
};

pushStep = { |id, title, expected, beforeDict, afterDict|
    var entry;
    entry = (
        id: id,
        title: title,
        expected: expected,
        before: beforeDict,
        after: afterDict,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
};

markIssue = { |reason = "user pressed X"|
    var step;
    step = ~qa.currentStep;
    if(step.notNil) {
        step.userFlagged = true;
        step.userReason = reason;
        step.userNote = noteField.string;
        if(~qa.issues.includes(step.id).not) {
            ~qa.issues = ~qa.issues.add(step.id);
        };
        ("[QA] Issue marked at step %: %".format(step.id, reason)).postln;
        if(step.userNote.notNil and: { step.userNote != "" }) {
            ("[QA] Note: " ++ step.userNote).postln;
        };
    }{
        "[QA] No active step to mark yet.".postln;
    };
};

say = { |text| text.asString.postln; };

countdown = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

show = {
    "‚Äî Chains ‚Äî".postln;
    m.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/* 3) QA UI (GUI must run on AppClock; we also defer updates) */
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
w = Window("MPBNew QA ‚Äì press X to mark issue", Rect(100, 100, 520, 180)).front.alwaysOnTop_(true);
infoView = StaticText(w, Rect(10, 10, 500, 40)).string_("Step: (pending)");
noteField = TextField(w, Rect(10, 60, 500, 24)).string_("Optional note about mismatch‚Ä¶");
markButton = Button(w, Rect(10, 100, 200, 30))
    .states_([["Mark Issue (X)", Color.white, Color.red]])
    .action_({ markIssue.("button") });

w.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { markIssue.("key") };
};

updateInfo = { |id, title, expected|
    AppClock.sched(0, {
        infoView.string = "Step: % ‚Äî %\nExpect: %".format(id, title, expected);
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/* 4) The narrated, interactive sequence (RUN ON AppClock) */
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShort = 1.8;
waitMed   = 3.0;

run = Routine({
    var beforeDict, afterDict;

    // A) Start silent on current (A)
    updateInfo.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    say.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdown.(3);
    beforeDict = snap.();
    m.setSourceCurrent(\ts0);
    m.playCurrent;
    show.();
    say.("You should hear nothing.");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    updateInfo.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    say.("Change CURRENT source to Dust(2000). Starting in");
    countdown.(3);
    beforeDict = snap.();
    m.setSourceCurrent(\tsDust);
    show.();
    say.("You should hear irregular noise bursts in stereo.");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT with Saw + Tremolo, then switch
    updateInfo.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    say.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    say.("Setting NEXT source to Saw in");
    countdown.(2);
    beforeDict = snap.();
    m.setSource(\tsSaw);
    m.add(\tremolo);     // inserts before source
    show.();
    say.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdown.(3);
    m.switchChain;
    show.();
    say.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    updateInfo.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    say.("Bypass CURRENT tremolo. Starting in");
    countdown.(2);
    beforeDict = snap.();
    m.bypassCurrent(\tremolo, true);
    show.();
    say.("You should hear plain Saw (no tremolo).");
    waitShort.wait;
    afterDict = snap.();
    pushStep.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    updateInfo.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    say.("Un-bypass CURRENT tremolo. Starting in");
    countdown.(2);
    beforeDict = snap.();
    m.bypassCurrent(\tremolo, false);
    show.();
    say.("Tremolo should be back.");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap order), then switch
    updateInfo.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    say.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    say.("Adding \\atten at index 1 in");
    countdown.(2);
    beforeDict = snap.();
    m.addAt(\atten, 1);
    show.();

    say.("Adding \\lofi at index 2 in");
    countdown.(2);
    m.addAt(\lofi, 2);
    show.();

    say.("Swap NEXT indices 1 and 2 in");
    countdown.(2);
    m.swap(1, 2);
    show.();
    say.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdown.(3);
    m.switchChain;
    show.();
    say.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) Remove a processor on NEXT and clear
    updateInfo.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    say.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    say.("Removing at index 1 on NEXT in");
    countdown.(2);
    beforeDict = snap.();
    m.removeAt(1);
    show.();

    say.("Clear NEXT back to [sink, source] in");
    countdown.(2);
    m.clearChain;
    show.();
    waitShort.wait;
    afterDict = snap.();
    pushStep.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) Change NEXT source to Sine and switch
    updateInfo.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    say.("Set NEXT source to Sine and then switch.");
    say.("Starting in");
    countdown.(3);
    beforeDict = snap.();
    m.setSource(\tsSine);
    m.switchChain;
    show.();
    say.("You should now hear a steady sine tone.");
    waitMed.wait;
    afterDict = snap.();
    pushStep.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    updateInfo.("Z", "Demo complete", "Nothing playing after stop");
    say.("Demo complete. Stopping current chain in");
    countdown.(3);
    m.stopCurrent;

    // Summary (on AppClock already; safe for GUI clipboard)
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged:".format(~qa.issues.size)).postln;
            ~qa.steps.do { |st|
                if(st[\userFlagged] == true) {
                    (st[\id] ++ " ‚Äî " ++ st[\title]).postln;
                    ("Expected: " ++ st[\expected]).postln;
                    ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next).postln;
                    ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next).postln;
                    ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext).postln;
                    if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                        ("Note: " ++ st[\userNote]).postln;
                    };
                    "".postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |st|
                    if(st[\userFlagged] == true) {
                        str << (st[\id] ++ " ‚Äî " ++ st[\title]) << Char.nl;
                        str << ("Expected: " ++ st[\expected]) << Char.nl;
                        str << ("Before: current=" ++ st[\before].current ++ " next=" ++ st[\before].next) << Char.nl;
                        str << ("After : current=" ++ st[\after].current ++ " next=" ++ st[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ st[\after].bypassCurrent ++ " / " ++ st[\after].bypassNext) << Char.nl;
                        if(st[\userNote].notNil and: { st[\userNote] != "" }) {
                            str << ("Note: " ++ st[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(AppClock);   // <<< Run the Routine on AppClock
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_7_TimedDemoWithQA.scd =====
/* Test_MagicPedalboardNew_v0_7_TimedDemoWithQA.scd
   Comprehensive, narrated demo with interactive QA for MagicPedalboardNew v0.1.5.

   HOW TO USE:
   - Keep the QA window focused. When narration says what you SHOULD hear,
     press 'X' (or click the red Mark Issue button) if you DON'T hear that.
   - You can add an optional note in the text field before marking the issue.
   - At the end, a diagnostic summary is printed (and copied to clipboard if supported).
*/

(
var qaWindow, infoText, noteTextField, markIssueButton, updateInfoFn;
var waitShortDur, waitMedDur, beforeSnapshot, afterSnapshot;
var sayFn, countdownFn, showFn, pushStepFn, markIssueFn, snapshotFn, runRoutine;
var pedalboard;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent (baseline)
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

// processors (clear audible effect choices)
Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate and reset pedalboard
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // clean start every time

// helper: set current source, with fallback if method is absent
~setCurrentSource = { |key|
    if(pedalboard.respondsTo(\setSourceCurrent)) {
        pedalboard.setSourceCurrent(key);
    }{
        // fallback: switch to NEXT, set its source, switch back
        pedalboard.switchChain;
        pedalboard.setSource(key);
        pedalboard.switchChain;
    }
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA data + helpers (no GUI calls here)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (steps: Array.new, issues: Array.new, currentStep: nil);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeDict, afterDict|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeDict,
        after: afterDict,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
};

markIssueFn = { |reason = "user pressed X"|
    var stepEntry;
    stepEntry = ~qa.currentStep;
    if(stepEntry.notNil) {
        stepEntry.userFlagged = true;
        stepEntry.userReason = reason;
        stepEntry.userNote = noteTextField.string;
        if(~qa.issues.includes(stepEntry.id).not) {
            ~qa.issues = ~qa.issues.add(stepEntry.id);
        };
        ("[QA] Issue marked at step %: %".format(stepEntry.id, reason)).postln;
        if(stepEntry.userNote.notNil and: { stepEntry.userNote != "" }) {
            ("[QA] Note: " ++ stepEntry.userNote).postln;
        };
    }{
        "[QA] No active step to mark yet.".postln;
    };
};

sayFn = { |text| text.asString.postln; };

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

showFn = {
    "‚Äî Chains ‚Äî".postln;
    pedalboard.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) QA UI (GUI must run on AppClock; we also defer updates)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
qaWindow = Window("MPBNew QA ‚Äì press X to mark issue", Rect(100, 100, 520, 180)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 500, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 500, 24)).string_("Optional note about mismatch‚Ä¶");
markIssueButton = Button(qaWindow, Rect(10, 100, 200, 30))
    .states_([["Mark Issue (X)", Color.white, Color.red]])
    .action_({ markIssueFn.("button") });

qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { markIssueFn.("key") };
};

updateInfoFn = { |stepId, stepTitle, expectedText|
    AppClock.sched(0, {
        infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) The narrated, interactive sequence (RUN ON AppClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    var beforeDict, afterDict;

    // A) Start silent on current (A)
    updateInfoFn.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    ~setCurrentSource.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    updateInfoFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    ~setCurrentSource.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT with Saw + Tremolo, then switch
    updateInfoFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.setSource(\tsSaw);
    pedalboard.add(\tremolo);     // inserts before source
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    updateInfoFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitShortDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    updateInfoFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap order), then switch
    updateInfoFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) Remove a processor on NEXT and clear
    updateInfoFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitShortDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) Change NEXT source to Sine and switch
    updateInfoFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    pedalboard.setSource(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    updateInfoFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged:".format(~qa.issues.size)).postln;
            ~qa.steps.do { |stepEntry|
                if(stepEntry[\userFlagged] == true) {
                    (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]).postln;
                    ("Expected: " ++ stepEntry[\expected]).postln;
                    ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next).postln;
                    ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next).postln;
                    ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext).postln;
                    if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                        ("Note: " ++ stepEntry[\userNote]).postln;
                    };
                    "".postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |stepEntry|
                    if(stepEntry[\userFlagged] == true) {
                        str << (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]) << Char.nl;
                        str << ("Expected: " ++ stepEntry[\expected]) << Char.nl;
                        str << ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next) << Char.nl;
                        str << ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext) << Char.nl;
                        if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                            str << ("Note: " ++ stepEntry[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(AppClock);   // <<< Run the Routine on AppClock
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_8_TimedDemoWithQA.scd =====
/* Test_MagicPedalboardNew_v0_8_TimedDemoWithQA.scd
   Interactive, narrated QA demo for MagicPedalboardNew v0.1.5
   - Runs on AppClock
   - GUI updates are deferred
   - Falls back if setSource / setSourceCurrent are missing
*/

(
var qaWindow, infoText, noteTextField, markIssueButton, updateInfoFn;
var waitShortDur, waitMedDur, beforeSnapshot, afterSnapshot;
var sayFn, countdownFn, showFn, pushStepFn, markIssueFn, snapshotFn, runRoutine;
var pedalboard;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent (baseline)
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // noisy bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate + reset
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline

// robust helpers for source setting
~setCurrentSource = { |key|
    if(pedalboard.respondsTo(\setSourceCurrent)) {
        pedalboard.setSourceCurrent(key);
    }{
        // fallback: switch to NEXT (which was next), set its source as current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: no setSourceCurrent available; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

~setNextSource = { |key|
    if(pedalboard.respondsTo(\setSource)) {
        pedalboard.setSource(key);
    }{
        // fallback: temporarily switch to NEXT, set its current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA data + helpers (no GUI calls here)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (steps: Array.new, issues: Array.new, currentStep: nil);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeDict, afterDict|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeDict,
        after: afterDict,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;
};

markIssueFn = { |reason = "user pressed X"|
    var stepEntry;
    stepEntry = ~qa.currentStep;
    if(stepEntry.notNil) {
        stepEntry.userFlagged = true;
        stepEntry.userReason = reason;
        stepEntry.userNote = noteTextField.string;
        if(~qa.issues.includes(stepEntry.id).not) {
            ~qa.issues = ~qa.issues.add(stepEntry.id);
        };
        ("[QA] Issue marked at step %: %".format(stepEntry.id, reason)).postln;
        if(stepEntry.userNote.notNil and: { stepEntry.userNote != "" }) {
            ("[QA] Note: " ++ stepEntry.userNote).postln;
        };
    }{
        "[QA] No active step to mark yet.".postln;
    };
};

sayFn = { |text| text.asString.postln; };

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    "Now.".postln;
};

showFn = {
    "‚Äî Chains ‚Äî".postln;
    pedalboard.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) QA UI (AppClock-safe GUI)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
qaWindow = Window("MPBNew QA ‚Äì press X to mark issue", Rect(100, 100, 520, 180)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 500, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 500, 24)).string_("Optional note about mismatch‚Ä¶");
markIssueButton = Button(qaWindow, Rect(10, 100, 200, 30))
    .states_([["Mark Issue (X)", Color.white, Color.red]])
    .action_({ markIssueFn.("button") });

qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { markIssueFn.("key") };
};

updateInfoFn = { |stepId, stepTitle, expectedText|
    AppClock.sched(0, {
        infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) Narrated sequence (RUN ON AppClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShortDur = 1.8;
waitMedDur   = 3.0;

Routine({
    var beforeDict, afterDict;

    // A) Start silent on CURRENT
    updateInfoFn.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    ~setCurrentSource.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    updateInfoFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    ~setCurrentSource.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    updateInfoFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    ~setNextSource.(\tsSaw);      // robust NEXT setter
    pedalboard.add(\tremolo);
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass / un-bypass tremolo on CURRENT
    updateInfoFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitShortDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    updateInfoFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    updateInfoFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    updateInfoFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitShortDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    updateInfoFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    ~setNextSource.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitMedDur.wait;
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    updateInfoFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary (AppClock-safe)
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged:".format(~qa.issues.size)).postln;
            ~qa.steps.do { |stepEntry|
                if(stepEntry[\userFlagged] == true) {
                    (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]).postln;
                    ("Expected: " ++ stepEntry[\expected]).postln;
                    ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next).postln;
                    ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next).postln;
                    ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext).postln;
                    if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                        ("Note: " ++ stepEntry[\userNote]).postln;
                    };
                    "".postln;
                };
            };
        };

        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |stepEntry|
                    if(stepEntry[\userFlagged] == true) {
                        str << (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]) << Char.nl;
                        str << ("Expected: " ++ stepEntry[\expected]) << Char.nl;
                        str << ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next) << Char.nl;
                        str << ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext) << Char.nl;
                        if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                            str << ("Note: " ++ stepEntry[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(AppClock);
)

===== Magicpedalboard/old/Test_MagicPedalboardNew_v0_9_QA_PauseResume.scd =====
/* Test_MagicPedalboardNew_v0_9_QA_PauseResume.scd
   Interactive, narrated QA demo for MagicPedalboardNew v0.1.5
   - Two-step issue capture:
       [Report Issue (Pause)] -> type note -> [Submit Issue & Resume]  (or [Resume (No Issue)])
   - Runs on AppClock; GUI updates are deferred.
   - Robust against missing setSource / setSourceCurrent (uses fallbacks).
*/

(
var qaWindow, infoText, noteTextField, reportButton, submitButton, resumeButton, updateInfoFn;
var waitShortDur, waitMedDur;
var sayFn, countdownFn, showFn;
var snapshotFn, setActiveStepFn, pushStepFn, absorbPendingIssueForFn;
var requestPauseFn, waitIfPausedFn, submitIssueFn, resumeNoIssueFn;
var setCurrentSourceRobustFn, setNextSourceRobustFn;
var runRoutine;

var beforeDict, afterDict;     // used within the Routine
var activeStepId, activeStepTitle, activeStepExpected;

var pedalboard;

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 0) Sources and processors (stereo; processors use \in)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Ndef(\ts0,   { Silent.ar(2) });                      // silent baseline
Ndef(\tsDust,{ Dust.ar(2000) ! 2 });                 // irregular bursts
Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });             // bright saw
Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });       // steady sine

Ndef(\tremolo, { |rate = 4, depth = 0.9|
    var inputSignal, mod;
    inputSignal = \in.ar(2);
    mod = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * mod
});

Ndef(\lofi, { |bits = 4, rate = 4000|
    var inputSignal;
    inputSignal = \in.ar(2);
    Decimator.ar(inputSignal, rate, bits)
});

Ndef(\atten, { |gain = 0.25|
    var inputSignal;
    inputSignal = \in.ar(2) * gain;
    inputSignal
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 1) Instantiate + reset
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
pedalboard = MagicPedalboardNew.new;
pedalboard.reset; // canonical baseline

// Robust helpers for source setting (handle older class versions)
setCurrentSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSourceCurrent);
    if(hasSetter) {
        pedalboard.setSourceCurrent(key);
    }{
        // fallback: temporarily switch, set NEXT as current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: setSourceCurrent missing; cannot set current source.".warn;
        };
        pedalboard.switchChain;
    }
};

setNextSourceRobustFn = { |key|
    var hasSetter;
    hasSetter = pedalboard.respondsTo(\setSource);
    if(hasSetter) {
        pedalboard.setSource(key);
    }{
        // fallback: temporarily switch to make NEXT current, set current, switch back
        pedalboard.switchChain;
        if(pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(key);
        }{
            "ERROR: missing setSource and setSourceCurrent; cannot set next source.".warn;
        };
        pedalboard.switchChain;
    }
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 2) QA state (no GUI calls here)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
~qa = (
    steps: Array.new,
    issues: Array.new,
    currentStep: nil,           // after a step is pushed, points to that entry
    pendingIssues: IdentityDictionary.new,   // stepId -> (reason:, note:)
    pauseRequested: false,
    pauseCondition: Condition.new
);

snapshotFn = {
    (
        time: Main.elapsedTime,
        current: pedalboard.currentChain.copy,
        next: pedalboard.nextChain.copy,
        effCurrent: pedalboard.effectiveCurrent,
        effNext: pedalboard.effectiveNext,
        bypassCurrent: pedalboard.bypassKeysCurrent,
        bypassNext: pedalboard.bypassKeysNext
    )
};

setActiveStepFn = { |stepId, stepTitle, expectedText|
    // not yet pushing; just announcing the "current" step context
    activeStepId = stepId;
    activeStepTitle = stepTitle;
    activeStepExpected = expectedText;
    AppClock.sched(0, {
        infoText.string = "Step: % ‚Äî %\nExpect: %".format(stepId, stepTitle, expectedText);
        nil
    });
};

pushStepFn = { |stepId, stepTitle, expectedText, beforeSnap, afterSnap|
    var entry;
    entry = (
        id: stepId,
        title: stepTitle,
        expected: expectedText,
        before: beforeSnap,
        after: afterSnap,
        userFlagged: false,
        userReason: nil,
        userNote: nil
    );
    ~qa.steps = ~qa.steps.add(entry);
    ~qa.currentStep = entry;

    // If the user paused earlier for this step and submitted, fold that in now
    absorbPendingIssueForFn.(stepId, entry);
};

absorbPendingIssueForFn = { |stepId, entry|
    var pending;
    pending = ~qa.pendingIssues[stepId];
    if(pending.notNil) {
        entry[\userFlagged] = true;
        entry[\userReason] = pending[\reason];
        entry[\userNote] = pending[\note];
        if(~qa.issues.includes(stepId).not) {
            ~qa.issues = ~qa.issues.add(stepId);
        };
        ~qa.pendingIssues.removeAt(stepId);
    };
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 3) Pause / resume workflow
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
requestPauseFn = {
    // called from GUI "Report Issue (Pause)"
    ~qa.pauseRequested = true;
    AppClock.sched(0, {
        infoText.string = "PAUSED at % ‚Äî %\nType your note, then Submit or Resume."
            .format(activeStepId ? "(unknown)", activeStepTitle ? "(unknown)");
        nil
    });
};

waitIfPausedFn = {
    // called from within the Routine at safe checkpoints
    while { ~qa.pauseRequested } {
        ~qa.pauseCondition.wait; // waits until submit or resume
    };
};

submitIssueFn = {
    var noteText, reasonText, stepIdLocal;
    noteText = noteTextField.string;
    reasonText = "user report (paused)";
    stepIdLocal = activeStepId ? ("unknown-" ++ Main.elapsedTime.round(0.01));
    ~qa.pendingIssues[stepIdLocal] = (reason: reasonText, note: noteText);

    // mark *something* in the console immediately for traceability
    ("[QA] Issue captured for step %".format(stepIdLocal)).postln;
    if(noteText.notNil and: { noteText != "" }) { ("[QA] Note: " ++ noteText).postln };

    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Captured issue for step %.\nResuming‚Ä¶".format(stepIdLocal);
        nil
    });
};

resumeNoIssueFn = {
    ~qa.pauseRequested = false;
    ~qa.pauseCondition.signal;

    AppClock.sched(0, {
        infoText.string = "Resuming without logging an issue‚Ä¶";
        nil
    });
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 4) Console helpers
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
sayFn = { |text|
    var msg;
    msg = text.asString;
    msg.postln;
};

countdownFn = { |seconds = 3|
    var remaining;
    remaining = seconds;
    while { remaining > 0 } {
        // allow mid-countdown pause
        waitIfPausedFn.();     // pause immediately if requested
        (remaining.asString ++ "...").postln;
        1.wait;
        remaining = remaining - 1;
    };
    waitIfPausedFn.();         // pause again before executing the action
    "Now.".postln;
};

showFn = {
    "‚Äî Chains ‚Äî".postln;
    pedalboard.printChains;
    "".postln;
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 5) QA UI (AppClock-safe GUI)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
qaWindow = Window("MPBNew QA ‚Äì two-step issue capture", Rect(100, 100, 640, 210)).front.alwaysOnTop_(true);
infoText = StaticText(qaWindow, Rect(10, 10, 620, 40)).string_("Step: (pending)");
noteTextField = TextField(qaWindow, Rect(10, 60, 620, 24)).string_("Type your note here‚Ä¶");

// left: report (pause). middle: submit & resume. right: resume without logging.
reportButton = Button(qaWindow, Rect(10, 100, 200, 30))
    .states_([["Report Issue (Pause)", Color.white, Color.red]])
    .action_({ requestPauseFn.() });

submitButton = Button(qaWindow, Rect(220, 100, 200, 30))
    .states_([["Submit Issue & Resume", Color.white, Color(0, 0.5, 0)]])
    .action_({ submitIssueFn.() });

resumeButton = Button(qaWindow, Rect(430, 100, 200, 30))
    .states_([["Resume (No Issue)", Color.white, Color.gray]])
    .action_({ resumeNoIssueFn.() });

// convenience keyboard: X pauses, Enter submits, Esc resumes without logging
qaWindow.view.keyDownAction = { |view, char, modifiers, unicode, keycode|
    if(char == $x or: { char == $X }) { requestPauseFn.() };
    if(keycode == 36 or: { keycode == 52 }) { submitIssueFn.() }; // Enter / keypad Enter
    if(keycode == 53) { resumeNoIssueFn.() };                      // Esc
};

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// 6) Narrated sequence (RUN ON AppClock)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
waitShortDur = 1.8;
waitMedDur   = 3.0;

runRoutine = Routine({
    // A) Start silent on CURRENT
    setActiveStepFn.("A1", "Start silent \\\\ts0 on CURRENT", "Silence");
    sayFn.("Starting with a silent CURRENT chain: [\\chainA, \\ts0]. Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\ts0);
    pedalboard.playCurrent;
    showFn.();
    sayFn.("You should hear nothing.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("A1", "silent on CURRENT", "You should hear nothing.", beforeDict, afterDict);

    // B) Change CURRENT source to Dust
    setActiveStepFn.("B1", "Change CURRENT source to Dust", "Irregular noise bursts (stereo)");
    sayFn.("Change CURRENT source to Dust(2000). Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setCurrentSourceRobustFn.(\tsDust);
    showFn.();
    sayFn.("You should hear irregular noise bursts in stereo.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("B1", "dust on CURRENT", "Irregular noise bursts", beforeDict, afterDict);

    // C) Prepare NEXT: Saw + Tremolo, then switch
    setActiveStepFn.("C1", "Prepare NEXT: Saw + Tremolo, then switch", "Saw with deep tremolo");
    sayFn.("Prepare NEXT: set source to Saw; add Tremolo just before the source.");
    sayFn.("Setting NEXT source to Saw in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSaw);
    pedalboard.add(\tremolo);     // inserts before source
    showFn.();
    sayFn.("Switch to NEXT (so Tremolo+Saw becomes CURRENT). Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear a saw tone with strong amplitude modulation (tremolo).");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("C1", "switch to Saw + Tremolo", "Saw with strong tremolo", beforeDict, afterDict);

    // D) Bypass tremolo on CURRENT, then un-bypass
    setActiveStepFn.("D1", "Bypass CURRENT tremolo", "Plain Saw (no tremolo)");
    sayFn.("Bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, true);
    showFn.();
    sayFn.("You should hear plain Saw (no tremolo).");
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D1", "bypass tremolo", "Plain Saw", beforeDict, afterDict);

    setActiveStepFn.("D2", "Un-bypass CURRENT tremolo", "Saw with tremolo returns");
    sayFn.("Un-bypass CURRENT tremolo. Starting in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.bypassCurrent(\tremolo, false);
    showFn.();
    sayFn.("Tremolo should be back.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("D2", "un-bypass tremolo", "Saw with tremolo", beforeDict, afterDict);

    // E) Prepare NEXT: Atten + Lofi + Saw (swap), then switch
    setActiveStepFn.("E1", "Prepare NEXT: add Atten then Lofi; swap; then switch", "Saw with heavy attenuation + crushing");
    sayFn.("Prepare NEXT: add \\atten near sink (index 1) and \\lofi after it, then swap them.");
    sayFn.("Adding \\atten at index 1 in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.addAt(\atten, 1);
    showFn.();

    sayFn.("Adding \\lofi at index 2 in");
    countdownFn.(2);
    pedalboard.addAt(\lofi, 2);
    showFn.();

    sayFn.("Swap NEXT indices 1 and 2 in");
    countdownFn.(2);
    pedalboard.swap(1, 2);
    showFn.();
    sayFn.("Switch to NEXT so Atten+Lofi+Saw becomes CURRENT. Starting in");
    countdownFn.(3);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should hear Saw with lower level and obvious bitcrush/decimation.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("E1", "switch to Atten+Lofi+Saw", "Quiet + crushed Saw", beforeDict, afterDict);

    // F) On NEXT: remove index 1, then clear
    setActiveStepFn.("F1", "On NEXT: remove index 1, then clear", "NEXT ends as [sink, source]");
    sayFn.("On NEXT, remove the processor at index 1 (nearest the sink), then clear.");
    sayFn.("Removing at index 1 on NEXT in");
    countdownFn.(2);
    beforeDict = snapshotFn.();
    pedalboard.removeAt(1);
    showFn.();

    sayFn.("Clear NEXT back to [sink, source] in");
    countdownFn.(2);
    pedalboard.clearChain;
    showFn.();
    waitIfPausedFn.(); waitShortDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("F1", "remove + clear NEXT", "[sink, source]", beforeDict, afterDict);

    // G) NEXT source to Sine, then switch
    setActiveStepFn.("G1", "Set NEXT source to Sine, then switch", "Steady sine tone");
    sayFn.("Set NEXT source to Sine and then switch.");
    sayFn.("Starting in");
    countdownFn.(3);
    beforeDict = snapshotFn.();
    setNextSourceRobustFn.(\tsSine);
    pedalboard.switchChain;
    showFn.();
    sayFn.("You should now hear a steady sine tone.");
    waitIfPausedFn.(); waitMedDur.wait; waitIfPausedFn.();
    afterDict = snapshotFn.();
    pushStepFn.("G1", "switch to Sine", "Steady sine tone", beforeDict, afterDict);

    // Wrap up
    setActiveStepFn.("Z", "Demo complete", "Nothing playing after stop");
    sayFn.("Demo complete. Stopping current chain in");
    countdownFn.(3);
    pedalboard.stopCurrent;

    // Summary
    {
        var summaryStr;

        "========== MagicPedalboardNew QA Summary ==========".postln;
        ("Class " ++ MagicPedalboardNew.version).postln;
        ("Steps run: " ++ ~qa.steps.size).postln;
        if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
            "No issues were flagged. üéâ".postln;
        }{
            ("% issues flagged (submitted during run):".format(~qa.issues.size)).postln;
            ~qa.steps.do { |stepEntry|
                if(stepEntry[\userFlagged] == true) {
                    (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]).postln;
                    ("Expected: " ++ stepEntry[\expected]).postln;
                    ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next).postln;
                    ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next).postln;
                    ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext).postln;
                    if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                        ("Note: " ++ stepEntry[\userNote]).postln;
                    };
                    "".postln;
                };
            };

            // Any issues submitted while paused *before* a step was pushed
            if(~qa.pendingIssues.size > 0) {
                "Pending issues captured before step completion:".postln;
                ~qa.pendingIssues.keysValuesDo { |sid, rec|
                    (sid ++ "  (no step snapshot available yet)").postln;
                    ("Note: " ++ rec[\note]).postln;
                };
            };
        };

        // One-line string for clipboard
        summaryStr = String.streamContents { |str|
            str << "========== MagicPedalboardNew QA Summary ==========" << Char.nl;
            str << ("Class " ++ MagicPedalboardNew.version) << Char.nl;
            str << ("Steps run: " ++ ~qa.steps.size) << Char.nl;
            if(~qa.issues.size == 0 and: { ~qa.pendingIssues.size == 0 }) {
                str << "No issues were flagged." << Char.nl;
            }{
                str << ("% issues flagged:".format(~qa.issues.size)) << Char.nl;
                ~qa.steps.do { |stepEntry|
                    if(stepEntry[\userFlagged] == true) {
                        str << (stepEntry[\id] ++ " ‚Äî " ++ stepEntry[\title]) << Char.nl;
                        str << ("Expected: " ++ stepEntry[\expected]) << Char.nl;
                        str << ("Before: current=" ++ stepEntry[\before].current ++ " next=" ++ stepEntry[\before].next) << Char.nl;
                        str << ("After : current=" ++ stepEntry[\after].current ++ " next=" ++ stepEntry[\after].next) << Char.nl;
                        str << ("Bypass(Current/Next): " ++ stepEntry[\after].bypassCurrent ++ " / " ++ stepEntry[\after].bypassNext) << Char.nl;
                        if(stepEntry[\userNote].notNil and: { stepEntry[\userNote] != "" }) {
                            str << ("Note: " ++ stepEntry[\userNote]) << Char.nl;
                        };
                        str << Char.nl;
                    };
                };

                if(~qa.pendingIssues.size > 0) {
                    str << "Pending issues captured before step completion:" << Char.nl;
                    ~qa.pendingIssues.keysValuesDo { |sid, rec|
                        str << sid << "  (no step snapshot available yet)" << Char.nl;
                        str << ("Note: " ++ rec[\note]) << Char.nl;
                    };
                };
            };
        };

        if(GUI.respondsTo(\setClipboard)) {
            GUI.setClipboard(summaryStr);
            "Summary copied to clipboard.".postln;
        };
    }.value;

}).play(AppClock);
)

===== Magicpedalboard/old/Test_MPB_Sanity_NoGUI_v0_13.scd =====
// Test_MPB_Sanity_NoGUI_v0_13.scd
// MD 20250911-1320

(
// Run everything only after the server is up.
s.waitForBoot({
    var say, countdown, show, sanityPreflight, setCurrent, setNext;
    var m;

    say = { |txt| txt.asString.postln };
    countdown = { |n = 3|
        n.do { |i| ((n - i).asString ++ "...").postln; 1.wait }; "Now.".postln;
    };
    show = {
        "‚Äî Chains ‚Äî".postln;
        m.printChains;
        "".postln;
    };

    // ---- Safe preflight (no s.freeAll), clear any old JITLib state ----
    sanityPreflight = {
        "== Preflight ==".postln;

        // stop + clear any Ndefs lingering from older sessions
        Ndef.all.keysValuesDo { |k, p|
            if(p.isPlaying) { ("[CLEAN] stop " ++ k).postln; p.stop };
            p.clear;
        };

        // clear all ProxySpaces we can see
        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo { |srv, ps|
                if(ps.notNil) { ("[CLEAN] ProxySpace on " ++ srv).postln; ps.clear };
            };
        };

        // ensure server tree is sane
        s.initTree;
        s.defaultGroup.freeAll;

        "== Preflight done ==".postln;
    };

    setCurrent = { |key|
        if(m.respondsTo(\setSourceCurrent)) { m.setSourceCurrent(key) }
        { "ERROR: setSourceCurrent missing".warn };
    };
    setNext = { |key|
        if(m.respondsTo(\setSource)) { m.setSource(key) }
        { "ERROR: setSource missing".warn };
    };

    // ---- Go ----
    sanityPreflight.();

    // Minimal source + processor Ndefs
    Ndef(\ts0,   { Silent.ar(2) });
    Ndef(\tsDust,{ Dust.ar(2000) ! 2 });
    Ndef(\tsSaw, { Saw.ar(200, 0.15) ! 2 });
    Ndef(\tremolo, { |rate = 4, depth = 0.9|
        var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1)
    });

    // Pedalboard
    m = MagicPedalboardNew.new;
    m.reset;

    // Hard silent baseline
    setCurrent.(\ts0);
    setNext.(\ts0);
    m.clearChain;         // clear NEXT
    m.switchChain;
    m.clearChain;         // clear previous CURRENT (now NEXT)
    m.switchChain;
    Ndef(\chainA).play(numChannels: 2);
    Ndef(\chainB).stop;

    // ---- Narrative, no pauses, explicit progress logs ----
    say.("A1 begin");
    say.("Starting silent. Starting in"); countdown.(3);
    show.(); say.("A1 end (should be silent)"); 2.wait;

    say.("B1 begin");
    say.("Switch CURRENT to Dust. Starting in"); countdown.(3);
    setCurrent.(\tsDust);
    show.(); say.("B1 end (should hear irregular bursts)"); 2.wait;

    say.("C1 begin");
    say.("Prepare NEXT: Saw + Tremolo. Starting in"); countdown.(2);
    setNext.(\tsSaw);
    m.add(\tremolo);
    show.();
    say.("Switching to NEXT in"); countdown.(3);
    m.switchChain; show.();
    say.("C1 end (should hear saw with tremolo)"); 2.wait;

    say.("D1 begin");
    say.("Bypass tremolo. Starting in"); countdown.(2);
    m.bypassCurrent(\tremolo, true); show.();
    say.("D1 end (plain saw)"); 1.wait;

    say.("D2 begin");
    say.("Un-bypass tremolo. Starting in"); countdown.(2);
    m.bypassCurrent(\tremolo, false); show.();
    say.("D2 end (tremolo returns)"); 2.wait;

    say.("E1 begin");
    say.("Prepare NEXT: add atten@1, lofi@2, swap. Starting in"); countdown.(2);
    m.addAt(\atten, 1); m.addAt(\lofi, 2); m.swap(1, 2); show.();
    say.("Switch to NEXT in"); countdown.(3);
    m.switchChain; show.();
    say.("E1 end (quiet + crushed)"); 2.wait;

    say.("F1 begin");
    say.("On NEXT, removeAt(1), then clear in"); countdown.(2);
    m.removeAt(1); show.(); m.clearChain; show.();
    say.("F1 end"); 1.wait;

    say.("G1 begin");
    say.("Set NEXT to \\ts0 (back to silence) and switch. Starting in"); countdown.(3);
    setNext.(\ts0); m.switchChain; show.();
    say.("G1 end (silent again)"); 2.wait;

    say.("Done. Stopping."); m.stopCurrent;
});
)

===== Magicpedalboard/previous attempt/testMagicpedalboard.scd =====
// testMagicpedalboard.scd
// MD 20250911-1524

// v0.2.2 to test the MagicPedalboard class

// Clear all Ndefs first
Ndef.clear;


// Sources (stereo)
Ndef(\ts0, { Silent.ar(2) });                                // quiet source
Ndef(\ts1, { Dust.ar(2000) ! 2 });                           // noise bursts
Ndef(\ts2, { Saw.ar(200, 0.1) ! 2 });                        // saw
Ndef(\ts3, { SinOsc.ar(333, 0, 0.2) ! 2 });                  // sine
Ndef(\ts4, { Dust.ar(200) ! 2 });                            // sparser bursts
// Processors (named audio input \in)
Ndef(\p1, { var inSig; inSig = \in.ar(2) * 0.5; inSig });
Ndef(\p2, { var inSig; inSig = \in.ar(2) * 0.2; inSig });
Ndef(\p3, { var inSig; inSig = \in.ar(2);       inSig });
Ndef(\p4, { var inSig; inSig = \in.ar(2) *SinOsc.ar(7).range(0,1);       inSig });
Ndef(\p5, { var inSig; inSig = \in.ar(2);       inSig });
Ndef(\p6, { var inSig; inSig = \in.ar(2);       inSig });

// Sink (monitor/output stage)
Ndef(\out, { var inSig; inSig = \in.ar(2); inSig });

// Optional: test source
Ndef(\ts2).play;
Ndef(\ts2).stop;


// Create instance
~mpb = MagicPedalboard.new;

// Add processors to next chain
~mpb.add(\p4);
~mpb.add(\p2);
~mpb.addAt(\p3, 1);

// Swap two processors
~mpb.swap(1, 2);

// Remove one
~mpb.removeAt(1);

// Bypass last inserted
~mpb.bypass;

// Switch to next chain
~mpb.switchChain;

// Clear the new next chain
~mpb.clearChain;

// Rebuild using explicit .set(\in, ...)
~mpb.rebuildExplicit;

// Show help
~mpb.help;


===== Magicpedalboard/QuickRestore_AudioAndExclusive.scd =====
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== Magicpedalboard/retargetMeters.scd =====
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)

===== Magicpedalboard/shelved/meters_preinstall_busmeters.scd =====
// meters_preinstall_busmeters.scd
// v0.1
// MD 20250916-1051

(
SynthDef(\busMeterA, { |inbus=0, numch=2| var sig = In.ar(inbus, numch); 0 }).add;
SynthDef(\busMeterB, { |inbus=0, numch=2| var sig = In.ar(inbus, numch); 0 }).add;
"[Meters] Installed stub SynthDefs: busMeterA/B.".postln;
)

===== Magicpedalboard/shelved/MPB_Scenarios_v6.scd =====
/* MPB_Scenarios_v6.scd ‚Äî SuperCollider-only (no Markdown)
   NO MIC TODAY: ts0 is overridden to an internal test source.
   Test sources are time-varying so delay/reverb are obvious.
   MD 20250915
*/

// [0] Prep ‚Äî boot server
Server.default.boot;

// [0.1] (Optional hard block) Disable *all* audio input at driver level, then reboot.
// Comment out if you don't want to reboot.
// (
// Server.default.quit;
// Server.default.options.numInputBusChannels = 0;  // hard disable input
// Server.default.options.numOutputBusChannels = 2;
// Server.default.reboot;
// )

// [0.2] Define musical test sources and effects (idempotent)

// Helper to define an Ndef only if it isn't already defined
(
var ensureProxyFunc;

ensureProxyFunc = { arg key, func;
    var hasSource, canRun;
    hasSource = Ndef(key).source.notNil;
    canRun = Server.default.serverRunning;
    if(hasSource.not and: { canRun }) {
        Server.default.bind({
            Ndef(key, func);
            Ndef(key).ar(2); // stereo bus guarantee
        });
    };
};

// ---- Test sources (no microphone) ----

// Percussive melody pings (pitches change; great for delay/reverb)
ensureProxyFunc.(\testmelody, {
    var trig, freqSeq, freq, ampEnv, panPos, tone;
    trig    = Impulse.kr(3.5);
    freqSeq = Dseq([220, 277.18, 329.63, 392.00, 329.63, 277.18, 246.94], inf);
    freq    = Demand.kr(trig, 0, freqSeq);
    ampEnv  = Decay2.kr(trig, 0.01, 0.35);
    panPos  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
    tone    = SinOsc.ar(freq) * ampEnv * 0.25;
    Pan2.ar(tone, panPos)
});

// Sparse tonal bursts (reverb tails are obvious)
ensureProxyFunc.(\testbursts, {
    var trig, env, freq, tone, panPos;
    trig   = Impulse.kr(1.2);
    env    = EnvGen.kr(Env.perc(0.005, 0.8, 0.6), trig);
    freq   = TExpRand.kr(180, 660, trig);
    tone   = SinOsc.ar(freq) * env * 0.35;
    panPos = LFNoise1.kr(0.2).range(-0.7, 0.7);
    Pan2.ar(tone, panPos)
});

// ---- Effects (stereo-safe, simple defaults) ----
ensureProxyFunc.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar(2);
    time = \time.kr(0.45).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.5).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

ensureProxyFunc.(\tremolo, {
    var inputSignal, rate, depth, lfo;
    inputSignal = \in.ar(2);
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.6).clip(0, 1);
    lfo   = SinOsc.kr(rate).range(1 - depth, 1);
    inputSignal * lfo
});

ensureProxyFunc.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar(2);
    mix  = \mix.kr(0.35).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    FreeVerb.ar(inputSignal, mix, room, damp)
});

ensureProxyFunc.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar(2);
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

ensureProxyFunc.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar(2);
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});
)

// [0.3] NO MIC GUARANTEE ‚Äî override \ts0 to be an internal source (before creating pedalboard)
(
Server.default.bind({
    // Use testmelody (or switch to \testbursts by replacing the function)
    Ndef(\ts0, {
        var trig, freqSeq, freq, env, panPos, tone;
        trig    = Impulse.kr(3.5);
        freqSeq = Dseq([220, 277.18, 329.63, 392.00, 329.63, 277.18, 246.94], inf);
        freq    = Demand.kr(trig, 0, freqSeq);
        env     = Decay2.kr(trig, 0.01, 0.35);
        panPos  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        tone    = SinOsc.ar(freq) * env * 0.25;
        Pan2.ar(tone, panPos)
    });
    Ndef(\ts0).ar(2);
});
);

// [0.4] Pedalboard instance (uses \ts0 internally, now safe)
~pedalboard = MagicPedalboardNew.new;
~pedalboard.printChains;

// [A] Audio sanity (no microphone)
~pedalboard.reset; // CURRENT plays \ts0 which is internal testmelody now
~pedalboard.setSource(\testmelody); ~pedalboard.switchChain(0.1);

// ======================
// [1] Scenario 1 ‚Äî basic
// ======================

~pedalboard.reset;
~pedalboard.setSource(\testmelody); ~pedalboard.switchChain(0.1);
~pedalboard.add(\delay); ~pedalboard.printChains;
~pedalboard.switchChain(0.1);
~procs = ~pedalboard.effectiveCurrent; ~currentProcs = if(~procs.size > 2) { ~procs.copyRange(1, ~procs.size-2) } { [] };
~pedalboard.clearChain;
(
var indexCounter;
indexCounter = 0;
while({ indexCounter < ~currentProcs.size }, {
    ~pedalboard.add(~currentProcs[indexCounter]);
    indexCounter = indexCounter + 1;
});
~pedalboard.setSource(~procs.last);
);
~pedalboard.add(\reverb); ~pedalboard.printChains;
~pedalboard.switchChain(0.12);
~effNext = ~pedalboard.effectiveNext; ~delayIndex = ~effNext.indexOf(\delay);
if(~delayIndex.notNil and: { ~delayIndex > 0 and: { ~delayIndex < (~effNext.size-1) } }) {
    ~pedalboard.removeAt(~delayIndex);
    ~pedalboard.addAt(\tremolo, ~delayIndex);
};
~pedalboard.printChains;
~pedalboard.switchChain(0.1);

// ==========================
// [2] Scenario 2 ‚Äî bypass/swap
// ==========================

~pedalboard.clearChain; ~pedalboard.add(\tremolo); ~pedalboard.add(\chorus); ~pedalboard.add(\delay); ~pedalboard.add(\reverb); ~pedalboard.printChains;
~pedalboard.bypass(\chorus, true); ~pedalboard.bypass(\reverb, true); ~pedalboard.printChains;
~pedalboard.switchChain(0.25);
~pedalboard.bypass(\chorus, false); ~pedalboard.printChains;
~pedalboard.swap(1, 2); ~pedalboard.printChains;
~pedalboard.switchChain(0.5);
~pedalboard.bypass(\reverb, false); ~pedalboard.switchChain(0.1);

// ===============================
// [3] Scenario 3 ‚Äî live tweaks now
// ===============================

~pedalboard.printChains;
~pedalboard.bypassAtCurrent(1, true); ~pedalboard.printChains;
~pedalboard.bypassAtCurrent(1, false);
~pedalboard.switchChain(0.1); ~pedalboard.switchChain(0.1);
~effNext = ~pedalboard.effectiveNext; ~lastProcIdx = ~effNext.size - 2;
if(~lastProcIdx >= 1) { ~pedalboard.removeAt(~lastProcIdx); ~pedalboard.addAt(\drive, ~lastProcIdx); };
~pedalboard.printChains;
~pedalboard.switchChain(0.1);




~assertHas = { arg list, key;
    if(list.includes(key).not) { ("ASSERT missing " ++ key).postln };
};
~assertEnds = { arg list, key;
    if(list.last != key) { ("ASSERT last must be " ++ key).postln };
};

===== Magicpedalboard/shelved/Runner_MagicDisplayGUI.scd =====
(
// =========================
// Runner_MagicDisplayGUI.scd  (single block)~md_force
// =========================

/* Goals:
   - Exactly 1 MagicDisplayGUI window (close dupes; rebuild cleanly)
   - Visible PROBE FRAME overlay
   - Run Scenario 1 (fast) step-by-step
   - Re-entrant guard with auto-unlock; repeatable after closing the window
   - AppClock-only GUI operations; no server.sync; no watchers; no queueUi override
   - Style: tilde vars, var-first, lowercase names, no single-letter locals
*/

~md_version = (~md_version ? (
    runner: "Runner 1.0.3",
    mpb: "MagicPedalboardNew v0.3.8",
    md: "MagicDisplay v0.1.2",
    mdgui: "MagicDisplayGUI v0.2.4"
));

~md_guard = ~md_guard ? false;
~md_guard_time = ~md_guard_time ? nil;
~md_guard_timeout = ~md_guard_timeout ? 10.0;
~md_run_token = ~md_run_token ? 0;

/* ---------- preflight ---------- */

~md_preflightGui = {
    var did_set;
    did_set = false;
    GUI.qt;  // safe to call repeatedly; warning is cosmetic
    AppClock.sched(0.0, { "[AC] preflight ping".postln; nil });
    did_set = true;
    did_set
};

/* ---------- window helpers ---------- */

~md_title_is_mdg = { |window_ref|
    var ok, title_text;
    ok = false;
    title_text = "";
    if(window_ref.notNil) {
        if(window_ref.respondsTo(\name) and: { window_ref.name.notNil }) {
            title_text = window_ref.name.asString;
            ok = title_text.beginsWith("MagicDisplayGUI");
        };
    };
    ok
};

/*~md_title_is_mdg = { |window_ref|
    var ok, title_text;
    ok = false;
    title_text = "";
    if(window_ref.notNil) {
        if(window_ref.respondsTo(\name) and: { window_ref.name.notNil }) {
            title_text = window_ref.name.asString;
            // REQUIRE: title begins with "MagicDisplayGUI"
            ok = title_text.beginsWith("MagicDisplayGUI");
        };
    };
    ok
};*/

/*~md_title_is_mdg = { |window_ref|
    var ok, title_text, lower;
    ok = false;
    title_text = "";
    lower = "";
    if(window_ref.notNil) {
        if(window_ref.respondsTo(\name) and: { window_ref.name.notNil }) {
            title_text = window_ref.name.asString;
            lower = title_text.toLower;
            ok = (
                lower.contains("magicdisplaygui")
                or: { lower.contains("current / next") }
                or: { lower.contains("magic display") }
            );
        };
    };
    ok
};*/

~md_all_windows = {
    var wins;
    wins = Window.allWindows;
    if(wins.isNil) { wins = [] };
    wins
};

~md_get_gui_windows = {
    var wins, mdg;
    wins = ~md_all_windows.();
    mdg = wins.select({ |w| ~md_title_is_mdg.(w) });
    mdg
};

~md_checkWindows = {
    var wins, titles;
    wins = ~md_all_windows.();
    titles = wins.collect({ |w| w.name.asString });
    "[WIN] ALL count = %, titles = %".format(wins.size, titles).postln;
};

~md_close_matching_windows = {
    var wins;
    wins = ~md_all_windows.();
    AppClock.sched(0.0, {
        var to_close, count_closed;
        to_close = wins.select({ |w| ~md_title_is_mdg.(w) });
        count_closed = 0;
        to_close.do({ |w|
            if(w.notNil) {
                w.close;
                count_closed = count_closed + 1;
            };
        });
        "[WIN] closed % MagicDisplayGUI window(s)".format(count_closed).postln;
        nil
    });
};

~md_frontWindow = {
    var wins, target, prev_flag, has_top;
    wins = ~md_all_windows.();
    if(wins.size == 0) {
        "[WIN] nothing to front".postln;
    }{
        target = wins.last;
        AppClock.sched(0.0, {
            has_top = target.respondsTo(\alwaysOnTop);
            if(has_top) {
                prev_flag = target.alwaysOnTop;
                target.alwaysOnTop_(true);
            };
            target.front;
            if(has_top) {
                AppClock.sched(0.05, { target.alwaysOnTop_(prev_flag); nil });
            };
            "[WIN] fronted: %".format(target.name).postln;
            nil
        });
    };
};

/* ---------- PROBE FRAME overlay ---------- */

~md_probe_view = ~md_probe_view ? nil;

~md_attach_probe_frame = {
    var wins, target, root, bounds_rect, view_local, font_obj;
    wins = ~md_all_windows.();
    if(wins.size == 0) {
        "[GUI] PROBE skipped (no windows)".postln;
    }{
        target = wins.last;
        AppClock.sched(0.0, {
            if(target.view.isNil) {
                "[GUI] PROBE skipped (no root view)".postln;
            }{
                if(~md_probe_view.notNil) {
                    (~md_probe_view.tryPerform(\remove) ? nil);
                    ~md_probe_view = nil;
                };
                root = target.view;
                bounds_rect = Rect(8, 8, 180, 24);
                font_obj = Font("Helvetica", 12);
                view_local = UserView(root, bounds_rect).background_(Color.clear).clearOnRefresh_(true);
                view_local.drawFunc_({
                    Pen.color_(Color.red); Pen.width = 1.5;
                    Pen.addRect(Rect(0, 0, bounds_rect.width, bounds_rect.height)); Pen.stroke;
                    Pen.stringAtPoint("PROBE FRAME", Point(6, 6), font_obj);
                });
                view_local.visible_(true);
                ~md_probe_view = view_local;
                "[GUI] PROBE FRAME attached".postln;
            };
            nil
        });
    };
};

/* ---------- ensure ~mpb exists (best-effort; no server.sync) ---------- */

~md_ensure_mpb = {
    var created_flag;
    created_flag = false;
    if(~mpb.isNil) {
        "[BOOT] ~mpb missing ‚Äî creating".postln;
        if(MagicPedalboardNew.respondsTo(\new)) {
            ~mpb = MagicPedalboardNew.new;
            created_flag = true;
        }{
            "[BOOT] MagicPedalboardNew.new not available".postln;
        };
    }{
        "[BOOT] ~mpb already present".postln;
    };
    if(created_flag) { "[BOOT] created ~mpb".postln; };
};

/* ---------- public API ---------- */

~md_runnerUnlock = {
    var now_time;
    now_time = Main.elapsedTime;
    if(~md_guard) { "[SAFE] manual unlock".postln };
    ~md_guard = false;
    ~md_guard_time = now_time;
};

/* Emergency fresh-create + front + probe (deterministic) */
~md_forceCreateWindow = {
    AppClock.sched(0.0, {
        var existing_window, attach_and_front;

        "[RUN] ensure single MagicDisplayGUI window".postln;
        ~md_preflightGui.();

        attach_and_front = {
            ~md_attach_probe_frame.();
            ~md_frontWindow.();
            ~md_checkWindows.();
        };

        AppClock.sched(0.20, {
            existing_window = Window.allWindows.detect({ |w|
                var name_string, begins_ok;
                name_string = w.name.asString;
                begins_ok = name_string.notNil and: { name_string.beginsWith("MagicDisplayGUI") };
                begins_ok
            });

            if(existing_window.notNil) {
                "[BOOT] reusing existing MagicDisplayGUI window".postln;
                existing_window.front;
                AppClock.sched(0.45, { attach_and_front.value; nil });
            }{
                "[BOOT] creating MagicDisplayGUI.new()".postln;
                ~gui = MagicDisplayGUI.new();
                AppClock.sched(0.45, { attach_and_front.value; nil });
            };
            nil
        });
        nil
    });
};

/*~md_forceCreateWindow = {
    AppClock.sched(0.0, {
        var existing_window, attach_and_front;

        "[RUN] ensure single MagicDisplayGUI window".postln;
        ~md_preflightGui.();

        attach_and_front = {
            // keep your probe & front logic the same
            ~md_attach_probe_frame.();
            ~md_frontWindow.();
            ~md_checkWindows.();
        };

        AppClock.sched(0.20, {
            existing_window = Window.allWindows.detect({ |w|
                var name_string, begins_ok;
                name_string = w.name.asString;
                begins_ok = name_string.notNil and: { name_string.beginsWith("MagicDisplayGUI") };
                begins_ok
            });

            if(existing_window.notNil) {
                "[BOOT] reusing existing MagicDisplayGUI window".postln;
                existing_window.front;
                AppClock.sched(0.45, { attach_and_front.value; nil });
            }{
                "[BOOT] creating MagicDisplayGUI.new()".postln;
                // Correct constructor for your GUI: builds on AppClock inside initGui
                ~gui = MagicDisplayGUI.new();
                AppClock.sched(0.45, { attach_and_front.value; nil });
            };
            nil
        });
        nil
    });
};*/

// ~md_forceCreateWindow = {
// 	AppClock.sched(0.0, {
// 		"[RUN] force-create window".postln;
// 		~md_preflightGui.();
// 		~md_close_matching_windows.();
// 		AppClock.sched(0.20, {
// 			// Correct constructor for your GUI: no args; builds on AppClock inside initGui
// 			"[BOOT] calling MagicDisplayGUI.new()".postln;
// 			~gui = MagicDisplayGUI.new();
// 			AppClock.sched(0.45, {
// 				~md_attach_probe_frame.();
// 				~md_frontWindow.();
// 				~md_checkWindows.();
// 				nil
// 			});
// 			nil
// 		});
// 		nil
// 	});
// };

~md_bootProbeScenario = {
    var now_time, guard_age, timeout_seconds, token_local, scenario_func;

    ~md_preflightGui.();

    now_time = Main.elapsedTime;
    guard_age = now_time - (~md_guard_time ? now_time);
    timeout_seconds = ~md_guard_timeout ? 10.0;

    if(~md_guard and: { guard_age > timeout_seconds }) {
        "[SAFE] auto-unlock (stale)".postln;
        ~md_runnerUnlock.();
    };

    if(~md_guard) {
        "[RUN] already running ‚Äî ignoring".postln;
    }{
        ~md_guard = true;
        ~md_guard_time = now_time;
        ~md_run_token = (~md_run_token ? 0) + 1;
        token_local = ~md_run_token;

        "[RUN] start token % | % / % / %".format(
            token_local, ~md_version[\mpb], ~md_version[\md], ~md_version[\mdgui]
        ).postln;

        // failsafe auto-unlock
        AppClock.sched(timeout_seconds, {
            var still_active;
            still_active = ~md_guard and: { ~md_run_token == token_local };
            if(still_active) {
                "[SAFE] auto-unlock (timeout)".postln;
                ~md_runnerUnlock.();
            };
            nil
        });

        // ensure env + window, then run Scenario 1 (fast)
        ~md_ensure_mpb.();
        ~md_forceCreateWindow.();
        AppClock.sched(0.90, {
            scenario_func = ~sc_fast_scenario1;
            if(scenario_func.notNil) {
                "[RUN] starting Scenario 1 (fast)".postln;
                scenario_func.({
                    "[RUN] Scenario 1 complete".postln;
                    ~md_runnerUnlock.();
                });
            }{
                "[RUN] Scenario 1 function (~sc_fast_scenario1) not found; unlocking".postln;
                ~md_runnerUnlock.();
            };
            nil
        });
    };
};

/* ---------- safe fallback for refresh (non-invasive) ---------- */

if(~refreshGuiFromMpb.isNil) {
    ~refreshGuiFromMpb = { |tag_text|
        var safe_tag;
        safe_tag = tag_text ? "no-tag";
        "[GUI] refreshGuiFromMpb (fallback) ‚Äî %".format(safe_tag).postln;
    };
    "[INFO] installed fallback ~refreshGuiFromMpb (non-invasive)".postln;
};

"[INFO] % loaded. Ready.".format(~md_version[\runner]).postln;

) // end block

===== Magicpedalboard/shelved/Scenarios_MagicDisplayGUI_Fast.scd =====
(
// =========================
// Scenarios_MagicDisplayGUI_Fast.scd  (single block)
// =========================
// AppClock-only; uses ~gui.queueUi if present; updates via ~refreshGuiFromMpb + showExpectation

~md_with_queue_ui = { |ui_func|
    var runnable_func, has_queue;
    runnable_func = ui_func ? { };
    has_queue = (~gui.notNil) and: { ~gui.respondsTo(\queueUi) };
    if(has_queue) { ~gui.queueUi.(runnable_func) }{ "[GUI] queueUi unavailable ‚Äî skipping ui_func".postln };
};

// -------- Scenario 1 (fast) --------
~sc_fast_scenario1 = { |done_func|
    var step_interval, carry_on;
    step_interval = 0.25;
    carry_on = { |next_func| AppClock.sched(step_interval, { next_func.value; nil }) };

    AppClock.sched(0.0, {
        ~md_with_queue_ui.({
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: step 0") };
        });
        ~refreshGuiFromMpb.("sc1-step0");
        nil
    });

    carry_on.({
        ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: step 1") } });
        ~refreshGuiFromMpb.("sc1-step1");

        carry_on.({
            ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: step 2") } });
            ~refreshGuiFromMpb.("sc1-step2");

            carry_on.({
                ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: step 3") } });
                ~refreshGuiFromMpb.("sc1-step3");

                carry_on.({
                    ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: step 4") } });
                    ~refreshGuiFromMpb.("sc1-step4");

                    carry_on.({
                        ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 1: done") } });
                        ~refreshGuiFromMpb.("sc1-done");
                        if(done_func.notNil) { done_func.value };
                    });
                });
            });
        });
    });
};

// -------- Scenario 2 (fast) --------
~sc_fast_scenario2 = { |done_func|
    var step_interval;
    step_interval = 0.2;

    AppClock.sched(0.0, {
        ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 2: A-chain preview") } });
        ~refreshGuiFromMpb.("sc2-A");

        AppClock.sched(step_interval, {
            ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 2: B-chain preview") } });
            ~refreshGuiFromMpb.("sc2-B");

            AppClock.sched(step_interval, {
                ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 2: done") } });
                ~refreshGuiFromMpb.("sc2-done");
                if(done_func.notNil) { done_func.value };
                nil
            });
            nil
        });
        nil
    });
};

// -------- Scenario 3 (fast) --------
~sc_fast_scenario3 = { |done_func|
    var step_interval, index_counter, rounds_total, do_round;
    step_interval = 0.18;
    index_counter = 0;
    rounds_total = 5;

    AppClock.sched(0.0, {
        do_round = {
            if(index_counter >= rounds_total) {
                ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 3: done") } });
                ~refreshGuiFromMpb.("sc3-done");
                if(done_func.notNil) { done_func.value };
            }{
                ~md_with_queue_ui.({ if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation.("Scenario 3: tick %".format(index_counter)) } });
                ~refreshGuiFromMpb.("sc3-%".format(index_counter));
                index_counter = index_counter + 1;
                AppClock.sched(step_interval, { do_round.value; nil });
            };
            nil
        };
        do_round.value;
        nil
    });
};

) // end block

===== Magicpedalboard/switchDelayCheck.scd =====
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)

===== Magicpedalboard/utils_mpb_force_reconnect.scd =====
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)

===== MDMiniLogger/test_MDMiniLogger.scd =====
// test_MDMiniLogger.scd

m = MDMiniLogger.get;

m.setverbosity(0);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(1);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(2);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");


===== temp files/BringBack_UserChoicesWindow.scd =====
// BringBack_UserChoicesWindow.scd
// v0.1.0  MD 2025-09-22

/*
Purpose
- Restore the old branch-choices window (UserDisplay) and wire it to CommandManager
  *alongside* MagicDisplayGUI, without changing your classes.

Style
- var-first; lowercase; AppClock-safe; no server.sync.
*/

(
// 1) close any old "user display" windows
Window.allWindows.do({ |w|
    var nm = w.tryPerform(\name);
    if(nm.notNil and: { nm.asString == "user display" }) { w.close };
});

// 2) create the choices window
~userChoices = UserDisplay.new;  // has updateTextField(\state|\queue|\lastCommand|\choices, ...)

// 3) small fan-out adaptor so CommandManager can write to BOTH displays
~displayFan = (
    targets: [ ~system.statusDisplay, ~userChoices ],

    showExpectation: { |self, text, secs = 0|
        self.targets.do({ |t| t.tryPerform(\showExpectation, text, secs) });
    },

    updateTextField: { |self, box, msg|
        self.targets.do({ |t| t.tryPerform(\updateTextField, box, msg) });
    },

    updateStatus: { |self, text|
        self.targets.do({ |t| t.tryPerform(\updateStatus, text) });
    }
);

// 4) inject the fan-out into CommandManager
~system.commandManager.display = ~displayFan;

// 5) initial refresh (shows current state & choices)
~system.commandManager.updateDisplay;
"‚úÖ Choices window wired. Press D2=prog then play notes to see choices update.".postln;
)

===== temp files/TempGUIChoicesWindows.scd =====
// TempGUIChoicesWindows.scd
// MD 20250922-1653
(
// Floating "Choices" window (always-on-top, readable)
var titleColor = Color(0.12, 0.12, 0.12);
var textColor = Color(0.10, 0.10, 0.10);
var bgColor = Color(0.98, 0.98, 0.98, 0.98);

if(~choicesWin.notNil and: { ~choicesWin.isClosed.not }) { ~choicesWin.close };
~choicesWin = Window("Choices", Rect(30, 120, 380, 220))
    .alwaysOnTop_(true);
~choicesWin.view.background_(bgColor);

~choicesWin_title = StaticText(~choicesWin, Rect(8, 6, 364, 16))
    .string_("Choices")
    .stringColor_(titleColor);

~choicesWin_text = TextView(~choicesWin, Rect(8, 26, 364, 186))
    .string_("‚Äî")
    .editable_(false)
    .hasVerticalScroller_(true)
    .background_(bgColor)
    .stringColor_(textColor)
    .font_(Font("Menlo", 12));

~choicesSet = { |items|
    var s = (items ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        if(~choicesWin_text.notNil) {
            ~choicesWin_text.string_((s.size > 0).if({ s }, { "‚Äî" }));
        };
        nil
    });
};

~choicesWin.front;
~choicesSet.([
    "fret 7 ‚Üí delay",
    "fret 9 ‚Üí tremolo",
    "fret 11 ‚Üí switch"
]);
"‚úÖ Floating Choices window ready (stop watcher: ~choicesWatcher.stop; close: ~choicesWin.close).".postln;
)

===== utilities/ControlLogVerbosity.scd =====
// ControlLogVerbosity.sc
// v1
// MD 20250923-0835

// error = 0
// warn = 1
// info = 2
// debug = 3
// trace = 4

MDMiniLogger.get.setverbosity(2);
===== utilities/DEMO20250923_FIXED.scd =====
// DEMO20250923_FIXED.scd
// v0.2.0
// MD 2025-09-23 10:46 BST

/* Purpose
 - Run the 2025-09-23 demo steps while updating MagicDisplayGUI at each step.
 - Uses ~nav_handleFret from the SimNav patch (Fix 1) so the GUI shows choices
   and "Apply ‚Üí ..." on leaf selections.
Style
 - var-first; AppClock-only; no server.sync; one MagicDisplayGUI window.
*/

(
var steps, gap, i, runStep, schedNext;

if(~system.isNil) { "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil };
if(~nav_handleFret.isNil) { "‚ö†Ô∏è Load SimNav_Bridge_ApplyLeafPayload_FIX.scd first".warn; ^nil };

// Your original script, now paced:
steps = [
    // Add delay ‚Üí /add/delay
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 1) }, // add
    { ~nav_handleFret.(4, 1) }, // delay (leaf ‚Üí applies)

    // Switch ‚Üí /switch
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 3) }, // switch (leaf ‚Üí applies)

    // Bypass delay ON
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 2) }, // bypass
    { ~nav_handleFret.(4, 1) }, // delay
    { ~nav_handleFret.(3, 2) }, // on (leaf)

    // Bypass delay OFF
    { ~nav_handleFret.(6,10) },
    { ~nav_handleFret.(5, 2) },
    { ~nav_handleFret.(4, 1) },
    { ~nav_handleFret.(3, 3) }, // off (leaf)

    // Set source testmelody ‚Üí /setSource/testmelody
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 4) }, // setSource
    { ~nav_handleFret.(4, 1) }  // testmelody (leaf)
];

// pacing
gap = 0.55;
i = 0;
runStep = { steps[i].value; i = i + 1; if(i < steps.size) { schedNext.() } };
schedNext = { AppClock.sched(gap, { runStep.(); nil }) };

// kick off and ensure GUI is showing something
~nav_reset.();
AppClock.sched(0.0, { runStep.(); nil });
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay ‚Üí /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf ‚Üí applies)


//Switch ‚Üí /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf ‚Üí applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody ‚Üí /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Editor_AddCommands_Branch_Canonical.scd =====
// Editor_AddCommands_Branch_Canonical.scd
// v0.1.7
// MD 20250923-0956

(
/*
Purpose
- Ensure a minimal 'commands' branch exists in the canonical CommandTree JSON used by LivePedalboardSystem.
- Set each leaf's payload under 'commands' to a canonical path string ("/verb/arg/...").
- Uses only known-good methods; no caret returns; var-first at top-level.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPath, tree, ok, proceed;
var findChildByName, ensureChildUnder, ensurePath;
var commandsNode, printSampleLeaves, showFirstN;
var setCanonicalPayloads, buildPathsDown, buildPathFromSegments, rootCmd, count;

// ‚îÄ‚îÄ entry banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
"Editor_AddCommands_Branch_Canonical: ENTER".postln;

// ‚îÄ‚îÄ canonical JSON path (LivePedalboardSuite) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
jsonPath = Platform.userExtensionDir
  ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
("JSON path ‚Üí " ++ jsonPath).postln;

// ‚îÄ‚îÄ load tree ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPath);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// ‚îÄ‚îÄ helpers (only stable fields/methods) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
findChildByName = { |parentNode, childName|
  var wanted, found;
  wanted = childName.asString;
  found = nil;
  parentNode.children.do({ |c|
    if(c.name.asString == wanted) { found = c };
  });
  found
};

ensureChildUnder = { |parentNode, childName, fretNumber|
  var existing, created, fret;
  fret = fretNumber ? 1;
  existing = findChildByName.(parentNode, childName);
  if(existing.notNil) {
    existing
  }{
    created = tree.addNode(parentNode.id, childName.asString, fret);
    if(created.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
    created
  }
};

ensurePath = { |names, frets|
  var node, i, count, name, fret;
  node = tree.root;
  i = 0; count = names.size;
  while({ i < count }, {
    name = names[i];
    fret = frets[i] ? 1;
    node = ensureChildUnder.(node, name, fret);
    i = i + 1;
  });
  node
};

showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new;
  i = 0;
  while({ i < lim }, {
    out.add(listIn[i]);
    i = i + 1;
  });
  out.asArray
};

// ‚îÄ‚îÄ do the work only if load succeeded ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if(proceed) {
  // 1) ensure 'commands' branch + minimal leaves (idempotent)
  ensurePath.( ["commands"], [10] );
  ensurePath.( ["commands","add","delay"],            [10,1,1] );
  ensurePath.( ["commands","bypass","delay","on"],    [10,2,1,2] );
  ensurePath.( ["commands","bypass","delay","off"],   [10,2,1,3] );
  ensurePath.( ["commands","switch"],                 [10,3] );
  ensurePath.( ["commands","setSource","testmelody"], [10,4,1] );

  // 2) normalize payloads and tag depths
  tree.assignPayloads;     // payload := name where missing
  tree.root.tagByDepth(0);

  // 2b) set canonical path strings for each 'commands' leaf ("/verb/arg/...")
  buildPathFromSegments = { |segs|
    var out, i, lim;
    out = "";
    i = 0; lim = segs.size;
    while({ i < lim }, {
      out = out ++ "/" ++ segs[i];
      i = i + 1;
    });
    out
  };

  setCanonicalPayloads = {
    rootCmd = findChildByName.(tree.root, "commands");
    if(rootCmd.isNil) {
      "‚ö†Ô∏è cannot set payloads: 'commands' missing.".postln;
    }{
      count = 0;
      buildPathsDown = { |node, segs|
        if(node.isLeaf) {
          node.payload = buildPathFromSegments.(segs);
          count = count + 1;
        }{
          node.children.do({ |child|
            var nextSegs;
            nextSegs = segs.copy;
            nextSegs.add(child.name.asString);
            buildPathsDown.(child, nextSegs);
          });
        }
      };
      // seed with immediate children of 'commands'
      rootCmd.children.do({ |child|
        buildPathsDown.(child, [child.name.asString]);
      });
      ("set canonical payloads on " ++ count ++ " leaf/leaves under 'commands'").postln;
    };
  };

  setCanonicalPayloads.();

  // 3) save back to the canonical file
  tree.exportJSONFile(jsonPath);
  ("‚úÖ Updated commands branch in ‚Üí " ++ jsonPath).postln;

  // 4) sample a few payloads under 'commands' (sanity)
  commandsNode = findChildByName.(tree.root, "commands");
  if(commandsNode.isNil) {
    "‚ö†Ô∏è 'commands' node not found after ensure-path (unexpected).".postln;
  }{
    printSampleLeaves = {
      var visit, payloads;
      payloads = List.new;
      visit = { |n|
        if(n.isLeaf) {
          payloads.add((n.payload ?? n.name).asString);
        }{
          n.children.do(visit);
        }
      };
      visit.(commandsNode);
      ("sample payloads: " ++ showFirstN.(payloads, 8).asString).postln;
    };
    printSampleLeaves.();
  };
}{
  ("‚ùå Failed to load " ++ jsonPath ++ " (no changes made)").postln;
};

// ‚îÄ‚îÄ exit banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"Editor_AddCommands_Branch_Canonical: EXIT".postln;
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
)

===== utilities/Fallback_Diag_OneShot.scd =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/GUI_QuickFix_Choices_Contrast.scd =====
// GUI_QuickFix_Choices_Contrast.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   Improve legibility of the "Choices" panel immediately (runtime).
   Style: var-first; AppClock-only; no server.sync.
*/

(
var displayRef, choicesPanelView, choicesTitleView, choicesTextView, canDo;

displayRef = ~system ? nil;
if(displayRef.isNil or: { ~system.statusDisplay.isNil }) {
  "‚ö†Ô∏è No status display found; bring-up first.".warn; ^nil;
};
displayRef = ~system.statusDisplay;

displayRef.queueUi({
  choicesPanelView = displayRef.tryPerform(\choicesPanel);
  choicesTitleView = displayRef.tryPerform(\choicesTitle);
  choicesTextView  = displayRef.tryPerform(\choicesText);

  if(choicesPanelView.notNil and: { choicesPanelView.respondsTo(\background_) }) {
    choicesPanelView.background_(Color(0.12, 0.12, 0.12));
  };
  if(choicesTitleView.notNil and: { choicesTitleView.respondsTo(\stringColor_) }) {
    choicesTitleView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  if(choicesTextView.notNil and: { choicesTextView.respondsTo(\stringColor_) }) {
    choicesTextView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  nil
});
)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "‚ùå Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "‚ùå Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Inspect_CommandTree_Under_Chain.scd =====
// Inspect_CommandTree_Under_Chain.scd
// v0.1.0
// MD 20250923--1255

/* Purpose
   Print child names (with frets) under "chain"; also prints under "add" if present.
   Helps confirm the live tree route to "delay".
   Style
   - var-first; descriptive variable names; no server.sync.
*/

(
var environmentReady, commandManager, commandTree, chainNode, addNode;
var listChildren, findChildByName;

environmentReady = (~system.notNil) and: { ~system.commandManager.notNil };
if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn; ^nil };

commandManager = ~system.commandManager;
commandTree    = commandManager.tree;

listChildren = { |nodeRef, labelText|
  var childrenArray, childLines;
  if(nodeRef.isNil) { ("[INSPECT] " ++ labelText ++ ": <nil>").postln; ^nil };
  childrenArray = nodeRef.children ? [];
  if(childrenArray.isEmpty) {
    ("[INSPECT] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[INSPECT] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil
};

findChildByName = { |parentNode, childNameString|
  if(parentNode.isNil) { ^nil };
  ^parentNode.getChildByName(childNameString.asString);
};

// 1) under "chain"
chainNode = commandTree.root.getChildByName("chain");
listChildren.(chainNode, "Children under [chain]");

// 2) under "chain ‚Üí add" (if present)
addNode = findChildByName.(chainNode, "add");
if(addNode.notNil) { listChildren.(addNode, "Children under [chain ‚Üí add]") };
)

===== utilities/Install_LightweightMeterPrinters.scd =====
// Install_LightweightMeterPrinters.scd
// v0.1
// MD 20250923-1556

/* Purpose
   Quiet console printers for '/ampA' and '/ampB' that print only non-zero-ish values.
*/

(
var threshold, freeIfExists;

threshold = 0.02;

freeIfExists = { |defName|
  var existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

freeIfExists.(\_meterA_dbg);
freeIfExists.(\_meterB_dbg);

OSCdef(\_meterA_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterA] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampA');

OSCdef(\_meterB_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterB] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampB');

"‚úÖ Lightweight printers installed (non-zero only).".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QuietProxyMeters_Core.scd =====
// Install_QuietProxyMeters_Core.scd
// v0.1
// MD 20250923-1610

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) using .filter:
   - Low-rate sampling with Impulse.kr.
   - Threshold gate from UGens (no Boolean 'or:').
   - Sends '/ampA' '/ampB' only when above threshold.
   - No console prints by default.

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold;
var ensureProxyAudio, installOrReplaceTap, installForProxy;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyAudio = { |proxyName|
  Server.default.bind({
    Ndef(proxyName).ar(2); // ensure 2ch audio-rate proxy exists
  });
};

installOrReplaceTap = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampLeft, ampRight, ampMax, tick, gate;

      // robust channel fetch
      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0.0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // per-channel level followers
      ampLeft  = Amplitude.kr(leftIn, 0.01, 0.15);
      ampRight = Amplitude.kr(rightIn, 0.01, 0.15);
      ampMax   = ampLeft.max(ampRight);     // <- UGen-safe combine

      // low-rate tick and gate when above threshold (UGen compare)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (ampMax > postThreshold); // 0 or tick

      // emit values only when above threshold
      SendReply.kr(gate, oscPath, [ampLeft, ampRight]);

      // pass-through audio unchanged
      inSig
    });
  });
};

installForProxy = { |proxyName, oscPath|
  ensureProxyAudio.(proxyName);
  installOrReplaceTap.(proxyName, oscPath);
};

installForProxy.(\chainA, '/ampA');
installForProxy.(\chainB, '/ampB');

"‚úÖ Quiet proxy taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"‚úÖ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Meters_Diagnostic_Bootstrap_FIX.scd =====
// Meters_Diagnostic_Bootstrap_FIX.scd
// v0.1.1
// MD 20250923-1543

/* Purpose
   - Ensure bus meter SynthDefs exist (defines them via MagicDisplay.ensureMeterDefs(2) if needed).
   - Instantiate meter readers on Ndef(\chainA) and Ndef(\chainB) buses.
   - Install console debug printers for '/ampA' and '/ampB' using correct OSCdef.free pattern.

   Style
   - var-first; Server.default.bind for server ops; AppClock-safe UI; no server.sync.
*/

(
var serverRef, statusDisplayRef, chainABusIndex, chainBBusIndex, metersGroupId;
var ensureMeterDefsExist, installDebugPrinters, freeIfExists;

serverRef        = Server.default;
statusDisplayRef = (~system ? nil).notNil.if({ ~system.statusDisplay }, { nil });

ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ÑπÔ∏è Defining meter synths (busMeterA/busMeterB).".postln;
    MagicDisplay.ensureMeterDefs(2); // should be idempotent in your codebase
  };
};

freeIfExists = { |defName|
  var existingDef;
  existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

installDebugPrinters = {
  // Avoid duplicates by
===== utilities/Meters_QuickCheck_And_Enable.scd =====
// Meters_QuickCheck_And_Enable.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - Ensure meter SynthDefs exist (busMeterA/B).
   - Attach meter readers to Ndef(\chainA/\chainB) buses.
   - Print incoming values to console (quick sanity).
   - Re-enable GUI meters if the display supports it.

   Style
   - var-first; Server.default.bind for server ops; no server.sync.
*/

(
var serverRef, displayRef, chainABusIndex, chainBBusIndex, metersGroup;
var ensureMeterDefsExist, installConsolePrinters;

serverRef  = Server.default;
displayRef = ~system ? nil;

// --- helpers ---
ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ö†Ô∏è Meter SynthDefs missing ‚Äî defining now via MagicDisplay.ensureMeterDefs(2)".postln;
  };
  MagicDisplay.ensureMeterDefs(2); // idempotent
};

installConsolePrinters = {
  // avoid duplicates
  OSCdef.remove(\_meterA_dbg);
  OSCdef.remove(\_meterB_dbg);
  OSCdef(\_meterA_dbg, { |oscMessage| ("[meterA] " ++ oscMessage[3..].asString).postln }, '/ampA');
  OSCdef(\_meterB_dbg, { |oscMessage| ("[meterB] " ++ oscMessage[3..].asString).postln }, '/ampB');
};

// --- server work ---
Server.default.bind({
  ensureMeterDefsExist.value;

  // ensure both chain proxies are realized at audio-rate
  Ndef(\chainA).ar(2);
  Ndef(\chainB).ar(2);
  chainABusIndex = Ndef(\chainA).bus.index;
  chainBBusIndex = Ndef(\chainB).bus.index;

  metersGroup = Group.head(serverRef.defaultGroup);

  // spawn readers (safe to re
===== utilities/MIDI_Input_Tests_20250922.scd =====
// MIDI_Input_Tests_20250922.scd
// Run these step by step

// STEP A ‚Äî canonical bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);   // nil -> class default tree path
    ~system.bringUpAll;
}.defer;
)


// STEP B ‚Äî Refresh and connect MIDI at the SC level (safe anytime)
(
MIDIClient.restart;     // re-scan devices (good after hot-plug)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)



// STEP C ‚Äî Inspect manager + the symbol names you can bind
(
var mi;

mi = ~system.commandManager.midiManager;

"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;   // prints "Symbol: \NAME  ‚Üí UID: 1234..."

"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;         // prints the connected devices it sees
)


// STEP D ‚Äî Bind nanoKEY2 and IAC "to SC" to handlers
(
var mi = ~system.commandManager.midiManager;

// nanoKEY2 -> FootController (so notes 36/38/40/41 switch idle/prog/queue/send)
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);

// IAC "to SC" -> Guitar handler (so notes become frets during PROG mode)
mi.bindDevice(\MD_IAC_to_SC, mi.guitarHandler);

// Show current bindings (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect { |k| mi.deviceUIDs[k] == srcID } ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)


// Option 1
MIDIdef.trace(true);   // start tracing all MIDI events
// Press a nanoKEY2 key (or send a note to IAC "to SC") ‚Äî you should see noteOn/off
// When done:
MIDIdef.trace(false);

// Option 2:
// Install once; re-evaluate if you hot-plug (it rebuilds the map)
(
var buildMap;
~midiLog_srcFilter = nil;  // e.g. set to \nanoKEY2_KEYBOARD to filter (optional)
~midiLog_chanFilter = nil; // e.g. set to 1 to filter (optional)
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name)
            .replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%"
                .format(sym, chan, num, val)).postln;
        };
    };
});

// quick refresh if you hot-plug:
~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

// stop logger if needed:
~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k| MIDIdef(k).free };
    "[MIDI-LOG] stopped".postln;
};

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)


===== utilities/MIDI_Input_Tests2_20250922.scd =====
//MIDI_Input_Tests2_20250922.scd

// 0) Bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
}.defer;
)


// 1) Refresh MIDI in SC and connect all sources
(
MIDIClient.restart;     // re-scan devices (safe after hot-plugging)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)


// 2) See the symbols your app uses and their UIDs
(
var mi = ~system.commandManager.midiManager;
"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;
"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;
)


// 3) Bind nanoKEY2 -> FootController; IAC 'to SC' -> Guitar
(
var mi = ~system.commandManager.midiManager;
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);
mi.bindDevice(\MD_IAC_to_SC,      mi.guitarHandler);

// Print bound table (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect({ |k| mi.deviceUIDs[k] == srcID }) ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)

MIDIdef.trace(true);   // enable global trace
// press keys on nanoKEY2 or send notes to IAC "to SC"
MIDIdef.trace(false);

// 4B) Install raw taps (noteOn/noteOff/cc)
(
var mkLabel, fns;

mkLabel = { |src|
    var ep = MIDIClient.sources.detect({ |e| e.uid == src });
    if(ep.notNil) { (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_") } { "uid:" ++ src }
};

~midiTap_remove.(); // remove any previous tap safely (defined below)

// keep references so we can remove cleanly
~midiTap_fns = IdentityDictionary[
    \noteOn  -> MIDIIn.addFuncTo(\noteOn,  { |src, chan, num, vel| ("[RAW] noteOn  src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \noteOff -> MIDIIn.addFuncTo(\noteOff, { |src, chan, num, vel| ("[RAW] noteOff src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \control -> MIDIIn.addFuncTo(\control, { |src, chan, num, val| ("[RAW] cc     src=%  ch=%  num=%  val=%".format(mkLabel.(src), chan, num, val)).postln; })
];

~midiTap_remove = {
    if(~midiTap_fns.notNil) {
        ~midiTap_fns.keysValuesDo { |k, fn| if(fn.notNil) { MIDIIn.removeFuncFrom(k, fn) } };
        ~midiTap_fns = nil;
        "[RAW] taps removed".postln;
    } {
        // noop
    };
};

"[RAW] taps installed ‚Äî press nanoKEY2 or send to IAC".postln;
)


// 4C) Minimal logger (noteOn/off & CC), with map refresh helper
(
var buildMap;
~midiLog_srcFilter = nil;
~midiLog_chanFilter = nil;
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k|
        var def = MIDIdef(k);
        if(def.notNil) { def.free };
    };
    "[MIDI-LOG] stopped".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%".format(sym, chan, num, val)).postln;
        };
    };
});

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "üîé [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"‚úÖ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "üõë [MIDI-LOG] stopped.".postln;
};
)

===== utilities/MIDI_Log_RefreshAndConnect.scd =====
// MIDI_Log_RefreshAndConnect.scd
// v0.1.0
// MD 20250922-1422

/*
Purpose
- If you plugged devices while SC was running, restart the MIDI client,
  reconnect all inputs, and refresh the logger's source map.
- Also clears any logger filters so you see everything.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

(
var announce;

announce = { |title| ("[MIDI-LOG] " ++ title).postln };

MIDIClient.restart;           // re-scan devices (idempotent & safe)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

~midiLog_srcFilter = nil;     // show all sources
~midiLog_chanFilter = nil;    // show all channels

if(~midiLog_refresh.isKindOf(Function)) {
    ~midiLog_refresh.();      // rebuild the uid->label map used by the logger
    announce.("sources remapped.");
} {
    announce.("note: logger not installed yet; run MIDI_Log_Console.scd first.");
};

// quick device listing
"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };
"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ [MIDI-LOG] refresh complete ‚Äî play/send something to see messages.".postln;
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "üßπ Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("üì• Command added: " ++ canonicalPathString).postln;
("üì¶ Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Report_ChainPlayFlags.scd =====
// Report_ChainPlayFlags.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Print whether Ndef(\chainA) and Ndef(\chainB) are playing.
   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var isChainAPlaying, isChainBPlaying;

isChainAPlaying = Ndef(\chainA).isPlaying;
isChainBPlaying = Ndef(\chainB).isPlaying;

("[PLAY] chainA=" ++ isChainAPlaying ++ "  chainB=" ++ isChainBPlaying).postln;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager‚Äôs builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X ‚Üí Name" lines for the GUI‚Äôs Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI‚Äôs expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager‚Äôs builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply ‚Üí " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready ‚Äî use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long ‚Üí short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long ‚Üí short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain ‚Üí add ‚Üí delay        (preferred if present)
       (b) chain ‚Üí add ‚Üí timebased ‚Üí delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> ‚Üí /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> ‚Üí /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path‚Üí " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) ‚Üí still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

===== utilities/Test_MagicPedalboard_MIDI_Simulation.scd =====
// Test_MagicPedalboard_MIDI_Simulation.scd
// v0.1.1
// MD 20250922-18-15

/*
Purpose
- Simulate MIDI input sequences for MagicPedalboard system testing.
- Each test step is labeled and commented with expected GUI/behavior.
- Allows repeatable, device-free testing and can be bundled with the suite.

Style
- var-first; lowercase; AppClock-only; no server.sync; clear comments.
*/

// --- Device UIDs: update these to match your system ---
var nanoUID = 302172822;    // nanoKEY2_KEYBOARD
var iacUID  = 1339807908;   // MD_IAC_to_SC

// --- Helper: fire a sequence of steps ---
~fireMidiSequence = { |steps|
    Routine({
        steps.do { |step|
            var src, chan, note, vel, dur, comment;
            src = step[0]; chan = step[1]; note = step[2];
            vel = step[3]; dur = step[4]; comment = step[5];
            ("[TEST] " ++ comment).postln;
            MIDIIn.doNoteOnAction(src, chan, note, vel);
            (dur ? 0.5).wait;
            MIDIIn.doNoteOffAction(src, chan, note, 0);
            0.1.wait;
        }
    }).play(AppClock);
};

// --- Test Sequence 1: Add Delay and Send ---
~test_add_delay = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 41, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /add"],
    [iacUID,  1, 45, 100, 0.5, "Step 3: IAC string 5 ‚Üí select /delay"],
    [nanoUID, 0, 40, 100, 0.5, "Step 4: nanoKEY2 E2 ‚Üí queue path"],
    [nanoUID, 0, 41, 100, 0.5, "Step 5: nanoKEY2 F2 ‚Üí send path"]
];

// --- Test Sequence 2: Switch Chain ---
/*~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 48, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"],
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]
];*/
~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"], // enter prog mode
    [iacUID,  0, 43, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"], // pitch 43 = base 40 + fret 3
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],   // queue
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]     // send
];



// --- To run a test sequence ---
~fireMidiSequence.(~test_add_delay);
// ~fireMidiSequence.(~test_switch_chain); // ‚Üê uncomment to run this one

// --- Add more sequences below as needed ---

===== utilities/Verify_Baseline_CurrentAudible_NextSilent.scd =====
// Verify_Baseline_CurrentAudible_NextSilent.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Verify that CURRENT‚Äôs sink is the audible one and NEXT‚Äôs sink is silent (Option A).
   - Posts a clear PASS/FAIL with details.

   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var systemReady, pedalboardRef;
var currentSinkSymbol, nextSinkSymbol;
var isChainAPlaying, isChainBPlaying;
var currentIsAudible, nextIsSilent;
var summaryText;

// guards
systemReady = ~system.notNil;
if(systemReady.not) {
    "‚ö†Ô∏è ~system is nil. Run Start_LivePedalboardSystem.scd (Option B) first.".postln;
};

// proceed only if ready
if(systemReady) {
    pedalboardRef = ~system.pedalboard;

    // sink symbols at the heads of CURRENT/NEXT
    currentSinkSymbol = pedalboardRef.effectiveCurrent[0];  // \chainA or \chainB
    nextSinkSymbol    = pedalboardRef.effectiveNext[0];     // \chainB or \chainA

    // live flags (do not change any routing)
    isChainAPlaying = Ndef(\chainA).isPlaying;
    isChainBPlaying = Ndef(\chainB).isPlaying;

    // interpret flags relative to CURRENT/NEXT
    currentIsAudible =
        ((currentSinkSymbol == \chainA) and: { isChainAPlaying })
        or: { (currentSinkSymbol == \chainB) and: { isChainBPlaying } };

    nextIsSilent =
        ((nextSinkSymbol == \chainA) and: { isChainAPlaying.not })
        or: { (nextSinkSymbol == \chainB) and: { isChainBPlaying.not } };

    if(currentIsAudible and: { nextIsSilent }) {
        "‚úÖ Baseline OK: CURRENT is audible; NEXT is silent.".postln;
    }{
        summaryText =
            "‚ö†Ô∏è Baseline mismatch ‚Äî "
            ++ "CURRENT=" ++ currentSinkSymbol.asString
            ++ " NEXT=" ++ nextSinkSymbol.asString
            ++ " | chainA=" ++ isChainAPlaying
            ++ " chainB=" ++ isChainBPlaying;
        summaryText.postln;
    };
};
)

