// MD_Stop_All_MeterDiagnostics.scd
// v0.1.1
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Quiet the console by freeing known OSCdef listeners and stopping any reporter routines
            we may have created during diagnostics. Safe to run multiple times. Auto-stops.
   Style:   single () block; var-first everywhere; descriptive lowercase names; AppClock-only where used;
            no server.sync; no single-letter locals; returns nil.
*/

(
var freeOscIfPresent, stopRoutineIfPresent, freedCount, oscKeys, indexCount, indexLimit;
var reporterStoppedCount, oscObj, routineRef;

// —— helpers (var-first in closures)
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MDSTOP: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineVar, labelString;
    var canStop;
    canStop = routineVar.notNil and: { routineVar.respondsTo(\stop) };
    if(canStop) { routineVar.stop; (labelString ++ ": stopped").postln };
};

// —— free known listeners (only if present)
freedCount = 0;
oscKeys = [
    \md_levels_sniffer_fixed,    // finite/continuous sniffers
    \md_levels_inline,           // overlay listener (if any)
    \md_levels_dbg_sniffer,      // debug taps listener
    \md_levels_gui_listener,     // if we created a GUI-only listener
    \md_levels_hud               // HUD listener (optional – remove if you want it kept)
];
indexCount = 0; indexLimit = oscKeys.size;
while({ indexCount < indexLimit }, {
    var keySym, exists;
    keySym = oscKeys[indexCount];
    exists = OSCdef.all.at(keySym).notNil;
    if(exists) { freeOscIfPresent.(keySym); freedCount = freedCount + 1 };
    indexCount = indexCount + 1;
});

// —— stop known reporter routines (only if present)
reporterStoppedCount = 0;
stopRoutineIfPresent.(~md_levels_dbg_reporter, "md_levels_dbg_reporter"); reporterStoppedCount = reporterStoppedCount + 1;
stopRoutineIfPresent.(~md_simple_reporter,     "md_simple_reporter");     reporterStoppedCount = reporterStoppedCount + 1;

// —— clear diagnostic dictionaries (safe)
~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
~md_levels_dbg = ~md_levels_dbg ? IdentityDictionary.new;

("MDSTOP: freed=" ++ freedCount.asString
 ++ " stopped=" ++ reporterStoppedCount.asString).postln;
nil
)
// MD_PerfHUD_LevelSubscriber.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:15 GMT+1

/*
Purpose
- Populate ~md_levelsById (IdentityDictionary) from /md/levels messages so
  MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd can render meters.
- Also updates ~md_lastMsgStamp for the "last /md/levels age" display.

Message shapes handled
- Standard: ['/md/levels', nodeID, replyID, L, R]   (preferred)
- Legacy:   ['/md/levels', replyID, L, R]           (fallback)

Reply IDs used by the GUI (per file comments):
- A = 2001, B = 2002, test = 1001
*/

(
var ensureDict, putPair, banner, oscAny;

banner = { arg text; ("[MD_SUB] " ++ text).postln; };

// Ensure the shared dictionary exists (the GUI reads this)
ensureDict = {
    (~md_levelsById.isKindOf(IdentityDictionary)).if({
        // already OK
    }, {
        ~md_levelsById = IdentityDictionary.new;
        banner.("created ~md_levelsById");
    });
    ~md_lastMsgStamp = ~md_lastMsgStamp ? thisThread.seconds;
};

putPair = { arg id, l, r;
    var pair;
    pair = [ (l ? 0.0).asFloat, (r ? 0.0).asFloat ];
    ~md_levelsById[id] = pair;
    ~md_lastMsgStamp = thisThread.seconds;
};

// Clean prior instance (idempotent)
OSCdef(\md_levels_any).free;

ensureDict.();

// One listener that accepts both shapes and writes into ~md_levelsById
oscAny = OSCdef(\md_levels_any, { arg msg, time, addr, port;
    var id, l, r, sz;
    sz = msg.size;
    // Standard
    (sz >= 5).if({
        id = msg[2];
        l  = msg[3];
        r  = msg[4];
        putPair.(id, l, r);
    }, {
        // Legacy
        (sz == 4).if({
            id = msg[1];
            l  = msg[2];
            r  = msg[3];
            putPair.(id, l, r);
        }, {
            // ignore
        });
    });
}, '/md/levels');

banner.("listening on /md/levels → ~md_levelsById (A=2001, B=2002, test=1001)");
"-> MD_PerfHUD_LevelSubscriber ready"
)
// MD_Taps_Clear_All_FIXED.scd
// v0.1.1 (clear proxies instead of filter(..., nil))
// MD timestamp: 2025-09-28 10:52 GMT+1

/*
Purpose
- Remove all taps/filters by clearing proxies and recreating chainA as a 2‑ch audio proxy.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var msg;

Server.default.bind({
    // stop and clear any existing sources/filters/taps
    Ndef(\chainA).stop; Ndef(\chainA).clear; Ndef(\chainA).ar(2);
    Ndef(\chainB).stop; Ndef(\chainB).clear; Ndef(\chainB).ar(2);
    Ndef(\testmelody).stop; Ndef(\testmelody).clear;
});

msg = "[TAPS] cleared: chainA, chainB, testmelody — chainA re-created as 2ch.";
msg.postln;
msg
)
// MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:27 GMT+1

/*
Purpose
- Audio proof with the tap attached to Ndef(\testmelody) (the generator),
  so measured levels are guaranteed non-zero and derived from the actual test signal.
- Sends /md/levels A=2001 from the tap; B stays untouched.

Style / Guard Rails
- Single () block; VAR-FIRST throughout; no non-local returns; no server.sync.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTapOnTest;

// params
hz = 12;
testFreq = 220;
testAmp  = 0.20;                       // gentle, audible
expectedRMS = (testAmp / (2.sqrt));    // ≈ 0.1414

banner = { arg text; ("[MD_A_AUDIO_FIX] " ++ text).postln; };

// ensure Ndefs exist (not strictly needed for \testmelody, kept for consistency)
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

// attach tap directly on \testmelody (NOT \chainA)
attachTapOnTest = { arg replyID;
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID); // replyID=2001
        inSig
    });
};

// generate tone, feed chainA, and play (so you hear it)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    ensureProxy.(\chainA, 2);
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

attachTapOnTest.(2001);

// finite console monitor for correlation (5 s)
OSCdef(\mdSpyA_fix).free;
OSCdef(\mdSpyA_fix, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
        ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA_fix).free;
    banner.("done (audio keeps playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS≈" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio_FIX_TapOnTest scheduled."
)
