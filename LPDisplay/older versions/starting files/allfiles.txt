// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)
