// LPDisplayLayoutTestWindow.sc
// v0.9.7.1 — Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.7.1 move makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‑pane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
        open, close
        setSourceA(\sym), setSourceB(\sym) — swap the tail source per chain
        sendPaneText(\diag, "…") — set any pane text
        setHudMap(mapOrNil), printHud — optional meter UI mapping

Works with:
    LPDisplaySigChain — the little wrapper that wires JITLib symbols into a playing chain.
    LPDisplayHudMap — optional linear→UI mapping (dB headroom + gamma) for the meters.
 */

LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.1";

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // optional; if nil, the meters take raw SendPeakRMS linear RMS.

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ⇒ raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } }; //closes any same name window
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------


	/* Make one labeled pane (internal helper)
 * Returns a UserView that draws a border and hosts a label + provided content.
 */
makePane { |content, label|
    var labelView, inner, pane, inset;

    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);

    inner = VLayout(labelView, content);

    pane = UserView().layout_(inner);

    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(
                inset, inset,
                v.bounds.width  - (2 * inset),
                v.bounds.height - (2 * inset)
            ));
            Pen.stroke;
        };
    });

    ^pane
}


    buildWindow {
        //var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

/*        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };*/

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}