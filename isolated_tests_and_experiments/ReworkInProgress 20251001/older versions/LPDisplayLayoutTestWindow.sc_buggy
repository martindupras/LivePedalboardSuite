// LPDisplayLayoutTestWindow.sc
// v0.9.2 - Grid window with A/B chains, LevelIndicators, OSC responders & console prints
// MD 20251001

/* Purpose
 - Recreate (and organize) the Layout Test window as a class with:
   labeled panes (left/right/system/diag/choices/recv), moving meters for A/B via
   SendPeakRMS, readable chain labels, quick methods to change tail sources, optional HUD mapping.
 - Keeps console level printers with ~1 Hz decimation and first-message dumps.
 Style
 - var-first declarations in every method block
 - lowercase method names; no non-local returns (^) inside function blocks
 - GUI updates via AppClock.defer; sinks read \in.ar(2)
 - JITLib operator strictly Ndef(left) <<> Ndef(right)
*/

LPDisplayLayoutTestWindow {
    classvar version;

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC names/defs
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // LPDisplayHudMap or nil

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplayLayoutTestWindow v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        var obj;
        obj = super.new;
        obj.init(hudMapInstance);
        obj
    }

    init { |hudMapInstance|
        var hm;
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        hm = hudMapInstance;
        hudMap = hm;
        paneColor = Color(0.0, 0.35, 0.0);
        this
    }

    // -------------------------- Public API --------------------------

    open {
        var wasOpen;
        wasOpen = false;
        Window.allWindows.do({ |w| if (w.name == "Layout Test", { wasOpen = true; w.close }) });
        this.buildWindow;
        this.bootAndBuildGraph;
        window // -> a Window
    }

    close {
        var a, b, ca, cb;
        if (window.notNil) {
            a = OSCdef(oscNameA);
            b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA);
            cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
            window.close;
            window = nil;
        };
        this
    }

    setSourceA { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainA.notNil) {
            chainA.setTailSource(s);
            { topLeftText.string_(chainA.chainToString) }.defer;
        };
        this
    }

    setSourceB { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainB.notNil) {
            chainB.setTailSource(s);
            { topRightText.string_(chainB.chainToString) }.defer;
        };
        this
    }

    sendPaneText { |paneKey, aString|
        var k, t;
        k = paneKey.asSymbol;
        t = aString.asString;
        if (k == \left)  { { topLeftText.string_(t)  }.defer };
        if (k == \right) { { topRightText.string_(t) }.defer };
        if (k == \system)  { { systemText.string_(t)  }.defer };
        if (k == \diag)    { { diagText.string_(t)    }.defer };
        if (k == \choices) { { choicesText.string_(t) }.defer };
        if (k == \recv)    { { recvText.string_(t)    }.defer };
        this
    }

    setHudMap { |mapOrNil|
        var m;
        m = mapOrNil;
        hudMap = m;
        this
    }

    printHud {
        var m;
        m = hudMap;
        if (m.notNil) { m.print } { "HUD mapping: none (raw 0..1)".postln };
        this
    }

    // ------------------------ Internal build steps ------------------------

    buildWindow {
        var buildLabeledPane;

        buildLabeledPane = { |content, label|
            var labelViewLocal, innerLocal, paneLocal, inset;
            labelViewLocal = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            innerLocal = VLayout(labelViewLocal, content);
            paneLocal = UserView().layout_(innerLocal);
            paneLocal.drawFunc_({ |v|
                var insetLocal;
                insetLocal = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(insetLocal, insetLocal, v.bounds.width - (2 * insetLocal), v.bounds.height - (2 * insetLocal)));
                    Pen.stroke;
                };
            });
            paneLocal
        };

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                buildLabeledPane.(HLayout(
                    topLeftText  = TextView().editable_(false),
                    topLeftMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Left Pane"),
                buildLabeledPane.(HLayout(
                    topRightText  = TextView().editable_(false),
                    topRightMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Right Pane")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), systemText  = TextView()), "System State"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), diagText    = TextView()), "Diagnostic Messages")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), choicesText = TextView()), "Choices"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), recvText    = TextView()), "Receiving Commands")
            ]
        );

        window.onClose = {
            var a, b, ca, cb;
            a = OSCdef(oscNameA); b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA); cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        this
    }

    bootAndBuildGraph {
        var valueFromMsg;

        Server.default.waitForBoot({
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI
            {
                topLeftText.string_(chainA.chainToString);
                topRightText.string_(chainB.chainToString);
            }.defer;

            // (Re)bind OSC responders (avoid duplicates)
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Extract last numeric value (typically RMS)
            valueFromMsg = { |msg|
                var v, sz;
                v = 0.0;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meter updaters (20 Hz)
            OSCdef(oscNameA, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topLeftMeter.value_(ui) }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topRightMeter.value_(ui) }.defer;
            }, '/peakrmsB');

            // Console printers (~1 Hz via decimation) + first-message dump
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (must read \in.ar(2)) + SendPeakRMS
        // Keep replyIDs A=1, B=2 to match earlier dumps.
        Ndef(\outA, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        this
    }
}
