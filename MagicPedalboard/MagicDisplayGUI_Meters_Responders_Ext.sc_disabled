// MagicDisplayGUI_Meters_Draw_Ext.sc
// v0.3.0
// MD 2025-09-24 22:58 BST

/*
Purpose
- Provide enableMeters(flag=true) without adding ivars.
- Draw simple A/B bars into the existing meterStrip : UserView and keep them
  updated from /reply packets sent by SendReply.kr in your AutoMeters helper.
Style
- Class extension only; var-first; AppClock UI; no server.sync; NO ^ inside closures.
*/

+ MagicDisplayGUI_GridDemo {

    // per-window state bag (no new ivars on the class)
    md_meterState {
        var bag, key, dict;
        bag = ~md_meterState ? IdentityDictionary.new;
        key = this.window.identityHash;
        dict = bag[key] ? IdentityDictionary.new;
        bag[key] = dict;
        ~md_meterState = bag;
        ^dict
    }

    // prepare the UserView and its drawFunc
    md_installMeterUserView {
        var state, host, setup;
        state = this.md_meterState;
        host  = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        setup = {
            var uv, ownUV, makeOwn, w, h, y;
            uv = state[\uv]; ownUV = state[\own];
            if(uv.isNil) {
                uv = this.meterStrip; // preferred: reuse your existing strip
                if(uv.isNil) {
                    // fall back: create a new one at bottom
                    w = host.bounds.width;  h = host.bounds.height; y = h - 46;
                    makeOwn = UserView(host);
                    makeOwn.bounds_(Rect(8, y, w - 16, 38));
                    uv = makeOwn; ownUV = true;
                };
                uv.background_(Color(0.12, 0.12, 0.12));
                uv.drawFunc = { |view|
                    var st, vw, vh, a, b, barW, barH, leftX, rightX, midY, titleY;
                    st = this.md_meterState;
                    vw = view.bounds.width;  vh = view.bounds.height;
                    a = (st[\valA] ? 0.0).clip(0, 1);
                    b = (st[\valB] ? 0.0).clip(0, 1);
                    barW = ((vw * 0.45) - 40).max(80);
                    barH = (vh * 0.40);
                    leftX  = 24;
                    rightX = (vw * 0.50) + 24;
                    midY   = (vh * 0.30);
                    titleY = (vh * 0.18);

                    Pen.color = Color(0.85,0.85,0.85);
                    Pen.stringAtPoint("A", Point(leftX - 18, titleY));
                    Pen.stringAtPoint("B", Point(rightX - 18, titleY));

                    Pen.color = Color(0.30, 0.90, 0.30); // A green
                    Pen.addRect(Rect(leftX, midY, barW * a, barH)); Pen.fill;

                    Pen.color = Color(0.30, 0.60, 0.90); // B blue
                    Pen.addRect(Rect(rightX, midY, barW * b, barH)); Pen.fill;
                };
                state[\uv] = uv; state[\own] = ownUV ? true : false;
                uv.refresh;
            };
        };

        AppClock.sched(0.0, { setup.value; nil });
        ^this
    }

    enableMeters { arg flag = true;
        var state, idStr, oscNameA, oscNameB, install, remove;

        state    = this.md_meterState;
        idStr    = this.window.identityHash.asString;
        oscNameA = ("md_ampA_" ++ idStr).asSymbol;
        oscNameB = ("md_ampB_" ++ idStr).asSymbol;

        remove = {
            var oa, ob, uv;
            oa = OSCdef(oscNameA); if(oa.notNil) { oa.free };
            ob = OSCdef(oscNameB); if(ob.notNil) { ob.free };
            state[\valA] = 0.0; state[\valB] = 0.0;
            uv = state[\uv]; if(uv.notNil) { uv.refresh };
            state[\enabled] = false;
        };

        install = {
            var uv;

            this.md_installMeterUserView;

            OSCdef.new(oscNameA, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampA") || (label == "ampA")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valA] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            OSCdef.new(oscNameB, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampB") || (label == "ampB")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valB] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            state[\enabled] = true;
        };

        AppClock.sched(0.0, { if(flag) { install.value } { remove.value }; nil });
        ^this
    }
}
