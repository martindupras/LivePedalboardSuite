===== CommandTree/CircularSaves.sc =====
// circularSaves.sc
// v1.2.1
// MD 20250819

// This allows me to save the last ten trees in a folder, and keep track of the last one. Versions are named after date/time.


CircularFileSave {
    var <>prefix, <>folderPath, <>maxVersions, <fileList;

    *new { |prefix = "myTree", folderPath = "~/TreeSaves", maxVersions = 10|
        ^super.new.init(prefix, folderPath, maxVersions);
    }

    init { |prefix, folderPath, maxVersions|
        this.prefix = prefix;
        this.folderPath = folderPath.standardizePath;
        this.maxVersions = maxVersions;
        this.ensureFolderExists;
        this.refreshFileList;
    }

    ensureFolderExists {
        File.mkdir(folderPath);
    }

/*    refreshFileList {
        fileList = PathName(folderPath).entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
    }*/

	// 20250922
refreshFileList {
    var pn, entries;
    pn = PathName(folderPath.standardizePath);
    if (pn.isFolder.not) { File.mkdir(pn.fullPath) };

    entries = pn.entries
        .select(_.isFile)
        .select({ |p| p.fileName.beginsWith(prefix) and: { p.fileName.endsWith(".json") } });

    // robust boolean comparator; no key-function; no .at on PathName
    entries = entries.asArray.sort({ |a, b| a.fileName > b.fileName });

    fileList = entries; // keep PathName objects; callers can use .fullPath / .fileName
    ^this
}



    saveVersion { |content|
        var timestamp = Date.getDate.stamp;
        var filename = "%-%".format(prefix, timestamp) ++ ".json";
        var path = folderPath +/+ filename;

        File.use(path, "w", { |f| f.write(content) });

        fileList.addFirst(PathName(path));

        if(fileList.size > maxVersions) {
            var toDelete = fileList.copyRange(maxVersions, fileList.size - 1);
            toDelete.do(_.delete);
            fileList = fileList.copyRange(0, maxVersions - 1);
        };

        path.postln;
    }

    listVersions {
        fileList.collect(_.fileName).do(_.postln);
    }

    loadVersion { |index|
        var file, content;

        if(index >= fileList.size or: { index < 0 }) {
            "Invalid index: % (available: 0 to %)".format(index, fileList.size - 1).warn;
            ^nil;
        };

        file = fileList[index];
        if(file.isNil) {
            "No file found at index %".format(index).warn;
            ^nil;
        };

        File.use(file.fullPath, "r", { |f|
            content = f.readAllString;
        });
        ^content;
    }

    latestVersion {
        ^this.loadVersion(0);
    }
}


===== CommandTree/CommandManager_PathPersistence.sc =====
// OBSOLETE


// // CommandManager_PathPersistence.sc
// // v1.0 — 2025-09-22 MD
// // Purpose: Remember last used tree path across runs.
// // Style: var-first; lowercase; no server.sync.
//
// + CommandManager {
// 	var <lastPathFile;
//
// 	init { |treePath|
// 		var defaultPath;
// 		lastPathFile = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/last_tree_path.txt";
// 		defaultPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//
// 		// Load last path if treePath is nil
// 		if(treePath.isNil) {
// 			treePath = this.readLastPath ?? defaultPath;
// 		};
//
// 		filePath = treePath;
// 		this.writeLastPath(filePath); // persist for next time
//
// 		// existing init logic continues...
// 		this.createNewTree;
// 		this.createBuilder;
// 		this.createCommandQueue;
// 		midiManager = MIDIInputManager.new(builder, nil, nil, nil);
// 		midiManager.parentCommandManager = this;
// 		^this
// 	}
//
// 	writeLastPath { |path|
// 		File.use(lastPathFile, "w", { |f| f.write(path) });
// 	}
//
// 	readLastPath {
// 		var content;
// 		if(File.exists(lastPathFile)) {
// 			File.use(lastPathFile, "r", { |f| content = f.readAllString });
// 		};
// 		^content
// 	}
// }

===== CommandTree/CommandManager.sc =====
// CommandManager.sc
// v1.6
// MD 20250921-22:40

// Purpose: Central controller; uses injected display (MagicDisplayGUI), does NOT create windows.
// Style: var-first, AppClock.defer for UI, no server.sync. Tree path is configurable in *new/init.

CommandManager {
	var <>currentState;
	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var <>filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver;
	var <>queueExportCallback;

	var launchpadHandler, footControllerHandler, guitarHandler;
	var <>launchpadID, <>footControllerID, <>guitarID;

	*new { arg treePath;
		^super.new.init(treePath);
	}


	init { arg treePath;
		var defaultPath, savedPath, stateDir, stateFile;
		var explicitOk, savedOk;

		currentState = \idle;
		saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);

		stateDir  = Platform.userExtensionDir ++ "/LivePedalboardSuite/.state";
		stateFile = stateDir ++ "/LastCommandTreePath.txt";

		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		savedPath = this.readLastPath(stateFile); // <- empty/whitespace -> nil

		explicitOk = treePath.isString and: { treePath.size > 0 };
		savedOk    = savedPath.isString and: { savedPath.size > 0 } and: { File.exists(savedPath) };

		filePath = if (explicitOk) { treePath } { if (savedOk) { savedPath } { defaultPath } };

		if (filePath.isString and: { filePath.size > 0 }) {
			this.writeLastPath(stateDir, stateFile, filePath);
		};

		this.createNewTree;        // will harden path again inside
		this.createBuilder;
		this.createCommandQueue;

		midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager.parentCommandManager = this;
		^this
	}

	// --- Build pieces --------------------------------------------------------

	createNewTree {
		var usePath;
		// final guard before import: ensure a usable String path
		usePath = filePath;
		if (usePath.isString.not or: { usePath.size <= 0 }) {
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};
		if (File.exists(usePath).not) {
			// last resort: keep going with default even if missing (import will warn gracefully)
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};

		tree = MDCommandTree.new("root");
		tree.importJSONFile(usePath);

		if (tree.notNil) {
			"📥 Tree imported from ".post; usePath.postln;
		}{
			"📥 Couldn't create/import tree.".postln;
		};
		^this
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			if (true) { "🔮 Builder created".postln };
		}{
			"🔮 Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			if (true) { "📦 Queue created".postln };
		}{
			"📦 Couldn't create queue".postln;
		}
	}

	// --- Display passthrough -------------------------------------------------

	setStatus { arg text;
		// If a MagicDisplayGUI is injected, use showExpectation (no updateStatus in that class)
		if (display.notNil and: { display.respondsTo(\showExpectation) }) {
			display.showExpectation(text, 0);
		}{
			("Status: " ++ text).postln;
		}
	}

	// Optional hot-reload from a new path
	reloadTreeFromPath { arg path;
		if (path.notNil) { filePath = path; };
		this.createNewTree;
		builder = MDCommandBuilder.new(tree);
		this.setStatus("✅ Tree reloaded from: " ++ filePath);
	}

	// --- tiny helpers (inside the same class) ---

	writeLastPath { arg dirPath, filePath, pathToWrite;
		var okDir;
		// guard: do nothing if not a non-empty String
		if (pathToWrite.isString.not or: { pathToWrite.size <= 0 }) { ^this };

		okDir = PathName(dirPath).isFolder;
		if (okDir.not) { File.mkdir(dirPath) };

		File.use(filePath, "w", { |fh| fh.write(pathToWrite) });
		^this
	}

	readLastPath { arg filePath;
		var content, cleaned, hasNonSpace;
		if (File.exists(filePath)) {
			File.use(filePath, "r", { |fh| content = fh.readAllString });
			// collapse whitespace-only to nil
			cleaned = content ? "";
			hasNonSpace = false;
			cleaned.do { |ch|
				if ((ch != $\ ) and: { ch != $\t } and: { ch != $\n } and: { ch != $\r }) {
					hasNonSpace = true;
				}
			};
			if (hasNonSpace.not) { content = nil };
		};
		^content
	}


	updateDisplay {
		var guiRef, modeText, choiceLines;

		guiRef = display;   // may be nil
		if (guiRef.isNil) { ^this };

		modeText = "Mode: " ++ (currentState ? \idle).asString;

		// build "fret X → Name" lines from the builder's current node
		choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
			builder.currentNode.children.collect({ |ch|
				("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString)
			})
		} { [] };

		{
			if (guiRef.respondsTo(\showExpectation)) {
				guiRef.showExpectation(modeText, 0);
			};
			if (guiRef.respondsTo(\updateTextField)) {
				guiRef.updateTextField(\state, modeText);
				guiRef.updateTextField(\choices, choiceLines.join("\n"));
			};
			// NEW: update choices panel in MagicDisplayGUI if present
			if (guiRef.respondsTo(\setOperations)) {
				guiRef.setOperations(choiceLines);
			};
		}.defer;

		^this
	}



}

// Back-compat alias
MDCommandMC : CommandManager {}

===== CommandTree/LivePedalboardSystem_MetersDelegate.sc =====
// OBSOLETE


// // LivePedalboardSystem_MetersDelegate.sc
// // v0.2.5 — 2025-09-21 MD
// // Purpose
// // - Defer meter definitions to MagicDisplay to avoid duplication.
// // Style
// // - var-first; lowercase; no server.sync.
//
// + LivePedalboardSystem {
// 	ensureMeterDefs {
// 		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
// 	}
// }

===== CommandTree/Logging/CommandManagerLogging.sc =====
// CommandManagerLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ CommandManager {

    logInit { |treePathString|
        this.mdlog(2, "CommandManager", "✅ created; treePath=" ++ treePathString);
        ^this
    }

    setStatus { |text|
        if(display.notNil and: { display.respondsTo(\showExpectation) }) {
            display.showExpectation(text, 0);
        }{
            this.mdlog(2, "CommandManager", "Status: " ++ text);
        };
        ^this
    }

    createNewTree {
        tree = MDCommandTree.new("root");
        tree.importJSONFile(filePath);
        if(tree.notNil) {
            this.mdlog(2, "CommandManager", "📥 tree imported: " ++ filePath);
            this.mdlog(3, "CommandManager", "tree pretty-print follows…");
            tree.printTreePretty;
        }{
            this.mdlog(1, "CommandManager", "⚠ couldn't create/import tree");
        };
        ^this
    }

    createBuilder {
        builder = MDCommandBuilder.new(tree);
        if(builder.notNil) {
            this.mdlog(2, "CommandManager", "🔭 builder created");
        }{
            this.mdlog(1, "CommandManager", "⚠ couldn't create builder");
        };
        ^this
    }

    createCommandQueue {
        queue = MDCommandQueue.new;
        if(queue.notNil) {
            this.mdlog(2, "CommandManager", "📦 queue created");
        }{
            this.mdlog(1, "CommandManager", "⚠ couldn't create queue");
        };
        ^this
    }

    reloadTreeFromPath { |path|
        if(path.notNil) { filePath = path; };
        this.createNewTree;
        builder = MDCommandBuilder.new(tree);
        this.setStatus("✅ tree reloaded from: " ++ filePath);
        this.mdlog(2, "CommandManager", "✅ tree reloaded: " ++ filePath);
        ^this
    }
}

===== CommandTree/Logging/MDCommandBuilderLogging.sc =====
// MDCommandBuilderLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandBuilder {

    printChildren {
        var names;
        if(currentNode.children.notEmpty) {
            currentNode.children.do { |item|
                this.mdlog(3, "CommandBuilder", "🎚 fret " ++ item.fret ++ " → " ++ item.name);
            };
            names = currentNode.children.collect(_.name);
        }{
            this.mdlog(1, "CommandBuilder", "⚠ no children");
            names = [];
        };
        ^names
    }

    navigateByFret { |stringLevel, fretNumber|
        var nextNode;
        this.mdlog(2, "CommandBuilder", "🎸 navigateByFret: " ++ fretNumber);
        nextNode = currentNode.getChildByFret(fretNumber);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        }{
            this.mdlog(1, "CommandBuilder", "⚠ no child for fret " ++ fretNumber);
        };
        ^currentNode
    }

    navigateByName { |stringLevel, childName|
        var nextNode = currentNode.getChildByName(childName);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        }{
            var avail = currentNode.children.collect(_.name).join(", ");
            this.mdlog(1, "CommandBuilder", "⚠ not found; available: " ++ avail);
        };
        ^currentNode
    }

    printPathToRoot {
        this.mdlog(3, "CommandBuilder", "📍 path=" ++ currentNode.getPathToRoot);
        ^this
    }

    getCurrentName {
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }

    getCurrentPayload {
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }

    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;
        this.mdlog(2, "CommandBuilder", "🔄 navigation reset");
        ^this
    }

    printfretPath {
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }
}

===== CommandTree/Logging/MDCommandNodeLogging.sc =====
// MDCommandNodeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandNode {

    addChild { |child|
        if(child.isKindOf(MDCommandNode)) {
            child.parent = this;
            children.add(child);
            this.mdlog(2, "CommandNode", "➕ added child '" ++ child.name ++ "' under '" ++ name ++ "'");
        }{
            this.mdlog(1, "CommandNode", "⚠ attempted to add non-node child");
        };
        ^this
    }

    createChild { |name, id, fret|
        var child;
        if(name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
            this.mdlog(1, "CommandNode", "❌ invalid args for createChild");
            ^nil;
        };
        child = this.getChildByName(name);
        if(child.isNil) {
            child = MDCommandNode.new(name, id, fret);
            this.addChild(child);
            this.mdlog(2, "CommandNode", "✅ created '" ++ name ++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
        }{
            this.mdlog(2, "CommandNode", "ℹ️ child already exists: " ++ name);
        };
        ^child
    }

    removeChildById { |idToRemove|
        var target = children.detect { |c| c.id == idToRemove };
        if(target.notNil) {
            children.remove(target);
            this.mdlog(2, "CommandNode", "🗑️ removed id " ++ idToRemove);
        }{
            this.mdlog(1, "CommandNode", "⚠ id not found: " ++ idToRemove);
        };
        ^this
    }

    getNodeByNamePath { |nameList|
        var currentLocal = this;
        nameList.do { |n|
            currentLocal = currentLocal.getChildByName(n);
            if(currentLocal.isNil) {
                this.mdlog(1, "CommandNode", "❌ path segment not found: " ++ n);
                ^nil;
            }
        };
        this.mdlog(2, "CommandNode", "✅ found node: " ++ currentLocal.name);
        ^currentLocal
    }

    printPathToRoot {
        this.mdlog(3, "CommandNode", "📍 " ++ this.getPathToRoot.join(" → "));
        ^this
    }

    printTreePretty { |level = 0, isLast = true, prefix = ""|
        var sortedChildren, connector, newPrefix, line;
        connector = if(level == 0) { "" } { if(isLast) { "└── " } { "├── " } };
        line = prefix ++ connector ++ this.name
            ++ " (fret:" ++ this.fret
            ++ ", id:" ++ this.id
            ++ ", payload:" ++ this.payload ++ ")";
        this.mdlog(3, "CommandNode", line);

        newPrefix = if(level == 0) { "" } { prefix ++ if(isLast) { "   " } { "│  " } };
        sortedChildren = this.children;
        sortedChildren.do { |child, i|
            var last = (i == (sortedChildren.size - 1));
            child.printTreePretty(level + 1, last, newPrefix);
        };
        ^this
    }
}

===== CommandTree/Logging/MDCommandTreeLogging.sc =====
// MDCommandTreeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandTree {

    printTreePretty {
        this.mdlog(3, "CommandTree", "pretty-print follows…");
        root.printTreePretty;
        ^this
    }

    findNodeByName { |name|
        var found;
        found = nodeMap.values.detect { |node| node.name == name };
        if(found.notNil) {
            this.mdlog(2, "CommandTree", "🔎 found '" ++ found.name ++ "' (id " ++ found.id ++ ")");
            ^found
        }{
            this.mdlog(1, "CommandTree", "⚠ node not found: " ++ name);
            ^nil
        }
    }

    getNodeByNamePath { |nameList|
        var found = root.getNodeByNamePath(nameList);
        if(found.notNil) { ^found }{
            this.mdlog(1, "CommandTree", "⚠ path not found: " ++ nameList.join(" → "));
            ^nil
        }
    }

    exportJSONFile { |path|
        var jsonString, file;
        jsonString = JSONlib.convertToJSON(root.asDictRecursively);
        file = File(path, "w");
        if(file.isOpen) {
            file.write(jsonString);
            file.close;
            this.mdlog(2, "CommandTree", "📤 exported to " ++ path);
        }{
            this.mdlog(1, "CommandTree", "⚠ failed to open for write: " ++ path);
        };
        ^this
    }

    importJSONFile { |path|
        var jsonString, dict, newTree;
        if(File.exists(path).not) {
            this.mdlog(0, "CommandTree", "❌ file does not exist: " ++ path);
            ^false;
        };
        jsonString = File(path, "r").readAllString;
        if(jsonString.isNil or: { jsonString.isEmpty }) {
            this.mdlog(1, "CommandTree", "⚠ file is empty/unreadable: " ++ path);
            ^false;
        };
        dict = JSONlib.convertToSC(jsonString);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "❌ failed to parse JSON: " ++ path);
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "📥 imported from " ++ path);
        ^true
    }

    saveVersioned {
        var json = JSONlib.convertToJSON(root.asDictRecursively);
        saver.saveVersion(json);
        this.mdlog(2, "CommandTree", "💾 versioned save complete");
        ^this
    }

    loadLatestVersion {
        var json, dict, newTree;
        json = saver.latestVersion;
        if(json.isNil or: { json.isEmpty }) {
            this.mdlog(1, "CommandTree", "⚠ no saved version found");
            ^false;
        };
        dict = JSONlib.convertToSC(json);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "❌ failed to parse saved JSON");
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "📥 loaded latest version");
        ^true
    }

    listSavedVersions {
        this.mdlog(2, "CommandTree", "🗂 listing saved versions…");
        saver.listVersions; // CircularFileSave may still post; optional: move it to logger later
        ^this
    }

    validateTree {
        var seen = Set.new, valid = true;
        nodeMap.values.do { |node|
            if(seen.includes(node.name)) {
                this.mdlog(1, "CommandTree", "⚠ duplicate node name: " ++ node.name);
                valid = false;
            };
            seen.add(node.name);
        };
        this.mdlog(valid.if(2,0), "CommandTree", valid.if("✅ validation passed", "❌ validation failed"));
        ^valid
    }

    assignPayloads {
        var assignRecursively;
        assignRecursively = { |node|
            node.payload = node.name;
            node.children.do { |child| assignRecursively.(child) };
        };
        assignRecursively.(this.root);
        this.mdlog(2, "CommandTree", "🧠 payloads assigned");
        ^this
    }

    printPayloads {
        var printRecursively;
        printRecursively = { |node, level = 0|
            var indent = " " ! level;
            this.mdlog(3, "CommandTree", indent.join ++ node.name ++ " → payload: " ++ node.payload);
            node.children.do { |child| printRecursively.(child, level + 1) };
        };
        printRecursively.(this.root);
        ^this
    }
}

===== CommandTree/Logging/MDLogFacade.sc =====
// MDLogFacade
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


// Minimal logging facade so any object can call: this.mdlog(level, label, message)
+ Object {
    mdlog { |level = 2, label = "GENERIC", message = ""|
        var logger = MDMiniLogger.get;
        switch(level,
            0, { logger.error(label, message) },
            1, { logger.warn(label, message) },
            2, { logger.info(label, message) },
            3, { logger.debug(label, message) },
            4, { logger.trace(label, message) }
        );
        ^this
    }
}

===== CommandTree/MDCommandBuilder.sc =====
// MDCommandBuilder.sc

// MD 20250818

MDCommandBuilder {
	var <>tree, <>currentNode, <>currentCommand, <>fretPath;
	var <>navigationComplete = false;

	*new { |argTree| ^super.new.init(argTree); }

	init { |argTree|
		tree = argTree;
		currentNode = tree.root;
		fretPath = List[0];
		"CommandBuilder initialized".postln;
		^this
	}

	printChildren {
		var childrenNames;
		if (currentNode.children.notEmpty) {
			currentNode.children.do { |item|
				("🎚 Fret: " ++ item.fret ++ " → " ++ item.name).postln;
			};
			childrenNames = currentNode.children.collect(_.name);
		} {
			"⚠️ No children".postln;
		};
		^childrenNames
	}

	navigateByFret { |stringLevel, fretNumber|
		var nextNode;
		("🎸 Navigating by fret: " ++ fretNumber).postln;
		nextNode = currentNode.getChildByFret(fretNumber);
		if (nextNode.notNil) {
			currentNode = nextNode;
			fretPath.add(currentNode.fret);
			("Current node: " ++ currentNode.name).postln;
		} {
			("⚠️ No child found for fret: " ++ fretNumber).postln;
		};
		^currentNode
	}


	navigateByName { |stringLevel, childName|
		var nextNode = currentNode.getChildByName(childName);
		if (nextNode.notNil) {
			currentNode = nextNode;
			fretPath.add(currentNode.fret);
			("Current node: " ++ currentNode.name).postln;
			("Path: " ++ currentNode.getFullPathString).postln;
		} {
			("⚠️ Available children: " ++ currentNode.children.collect(_.name).join(", ")).postln;
		};
		^currentNode
	}

	printPathToRoot {
		currentNode.getPathToRoot.postln;
		^this
	}

	getCurrentName {
		currentNode.name.postln;
		^currentNode.name
	}

	getCurrentPayload {
		("Current payload: " ++ currentNode.payload).postln;
		//currentNode.payload.postln;
		^currentNode.payload
	}
	isAtLeaf {
		^currentNode.children.isEmpty;
	}

	resetNavigation {
		currentNode = tree.root;
		fretPath = List[0];
		navigationComplete = false;  // important; reset the flag!
		"🔄 Navigation reset".postln;
		^this
	}

	printfretPath {
		("Fret path: " ++ fretPath).postln;
		^this
	}

}

===== CommandTree/MDCommandNode_FixIntegrity+DepthTag.sc =====
// MDCommandNode_FixIntegrity+DepthTag.sc
// v1.0 — 2025-09-21 MD

// Purpose
// - Accept SortedList in checkIntegrity.
// - Add tagByDepth(depth) used by MDCommandTree.tagDepths.
// Style
// - var-first; lowercase; no server.sync.

+ MDCommandNode {
    // Accept List OR SortedList
    checkIntegrity {
        var failedChild;
        if( (this.children.isKindOf(List).not) && (this.children.isKindOf(SortedList).not) ) {
            ("❌ Integrity check failed at node '" ++ this.name ++ "': children is " ++ children.class).postln;
            ^false;
        };
        failedChild = this.children.detect { |c| c.checkIntegrity.not };
        if(failedChild.notNil) {
            ("❌ Integrity failed in child: " ++ failedChild.name).postln;
            ^false;
        };
        ^true
    }

    // annotate nodes with a 'depth' entry in payload (non-destructive)
    tagByDepth { |depth|
        var nextDepth = (depth ? 0).asInteger.max(0);
        // if payload is nil or a String, wrap in a simple Event to attach depth safely
        if(this.payload.isNil or: { this.payload.isKindOf(String) }) {
            this.payload = (name: this.name, depth: nextDepth);
        }{
            // if payload is e.g., an Event/Dict, set depth if slot exists
            this.payload.put(\depth, nextDepth);
        };
        this.children.do { |child| child.tagByDepth(nextDepth + 1) };
        ^this
    }
}

===== CommandTree/MDCommandNode.sc =====
// MDCommandNode.sc
// Refactored for clarity and correctness
// MD 20250813

MDCommandNode {
	var <>name, <>id, <>fret, <>parent, <>children;
	var <> payload; // the "command" that will be inserted in the tree


	*new { |name = "default", id = 1, fret = 1, parent = nil|
		^super.new.init(name, id, fret, parent);
	}

	init { |name, id, fret, parent = nil|
		this.name = name;
		this.id = id;
		this.fret = fret;
		this.parent = parent;
		//this.children = List.new; // updated to following:
		this.children = SortedList.new(nil, { |a, b| a.fret < b.fret });

		//if (children.isKindOf(List).not) updated to following:
		if (this.children.isKindOf(SortedList).not) {
			{
				("⚠️ Children is not a SortedList in node '" ++ name ++ "'! It is: " ++ children.class).postln;
			};

			^this
		}
	}

		// ───── Child Management ─────

		addChild { |child|
			if (child.isKindOf(MDCommandNode)) {
				child.parent = this;
				children.add(child);
			} {
				"⚠️ Attempted to add a non-node child.".warn;
			}
		}

		createChild { |name, id, fret|
			var child;
			if (name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
				("❌ Invalid arguments for createChild").warn;
				^nil;
			};

			child = this.getChildByName(name);
			if (child.isNil) {
				child = MDCommandNode.new(name, id, fret);
				this.addChild(child);
				("✅ Created new child node: " ++ name ++ " (ID: " ++ id ++ ", Fret: " ++ fret ++ ")").postln;
			} {
				("ℹ️ Child node already exists: " ++ name).postln;
			};

			^child
		}

		removeChildByName { |nameToRemove|
			var index = children.findIndex { |c| c.name == nameToRemove };
			if (index.notNil) { children.removeAt(index); }
		}

		removeChildById { |idToRemove|
			var childToRemove = children.detect { |c| c.id == idToRemove };
			if (childToRemove.notNil) {
				children.remove(childToRemove);
				("🗑 Child removed").postln;
			} {
				("⚠️ ID not found").postln;
			}
		}

		// ───── Child Lookup ─────

		getChildByName { |name|
			if (name.isKindOf(String).not) {
				("❌ getChildByName error: name must be a String").warn;
				^nil;
			};
			^children.detect { |c| c.name == name }
		}

		getChildById { |id| ^children.detect { |c| c.id == id } }

		getChildByFret { |fret| ^children.detect { |c| c.fret == fret } }

		childNameExists { |name| ^children.any { |c| c.name == name } }

		// ───── Tree Navigation ─────

		getPathToRoot {
			var path = List.new;
			var current = this;
			while { current.notNil } {
				path.addFirst(current.name);
				current = current.parent;
			};
			^path
		}

		printPathToRoot {
			("📍 Path: " ++ this.getPathToRoot.join(" → ")).postln;
		}

		getNodeByNamePath { |nameList|
			var current = this;
			nameList.do { |name|
				current = current.getChildByName(name);
				if (current.isNil) {
					("❌ Node not found at path segment: " ++ name).postln;
					^nil;
				}
			};
			("✅ Found node: " ++ current.name).postln;
			^current
		}

		getDepth {
			^this.parent.notNil.if({ this.parent.getDepth + 1 }, { 0 })
		}


		// ───── Tree Analysis ─────

		isLeaf {
			^this.children.size == 0
		}

	// isDescendant replaced with hasChild; clearer
/*		isDescendant { |node|
			^this.children.any { |c| c === node }
		}*/

		hasChild { |node|
			^this.children.any { |c| c === node }
		}
		countDescendants {
			if (this.isLeaf) { ^1 } {
				^this.children.sum { |c| c.countDescendants }
			}
		}

		countLeavesOnly {
			^this.isLeaf.if({ 1 }, {
				this.children.sum { |c| c.countLeavesOnly }
			})
		}

		getFullPathString {
			^this.getPathToRoot.join(" → ");
		}

		checkIntegrity {
			var failedChild;

			if (this.children.isKindOf(List).not) {
				("❌ Integrity check failed at node '" ++ this.name ++ "'").postln;
				^false;
			};

			failedChild = this.children.detect { |c| c.checkIntegrity.not };
			if (failedChild.notNil) {
				("❌ Integrity failed in child: " ++ failedChild.name).postln;
				^false;
			};

			^true
		}


	// ───── Tree Display ─────
printTreePretty { |level = 0, isLast = true, prefix = ""|
    var sortedChildren, connector, newPrefix;

    // Print current node
    connector = if (level == 0) { "" } { if (isLast) { "└── " } { "├── " } };
    (prefix ++ connector ++ this.name ++
        " (fret: " ++ this.fret ++
        ", id: " ++ this.id ++
        ", payload: " ++ this.payload ++ ")").postln;

    // Prepare prefix for children
    newPrefix = if (level == 0) { "" } {
        prefix ++ if (isLast) { "    " } { "│   " }
    };

    // Use existing sortedChildren logic
    sortedChildren = this.children;

    // Recursively print children
    sortedChildren.do { |child, i|
        var last = (i == (sortedChildren.size - 1));
        child.printTreePretty(level + 1, last, newPrefix);
    };
}

		// ───── Serialization for exporting ─────

		asDictRecursively {
			^(
				id: this.id,
				name: this.name,
				fret: this.fret,
				children: this.children.collect { |c| c.asDictRecursively }
			)
		}
	}
	
===== CommandTree/MDCommandQueue.sc =====
// MDCommandQueue.sc
// Refactored for clarity and consistency
// MD 20250818



MDCommandQueue {
    var <>commandList;

    *new { ^super.new.init(); }

    init {
        commandList = List.new(8);
        Verbosity.postIf(1, "✅ CommandQueue initialized");
        ^this
    }

    enqueueCommand { |command|
        commandList.add(command);
        Verbosity.postIf(1, "📥 Command added: " ++ command);
        Verbosity.postIf(2, "📦 Current queue: " ++ commandList);
        ^commandList
    }

    dequeueLastCommand {
        if (commandList.notEmpty) {
            commandList.removeAt(commandList.size - 1);
            Verbosity.postIf(1, "🗑 Last command removed");
        } {
            Verbosity.postIf(0, "⚠ No command to remove");
        };
        ^commandList
    }

    clearQueue {
        commandList.clear;
        Verbosity.postIf(1, "🧹 Queue cleared");
        ^this
    }

    exportAsOSCPath {
        var oscPath;

        oscPath = "/" ++ commandList.collect { |cmd|
            cmd.asString;
        }.join("/");

        ~commandToSend = oscPath;
        Verbosity.postIf(2, "🚀 Exported OSC path: " ++ oscPath);
        ^oscPath
    }
}

// MDCommandQueue {
// 	var <>commandList;
//
// 	*new { ^super.new.init(); }
//
// 	init {
// 		commandList = List.new(8);
// 		"CommandQueue initialized".postln;
// 		^this
// 	}
//
// 	enqueueCommand { |command|
// 		commandList.add(command);
// 		("Command added: " ++ command).postln;
// 		("Current queue: " ++ commandList).postln;
// 		^commandList
// 	}
//
// 	dequeueLastCommand {
// 		if (commandList.notEmpty) {
// 			commandList.removeAt(commandList.size - 1);
// 			"Last command removed".postln;
// 		} {
// 			"⚠No command to remove".postln;
// 		};
// 		^commandList
// 	}
//
// 	clearQueue {
// 		commandList.clear;
// 		"🧹 Queue cleared".postln;
// 		^this
// 	}
//
//
// 	exportAsOSCPath {
// 		var oscPath;
//
// 		oscPath = "/" ++ commandList.collect { |cmd|
// 			cmd.asString;
// 		}.join("/");
//
// 		~commandToSend = oscPath;
// 		("Exported OSC path: " ++ oscPath).postln;
// 		^oscPath
// 	}
// }
===== CommandTree/MDCommandTree.sc =====
MDCommandTree {
	var <>root, <>nodeLimit = 200, <>nodeCount = 0, <>nodeMap;
	var <>saver;

	*new { |rootName = "root", rootId = 0, nodeLimit|
		^super.new.init(rootName, rootId, nodeLimit);
	}


	*fromDict { |dict|
		var tree;

		// Use a default node limit, or extract from dict if available
		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ?? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				tree.rebuildTreeFromDict(childDict, tree.root);
			};
		};
		tree.root.payload = dict[\payload];

		^tree;
	}


	init { |rootName, rootId, limit|
		root = MDCommandNode.new(rootName, rootId);
		nodeLimit = limit;
		nodeCount = 1;

		nodeMap = IdentityDictionary.new(100);
		nodeMap.put(rootId, root);

		saver = CircularFileSave.new("myTree", "~/TreeSaves", 10); // this is what will manage saves

		^this
	}

	rebuildTreeFromDict { |dict, parent|
		var node;

		node = MDCommandNode.new(dict[\name], dict[\id], dict[\fret]);
		parent.addChild(node);

		nodeMap.put(node.id, node);
		nodeCount = node.id.max(nodeCount);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				this.rebuildTreeFromDict(childDict, node);
			};
		};

		node.payload = dict[\payload];

		^node;
	}

	printTreePretty {
		root.printTreePretty;
		^this;
	}

	tagDepths {
		root.tagByDepth(0);
		^this;
	}

	findNodeByName { |name|
		var found;
		found = nodeMap.values.detect { |node| node.name == name };
		if (found.notNil) {
			("🔍 Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			^found
		} {
			"⚠️ Node not found".postln;
			^nil
		}
	}

	getNodeByNamePath { |nameList|
		var found;
		found = root.getNodeByNamePath(nameList);
		if (found.notNil) {
			^found
		} {
			("⚠️ Node not found at path: " ++ nameList.join(" → ")).postln;
			^nil
		}
	}

	addNode { |parentId, name, fret|
		var newId, parentNode, newNode;

		newId = nodeCount + 1;
		parentNode = nodeMap.at(parentId);

		if (parentNode.notNil) {
			nodeCount = newId;
			newNode = MDCommandNode.new(name, newId, fret);
			newNode.parent = parentNode;
			parentNode.addChild(newNode);
			nodeMap.put(newId, newNode);
			^newNode
		} {
			("⚠️ Invalid parent ID: " ++ parentId).postln;
			^nil
		}
	}

	removeNode { |nodeId|
		var nodeToRemove, parentNode, found;

		nodeToRemove = nodeMap.at(nodeId);
		parentNode = nodeToRemove.parent;

		if (parentNode.notNil) {
			found = parentNode.children.detect { |c| c === nodeToRemove };
			if (found.notNil) {
				parentNode.removeChildById(found.id);
				nodeMap.removeAt(nodeId);
				("🗑 Node " ++ nodeId ++ " removed.").postln;
				^nodeToRemove
			} {
				"⚠️ Node not found in parent's children".postln;
				^nil
			}
		} {
			"⚠️ Cannot remove root node".postln;
			^nil
		}
	}

	swapNodes { |nodeId1, nodeId2|
		var node1, node2, parent1, parent2;

		node1 = nodeMap.at(nodeId1);
		node2 = nodeMap.at(nodeId2);
		parent1 = node1.parent;
		parent2 = node2.parent;

		if (parent1.isNil or: { parent2.isNil }) {
			"⚠️ Both nodes must have parents to swap".postln;
			^nil
		};

		node1 = removeNode(nodeId1);
		node2 = removeNode(nodeId2);

		if (node1.isNil or: { node2.isNil }) {
			"⚠️ Failed to remove nodes for swapping".postln;
			^nil
		};

		parent1.addChild(node2);
		parent2.addChild(node1);

		"🔄 Nodes swapped".postln;
		^nil
	}

	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("📤 Tree exported to " ++ path).postln;
		} {
			"⚠️ Failed to open file for writing.".warn;
		}
	}

	importJSONFile { |path|
		var jsonString, dict, newTree;

		if (File.exists(path).not) {
			"❌ File does not exist: %".format(path).postln;
			^false;
		};

		jsonString = File(path, "r").readAllString;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"⚠️ File is empty or unreadable.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"⚠️ Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		("📥 Tree imported from " ++ path).postln;
		^true;
	}

	// NEW - added to manage circular saves
	saveVersioned {
		var json = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(json);
		"Tree saved to versioned file.".postln;
	}
	//---

	// NEW - added to manage circular saves
	loadLatestVersion {
		var json = saver.latestVersion;
		var dict, newTree;

		if(json.isNil or: { json.isEmpty }) {
			"⚠️ No saved version found.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(json);

		if(dict.isNil) {
			"⚠️ Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		"📥 Tree loaded from latest version.".postln;
		^true;
	}
	//---

	// NEW - added to manage circular saves
	listSavedVersions {
		saver.listVersions;
	}

	//---




	validateTree {
		var seenNames = Set.new;
		var valid = true;
		nodeMap.values.do { |node|
			if (seenNames.includes(node.name)) {
				("⚠️ Duplicate node name: " ++ node.name).postln;
				valid = false;
			};
			seenNames.add(node.name);
		};
		^valid;
	}


	// THIS IS NEW. This is so that (for now) we can copy the name of the node into the payload instance variable.
	assignPayloads {
		var assignRecursively;

		assignRecursively = { |node|
			node.payload = node.name;
			node.children.do { |child|
				assignRecursively.(child);
			};
		};

		assignRecursively.(this.root);
		"🧠 Payloads assigned to all nodes in tree.".postln;
		^this;
	}

	printPayloads {
		var printRecursively;

		printRecursively = { |node, level = 0|
			var indent = "  " ! level;
			(indent.join ++ node.name ++ " → Payload: " ++ node.payload).postln;
			node.children.do { |child|
				printRecursively.(child, level + 1);
			};
		};

		printRecursively.(this.root);
		^this;
	}


}

===== CommandTree/MIDIHandlers.sc =====
//MIDIHandlers.sc
// MD 20250818
// taken out of MIDIInputManager.sc to make smaller file and cleaner organisation.

MIDIInputHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}

LaunchpadHandler  {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
	}
}

LaunchpadDAWHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		// Intentionally left blank to ignore DAW messages
	}
}

FootControllerHandler {
	var <>inputManager;

	*new { |inputManager|
		if (inputManager.isNil) {
			Error("FootControllerHandler requires a inputManager").throw;
		};
		^super.new.init(inputManager);
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("✅ FootControllerHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, value|
		("🧪 inputManager class is: " ++ inputManager.class).postln;


		if (type === \noteOn) {
			switch (value,
				36, { inputManager.setMode(inputManager.modes[\idle]) },
				38, { inputManager.setMode(inputManager.modes[\prog]) },
				40, { inputManager.setMode(inputManager.modes[\queue]) },
				41, { inputManager.setMode(inputManager.modes[\send]) },
				{ ("⚠️ No action for note: " ++ value).postln }
			);
		}
	}
}

GuitarMIDIHandler {
	var <>inputManager;

	*new { |inputManager|
		var instance = super.new;
		instance.init(inputManager);
		^instance
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("✅ GuitarMIDIHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, pitch|
		var stringBasePitches, basePitch, fret, stringNumber;

		// ✅ Confirm method is being called
		("📥 handleMessage called with channel: " ++ channel ++ ", type: " ++ type ++ ", pitch: " ++ pitch).postln;

		// ✅ Check type
		if (type === \noteOn) {
			"✅ type is noteOn".postln;
		} {
			"❌ type is not noteOn".postln;
		};

		// ✅ Check current mode
		if (inputManager.currentMode == inputManager.modes[\prog]) {
			"✅ currentMode is prog".postln;

			stringBasePitches = (
				0: 40, // E string (6th)
				1: 45, // A
				2: 50, // D
				3: 55, // G
				4: 59, // B
				5: 64  // E (1st)
			);

			basePitch = stringBasePitches[channel];
			if (basePitch.notNil) {
				fret = pitch - basePitch;
				stringNumber = 6 - channel;

				("🎸 Received MIDI note: " ++ pitch ++
					" on channel: " ++ channel ++
					" → string: " ++ stringNumber ++
					", base pitch: " ++ basePitch ++
					", calculated fret: " ++ fret).postln;

				// ✅ Navigation logic
				if (inputManager.waitingForString == stringNumber) {
					inputManager.waitingForString = nil;
					inputManager.navigationCallback.value(fret);
				};
			} {
				("⚠️ Unrecognized channel: " ++ channel ++ ". No base pitch defined.").postln;
			}
		} {
			("❌ currentMode is: " ++ inputManager.currentMode).postln;
		};

		{ inputManager.parentCommandManager.updateDisplay; }.defer;
	}
}
===== CommandTree/MIDIInputManager.sc =====
// MIDIInputManager.sc
// v1.1 added things in send mode for LivePedalboardSystem
// MD 20250817-1926

MIDIInputManager {
	var <>deviceUIDs;         // Dict: symbolic name -> srcID
	var <>deviceHandlers;     // Dict: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <> builder, <>queue;
	var <> parentCommandManager;
	var <> modes;
	var <>waitingForString, <>navigationCallback;
	var <>lastEnqueuedPayload;


	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|

		this.modes = IdentityDictionary[
			\idle -> \idle,
			\prog -> \prog,
			\queue -> \queue,
			\send -> \send,
			\play -> \play,
			\numeric -> \numeric,
			\capture -> \capture,
			\record -> \record
		];

		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		//DEBUG:
		("footControllerHandler manager is: " ++ footControllerHandler.inputManager).postln;

		this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;

		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getDeviceSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}

	setMode { |newMode|
		currentMode = newMode;
		parentCommandManager.currentState = newMode;
		this.handleModeChange(newMode);
		{ parentCommandManager.updateDisplay }.defer;
	}

	handleModeChange { |mode|
		switch(mode,
			modes[\idle], {
				queue.clear;
				builder.resetNavigation;
				"Tree navigation reset.".postln;
			},

			modes[\prog], {
				var root;

				builder.resetNavigation;

				root = builder.tree.root; // get the root
				if (root.notNil) {
					root.children.do { |child| ("• " ++ child.name).postln };
				};

				this.startNavigationFromString(6);

				"Tree navigation started.".postln;
			},

			//---


			modes[\queue], {
				var queueText;
				var payload = builder.getCurrentPayload;

				if (payload != lastEnqueuedPayload) {
					("Current payload to queue: " ++ payload).postln;
					queue.enqueueCommand(payload);
					lastEnqueuedPayload = payload;

					if (builder.isAtLeaf) {
						parentCommandManager.setStatus("🌿 Leaf node reached; payload: " ++ payload);
					} {
						parentCommandManager.setStatus("📥 Queued node: " ++ payload);
					};

					queueText = queue.commandList.collect { |cmd| "- " ++ cmd.asString }.join("\n");
					("Queue contents:\n" ++ queueText).postln;

					{
						/*parentCommandManager.display.display(\state, "Mode: queue");
						parentCommandManager.display.display(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.display(\lastCommand, "Last Added: " ++ payload);*/
						parentCommandManager.display.updateTextField(\state, "Mode: queue");
						parentCommandManager.display.updateTextField(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.updateTextField(\lastCommand, "Last Added: " ++ payload);

					}.defer;
				} {
					("⚠️ Duplicate payload ignored: " ++ payload).postln;
					parentCommandManager.setStatus("⚠️ Duplicate payload ignored");
				};

				builder.resetNavigation;
				"Added node to queue and restarted navigation.".postln;
				this.setMode(modes[\prog]);
			},

			//---

/*			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;

				("Sent queue as OSC: " ++ path).postln;
				queue.clear;
			},*/

			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;
				("Sent queue as OSC: " ++ path).postln;
				if (parentCommandManager.notNil and: { parentCommandManager.queueExportCallback.notNil }) {
					parentCommandManager.queueExportCallback.value(path);
				};
				queue.clear;
			},

			modes[\play], {
				"🎸 Play mode: no interaction.".postln;
			},
			modes[\numeric], {
				"🔢 Numeric input mode (not yet implemented).".postln;
			},
			modes[\capture], {
				"🎼 Capture mode (not yet implemented).".postln;
			},
			modes[\record], {
				"🔴 Record mode (not yet implemented).".postln;
			}
		);
	}
	startNavigationFromString { |stringNum|
		if (stringNum < 1) {
			builder.navigationComplete = true;
			"✅ Navigation complete.".postln;
			^this;
		};

		this.listenForNoteFromString(stringNum, { |fret|
			builder.navigateByFret(stringNum, fret);
			this.startNavigationFromString(stringNum - 1);
		});
	}

	listenForNoteFromString { |stringNum, callback|
		waitingForString = stringNum;
		navigationCallback = callback;
		("🎧 Waiting for note on string " ++ stringNum).postln;
	}

	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"🎛 Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getDeviceSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " → UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getDeviceSrcID(keyOrID);
			symbol = keyOrID;
		}{
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("⚠️ Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("⚠️ No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("🔗 Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}

	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("⚠️ No handler bound for srcID: " + srcID).postln;
			}
		});
	}

} // end of MIDIInputManager class


===== CommandTree/UserDisplay.sc =====
// userFeedbackSystem.sc
// MD 20250806

// Used to display states of the system and such.

UserDisplay {

	var <>window;
	var <>modeText;
	var <>queueText;
	var <>lastCommandText;
	var <>userChoicesText;
	var <>statusText;

	*new{
		^super.new.init
	}

	init{
		"userFeedback created".postln;

		// create window
		window = Window("user display", Rect(10, 400, 800, 600));

		// create the fields:
		modeText = StaticText(window).string_("modeText");
		queueText = StaticText(window).string_("queueText");
		lastCommandText = StaticText(window).string_("lastCommandText");
		userChoicesText = StaticText(window).string_("userChoicesText");
		statusText = StaticText(window).string_(""); // choose appropriate position and size


		// add layouts to the window
		window.layout =
		VLayout(
			modeText,
			queueText,
			lastCommandText,
			userChoicesText,
			statusText
		);

		// bring window to front:
		window.front;
		^this // return instance of UserDisplay
	}

	updateTextField{
		|box, msg|
		switch (box,
			\state, { modeText.string_(msg)},
			\queue, { queueText.string_(msg)},
			\lastCommand, { lastCommandText.string_(msg)},
			\choices, { userChoicesText.string_(msg)}
		);

		postln("box:" + box);
		postln("msg:" + msg);
	}

	updateStatus { |text|
    ("🖥 Status update: " ++ text).postln;
    { this.statusText.string = text; }.defer; // assuming you have a GUI element called statusText
}


} //end of class
===== CommandTree/Verbosity.sc =====
// Verbosity.sc
// MD 20250819

// used to manage verbosity levels of my debugging messages

// Verbosity Levels:
// 0 → Errors only
// 1 → Actions
// 2 → Input/Output
// 3 → Object and type reporting
// 4 → Full debug (everything)






// Verbosity.sc
Verbosity {
    classvar <level = 2; // Default level

	*help {
    "Verbosity Levels:".postln;
    "0 → Errors only".postln;
    "1 → Actions".postln;
    "2 → Input/Output".postln;
    "3 → Object and type reporting".postln;
    "4 → Full debug (everything)".postln;
}


    *setLevel { |newLevel|
        level = newLevel;
        ("🔧 Verbosity level set to: " ++ level).postln;
    }

    *shouldPost { |requiredLevel|
        ^level >= requiredLevel;
    }

    *postIf { |requiredLevel, msg|
        if (level >= requiredLevel) {
            msg.postln;
        };
    }
}

===== LivePedalboardSystem/LivePedalboardSystem-Pathing.sc =====
// LivePedalboardSystem-Pathing.sc
// v0.3.0
// MD 2025-09-22 10:44 BST

/*
Purpose
- Make LivePedalboardSystem default to a JSON tree INSIDE the repo so a fresh clone runs.
- Allow optional, per-user overrides in Extensions/MDclasses or UserState.
- Preserve explicit constructor path as the highest priority.

Style
- var-first; lowercase method names; no server.sync.
- Class extension only; pure path logic here.
*/

+ LivePedalboardSystem {

    // 1) Repo default (shipped in Git)
    *defaultTreePath {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 2) Optional per-user override in MDclasses (not in Git)
    *userOverrideMDclasses {
        ^Platform.userExtensionDir
        ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 3) Optional per-user override alongside the code (normally .gitignored)
    *userOverrideUserState {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";
    }

    // Resolution: explicit → MDclasses → UserState → repo default
    *resolveTreePath { |maybePath|
        var p, mdOverride, usOverride, repoDefault;

        p = maybePath;
        if (p.notNil) { ^p }; // caller took responsibility

        mdOverride   = this.userOverrideMDclasses;
        usOverride   = this.userOverrideUserState;
        repoDefault  = this.defaultTreePath;

        if (File.exists(mdOverride)) { ^mdOverride };
        if (File.exists(usOverride)) { ^usOverride };
        if (File.exists(repoDefault)) { ^repoDefault };

        // Nothing found → helpful message
        ("[LPS] No CommandTree JSON found.\n"
        ++ "Tried:\n  1) " ++ mdOverride
        ++ "\n  2) " ++ usOverride
        ++ "\n  3) " ++ repoDefault
        ++ "\nCreate one of these files or pass a path to LivePedalboardSystem.new(path)."
        ).warn;

        ^repoDefault  // return something to avoid nil crashes; caller can handle missing file
    }

    // Ensure the constructor honours the resolver
    *new { |maybePath|
        ^super.newCopyArgs(
            this.resolveTreePath(maybePath)
        ).init;
    }
}

===== LivePedalboardSystem/LivePedalboardSystem.sc =====
// LivePedalboardSystem.sc
// v0.2.8
// MD 2025-09-22 1204

// Purpose: Bring-up MagicPedalboard + CommandManager + single MagicDisplayGUI (no duplicate windows).
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

LivePedalboardSystem : Object {
	var <>pedalboard;
	var <>pedalboardGUI;
	var <>commandManager;
	var <>statusDisplay;   // this will hold a MagicDisplayGUI
	var <>logger;
	var <>treeFilePath;

	*new { arg treePath;
		^super.new.init(treePath);
	}

	init { arg treePath;
		var defaultPath;
		logger = MDMiniLogger.get;

		// Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		treeFilePath = treePath.ifNil { defaultPath };
		^this;
	}


	bringUpAll {
		// ✅ Make sure the server is up and the tree is clean *before* we create MPB
		this.ensureServerReady;

		this.bringUpMagicDisplayGUI;   // 1) GUI first
		this.bringUpPedalboard;        // 2) create MPB (it will create groups)
		this.bringUpCommandSystem;     // 3) hook command system
		this.ensureAudioOn;            // 4) prime sources + play current (no tree reset here)


		// meters last (you already moved this)
/*    if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
        statusDisplay.enableMeters(true);
    };*/

		//v0.2.8
		AppClock.sched(0.35, {    // 350 ms is enough to outlive the initial MPB rebuild
			if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
				statusDisplay.enableMeters(true);
			};
			nil
		});

		logger.info("LivePedalboardSystem", "✅ System is ready.");
		^this;
	}


/*	bringUpPedalboard {
		pedalboard = MagicPedalboard.new;
		pedalboardGUI = MagicPedalboardTestRunner.new(pedalboard, nil);
		pedalboardGUI.bringUp;
		logger.info("Pedalboard", "Pedalboard and GUI initialized.");
	}*/

/*	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}*/

	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}

	bringUpCommandSystem {
		commandManager = CommandManager.new(treeFilePath);


		// inject GUI so updateDisplay() can actually update something
		commandManager.display = statusDisplay;

		// Queue export -> pedalboard
		commandManager.queueExportCallback = { |oscPath|
			pedalboard.handleCommand(oscPath);
			logger.info("Integration", "Sent command to pedalboard: " ++ oscPath);
			// If GUI is up, show last command
			if (statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
				statusDisplay.showExpectation("Sent: " ++ oscPath, 0);
			};
		};

		logger.info("CommandSystem", "CommandManager initialized and connected.");
	}

	// --- Single MagicDisplayGUI window, with meters enabled ---


	bringUpMagicDisplayGUI {
		// close any previous MagicDisplayGUI windows to avoid duplicates
		this.closeExistingMagicDisplayWindows;

		statusDisplay = MagicDisplayGUI_GridDemo.new; // existing line
		statusDisplay.showExpectation("System ready.", 0);

		// share GUI with CommandManager so CommandManager:setStatus can target it
		if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };

		this.ensureMeterDefs;
		// meters are enabled later in bringUpAll to avoid node races
	}



	// --- Provide \busMeterA / \busMeterB if they don't exist yet ---
	// replaced with the below, which uses MagicDisplay meters instead:
	ensureMeterDefs {
		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
	}

	// --- Conservative "make sure something is audible" ---
/*	ensureAudioOn {
		var started;
		started = false;

		if (pedalboard.respondsTo(\start)) { pedalboard.start; started = true; }
		{ if (pedalboard.respondsTo(\play)) { pedalboard.play; started = true; } };

		if (started.not) {
			this.tryPlayNdefs([\chainA, \chainB, \testmelody]);
		};

		logger.info("Audio", "ensureAudioOn called (started: %).".format(started));
	}*/


	ensureAudioOn {
		var s;
		s = Server.default;

		// Define sources/sinks idempotently
		Server.default.bind({
			if (Ndef(\testmelody).source.isNil) {
				Ndef(\testmelody, {
					var trig = Impulse.kr(3.2);
					var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
					var f = Demand.kr(trig, 0, seq);
					var env = Decay2.kr(trig, 0.01, 0.35);
					var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
					Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
				});
			};
			Ndef(\testmelody).ar(2);

			if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
			Ndef(\ts0).ar(2);

			// Ensure sink proxies exist at audio rate; MPB wires them
			Ndef(\chainA).ar(2);
			Ndef(\chainB).ar(2);
		});

		// Route CURRENT to \testmelody + Option A
		if (pedalboard.respondsTo(\setSourceCurrent)) {
			pedalboard.setSourceCurrent(\testmelody);
		};
		if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
			pedalboard.enforceExclusiveCurrentOptionA(0.1);
		};

		// Make sure CURRENT sink is actually playing; stop the other
		if (pedalboard.respondsTo(\playCurrent)) {
			pedalboard.playCurrent;
		} {
			Server.default.bind({
				if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
				if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
			});
		};

		// One tiny deferred re-assert (survives any late rebuild)
/*		AppClock.sched(0.10, {
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
            });
        };
        nil*/


		// --- Make sure CURRENT sink is actually playing (single deferred assert) ---
		AppClock.sched(0.25, {     // allow the temp SynthDef add to complete
			if (pedalboard.respondsTo(\playCurrent)) {
				pedalboard.playCurrent;  // MPB decides which (A/B) should be audible
			} {
				Server.default.bind({
					if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
					if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
				});
			};
			nil
		});



		if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
		logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
	}


	ensureServerReady {
		var s, didBoot;

		s = Server.default;
		didBoot = false;

		if (s.serverRunning.not) {
			s.boot;
			s.waitForBoot;   // permitted in your safe-reset pattern
			didBoot = true;
		};

		if (didBoot) {
			// Only wipe the tree on fresh boot, before MPB is constructed
			Server.default.bind({
				s.initTree;
				s.defaultGroup.freeAll;
			});
		};

		^didBoot
	}


	tryPlayNdefs { arg syms;
		syms.do { arg sym;
			var nd = Ndef(sym);
			if (nd.notNil) { nd.play; };
		};
	}

	showStatus {
		logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
			pedalboard, commandManager
		));
	}

/*    shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/


	closeExistingMagicDisplayWindows {
		var wins;
		wins = Window.allWindows.select({ |w|
			var nm = w.tryPerform(\name);
			nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
		});
		AppClock.sched(0.0, {
			wins.do({ |w| w.close });
			nil
		});
		^this
	}



	shutdownAll {
		var runnerClosed;

		runnerClosed = false;

		if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
			pedalboard.free;
		};

		if (pedalboardGUI.notNil) {
			if (pedalboardGUI.respondsTo(\close)) {
				pedalboardGUI.close; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
				pedalboardGUI.stop; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
				pedalboardGUI.free; runnerClosed = true;
			};
		};

		if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
			statusDisplay.close;
		};

		logger.warn("Shutdown", "LivePedalboardSystem shut down.");
	}
}

===== Magicpedalboard/_archive/2025-09-20/TestMagicPedalboard.sc =====
// TestMagicPedalboard.sc
// v0.1.0
// MD 20250919-15.33

/*
Purpose:
- Run a basic acceptance test on MagicPedalboardNew.
- Uses MDMiniLogger for structured logging.
- Verifies chain mutation, switching, and bypass toggling.

Style:
- var-first; lowercase method names; no server.sync.
- GUI optional; logs to console.
*/

TestMagicPedalboard : Object {
    var <logger, <pedalboard, <gui;

    *new { arg mpb, gui = nil;
        ^super.new.init(mpb, gui);
    }

    init { arg mpb, gui;
        pedalboard = mpb;
        this.gui = gui;
        logger = MDMiniLogger.new("TestMagicPedalboard");
        ^this;
    }

    runAcceptanceTest {
        logger.info("Starting acceptance test...");

        logger.info("Step 1: Add \\delay to NEXT");
        pedalboard.add(\delay);
        pedalboard.printChains;

        logger.info("Step 2: Switch chains (A → B)");
        pedalboard.switchChain(0.12);
        pedalboard.printChains;

        logger.info("Step 3: Bypass \\delay ON (CURRENT)");
        pedalboard.bypassCurrent(\delay, true);
        pedalboard.printChains;

        logger.info("Step 4: Bypass \\delay OFF (CURRENT)");
        pedalboard.bypassCurrent(\delay, false);
        pedalboard.printChains;

        logger.info("Step 5: Switch back (B → A)");
        pedalboard.switchChain(0.12);
        pedalboard.printChains;

        logger.info("Acceptance test complete.");
    }

    help {
        "Available methods: runAcceptanceTest".postln;
    }
}

===== Magicpedalboard/MagicDisplay.sc =====
/* MagicDisplay.sc  v0.1.3
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

	classvar < version, < metersReady, < meterChannels;

	var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose


	*initClass {
		version = "v0.1.3";
		("MagicDisplay " ++ version).postln;

		// default compile-time meter channel count
		meterChannels = 2;
		metersReady = false;

		// define (or re-define) the meter SynthDefs now
		this.ensureMeterDefs(meterChannels);
	}


	*new { |level = 1|
		^super.new.init(level)
	}

	init { |level|
		var initialLevel;
		initialLevel = level ? 1;
		logLevel = initialLevel;
		^this
	}

	help {
		var text;
		text = "MagicDisplay " ++ version
		++ "\nMethods:\n"
		++ "  showInit(pedalboard, versionString, current, next)\n"
		++ "  showRebuild(which, fullChain, effective)\n"
		++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
		++ "  showMutation(action, args, nextChain)\n"
		++ "  showBypass(which, key, state, chain, bypassKeys)\n"
		++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
		++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
		++ "  showError(message)\n";
		text.postln;
	}

	showInit { |pedalboard, versionString, current, next|
		if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
	}

	showRebuild { |which, fullChain, effective|
		if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
	}

	showPlay { |sinkKey|
		if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
	}

	showStop { |sinkKey|
		if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
	}

	showSwitch { |oldSink, newSink, current, next|
		if(logLevel > 0) {
			("[MPB:switch] " ++ oldSink ++ " → " ++ newSink
				++ "  current=" ++ current ++ "  next=" ++ next).postln;
		};
	}

	showMutation { |action, args, nextChain|
		if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
	}

	showBypass { |which, key, state, chain, bypassKeys|
		if(logLevel > 0) {
			("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
				++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
		};
	}

	showReset { |current, next|
		if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
	}

	showChains { |current, next, bypassAKeys, bypassBKeys|
		if(logLevel > 0) {
			"MagicPedalboardNew.printChains:".postln;
			("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
			("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
		};
	}

	showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
		var header, formatOne;

		if(logLevel <= 0) { ^this };

		header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

		formatOne = { |titleString, listRef, bypassKeys, effective|
			var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

			lastIndex = listRef.size - 1;
			sinkKey = listRef[0];
			sourceKey = listRef[lastIndex];

			header.(titleString);
			("sink : " ++ sinkKey).postln;

			indexCounter = 1;
			if(listRef.size > 2) {
				"procs:".postln;
				listRef.copyRange(1, lastIndex - 1).do { |procKey|
					var isBypassed, mark;
					isBypassed = bypassKeys.includes(procKey);
					mark = if(isBypassed) { "BYP" } { "ON " };
					lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
					lineText.postln;
					indexCounter = indexCounter + 1;
				};
			}{
				"procs: (none)".postln;
			};

			("src  : " ++ sourceKey).postln;
			("eff  : " ++ effective.join("  ->  ")).postln;
			"".postln;
		};

		formatOne.("CURRENT", current, bypassAKeys, effCurrent);
		formatOne.("NEXT",    next,    bypassBKeys, effNext);
	}

	showError { |message|
		("[MPB:error] " ++ message).warn;
	}

	// ----- meter SynthDefs (class-level) -----

	*ensureMeterDefs { arg ch = 2;
		var n;
		// clamp to a sensible positive integer
		n = ch.asInteger.max(1);
		meterChannels = n;

		// Define (or re-define) once per class init (safe to call again after recompile).
		// Uses compile-time channel count 'n' inside the UGen graph.
		Server.default.bind({
			SynthDef(\busMeterA, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);                 // compile-time 'n'
				var amp  = Amplitude.ar(sig).clip(0, 1);    // per-channel amplitude
				SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
			}).add;

			SynthDef(\busMeterB, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);
				var amp  = Amplitude.ar(sig).clip(0, 1);
				SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
			}).add;
		});

		metersReady = true;
	}

	*setMeterChannels { arg ch = 2;
		// convenience: re-emit defs with a new compile-time channel count
		this.ensureMeterDefs(ch);
	}

}

===== Magicpedalboard/MagicDisplayGUI_Ext_VisualOnly.sc =====
// MagicDisplayGUI_Ext_VisualOnly.sc
// v0.1.1 (fixed: no ivar; uses window property bag instead)
// MD 20250919-08:05 BST

/*
Purpose
- Add "visual-only" layout controls to MagicDisplayGUI without modifying the class file.
- setVisualOnly(true): hides Ops area; recomputes A/B panel heights so they stop above
  the expectation/countdown block; meters group remains at the bottom.
- relayoutVisualOnly: recompute bounds; attachResize wires window.onResize -> relayout.

Style
- AppClock for UI; no server.sync; methods live in a class extension.
- Uses window.setProperty/getProperty(\visualOnlyFlag) instead of new ivars.
*/

+ MagicDisplayGUI {

    // -- helpers to read/write the visual-only flag using the window as property bag
    getVisualOnlyFlag {
        var v;
        v = false;
        if(window.notNil) {
            v = window.getProperty(\visualOnlyFlag) ? false;
        };
        ^v
    }

    setVisualOnly { arg flag = true;
        var on;
        on = flag ? true;
        this.queueUi({
            if(window.notNil) { window.setProperty(\visualOnlyFlag, on) };

            // Hide or show ops widgets
            if(opsListView.notNil)   { opsListView.visible_(on.not) };
            if(opsNextButton.notNil) { opsNextButton.visible_(on.not) };
            if(opsStatusText.notNil) { opsStatusText.visible_(on.not) };

            this.relayoutVisualOnly;  // recompute layout now
        });
        ^this
    }

    relayoutVisualOnly {
        var pad, metersH, expH, expGap, countH, winRect, colGap;
        var visualOnly, rightW, usableW, colW, colH, leftX, rightX;
        var groupLeft, groupTop, groupW, labelW, barW;

        // Geometry constants (aligned to your class)
        pad     = 10;
        metersH = 86;   // meters block height in your class
        expH    = 52;   // expectation text height
        expGap  = 6;    // spacing between expectation and countdown bar row
        countH  = 20;   // countdown row height
        colGap  = 40;   // gap between columns

        visualOnly = this.getVisualOnlyFlag;

        // Window rect fallback if not created yet
        winRect = (window.notNil).if({ window.view.bounds }, { Rect(0, 0, 980, 520) });

        // If visual-only, reclaim the ops panel width
        rightW  = (visualOnly ? 0 : 320);

        // Compute column widths
        usableW = winRect.width - (2 * pad) - rightW - colGap;
        colW    = (usableW / 2).max(220);

        // Compute column heights so panels stop ABOVE the expectation + countdown region
        colH = winRect.height
            - (2 * pad)   // top + bottom padding
            - metersH     // meters area at bottom
            - expH        // expectation text
            - expGap      // spacing
            - countH      // countdown row
            - 12;         // small margin

        colH = colH.max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        this.queueUi({
            // Left/right column panels
            if(leftPanel.notNil)  { leftPanel.bounds  = Rect(leftX,  pad, colW, colH) };
            if(rightPanel.notNil) { rightPanel.bounds = Rect(rightX, pad, colW, colH) };

            // Expectation + countdown spans both columns
            if(expectationText.notNil) {
                expectationText.bounds = Rect(leftX, leftPanel.bounds.bottom + 6, colW*2 + colGap, expH)
            };
            if(countdownLabel.notNil)   {
                countdownLabel.bounds    = Rect(leftX, expectationText.bounds.bottom + expGap, 120, 20)
            };
            if(countdownBarView.notNil) {
                countdownBarView.bounds  = Rect(leftX + 130, expectationText.bounds.bottom + expGap,
                                                (colW*2 + colGap) - 140, 20)
            };

            // Ops area only when not visual-only
            if(visualOnly.not and: { opsListView.notNil }) {
                opsListView.bounds = Rect(expectationText.bounds.right + pad, pad,
                                          rightW - pad, winRect.height - 2 * pad);
                if(opsStatusText.notNil) {
                    opsStatusText.bounds = Rect(opsListView.bounds.left,
                                                opsListView.bounds.bottom - 52,
                                                opsListView.bounds.width - 110, 20)
                };
                if(opsNextButton.notNil) {
                    opsNextButton.bounds = Rect(opsListView.bounds.right - 100,
                                                opsListView.bounds.bottom - 56, 100, 28)
                };
            };

            // Meters group: reuse the parent of meterViewA/B
            if(meterViewA.notNil and: { meterViewB.notNil } and: { meterViewA.parent.notNil }) {
                groupLeft = pad;
                groupTop  = winRect.height - metersH - pad;
                groupW    = winRect.width  - 2*pad;
                meterViewA.parent.bounds = Rect(groupLeft, groupTop, groupW, metersH);

                // child bars
                labelW = 60;
                barW   = groupW - labelW - 10;
                meterViewA.bounds = Rect(labelW + 6, 4, barW, 20);
                meterViewB.bounds = Rect(labelW + 6, 4 + 38, barW, 20);
            };
        });

        ^this
    }

    attachResize {
        this.queueUi({
            if(window.notNil) {
                window.onResize = { this.relayoutVisualOnly };
            };
        });
        ^this
    }
}

===== Magicpedalboard/MagicDisplayGUI_GridDemo.sc =====
// MagicDisplayGUI_GridDemo.sc
// v0.1.6
// MD 20250919-10:46 BST

/*
Purpose
- GridLayout-based GUI for VISUAL-ONLY demos (no audio, meters disabled).
- Row 0: CURRENT | NEXT (two equal columns).
- Rows 1..4: full-width using addSpanning (expectation, countdown, thin meters=30px, processors).
- Extra height only goes to Row 0 (chains row).

Debug
- debugGuides(true): overlays red outlines + row labels; postLayoutReport() prints rects.

Style
- var-first; lowercase; AppClock-only UI ops; no caret returns in closures; no server.sync.
*/

MagicDisplayGUI_GridDemo : MagicDisplay {
	classvar <versionGUI;
	var <window;

	// root + top-level row views (children of window.view)
	var rootLayout;
	var leftPanel, rightPanel;
	var expectationView, countdownHolder, meterStrip, bottomHudView;

	// children within panels
	var leftHeader, leftListView, leftEff;
	var rightHeader, rightListView, rightEff;
	var countdownLabel, countdownBar;
	var bottomCurText, bottomNextText;

	// debug overlay
	var debugOn = false;
	var overlayRow0, overlayRow1, overlayRow2, overlayRow3, overlayRow4;

	var metersEnabled;

	//new
	var <choicesPanel, <choicesTitle, <choicesText;
	var buildChoices;

	*initClass {
		var s;
		versionGUI = "v0.1.5";
		s = "MagicDisplayGUI_GridDemo " ++ versionGUI;
		s.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var reqW, reqH, sb, maxW, maxH, winW, winH, rect;
		var metersRowH, hudRowH;
		var buildLeft, buildRight, buildExpectation, buildCountdown, buildMeters, buildBottomHud;

		// window sizing (fits iPad side-screen limit)
		reqW = 1200; reqH = 760;
		sb   = Window.screenBounds ? Rect(0, 0, 1920, 1080);
		maxW = (2560).min(sb.width);
		maxH = (1666).min(sb.height);
		winW = reqW.clip(640, maxW);
		winH = reqH.clip(480, maxH);
		rect = Rect(
			sb.left + ((sb.width - winW) * 0.5),
			sb.top  + ((sb.height - winH) * 0.5),
			winW, winH
		);

		metersRowH = 30;   // thin strips
		hudRowH    = 88;

		window = Window("MagicDisplayGUI – GridDemo", rect).front.alwaysOnTop_(true);
		metersEnabled = false;

		// root GridLayout on the VIEW (not the Window)
		rootLayout = GridLayout.new;
		window.view.layout = rootLayout;

		// equal columns globally (row 0 uses them)
		rootLayout.setColumnStretch(0, 1);
		rootLayout.setColumnStretch(1, 1);

		// ---- Row 0: CURRENT / NEXT (two equal columns) ----
		buildLeft = {
			var grid;
			grid = GridLayout.new;
			leftPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			leftPanel.layout = grid;

			leftHeader   = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
			leftListView = ListView(leftPanel).items_([]);
			leftEff      = StaticText(leftPanel).string_("eff: —").align_(\center);

			grid.add(leftHeader,   0, 0);
			grid.add(leftListView, 1, 0);
			grid.add(leftEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildRight = {
			var grid;
			grid = GridLayout.new;
			rightPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			rightPanel.layout = grid;

			rightHeader   = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
			rightListView = ListView(rightPanel).items_([]);
			rightEff      = StaticText(rightPanel).string_("eff: —").align_(\center);

			grid.add(rightHeader,   0, 0);
			grid.add(rightListView, 1, 0);
			grid.add(rightEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildLeft.value;
		buildRight.value;
		rootLayout.add(leftPanel,  0, 0);
		rootLayout.add(rightPanel, 0, 1);
		rootLayout.setRowStretch(0, 1); // only row allowed to grow

		// ---- Row 1: expectation (FULL width) ----
		buildExpectation = {
			expectationView = TextView(window.view)
			.background_(Color(1, 1, 0.9))
			.string_("Command:");
		};
		buildExpectation.value;
        // rootLayout.addSpanning(expectationView, 1, 0, 1, 2);
        // rootLayout.setRowStretch(1, 0);
        // rootLayout.setMinRowHeight(1, 36);

		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
rootLayout.add(choicesPanel, 4, 0);     // left column
rootLayout.add(bottomHudView, 4, 1);    // right column

// Tweaks for row/column growth
rootLayout.setRowStretch(4, 0);         // fixed height for bottom row
rootLayout.setMinRowHeight(4, hudRowH); // keep same height as before


        // ---- Row 2: countdown (FULL width) ----
        buildCountdown = {
            var sub;
            countdownHolder = CompositeView(window.view);
            sub = GridLayout.new; countdownHolder.layout = sub;
            countdownLabel = StaticText(countdownHolder).string_("Ready");
            countdownBar   = UserView(countdownHolder);
            sub.add(countdownLabel, 0, 0);
            sub.add(countdownBar,   0, 1);
            sub.setColumnStretch(0, 0);
            sub.setColumnStretch(1, 1);
        };
        buildCountdown.value;
        rootLayout.addSpanning(countdownHolder, 2, 0, 1, 2);
        rootLayout.setRowStretch(2, 0);
        rootLayout.setMinRowHeight(2, 24);

        // ---- Row 3: meters (FULL width; 30 px) ----
        buildMeters = {
            meterStrip = UserView(window.view);
            meterStrip.background = Color(0.96, 0.96, 0.96);
            meterStrip.drawFunc = { |view|
                var b, pad, h, barH, top1, top2;
                b   = view.bounds;
                pad = 8;
                h   = b.height;
                barH = (h - (pad * 2) - 4) / 2;
                barH = barH.clip(8, 14);
                top1 = pad;
                top2 = pad + barH + 4;
                Pen.color = Color.gray(0.3);
                Pen.addRect(Rect(pad, top1, b.width - pad*2, barH)); Pen.fill;
                Pen.color = Color.gray(0.5);
                Pen.addRect(Rect(pad, top2, b.width - pad*2, barH)); Pen.fill;
                Pen.color = Color.gray(0.7);
                Pen.strokeRect(Rect(0.5, 0.5, b.width - 1, b.height - 1));
            };
        };
        buildMeters.value;
        rootLayout.addSpanning(meterStrip, 3, 0, 1, 2);
        rootLayout.setRowStretch(3, 0);
        rootLayout.setMinRowHeight(3, metersRowH);

		// new
		// --- Row 4 (left column): Choices panel (new) ---

buildChoices = {
			var sub; // nested layout for the choices panel

			choicesPanel = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));

			// install a GridLayout into the choices panel
			sub = GridLayout.new;
			choicesPanel.layout = sub;

choicesTitle = StaticText(choicesPanel)
    .string_("Choices")
    .stringColor_(Color(0.12, 0.12, 0.12));

choicesText  = TextView(choicesPanel)
    .string_("—")
    .editable_(false)
    .hasVerticalScroller_(true)
    .background_(Color(0.98, 0.98, 0.98, 0.96))  // very light
    .stringColor_(Color(0.10, 0.10, 0.10))       // near-black text
    .font_(Font("Menlo", 12));





			// add to nested grid: title on row 0, text on row 1 (stretches)
			sub.add(choicesTitle, 0, 0);
			sub.add(choicesText, 1, 0);
			sub.setRowStretch(0, 0);   // title fixed
			sub.setRowStretch(1, 1);   // text grows to fill
			sub.setColumnStretch(0, 1);
		};
		buildChoices.value;


        // ---- Row 4: processors (FULL width) ----
        buildBottomHud = {
            var grid, title, curLabel, nextLabel;
            bottomHudView = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));
            grid = GridLayout.new; bottomHudView.layout = grid;

            title          = StaticText(bottomHudView).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
            curLabel       = StaticText(bottomHudView).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
            bottomCurText  = StaticText(bottomHudView).string_("–").stringColor_(Color(0.90, 0.90, 0.90));
            nextLabel      = StaticText(bottomHudView).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
            bottomNextText = StaticText(bottomHudView).string_("–").stringColor_(Color(0.80, 0.80, 0.80));

            grid.add(title,          0, 0, 1, 2);
            grid.add(curLabel,       1, 0);
            grid.add(bottomCurText,  1, 1);
            grid.add(nextLabel,      2, 0);
            grid.add(bottomNextText, 2, 1);
            grid.setColumnStretch(0, 0);
            grid.setColumnStretch(1, 1);
            grid.hSpacing = 10;
            grid.vSpacing = 4;
        };
        buildBottomHud.value;
/*        rootLayout.addSpanning(bottomHudView, 4, 0, 1, 2);
        rootLayout.setRowStretch(4, 0);
        rootLayout.setMinRowHeight(4, hudRowH);*/

		//new
		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
		rootLayout.add(choicesPanel, 4, 0);     // left column
		rootLayout.add(bottomHudView, 4, 1);    // right column
		rootLayout.setRowStretch(4, 0);         // fixed bottom-row height
		rootLayout.setMinRowHeight(4, hudRowH);


        this.attachResizeHandler;
        ^this
    }

    // -------- Public (visual-only) --------
    showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
        var fmt, effCText, effNText, aIsCurrent;

        fmt = { arg listRef, bypassKeys, effList;
            var itemsOut, lastIndex, processors, indexCounter;
            itemsOut = Array.new;
            lastIndex = listRef.size - 1;
            itemsOut = itemsOut.add("src : " ++ listRef[lastIndex]);
            if(listRef.size > 2) {
                itemsOut = itemsOut.add("procs:");
                processors = listRef.copyRange(1, lastIndex - 1).reverse;
                indexCounter = 1;
                processors.do({ arg key;
                    var byp, badge, lineText;
                    byp = bypassKeys.includes(key);
                    badge = byp.if({ "[BYP]" }, { "[ON]" });
                    lineText = " [" ++ indexCounter ++ "] " ++ key ++ " " ++ badge;
                    itemsOut = itemsOut.add(lineText);
                    indexCounter = indexCounter + 1;
                });
            }{
                itemsOut = itemsOut.add("procs: (none)");
            };
            itemsOut = itemsOut.add("sink : " ++ listRef[0]);
            itemsOut
        };

        effCText = "eff: " ++ effCurrent.join(" -> ");
        effNText = "eff: " ++ effNext.join(" -> ");

        if(leftListView.notNil)  { leftListView.items_(fmt.value(current, bypassAKeys, effCurrent)) };
        if(rightListView.notNil) { rightListView.items_(fmt.value(next,    bypassBKeys, effNext))    };
        if(leftEff.notNil)  { leftEff.string_(effCText) };
        if(rightEff.notNil) { rightEff.string_(effNText) };

        aIsCurrent = (current[0] == \chainA);
        if(leftHeader.notNil)  { leftHeader.string_((aIsCurrent).if({ "CHAIN A ACTIVE" }, { "CHAIN A NEXT" })) };
        if(rightHeader.notNil) { rightHeader.string_((aIsCurrent).if({ "CHAIN B NEXT"   }, { "CHAIN B ACTIVE" })) };

        // no .trim (SC String has no trim); keep plain join
        if(bottomCurText.notNil)  { bottomCurText.string_(" " ++ effCurrent.copyRange(1, effCurrent.size-1).join(" -> ")) };
        if(bottomNextText.notNil) { bottomNextText.string_(" " ++ effNext.copyRange(1, effNext.size-1).join(" -> ")) };

        ^this
    }

    highlightCurrentColumn { arg currentSinkSym;
        var greenBg, neutralBg, isA;
        greenBg   = Color(0.85, 1.0, 0.85);
        neutralBg = Color(0.92, 0.92, 0.92);
        isA = (currentSinkSym == \chainA);
        if(leftPanel.notNil)  { leftPanel.background_((isA).if({ greenBg }, { neutralBg })) };
        if(rightPanel.notNil) { rightPanel.background_((isA).if({ neutralBg }, { greenBg })) };
        ^this
    }

    showExpectation { arg textString, seconds = 0;
        var secs;
        secs = seconds ? 0;
        if(expectationView.notNil) { expectationView.string_(textString.asString) };
        if(countdownLabel.notNil)  { countdownLabel.string_((secs > 0).if({ "Listen in… (" ++ secs ++ "s)" }, { "Ready" })) };
        ^this
    }


	//new:
	// Add inside MagicDisplayGUI_GridDemo class:
setOperations { arg itemsArray;
    var s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
    AppClock.sched(0.0, {
        if(choicesText.notNil) {
            choicesText.string_( (s.size > 0).if({ s }, { "—" }) );
            // Re-assert color to be safe across themes (match dark/light choice you used)
            choicesText.stringColor_(Color(0.96, 0.96, 0.96));  // dark panel
            // or choicesText.stringColor_(Color(0.10, 0.10, 0.10));  // light panel
        }{
            if(expectationView.notNil) {
                expectationView.string_("Choices:\n" ++ ((s.size > 0).if({ s }, { "—" })));
            };
        };
        nil
    });
    ^this
}




    enableMeters { arg flag = false; metersEnabled = (flag ? false); ^this }

    attachResizeHandler {
        var run;
        run = {
            var v;
            v = window.tryPerform(\view);
            if(v.notNil) {
                v.onResize = {
                    if(debugOn) { this.debugGuides(true) };
                };
            };
            nil
        };
        AppClock.sched(0.00, { run.value; nil });
        ^this
    }

    // -------- Debug overlay --------

    debugGuides { arg on = true;
        var mkOverlay, labelText;
        debugOn = (on ? true);

        mkOverlay = { arg ov;
            var out;
            out = ov;
            if(out.isNil or: { out.isClosed }) {
                out = UserView(window.view);
                out.drawFunc = { |v|
                    var b;
                    b = v.bounds;
                    Pen.color = Color(1, 0, 0, 0.35);
                    Pen.width = 2;
                    Pen.strokeRect(Rect(1, 1, b.width - 2, b.height - 2));
                };
                out.background = Color.clear;
            };
            out
        };

        AppClock.sched(0.00, {
            overlayRow0 = mkOverlay.value(overlayRow0);
            overlayRow1 = mkOverlay.value(overlayRow1);
            overlayRow2 = mkOverlay.value(overlayRow2);
            overlayRow3 = mkOverlay.value(overlayRow3);
            overlayRow4 = mkOverlay.value(overlayRow4);

            rootLayout.addSpanning(overlayRow0, 0, 0, 1, 2);
            rootLayout.addSpanning(overlayRow1, 1, 0, 1, 2);
            rootLayout.addSpanning(overlayRow2, 2, 0, 1, 2);
            rootLayout.addSpanning(overlayRow3, 3, 0, 1, 2);
            rootLayout.addSpanning(overlayRow4, 4, 0, 1, 2);

            AppClock.sched(0.02, {
                var r0, r1, r2, r3, r4;
                var mkLabel;
                mkLabel = { arg parent, text;
                    var st;
                    st = StaticText(parent).string_(text).stringColor_(Color(1, 0.2, 0.2)).align_(\left);
                    st.background = Color(1, 1, 1, 0.20);
                    st  // no caret return in closures
                };

                overlayRow0.children.do(_.remove);
                overlayRow1.children.do(_.remove);
                overlayRow2.children.do(_.remove);
                overlayRow3.children.do(_.remove);
                overlayRow4.children.do(_.remove);

                r0 = overlayRow0.bounds; r1 = overlayRow1.bounds; r2 = overlayRow2.bounds; r3 = overlayRow3.bounds; r4 = overlayRow4.bounds;
                mkLabel.value(overlayRow0, "row 0  " ++ r0.width.round(1) ++ "×" ++ r0.height.round(1));
                mkLabel.value(overlayRow1, "row 1  " ++ r1.width.round(1) ++ "×" ++ r1.height.round(1));
                mkLabel.value(overlayRow2, "row 2  " ++ r2.width.round(1) ++ "×" ++ r2.height.round(1));
                mkLabel.value(overlayRow3, "row 3  " ++ r3.width.round(1) ++ "×" ++ r3.height.round(1) ++ " (meters)");
                mkLabel.value(overlayRow4, "row 4  " ++ r4.width.round(1) ++ "×" ++ r4.height.round(1) ++ " (processors)");
                nil
            });
            nil
        });

        ^this
    }

    postLayoutReport {
        var run;
        run = {
            var r0, r1, r2, r3, r4, unionRow0;
            unionRow0 = leftPanel.bounds.union(rightPanel.bounds);
            r0 = unionRow0; r1 = expectationView.bounds; r2 = countdownHolder.bounds; r3 = meterStrip.bounds; r4 = bottomHudView.bounds;
            ("[layout] row0=" ++ r0).postln;
            ("[layout] row1=" ++ r1).postln;
            ("[layout] row2=" ++ r2).postln;
            ("[layout] row3=" ++ r3).postln;
            ("[layout] row4=" ++ r4).postln;
            nil
        };
        AppClock.sched(0.00, { run.value; nil });
        ^this
    }

	updateTextField { |box, msg|
    // fallback: write to expectationView only
    if(expectationView.notNil) {
        expectationView.string_("[" ++ box.asString ++ "] " ++ msg.asString);
    };
    ^this;
}



	//new
	// Add inside MagicDisplayGUI_GridDemo class:
	// setOperations { arg itemsArray;
	// 	var s;
	// 	// build a visible list; accept nil and non-strings defensively
	// 	s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
	// 	if(choicesText.notNil) {
	// 		AppClock.sched(0.0, {
	// 			choicesText.string_( (s.size > 0).if({ s }, { "—" }) );
	// 			nil
	// 		});
	// 	};
	// 	^this
	// }

}

===== Magicpedalboard/MagicDisplayGUI.sc =====
/* MagicDisplayGUI.sc v0.2.7
 CURRENT column highlighted in green; top-down list (src → procs → sink);
 expectation text + visual countdown; operations list with 3s pre-roll;
 embedded meters (A/B). UI-ready queue prevents touching nil views.
 No server.sync; server ops inside Server.default.bind.
 // MD 20250912-1738
*/
MagicDisplayGUI : MagicDisplay {
	classvar <versionGUI;

	var <window;

	// layout elements
	var leftPanel, rightPanel;
	var leftHeader, rightHeader;
	var leftListView, rightListView;
	var leftEffective, rightEffective;

	// expectation + countdown
	var expectationText;
	var countdownLabel, countdownBarView, countdownTask, countdownSecondsDefault;

	// operations panel
	var opsListView, opsNextButton, opsStatusText;
	var opsItems, opsIndexNext, opsCallback, opsCountdownSeconds;

	// meters
	var meterViewA, meterViewB;
	var meterSynthA, meterSynthB, oscA, oscB;
	var enableMetersFlag;

	// ui-ready machinery
	var uiReadyFlag;
	var uiPendingActions;

	*initClass {
		var text;
		versionGUI = "v0.2.7";
		text = "MagicDisplayGUI " ++ versionGUI;
		text.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var windowRect, panelWidth, listHeight, headerHeight, footerHeight, pad;
		var opsWidth, opsRect;
		var buildWindow;

		windowRect = Rect(100, 100, 980, 520);
		panelWidth = 300;
		listHeight = 300;
		headerHeight = 28;
		footerHeight = 22;
		pad = 10;

		opsWidth = 320;
		opsRect = Rect(2 * pad + 2 * panelWidth + 40, pad, opsWidth, windowRect.height - 2 * pad);

		countdownSecondsDefault = 3.0;
		opsCountdownSeconds = 3.0;
		enableMetersFlag = true;

		uiReadyFlag = false;
		uiPendingActions = Array.new;

		buildWindow = {
			var metersHeight, greenBg, neutralBg;
			var buildColumn, buildMeters, applyInitialHighlight;
			var columnLeftX, columnRightX;
			var columnLeftDict, columnRightDict;

			metersHeight = 86;
			greenBg = Color(0.85, 1.0, 0.85);
			neutralBg = Color(0.92, 0.92, 0.92);

			columnLeftX = pad;
			columnRightX = pad + panelWidth + 40;

			buildColumn = { arg xPos, title;
				var panel, header, listView, effectiveLabel;
				var headerRect, listRect, effRect, resultDict;

				panel = CompositeView(window, Rect(xPos, pad, panelWidth, windowRect.height - 2 * pad - metersHeight));
				panel.background_(neutralBg);

				headerRect = Rect(0, 0, panelWidth, headerHeight);
				header = StaticText(panel, headerRect).string_(title);
				header.align_(\center);

				listRect = Rect(0, headerHeight + 6, panelWidth, listHeight);
				listView = ListView(panel, listRect).items_([]);

				effRect = Rect(0, headerHeight + 6 + listHeight + 6, panelWidth, footerHeight);
				effectiveLabel = StaticText(panel, effRect).string_("eff: —");
				effectiveLabel.align_(\center);

				resultDict = (panel: panel, header: header, list: listView, eff: effectiveLabel);
				resultDict
			};

			buildMeters = {
				var metersGroup, labelA, labelB, row1, row2, labelWidth, barWidth, rowHeight;

				labelWidth = 60;
				barWidth = windowRect.width - 2 * pad - labelWidth - 10;
				rowHeight = 30;

				metersGroup = CompositeView(window, Rect(pad, windowRect.height - metersHeight - pad, windowRect.width - 2 * pad, metersHeight));
				metersGroup.background_(Color(0.96, 0.96, 0.96));

				row1 = CompositeView(metersGroup, Rect(0, 0, metersGroup.bounds.width, rowHeight));
				labelA = StaticText(row1, Rect(0, 4, labelWidth, 20)).string_("chainA");
				meterViewA = LevelIndicator(row1, Rect(labelWidth + 6, 4, barWidth, 20));

				row2 = CompositeView(metersGroup, Rect(0, rowHeight + 8, metersGroup.bounds.width, rowHeight));
				labelB = StaticText(row2, Rect(0, 4, labelWidth, 20)).string_("chainB");
				meterViewB = LevelIndicator(row2, Rect(labelWidth + 6, 4, barWidth, 20));
			};

			applyInitialHighlight = {
				var currentBg, nextBg;
				currentBg = greenBg;
				nextBg = neutralBg;
				if(leftPanel.notNil) { leftPanel.background_(currentBg) };
				if(rightPanel.notNil) { rightPanel.background_(nextBg) };
			};

			window = Window("MagicDisplayGUI – CURRENT / NEXT", windowRect).front.alwaysOnTop_(true);

			columnLeftDict = buildColumn.value(columnLeftX, "CURRENT");
			leftPanel      = columnLeftDict[\panel];
			leftHeader     = columnLeftDict[\header];
			leftListView   = columnLeftDict[\list];
			leftEffective  = columnLeftDict[\eff];

			columnRightDict = buildColumn.value(columnRightX, "NEXT");
			rightPanel      = columnRightDict[\panel];
			rightHeader     = columnRightDict[\header];
			rightListView   = columnRightDict[\list];
			rightEffective  = columnRightDict[\eff];

			expectationText = TextView(window, Rect(pad, leftPanel.bounds.bottom + 6, 2 * panelWidth + 40, 52));
			expectationText.background_(Color(1, 1, 0.9));
			expectationText.string_("Command:");

			countdownLabel = StaticText(window, Rect(pad, expectationText.bounds.bottom + 6, 120, 20)).string_("Ready");

			countdownBarView = UserView(window, Rect(pad + 130, expectationText.bounds.bottom + 6, panelWidth - 10, 20));
			countdownBarView.background_(Color(0.9, 0.9, 0.9));
			countdownBarView.drawFunc_({ arg view;
				var barWidthNow, fullWidth, progressFraction, colorFill, progressStored;
				progressStored = view.getProperty(\progress) ? 0.0;
				progressFraction = progressStored.clip(0, 1);
				fullWidth = view.bounds.width;
				barWidthNow = fullWidth * progressFraction;
				colorFill = Color(0.3, 0.8, 0.3);
				Pen.fillColor = colorFill;
				Pen.addRect(Rect(0, 0, barWidthNow, view.bounds.height));
				Pen.fill;
			});
			countdownBarView.setProperty(\progress, 0.0);

			opsItems = Array.new;
			opsIndexNext = 0;
			opsCallback = nil;

			opsListView = ListView(window, opsRect).items_([]);
			opsStatusText = StaticText(window, Rect(opsRect.left, opsRect.bottom - 52, opsRect.width - 110, 20)).string_("Next: —");
			opsNextButton = Button(window, Rect(opsRect.right - 100, opsRect.bottom - 56, 100, 28))
			.states_([["Next (3s)", Color.white, Color(0, 0.5, 0)]])
			.action_({
				var nextIndexLocal, totalCountLocal, nextLabel;
				nextIndexLocal = opsIndexNext;
				totalCountLocal = opsItems.size;
				if(nextIndexLocal >= totalCountLocal) { "No more operations.".postln; ^nil };
				nextLabel = opsItems[nextIndexLocal];
				this.startCountdown(opsCountdownSeconds, "Next: " ++ nextLabel, {
					var clampedIndex;
					clampedIndex = opsIndexNext.clip(0, opsItems.size - 1);
					this.runNextOperation(clampedIndex);
				});
			});

			buildMeters.value;
			applyInitialHighlight.value;

			uiReadyFlag = true;
			this.flushUiPendingActions;
		};

		AppClock.sched(0, {
			var enableNow;
			buildWindow.value;
			enableNow = enableMetersFlag;
			if(enableNow) { this.enableMeters(true) };
			nil
		});

		^this
	}

	// ui-ready helpers
	queueUi { arg func;
		var fn;
		fn = func;
		if(uiReadyFlag) {
			AppClock.sched(0, { fn.value; nil });
		}{
			uiPendingActions = uiPendingActions.add(fn);
		};
	}

	flushUiPendingActions {
		var actionsToRun;
		actionsToRun = uiPendingActions;
		uiPendingActions = Array.new;
		actionsToRun.do({ arg f;
			AppClock.sched(0, { f.value; nil });
		});
	}


	// visuals

// highlight whichever sink is CURRENT
highlightCurrentColumn { arg currentSinkSym;
    var greenBg, neutralBg, isA;
    greenBg   = Color(0.85, 1.0, 0.85);
    neutralBg = Color(0.92, 0.92, 0.92);
    isA = (currentSinkSym == \chainA);

    this.queueUi({
        if(leftPanel.notNil)  { leftPanel.background_(if(isA) { greenBg } { neutralBg }) };
        if(rightPanel.notNil) { rightPanel.background_(if(isA) { neutralBg } { greenBg }) };
    });
}

/*	highlightCurrentColumn {
		var greenBg, neutralBg;
		greenBg = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		this.queueUi({
			if(leftPanel.notNil) { leftPanel.background_(greenBg) };
			if(rightPanel.notNil) { rightPanel.background_(neutralBg) };
		});
	}*/

	formatListTopDown { arg listRef, bypassKeys, effectiveList;
		var itemsOut, lastIndex, processorsList, indexCounter, sourceKey, sinkKey, isBypassed, badge, lineText;
		itemsOut = Array.new;
		lastIndex = listRef.size - 1;
		sinkKey = listRef[0];
		sourceKey = listRef[lastIndex];

		itemsOut = itemsOut.add("src  : " ++ sourceKey);

		if(listRef.size > 2) {
			itemsOut = itemsOut.add("procs:");
			processorsList = listRef.copyRange(1, lastIndex - 1).reverse;
			indexCounter = 1;
			processorsList.do({ arg procKey;
				isBypassed = bypassKeys.includes(procKey);
				badge = if(isBypassed) { "[BYP]" } { "[ON]" };
				lineText = "  [" ++ indexCounter ++ "] " ++ procKey ++ " " ++ badge;
				itemsOut = itemsOut.add(lineText);
				indexCounter = indexCounter + 1;
			});
		}{
			itemsOut = itemsOut.add("procs: (none)");
		};

		itemsOut = itemsOut.add("sink : " ++ sinkKey);
		itemsOut = itemsOut.add("eff  : " ++ effectiveList.join(" -> "));
		^itemsOut
	}

	// expectation + countdown
	showExpectation { arg textString, seconds = 0;
		var secondsLocal, hasCountdown;
		secondsLocal = seconds ? 0;
		hasCountdown = secondsLocal > 0;

		this.queueUi({
			var labelNow;
			if(expectationText.notNil) { expectationText.string_(textString.asString) };
			if(hasCountdown) {
				this.startCountdown(secondsLocal, "Listen in…", { nil });
			}{
				labelNow = "Ready";
				if(countdownLabel.notNil) { countdownLabel.string_(labelNow) };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, 0.0);
					countdownBarView.refresh;
				};
			};
		});
	}

	startCountdown { arg seconds, labelText, onFinishedFunc;
		var secondsClamped, startTime, stopTime;
		secondsClamped = seconds.clip(0.5, 10.0);
		startTime = Main.elapsedTime;
		stopTime = startTime + secondsClamped;

		if(countdownTask.notNil) { countdownTask.stop; countdownTask = nil };

		this.queueUi({
			var finishedFlag, delaySeconds, updateAndCheckDone;

			if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ secondsClamped.asString ++ "s)") };
			if(countdownBarView.notNil) {
				countdownBarView.setProperty(\progress, 0.0);
				countdownBarView.refresh;
			};

			finishedFlag = false;
			delaySeconds = 0.05;

			updateAndCheckDone = {
				var nowTime, remainingSeconds, progressFraction;
				nowTime = Main.elapsedTime;
				remainingSeconds = (stopTime - nowTime).max(0);
				progressFraction = ((secondsClamped - remainingSeconds) / secondsClamped).clip(0.0, 1.0);

				if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ remainingSeconds.round(0.1).asString ++ "s)") };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, progressFraction);
					countdownBarView.refresh;
				};

				if(remainingSeconds <= 0) { finishedFlag = true };
			};

			countdownTask = Task({
				var localFinished;
				localFinished = false;
				while({ localFinished.not }, {
					updateAndCheckDone.value;
					localFinished = finishedFlag;
					delaySeconds.wait;
				});
				if(countdownLabel.notNil) { countdownLabel.string_("Now") };
				if(onFinishedFunc.notNil) { onFinishedFunc.value };
			}, AppClock).play;
		});
	}

	// operations
	setOperations { arg itemsArray;
		var itemsSafe, entryStrings;
		itemsSafe = itemsArray ? Array.new;
		entryStrings = itemsSafe.collect({ arg it; it.asString });

		this.queueUi({
			opsItems = entryStrings;
			if(opsListView.notNil) { opsListView.items_(opsItems) };
			opsIndexNext = 0;
			this.updateOpsHighlight;
		});
	}

	setNextAction { arg func;
		var f;
		f = func;
		opsCallback = f;
	}

	runNextOperation { arg indexToRun;
		var totalCount, nextIndexComputed;
		totalCount = opsItems.size;

		if(opsCallback.notNil) {
			opsCallback.value(indexToRun);
		}{
			("[ops] No callback for index " ++ indexToRun).warn;
		};

		nextIndexComputed = (indexToRun + 1).clip(0, totalCount);
		opsIndexNext = nextIndexComputed;
		this.updateOpsHighlight;
	}

	updateOpsHighlight {
		var totalCount, entryStrings, nextIndexLocal, statusText;
		totalCount = opsItems.size;
		nextIndexLocal = opsIndexNext.min(totalCount);

		entryStrings = opsItems.collect({ arg item, idx;
			var marker;
			marker = if(idx == opsIndexNext) { "→ " } { "   " };
			marker ++ item
		});

		statusText = if(opsIndexNext < totalCount) {
			"Next: " ++ opsItems[opsIndexNext]
		}{
			"Done."
		};

		this.queueUi({
			if(opsListView.notNil) { opsListView.items_(entryStrings) };
			if(opsStatusText.notNil) { opsStatusText.string_(statusText) };
		});
	}

	/////////////////
	// meters
	// --- canonical enableMeters: waits until sinks are audio-rate, then attaches meters ---
// MagicDisplayGUI.sc
// canonical enableMeters: resend SynthDefs every time; wait until sinks are audio-rate

	enableMeters { arg flag = true;
    var shouldEnable, busA, busB;

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        // Guard: wait until sinks are audio-rate and server is up
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        if(
            Server.default.serverRunning.not
            or: { busA.isNil or: { busB.isNil } }
            or: { busA.rate != \audio or: { busB.rate != \audio } }
        ) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };

        // Meters rely on SynthDefs provided by MagicDisplay.ensureMeterDefs(...)
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };
            meterSynthA = Synth(\busMeterA, [\inBus, Ndef(\chainA).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, Ndef(\chainB).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free }; if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');

        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');

        ^this;
    }{
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}

/*
enableMeters { arg flag = true;
    var shouldEnable, aOK, bOK, busA, busB;

    // When enabling, wait until sinks are audio-rate (no control-rate bus warnings)
    if(flag) {
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        aOK = busA.notNil and: { busA.rate == \audio };
        bOK = busB.notNil and: { busB.rate == \audio };
        if(aOK.not or: { bOK.not }) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
        // Also guard against server being off
        if(Server.default.serverRunning.not) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
    };

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        Server.default.bind({
            var busA_local, busB_local;

            // Always (re)send SynthDefs so they exist on the server now.
            SynthDef(\busMeterA, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
            }).add;
            SynthDef(\busMeterB, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
            }).add;

            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };

            busA_local = Ndef(\chainA).bus;
            busB_local = Ndef(\chainB).bus;

            meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free };
        if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');
        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');
        ^this;

    } {
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}*/
//////
/*	enableMeters { arg flag = true;
		var shouldEnable, aOK, bOK, busA, busB;

		// Only guard when enabling
		if(flag) {
			// read buses once
			busA = Ndef(\chainA).bus;
			busB = Ndef(\chainB).bus;
			// both must exist and be audio-rate
			aOK = busA.notNil and: { busA.rate == \audio };
			bOK = busB.notNil and: { busB.rate == \audio };
			if(aOK.not or: { bOK.not }) {
				// retry shortly on AppClock; do not mutate the audio tree here
				AppClock.sched(0.20, { this.enableMeters(true); nil });
				^this;
			};
		};

		shouldEnable = flag ? true;
		enableMetersFlag = shouldEnable;

		if(shouldEnable) {
			// --- enable path (unchanged except for the pre-check above) ---
			Server.default.bind({
				var hasA, hasB, busA_local, busB_local;
				hasA = SynthDescLib.global.at(\busMeterA).notNil;
				hasB = SynthDescLib.global.at(\busMeterB).notNil;
				if(hasA.not) {
					SynthDef(\busMeterA, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
					}).add;
				};
				if(hasB.not) {
					SynthDef(\busMeterB, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
					}).add;
				};
				if(meterSynthA.notNil) { meterSynthA.free };
				if(meterSynthB.notNil) { meterSynthB.free };
				// read buses post-guard
				busA_local = Ndef(\chainA).bus;
				busB_local = Ndef(\chainB).bus;
				meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
				meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
			});

			if(oscA.notNil) { oscA.free };
			if(oscB.notNil) { oscB.free };
			oscA = OSCdef(\ampA, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
			}, '/ampA');
			oscB = OSCdef(\ampB, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
			}, '/ampB');
			^this;

		} {
			// --- disable path (unchanged) ---
			Server.default.bind({
				if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
				if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
			});
			if(oscA.notNil) { oscA.free; oscA = nil; };
			if(oscB.notNil) { oscB.free; oscB = nil; };
			AppClock.sched(0, {
				if(meterViewA.notNil) { meterViewA.value_(0.0) };
				if(meterViewB.notNil) { meterViewB.value_(0.0) };
				nil
			});
			^this;
		};
	}
*/

	///////////////

	// display hooks
	showInit { arg pedalboard, versionString, current, next;
		var titleText;
		titleText = "MagicDisplayGUI – " ++ versionString;
		this.queueUi({
			if(window.notNil) { window.name_(titleText) };
		});
	}

	showRebuild { arg which, fullChain, effective;
		var infoText;
		infoText = "[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ " effective=" ++ effective;
		AppClock.sched(0, { infoText.postln; nil });
	}

	showPlay { arg sinkKey;
		var text;
		text = "[MPB:play] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showStop { arg sinkKey;
		var text;
		text = "[MPB:stop] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showSwitch { arg oldSink, newSink, current, next;
    var infoText;
    infoText = "[MPB:switch] " ++ oldSink ++ " → " ++ newSink;
    this.queueUi({
        // was: this.highlightCurrentColumn;
        this.highlightCurrentColumn(newSink);               // <-- pass which sink is now CURRENT

        if(opsStatusText.notNil) {
            opsStatusText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
        }{
            if(expectationText.notNil) {
                expectationText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
            };
        };
    });
    AppClock.sched(0, { infoText.postln; nil });
}

	// showSwitch { arg oldSink, newSink, current, next;
	// 	var infoText;
	// 	infoText = "[MPB:switch] " ++ oldSink ++ " → " ++ newSink;
	// 	this.queueUi({
	// 		// keep window title stable; show transient text in labels instead
	// 		this.highlightCurrentColumn;
	// 		if(opsStatusText.notNil) {
	// 			opsStatusText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
	// 		}{
	// 			if(expectationText.notNil) {
	// 				expectationText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
	// 			};
	// 		};
	// 	});
	// 	AppClock.sched(0, { infoText.postln; nil });
	// }


	showMutation { arg action, args, nextChain;
		var text;
		text = "[MPB:mutate] " ++ action ++ " " ++ args ++ " next=" ++ nextChain;
		AppClock.sched(0, { text.postln; nil });
	}

	showBypass { arg which, key, state, chain, bypassKeys;
		var text;
		text = "[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state ++ " active=" ++ bypassKeys;
		AppClock.sched(0, { text.postln; nil });
	}

	showReset { arg current, next;
		var text;
		text = "[MPB:reset] current=" ++ current ++ " next=" ++ next;
		AppClock.sched(0, { text.postln; nil });
	}

	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
    var currentItems, nextItems, effCurrentText, effNextText, aIsPlaying, bIsPlaying, aIsCurrent;

    currentItems   = this.formatListTopDown(current, bypassAKeys, effCurrent);
    nextItems      = this.formatListTopDown(next,   bypassBKeys, effNext);
    effCurrentText = "eff: " ++ effCurrent.join(" -> ");
    effNextText    = "eff: " ++ effNext.join(" -> ");

    // detect which sink is CURRENT by the actual play state of the sink Ndef
    aIsPlaying = Ndef(\chainA).isPlaying;
    bIsPlaying = Ndef(\chainB).isPlaying;
    aIsCurrent = (aIsPlaying and: { bIsPlaying.not });  // Option A expects XOR; if both stopped, keep previous
    this.queueUi({
        if(leftHeader.notNil)  { leftHeader.string_(if(aIsCurrent) { "CHAIN A ACTIVE" } { "CHAIN A NEXT" }) };
        if(rightHeader.notNil) { rightHeader.string_(if(aIsCurrent) { "CHAIN B NEXT"  } { "CHAIN B ACTIVE" }) };

        if(leftListView.notNil)  { leftListView.items_(currentItems) };
        if(rightListView.notNil) { rightListView.items_(nextItems) };

        if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
        if(rightEffective.notNil) { rightEffective.string_(effNextText) };
    });
}

/*	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var currentItems, nextItems, effCurrentText, effNextText;
		currentItems = this.formatListTopDown(current, bypassAKeys, effCurrent);
		nextItems = this.formatListTopDown(next,   bypassBKeys, effNext);
		effCurrentText = "eff: " ++ effCurrent.join(" -> ");
		effNextText    = "eff: " ++ effNext.join(" -> ");

		this.queueUi({
			if(leftHeader.notNil)  { leftHeader.string_("CHAIN A ACTIVE") };
			if(rightHeader.notNil) { rightHeader.string_("CHAIN B NEXT") };
			if(leftListView.notNil)  { leftListView.items_(currentItems) };
			if(rightListView.notNil) { rightListView.items_(nextItems) };
			if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
			if(rightEffective.notNil) { rightEffective.string_(effNextText) };
		});
	}*/

	showError { arg message;
		var text;
		text = "[MPB:error] " ++ message;
		AppClock.sched(0, { text.warn; nil });
	}
}

===== Magicpedalboard/MagicPedalboard.sc =====
// MagicPedalboard.sc
// v0.1.0
// MD 2025-09-21 17:05

// Purpose: Compatibility alias for MagicPedalboardNew
// Style: Minimal, non-breaking, avoids renaming existing class

MagicPedalboard : MagicPedalboardNew {
    // No additional code needed
}

===== Magicpedalboard/MagicPedalboardNew.sc =====
/* MagicPedalboardNew.sc v0.4.8
 A/B pedalboard chain manager built on Ndefs.

 - Chains are Arrays of Symbols ordered [sink, …, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
 // MD 20250912-1838
*/
MagicPedalboardNew : Object {

	// ───────────────────────────────────────────────────────────────
	// class metadata
	// ───────────────────────────────────────────────────────────────
	classvar <version;

	// ───────────────────────────────────────────────────────────────
	// instance state
	// ───────────────────────────────────────────────────────────────
	var < currentChain;     // read-only pointer to Array of Symbols
	var <nextChain;        // read-only pointer to Array of Symbols
	var chainAList;        // [\chainA, ...processors..., source]
	var chainBList;        // [\chainB, ...processors..., source]
	var bypassA;           // IdentityDictionary: key(Symbol) -> Bool
	var bypassB;           // IdentityDictionary: key(Symbol) -> Bool
	var < defaultNumChannels;
	var < defaultSource;
	var < display;          // optional display adaptor
	var < processorLib;
	var < ready;              // <-- ADD this line

	*initClass {
		var text;
		version = "v0.4.7";
		text = "MagicPedalboardNew " ++ version;
		text.postln;
	}

	*new { arg disp = nil;
		var instance;
		instance = super.new;
		^instance.init(disp);
	}

	init { arg disp;
		var sinkFunc;
		display = disp;
		defaultNumChannels = 2;
		defaultSource = \ts0;

		// less good than the version below
		// sinkFunc = { arg inSignal; inSignal };


		sinkFunc = {
			var inputSignal;
			inputSignal = \in.ar(defaultNumChannels);
			inputSignal
		};

		Ndef(\chainA, sinkFunc);
		Ndef(\chainB, sinkFunc);

		// Guarantee sink buses are audio-rate early (prevents kr-meter races)
		Server.default.bind({
			Ndef(\chainA).ar(defaultNumChannels);  // typically 2
			Ndef(\chainB).ar(defaultNumChannels);
		});


		chainAList = [\chainA, defaultSource];
		chainBList = [\chainB, defaultSource];

		bypassA = IdentityDictionary.new;
		bypassB = IdentityDictionary.new;

		currentChain = chainAList;
		nextChain = chainBList;

		Server.default.bind({
			this.rebuildUnbound(nextChain); // stays stopped
			this.rebuildUnbound(currentChain); // plays
		});

/*		this.rebuild(currentChain);
		this.rebuild(nextChain);*/

/*        Server.default.bind({
            Ndef(\chainA).play(numChannels: defaultNumChannels);
        });*/

		if(display.notNil) {
			display.showInit(this, version, currentChain, nextChain);
		};

		// enforce exclusive invariant (Option A) at first bring-up
		this.enforceExclusiveCurrentOptionA(0.1);



		// set initial state; the poll will flip it once conditions are true
		ready = false;

		// OPTION A: enable background poll (comment out if you prefer Option B)
		this.startReadyPoll;


		^this
	}

	// ───────────────────────────────────────────────────────────────
	// public API
	// ───────────────────────────────────────────────────────────────


	// add a setter (public)
	setProcessorLib { arg lib;
		processorLib = lib;
	}

	setDisplay { arg disp;
		var shouldShow;
		display = disp;
		shouldShow = display.notNil;
		if(shouldShow) {
			display.showInit(this, version, currentChain, nextChain);
		};
	}

	help {
		var text;
		text = String.new;
		text = text
		++ "MagicPedalboardNew " ++ version ++ "\n"
		++ "Chains are Arrays of Symbols ordered [sink, …, source].\n"
		++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
		++ "Core methods (operate mostly on the *next* chain):\n"
		++ " printChains\n"
		++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
		++ " add(key), addAt(key, index)\n"
		++ " removeAt(index), swap(indexA, indexB)\n"
		++ " bypass(key, state=true), bypassAt(index, state=true)\n"
		++ " clearChain\n"
		++ "Current-chain bypass helpers:\n"
		++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
		++ "Diagnostics/helpers:\n"
		++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
		++ "Source setters:\n"
		++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
		text.postln;
	}

	// Detailed printing routed through display if available
	printChains {
		var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
		var headerFunc, formatOne;

		bypassAKeys = this.bypassKeysForListInternal(chainAList);
		bypassBKeys = this.bypassKeysForListInternal(chainBList);
		effectiveA = this.effectiveListForInternal(chainAList);
		effectiveB = this.effectiveListForInternal(chainBList);
		hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };

		if(hasDisplay) {
			display.showChainsDetailed(
				chainAList, chainBList,
				bypassAKeys, bypassBKeys,
				effectiveA, effectiveB
			);
		}{
			headerFunc = { arg titleString;
				var lineText;
				lineText = "==== " ++ titleString ++ " ====";
				lineText.postln;
			};

			formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
				var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
				lastIndex = listRef.size - 1;
				sinkKey = listRef[0];
				sourceKey = listRef[lastIndex];

				headerFunc.(titleString);
				("src : " ++ sourceKey).postln;

				if(listRef.size > 2) {
					"procs:".postln;
					processorsList = listRef.copyRange(1, lastIndex - 1);
					indexCounter = 1;
					processorsList.do({ arg procKey;
						isBypassed = bypassKeys.includes(procKey);
						markText = if(isBypassed) { "BYP" } { "ON " };
						lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
						lineText.postln;
						indexCounter = indexCounter + 1;
					});
				}{
					"procs: (none)".postln;
				};

				("sink: " ++ sinkKey).postln;
				("eff : " ++ effectiveList.join(" -> ")).postln;
				"".postln;
			};

			formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
			formatOne.("NEXT",    chainBList, bypassBKeys, effectiveB);
		};
	}

	playCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		this.rebuild(currentChain);
		Server.default.bind({
			Ndef(sinkKey).play(numChannels: defaultNumChannels);
		});
		if(display.notNil) {
			display.showPlay(sinkKey);
		};
		// enforce exclusive invariant (Option A) after play
		this.enforceExclusiveCurrentOptionA(0.1);

	}

	stopCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		Server.default.bind({
			Ndef(sinkKey).stop;
		});
		if(display.notNil) {
			display.showStop(sinkKey);
		};
	}

	// Crossfading chain switch (default 0.1 s, clamped to ~80–200 ms)
	switchChain { arg fadeTime = 0.1;
		var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		actualFadeTime = fadeTime.clip(0.08, 0.2);
		oldSinkKey = currentChain[0];
		newSinkKey = nextChain[0];

		Server.default.bind({
			// set fade durations
			Ndef(oldSinkKey).fadeTime_(actualFadeTime);
			Ndef(newSinkKey).fadeTime_(actualFadeTime);

			// prebuild NEXT so it is ready, then start it (will fade in)
			this.rebuildUnbound(nextChain);
			Ndef(newSinkKey).play(numChannels: defaultNumChannels);

			// stop OLD (will fade out)
			Ndef(oldSinkKey).stop;

			// swap pointers
			temporaryList = currentChain;
			currentChain = nextChain;
			nextChain = temporaryList;

			// ensure both chains are in correct post-swap state
			this.rebuildUnbound(currentChain);
			this.rebuildUnbound(nextChain);
		});

		// enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
		this.enforceExclusiveCurrentOptionA(actualFadeTime);

		if(display.notNil) {
			display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
		};
	}

	// ─── next-chain mutations ─────────────────────────────────────
	add { arg key;
		var insertIndex;
		insertIndex = nextChain.size - 1;
		this.addAt(key, insertIndex);
		if(display.notNil) { display.showMutation(\add, [key], nextChain) };
	}

	addAt { arg key, index;
		var indexClamped, newList;
		indexClamped = index.clip(1, nextChain.size - 1);
		newList = nextChain.insert(indexClamped, key);
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
	}

	removeAt { arg index;
		var sizeNow, lastIndex, newList, removedKey;
		sizeNow = nextChain.size;
		lastIndex = sizeNow - 1;

		if(sizeNow <= 2) {
			if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
			{ "refuse to remove: need at least [sink, source]".postln };
		}{
			if((index == 0) or: { index == lastIndex }) {
				if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
				{ "refuse to remove sink or source".postln };
			}{
				removedKey = nextChain[index];
				newList = nextChain.copy;
				newList.removeAt(index);
				this.setNextListInternal(newList);
				this.bypassDictForListInternal(nextChain).removeAt(removedKey);
				this.rebuild(nextChain);
				if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
			};
		};
	}

	swap { arg indexAParam, indexBParam;
		var lastIndex, indexA, indexB, newList, tempKey;
		lastIndex = nextChain.size - 1;
		indexA = indexAParam.clip(1, lastIndex - 1);
		indexB = indexBParam.clip(1, lastIndex - 1);

		if(indexA == indexB) {
			// nothing to do
		}{
			newList = nextChain.copy;
			tempKey = newList[indexA];
			newList[indexA] = newList[indexB];
			newList[indexB] = tempKey;
			this.setNextListInternal(newList);
			this.rebuild(nextChain);
			if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
		};
	}

	clearChain {
		var sinkKey, sourceKey, newList;
		if(nextChain.size < 2) { ^this };
		sinkKey = nextChain[0];
		sourceKey = nextChain[nextChain.size - 1];
		newList = [sinkKey, sourceKey];
		this.setNextListInternal(newList);
		this.bypassDictForListInternal(nextChain).clear;
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
	}

	bypass { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(nextChain);
		dict[key] = state;
		this.rebuild(nextChain);
		if(display.notNil) {
			display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
		};
	}

	bypassAt { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = nextChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = nextChain[clampedIndex];
		this.bypass(keyAtIndex, state);
	}

	// ─── current-chain bypass ─────────────────────────────────────
	bypassCurrent { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(currentChain);
		dict[key] = state;
		this.rebuild(currentChain);
		if(display.notNil) {
			display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
		};
	}

	bypassAtCurrent { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = currentChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = currentChain[clampedIndex];
		this.bypassCurrent(keyAtIndex, state);
	}

	// ─── source setters ───────────────────────────────────────────
	setSource { arg key;
		var newList, lastIndex;
		lastIndex = nextChain.size - 1;
		newList = nextChain.copy;
		newList[lastIndex] = key;
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
	}

	setSourceCurrent { arg key;
		var newList, lastIndex, isAList;
		lastIndex = currentChain.size - 1;
		newList = currentChain.copy;
		newList[lastIndex] = key;
		isAList = (currentChain === chainAList);
		if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
		this.rebuild(currentChain);
		if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
	}



	setSourcesBoth { arg key;
		var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;

		// pick a sensible key (today we want \testmelody)
		k = key ? \testmelody;

		// guard: require [sink, source] minimum on both chains
		sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
		if(sizeOk.not) { ^this };

		// remember which concrete list object was CURRENT/NEXT *before* we replace them
		curWasA  = (currentChain === chainAList);
		nextWasA = (nextChain    === chainAList);

		// compute last indices
		lastA = chainAList.size - 1;
		lastB = chainBList.size - 1;

		// replace the *source symbol* (last position) on both lists
		newA = chainAList.copy; newA[lastA] = k;
		newB = chainBList.copy; newB[lastB] = k;

		// publish new lists and restore CURRENT/NEXT pointers to the matching list
		chainAList = newA;
		chainBList = newB;
		currentChain = if(curWasA)  { chainAList } { chainBList };
		nextChain    = if(nextWasA) { chainAList } { chainBList };

		// rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
		this.rebuild(currentChain);
		this.rebuild(nextChain);

		// (optional) inform display
		if(display.notNil and: { display.respondsTo(\showMutation) }) {
			display.showMutation(\setSourcesBoth, [k], nextChain);
		};

		^this
	}

	setDefaultSource { arg key;
		var k;
		// update the instance default; does not modify existing chains immediately
		k = key ? \testmelody;
		defaultSource = k;
		^this
	}


	// ─── diagnostics helpers ──────────────────────────────────────
	effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
	effectiveNext    { ^this.effectiveListForInternal(nextChain) }
	bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
	bypassKeysNext    { ^this.bypassKeysForListInternal(nextChain) }

	reset {
		var sinkAKey, sinkBKey, canRun;
		sinkAKey = \chainA;
		sinkBKey = \chainB;

		chainAList = [sinkAKey, defaultSource];
		chainBList = [sinkBKey, defaultSource];

		bypassA.clear;
		bypassB.clear;

		currentChain = chainAList;
		nextChain = chainBList;

		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			// soft reset: stop both, then rebuild clean connections
			Ndef(sinkAKey).stop;
			Ndef(sinkBKey).stop;

			// Rebuild NEXT first (stays stopped), then CURRENT (plays)
			this.rebuildUnbound(nextChain);
			this.rebuildUnbound(currentChain);
		});

		// enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
		this.enforceExclusiveCurrentOptionA(0.1);

		if(display.notNil) { display.showReset(currentChain, nextChain) };
	}



/*    OLDreset {
        var sinkAKey, sinkBKey;
        sinkAKey = \chainA;
        sinkBKey = \chainB;

        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];

        bypassA.clear;
        bypassB.clear;

        currentChain = chainAList;
        nextChain = chainBList;

        // SAFE server reset ONLY here, using Server.default.* (not 's')
        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;

                this.rebuildUnbound(nextChain);
                this.rebuildUnbound(currentChain);

                Ndef(sinkBKey).stop;
                Ndef(sinkAKey).play(numChannels: defaultNumChannels);
            });
        });

        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }*/

	// ───────────────────────────────────────────────────────────────
	// internal helpers (lowercase, no leading underscore)
	// ───────────────────────────────────────────────────────────────
	setNextListInternal { arg newList;
		var isAList;
		isAList = nextChain === chainAList;
		if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
	}

	bypassDictForListInternal { arg listRef;
		^if(listRef === chainAList) { bypassA } { bypassB }
	}

	bypassKeysForListInternal { arg listRef;
		var dict, keysBypassed;
		dict = this.bypassDictForListInternal(listRef);
		keysBypassed = Array.new;
		dict.keysValuesDo({ arg key, state;
			if(state == true) { keysBypassed = keysBypassed.add(key) };
		});
		^keysBypassed
	}

	ensureStereoInternal { arg key;
		var proxyBus, needsInit;
		proxyBus = Ndef(key).bus;
		needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
		if(needsInit) {
			Ndef(key).ar(defaultNumChannels);
		};
	}

	// Non-destructive: guard only; do not reset here
	ensureServerTree {
		var serverIsRunning;
		serverIsRunning = Server.default.serverRunning;
		^serverIsRunning
	}

	//
	// v0.4.6 change


	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink    = nextChain[0];
		chans       = defaultNumChannels;
		fadeCur     = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust \in.ar, stereo shape pinned, playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).mold(chans, \audio);   // authoritative shape
			Ndef(currentSink).fadeTime_(fadeCur);
			if(Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans);
			};

			// NEXT: hard-silence + ensure flag drops
			// 1) silence source, then .stop (no audio either way)
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).mold(chans, \audio);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;

			// 2) drop monitor/flag deterministically, then re-establish silent sink
			Ndef(nextSink).end;                      // frees inner players, "stop listen" (NodeProxy help)
			Ndef(nextSink, { Silent.ar(chans) });    // keep NEXT present & silent for prebuild
			Ndef(nextSink).mold(chans, \audio);
			// do NOT play NEXT
		});

		^this
	}

/*	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink = nextChain[0];
		chans = defaultNumChannels;
		fadeCur = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust sink that consumes embedded input; ensure playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).ar(chans);
			Ndef(currentSink).fadeTime_(fadeCur);
			if (Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans)
			};

			// NEXT: hard silence at the sink source; stop its monitor quickly
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).ar(chans);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;
		});

		^this
	}*/


	effectiveListForInternal { arg listRef;
		var dict, resultList, lastIndex, isProcessor, isBypassed;
		dict = this.bypassDictForListInternal(listRef);
		resultList = Array.new;
		lastIndex = listRef.size - 1;

		listRef.do({ arg key, indexPosition;
			isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
			isBypassed = isProcessor and: { dict[key] == true };

			if((indexPosition == 0) or: { indexPosition == lastIndex }) {
				resultList = resultList.add(key);
			}{
				if(isBypassed.not) { resultList = resultList.add(key) };
			};
		});
		^resultList
	}

	// Public rebuild: bundles server ops; guard only
	rebuild { arg listRef;
		var whichChain, canRun;
		whichChain = if(listRef === currentChain) { \current } { \next };
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			this.rebuildUnbound(listRef);
		});

		if(display.notNil) {
			display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
		};
	}


	// Internal rebuild that assumes we are already inside a server bind (no resets)

	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		// (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
		if(processorLib.notNil) {
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};

		// From here on, this is your original "effective / do / connect"
		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}


/*	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/*	// At end of rebuildUnbound
	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;


/*		if(processorLib.notNil) {
			// Ask the lib to make sure each symbol in this chain has an Ndef with a function.
			// It will quietly do nothing for unknown keys.
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};*/


		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;

		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/* OLD   rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };

        effective = this.effectiveListForInternal(listRef);

        effective.do({ arg keySymbol;
            this.ensureStereoInternal(keySymbol);
        });

        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });

		// sinkKey = effective[0];
		// if(listRef === currentChain) {
		// 	Ndef(sinkKey).play(numChannels: defaultNumChannels);
		// }{
		// 	Ndef(sinkKey).stop;
		// };
		// At the end of rebuildUnbound:
		sinkKey = effective[0];
		if(listRef === currentChain) {
			if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		} {
			if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
		};

    }*/

	// ---- Ready helpers (public API) ----
	// boolean snapshot (no server ops)
	isReady {
		^ready
	}

	// AppClock polling; onReadyFunc is optional
	waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
		var startTime, tick;
		startTime = Main.elapsedTime;

		AppClock.sched(0, {
			tick = {
				if(this.readyConditionOk) {
					ready = true;
					if(onReadyFunc.notNil) { onReadyFunc.value };
					nil
				}{
					if((Main.elapsedTime - startTime) > timeoutSec) {
						// timed out; leave 'ready' as-is
						nil
					}{
						AppClock.sched(pollSec, tick)
					}
				}
			};
			tick.value;
			nil
		});
		^this
	}

	// ---- Ready helpers (internal; no leading underscore) ----

	// light background poll started from init (OPTION A)
	startReadyPoll {
		var alreadyTrue;
		alreadyTrue = this.readyConditionOk;
		if(alreadyTrue) { ready = true; ^this };
		this.waitUntilReady(2.0, 0.05, { nil });
		^this
	}

	// compute the readiness condition; no server ops here
	readyConditionOk {
		var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;

		curSink = currentChain[0];
		nxtSink = nextChain[0];

		serverOk = Server.default.serverRunning;

		curBus = Ndef(curSink).bus;
		nxtBus = Ndef(nxtSink).bus;

		busesOk = curBus.notNil and: { nxtBus.notNil }
		and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };

		currentPlaying = Ndef(curSink).isPlaying;

		^(serverOk and: { busesOk } and: { currentPlaying })
	}

	// handleCommand { |oscPath|
	// 	var path;
	// 	path = oscPath.asString;
	//
	// 	// Route to your existing mutation logic
	// 	// Update this if you use a different handler name
	// 	if(this.respondsTo(\applyOSCPath)) {
	// 		this.applyOSCPath(path);
	// 	} {
	// 		("[MPB] handleCommand: " ++ path ++ " → no handler found").warn;
	// 	};
	//
	// 	^this;
	// }
handleCommand { |oscPath|
    var path;
    path = oscPath.asString;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(path, this, display);
    } {
        ("[MPB] handleCommand: " ++ path ++ " → no handler found").warn;
    };

    ^this;
}




}

===== Magicpedalboard/MagicPedalboardTestRunner.sc =====
// MagicPedalboardTestRunner.sc
// v0.2.2
// MD 20250919

/*
Purpose:
- Unified bring-up, audio reset, GUI sync, and test runner for MagicPedalboardNew.
- Replaces StartHere_CleanBoot_OneWindow_BringUp.scd.
- Logs all steps using MDMiniLogger.
- Extensible with new test methods.

Style:
- var-first; lowercase methods; no server.sync.
- Server ops inside Server.default.bind; GUI ops on AppClock.
- No single-letter vars; all var declarations at top of each block.
*/

MagicPedalboardTestRunner : Object {
    var <logger, <pedalboard, <>gui;

    *new { arg mpb, gui;
        ^super.new.init(mpb, gui);
    }

    init { arg mpb, gui;
        pedalboard = mpb;
        this.gui = gui;
        logger = MDMiniLogger.new("MagicPedalboardTestRunner");
        ^this;
    }

    bringUp {
        var trigger, sequence, freqDemand, envelope, toneSignal, panPosition;
        var isPlayingA, isPlayingB, currentSink;

        logger.info("Starting full bring-up...");

        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;
                logger.info("Server tree initialized.");
            });
        });

        Server.default.bind({
            Ndef(\chainA, { \in.ar(2) }).ar(2);
            Ndef(\chainB, { \in.ar(2) }).ar(2);
            Ndef(\ts0, { Silent.ar(2) }).ar(2);
            Ndef(\testmelody, {
                trigger = Impulse.kr(3.2);
                sequence = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
                freqDemand = Demand.kr(trigger, 0, sequence);
                envelope = Decay2.kr(trigger, 0.01, 0.35);
                toneSignal = SinOsc.ar(freqDemand) * envelope * 0.25;
                panPosition = ToggleFF.kr(trigger).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(toneSignal, panPosition);
            }).ar(2);
            logger.info("Sinks and sources defined.");
        });

        pedalboard.reset;
        pedalboard.setSourceCurrent(\testmelody);
        pedalboard.playCurrent;
        pedalboard.enforceExclusiveCurrentOptionA(0.1);

        if(gui.notNil) {
            gui.enableMeters(false);
            gui.enableMeters(true);
            gui.window.front;
            gui.showExpectation("System ready", 0);
        };

        pedalboard.printChains;

        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Playback state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
        logger.info("Bring-up complete.");
    }

    audioReset {
        logger.info("Running ~audioReset...");
        if(~audioReset.notNil) {
            ~audioReset.();
            logger.info("~audioReset complete.");
        } {
            logger.warn("~audioReset is not defined.");
        };
    }

    syncGui {
        var currentSink;
        if(gui.notNil) {
            currentSink = pedalboard.effectiveCurrent[0];
            gui.window.front;
            gui.highlightCurrentColumn(currentSink);
            gui.showChainsDetailed(
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext,
                pedalboard.bypassKeysCurrent,
                pedalboard.bypassKeysNext,
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext
            );
            logger.info("GUI synced with audio state.");
        };
    }

    runAcceptanceTest {
        logger.info("Running acceptance test...");
        pedalboard.add(\delay);
        pedalboard.switchChain(0.12);
        pedalboard.bypassCurrent(\delay, true);
        pedalboard.bypassCurrent(\delay, false);
        pedalboard.switchChain(0.12);
        pedalboard.printChains;
        logger.info("Acceptance test complete.");
    }

    verifyAudioState {
        var isPlayingA, isPlayingB;
        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Audio state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
    }

    help {
        "Available methods: bringUp, audioReset, syncGui, runAcceptanceTest, verifyAudioState".postln;
    }
}

===== Magicpedalboard/MagicProcessorLibrary.sc =====
/* MagicProcessorLibrary.sc
   Holds a registry of processor/source functions and can ensure Ndefs exist.
   MD 20250913
*/
MagicProcessorLibrary : Object {
    var <defs;           // IdentityDictionary: Symbol -> Function
    var <defaultNumChannels;

    *new { ^super.new.init }

    init {
        var empty;
        defaultNumChannels = 2;
        empty = IdentityDictionary.new;
        defs = empty;
        ^this
    }

    register { arg key, func;
        defs[key] = func;
        ^this
    }

    has { arg key;
        ^defs.includesKey(key)
    }

    get { arg key;
        ^defs[key]
    }

    keys { ^defs.keys }

    // Create or update an Ndef for key
    ensure { arg key, chans;
        var func, numCh, canRun;
        func = defs[key];
        if(func.isNil) { ^this }; // silently ignore if not registered
        numCh = chans ? defaultNumChannels;
        canRun = Server.default.serverRunning;
        if(canRun) {
            Server.default.bind({
                Ndef(key, func);
                Ndef(key).ar(numCh);
            });
        };
        ^this
    }

    // Ensure many keys at once
    ensureMany { arg keyArray, chans;
        keyArray.do({ arg key; this.ensure(key, chans) });
        ^this
    }

    // Convenience: ensure whatever appears in a chain array
    ensureFromChain { arg chainArray, chans;
        var lastIndex, idx;
        if(chainArray.isNil or: { chainArray.size < 2 }) { ^this };
        lastIndex = chainArray.size - 1;
        idx = 0;
        while({ idx <= lastIndex }, {
            this.ensure(chainArray[idx], chans);
            idx = idx + 1;
        });
        ^this
    }
}

===== Magicpedalboard/MPBTest/Classes/MPBTest_AcceptanceSuites.sc =====
// MPBTest_AcceptanceSuites.sc
// v0.1.1
// MD 20250920-1608

// Purpose
// - Ready-made, extensible step lists for acceptance.
// Style
// - var-first; lowercase; data-only class methods.

MPBTest_AcceptanceSuites : Object {
    *classic { arg fade = 0.12;
        ^[
            (verb:\add,           args:[\delay]),
            (verb:\switch,        args:[fade]),
            (verb:\bypassCurrent, args:[\delay, true]),
            (verb:\bypassCurrent, args:[\delay, false]),
            (verb:\switch,        args:[fade])
        ]
    }

    *mutatorsBasic { arg fade = 0.12;
        ^[
            (verb:\insert,   args:[\chorus]),
            (verb:\addAt,    args:[\reverb, 1]),
            (verb:\swap,     args:[1, 2]),
            (verb:\removeAt, args:[2]),
            (verb:\switch,   args:[fade])
        ]
    }

    *bypassNextCycle {
        ^[
            (verb:\add,    args:[\delay]),
            (verb:\bypass, args:[\delay, \on]),
            (verb:\bypass, args:[\delay, \off]),
            (verb:\switch, args:[0.12])
        ]
    }
}

===== Magicpedalboard/MPBTest/Classes/MPBTest_Assertions.sc =====
// MPBTest_Assertions.sc
// v0.1.0
// MD 20250920-1540
//
// Purpose
// - Centralized assertions used across scenarios (A XOR B, single \delay in list, NEXT audible tail...)
// Style
// - var-first; lowercase; no server.sync; no single-letter locals.

MPBTest_Assertions : Object {
    *xorPlaying { arg expectA = true, expectB = false;
        var a, b, ok;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ok = (a == expectA) and: { b == expectB };
        ("[ASSERT] XOR A="++a++" B="++b++" expect("++expectA++","++expectB++") -> "++
            (ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }

    *countKey { arg list, key;
        var count = 0;
        list.do({ arg k; if(k == key) { count = count + 1 } });
        ^count
    }

    *exactlyOne { arg list, key, label="count";
        var n, pass;
        n = this.countKey(list, key);
        pass = (n == 1);
        ("[ASSERT] "++label++" '"++key.asString++"' = "++n++" -> "++
            (pass.if({"PASS"},{"FAIL"}))).postln;
        ^pass
    }

    *nextTailNotTs0 { arg mpb;
        var last, ok;
        last = mpb.effectiveNext.last;
        ok = (last != \ts0);
        ("[ASSERT] NEXT tail != \\ts0 -> "++(ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }
}

===== Magicpedalboard/MPBTest/Classes/MPBTest_BringUp.sc =====
// MPBTest_BringUp.sc
// v0.1.9
// MD 20250920-1919

// Purpose
// - Fresh-boot bring-up with Grid GUI by default; avoids display=nil and close/create races.
// Style
// - var-first; lowercase; AppClock for GUI; Server.default.bind for audio; no server.sync.

MPBTest_BringUp : Object {
    classvar < version;
    var < logger, < pedalboard, < gui, < readyFlag, < numChannels, < testAmp;

    *initClass { version = "v0.1.9"; ("MPBTest_BringUp " ++ version).postln; }

    *new {
        arg useGui = true, channels = 2, sourceAmp = 0.40, publishToTildes = true,
            freshBoot = true, guiClassSym = \MagicDisplayGUI_GridDemo, closeExistingGUIs = true;
        ^super.new.init(useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs)
    }

    init { arg useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs;
        var s, doFreshBoot, startBoot, afterBoot, scheduleGuiClose, scheduleGuiCreate;
        var ensureSinks, ensureSources, setSourcesAndPlay, enforceOptionA, attachMeters, postBaseline, maybePublish;

        logger     = MDMiniLogger.new("MPBTest_BringUp");
        readyFlag  = false;
        numChannels = (channels ? 2).asInteger.max(1);
        testAmp     = (sourceAmp ? 0.40).asFloat.clip(0.05, 1.0);
        s = Server.default;

        // --- audio preparation ---
        ensureSinks = {
            Server.default.bind({
                Ndef(\chainA, { \in.ar(numChannels) }); Ndef(\chainA).ar(numChannels);
                Ndef(\chainB, { \in.ar(numChannels) }); Ndef(\chainB).ar(numChannels);
            });
        };

        ensureSources = {
            Server.default.bind({
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f    = Demand.kr(trig, 0, seq);
                    var env  = Decay2.kr(trig, 0.01, 0.35);
                    var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                    Pan2.ar(SinOsc.ar(f) * env * testAmp, pan)
                });
                Ndef(\testmelody).ar(numChannels);
                Ndef(\ts0, { Silent.ar(numChannels) }).ar(numChannels);
            });
        };

        setSourcesAndPlay = {
            pedalboard.setDefaultSource(\testmelody);
            pedalboard.setSourceCurrent(\testmelody);
            pedalboard.playCurrent;
        };

        enforceOptionA = {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
            Server.default.bind({
                var nextSink = pedalboard.nextChain[0];
                Ndef(nextSink).end;
                Ndef(nextSink).mold(numChannels, \audio);
            });
        };

        attachMeters = {
            if(gui.notNil and: { gui.respondsTo(\enableMeters) }) {
                gui.enableMeters(false); gui.enableMeters(true);
            };
        };

        postBaseline = {
            pedalboard.printChains;
            ("[[PLAY]] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            readyFlag = true;
        };

        maybePublish = {
            if(publishToTildes) { ~bring = this; ~mpb = pedalboard; ~gui = gui };
        };

        // --- GUI sequencing to avoid races ---
        scheduleGuiClose = {
            if(closeExistingGUIs and: { useGui }) {
                AppClock.sched(0.00, {
                    var wins = Window.allWindows.select({ arg w;
                        var nm = w.tryPerform(\name) ? "";
                        nm.asString.beginsWith("MagicDisplayGUI")
                    });
                    wins.do(_.close);
                    nil
                });
            };
        };

        scheduleGuiCreate = {
            if(useGui) {
                AppClock.sched(0.05, {
                    gui = guiClassSym.asClass.new;   // MagicDisplayGUI_GridDemo by default
                    gui.window.front.alwaysOnTop_(true);
                    // Build pedalboard only **after** GUI exists so display is bound at construction
                    pedalboard = MagicPedalboardNew.new(gui);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    attachMeters.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            }{
                // Headless: create pedalboard immediately (no display)
                AppClock.sched(0.00, {
                    pedalboard = MagicPedalboardNew.new(nil);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            };
        };

        // --- boot choreography ---
        afterBoot = {
            ensureSinks.value;
            ensureSources.value;
            scheduleGuiClose.value;
            scheduleGuiCreate.value;
        };

        startBoot = {
            s.doWhenBooted({ afterBoot.value });
            if(s.serverRunning.not) { s.boot };
        };

        doFreshBoot = {
            var waitDown;
            if(s.serverRunning) {
                if(gui.notNil and: { gui.respondsTo(\enableMeters) }) { gui.enableMeters(false) };
                s.quit;
                waitDown = {
                    if(s.serverRunning.not) { startBoot.value; nil } {
                        AppClock.sched(0.05, waitDown)
                    }
                };
                AppClock.sched(0.05, waitDown);
            }{
                startBoot.value;
            };
        };

        if(freshBoot) { doFreshBoot.value } { startBoot.value };
        ^this
    }

    isReady { ^readyFlag }
    getPedalboard { ^pedalboard }
    getGui { ^gui }
    getChannels { ^numChannels }
}

===== Magicpedalboard/MPBTest/Classes/MPBTest_Scenario.sc =====
// MPBTest_Scenario.sc
// v0.2.2
// MD 20250920-2015

// Purpose
// - Timed acceptance runner (add/insert/addAt/removeAt/swap/bypass/.../switch/wait)
//   with optional CommandTree path hook via .setPathApplier.
// - Removes caret-returns from AppClock closures to avoid OutOfContextReturnError.
// Style
// - var-first; lowercase; AppClock scheduling; no server.sync.

MPBTest_Scenario : Object {
    classvar < version;
    var < pedalboard, < gui, < logger;
    var pathApplierFunc;

    *initClass { version = "v0.2.2" }

    *new { arg mpb, guiObj = nil; ^super.new.init(mpb, guiObj) }

    init { arg mpb, guiObj;
        var lg;
        pedalboard = mpb;
        gui = guiObj;
        logger = MDMiniLogger.new("MPBTest_Scenario");
        pathApplierFunc = nil;
        ^this
    }

    setPathApplier { arg func;
        pathApplierFunc = func;
        ^this
    }

    useDefaultAdapterIfPresent {
        if(pathApplierFunc.isNil and: { ~ct_applyOSCPathToMPB.notNil }) {
            pathApplierFunc = { arg pathString;
                ~ct_applyOSCPathToMPB.(pathString.asString, pedalboard, gui);
            };
            logger.info("Using ~ct_applyOSCPathToMPB as default path applier.");
        };
        ^this
    }

    run { arg stepsArray;
        var indexCounter, totalCount, runOne;

        this.useDefaultAdapterIfPresent;

        indexCounter = 0;
        totalCount   = stepsArray.size;

        runOne = {
            var stepDict, verb, args, hasMore;

            hasMore = indexCounter < totalCount;

            if(hasMore) {
                stepDict = stepsArray[indexCounter];
                verb = stepDict[\verb];
                args = stepDict[\args] ? [];

                this.applyStep(verb, args);

                indexCounter = indexCounter + 1;

                // Schedule next step tick; explicit \wait steps still add their own delay.
                AppClock.sched(0.20, { runOne.value; nil });
            }{
                // finished; nothing to return from a scheduled closure
                logger.info("scenario complete (" ++ totalCount ++ " steps).");
            };
            nil
        };

        AppClock.sched(0.00, { runOne.value; nil });
        ^this
    }

    applyStep { arg verb, args;
        var v, brief;
        v = verb;
        brief = {
            pedalboard.printChains;
            this.refreshGui;
        };

        switch(v,
            \wait, {
                var delaySec;
                delaySec = (args[0] ? 0.25).asFloat.max(0.0);
                AppClock.sched(delaySec, { nil }); // no return
            },

            \add, {
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \insert, { // alias of add
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \addAt, {
                var proc, idx;
                proc = args[0];
                idx  = (args[1] ? 1).asInteger;
                pedalboard.addAt(proc, idx);
                brief.value;
            },

            \removeAt, {
                var idx;
                idx = (args[0] ? 1).asInteger;
                pedalboard.removeAt(idx);
                brief.value;
            },

            \swap, {
                var idxA, idxB;
                idxA = (args[0] ? 1).asInteger;
                idxB = (args[1] ? 2).asInteger;
                pedalboard.swap(idxA, idxB);
                brief.value;
            },

            \bypass, { // NEXT chain
                var key, stateSym, state;
                key = args[0];
                stateSym = args[1] ? \on;
                state = (stateSym == \on) or: { stateSym == \true } or: { stateSym == 1 };
                pedalboard.bypass(key, state);
                brief.value;
            },

            \unbypass, {
                var key;
                key = args[0];
                pedalboard.bypass(key, false);
                brief.value;
            },

            \bypassCurrent, {
                var key, state;
                key   = args[0];
                state = (args[1] ? true);
                pedalboard.bypassCurrent(key, state);
                brief.value;
            },

            \bypassAt, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAt(indexParam, stateParam);
                brief.value;
            },

            \bypassAtCurrent, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAtCurrent(indexParam, stateParam);
                brief.value;
            },

            \setSource, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSource(key);
                brief.value;
            },

            \setSourceCurrent, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSourceCurrent(key);
                brief.value;
            },

            \switch, {
                var fade;
                fade = (args[0] ? 0.12).asFloat.clip(0.08, 0.20);
                if(pedalboard.effectiveNext.last == \ts0) {
                    if(pathApplierFunc.notNil) { pathApplierFunc.value("/setSource/testmelody") } {
                        pedalboard.setSource(\testmelody);
                    };
                };
                pedalboard.switchChain(fade);
                this.refreshGui;
            },

            \ctPath, {
                var path;
                path = args[0].asString;
                if(pathApplierFunc.notNil) { pathApplierFunc.value(path) } {
                    logger.warn("[ctPath] adapter missing; ignored: " ++ path);
                };
                this.refreshGui;
            },

            { logger.warn("Unknown step: " ++ v.asString) }
        );
    }

    refreshGui {
        if(gui.notNil and: { gui.respondsTo(\showChainsDetailed) }) {
            var effC, effN;
            effC = pedalboard.effectiveCurrent;
            effN = pedalboard.effectiveNext;
            gui.highlightCurrentColumn(effC[0]);
            gui.showChainsDetailed(effC, effN, pedalboard.bypassKeysCurrent, pedalboard.bypassKeysNext, effC, effN);
        };
    }
}

===== MDMiniLogger/MDMiniLogger.sc =====
// MDMiniLogger.sc
// v0.3.3
// MD 20250919-13:51

// access with MDMiniLogger.get (which creates the instance if there isn't one)
// verbosity levels: 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=TRACE

MDMiniLogger : Object {
	classvar < logger;
	classvar verbosityNames;
	var < verbosity;
	var < enabled;

	// 3.1 fix
	*initClass {
		verbosityNames = ["ERROR", "WARN", "INFO", "DEBUG", "TRACE"];
		logger = nil; // discard any stale instance after class library recompile
	}

	init {
		verbosity = 2;
		enabled = true;
	}
	*get {
		// return existing, otherwise create one
		^logger ?? { logger = MDMiniLogger.new };
	}

	shouldLog { |msgVerbosity|
		var messageLevel, thresholdLevel, isOn;

		messageLevel   = (msgVerbosity ? 0).clip(0, 4);  // if nil default to 0
		thresholdLevel = (verbosity ? 0).clip(0, 4);     // the logger's current threshold
		isOn = (enabled ? true);
		// Print when:
		//  - logging is enabled, AND
		//  - the message is at least as important as the threshold (lower number = more important)
/*		^(isOn and: { messageLevel <= thresholdLevel });*/

// fix 0.3.2
^((enabled == true) and: { messageLevel <= thresholdLevel });

	}

	setverbosity { |newverbosity| verbosity = (newverbosity ? 0).clip(0, 4); ^verbosity }

	enable  { enabled = true;  ^enabled }

	disable { enabled = false; ^enabled }

	format {|argVerbosity, argLabel, argMessage |
		var line, logVerbosity, logLabel, logMessage;

		// check we have a verbosity
		logVerbosity = (argVerbosity ? 0).clip(0,4); // 0 if nil

		// check we have a label
		logLabel = argLabel ? "GENERIC";

		// check we have a message:
		logMessage = argMessage ? "";

		line = "[" ++ Date.getDate.stamp
		++ " | " ++ verbosityNames.at(logVerbosity)
		++ " | " ++ logLabel ++ "] "
		++ logMessage;
		^line;
	}

	log { |msgVerbosity, label, message|
		if (this.shouldLog(msgVerbosity)) {
			this.format(msgVerbosity, label, message).postln;
		};
		^this
	}

	// helpers

	error { |label, message| ^this.log(0, label, message) }  // ERROR
	warn  { |label, message| ^this.log(1, label, message) }  // WARN
	info  { |label, message| ^this.log(2, label, message) }  // INFO
	debug { |label, message| ^this.log(3, label, message) }  // DEBUG
	trace { |label, message| ^this.log(4, label, message) }  // TRACE

}
