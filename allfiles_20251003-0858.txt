===== .state/LastCommandTreePath.txt =====
/Users/martindupras/Library/Application Support/SuperCollider/Extensions/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json
===== allfiles.txt =====
===== .state/LastCommandTreePath.txt =====
/Users/martindupras/Library/Application Support/SuperCollider/Extensions/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json
===== CommandTree/archived/CommandManager_PathPersistence.sc_OBSOLETE =====
// OBSOLETE


// // CommandManager_PathPersistence.sc
// // v1.0 ‚Äî 2025-09-22 MD
// // Purpose: Remember last used tree path across runs.
// // Style: var-first; lowercase; no server.sync.
//
// + CommandManager {
// 	var <lastPathFile;
//
// 	init { |treePath|
// 		var defaultPath;
// 		lastPathFile = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/last_tree_path.txt";
// 		defaultPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//
// 		// Load last path if treePath is nil
// 		if(treePath.isNil) {
// 			treePath = this.readLastPath ?? defaultPath;
// 		};
//
// 		filePath = treePath;
// 		this.writeLastPath(filePath); // persist for next time
//
// 		// existing init logic continues...
// 		this.createNewTree;
// 		this.createBuilder;
// 		this.createCommandQueue;
// 		midiManager = MIDIInputManager.new(builder, nil, nil, nil);
// 		midiManager.parentCommandManager = this;
// 		^this
// 	}
//
// 	writeLastPath { |path|
// 		File.use(lastPathFile, "w", { |f| f.write(path) });
// 	}
//
// 	readLastPath {
// 		var content;
// 		if(File.exists(lastPathFile)) {
// 			File.use(lastPathFile, "r", { |f| content = f.readAllString });
// 		};
// 		^content
// 	}
// }

===== CommandTree/archived/LivePedalboardSystem_MetersDelegate.sc_OBSOLETE =====
// OBSOLETE


// // LivePedalboardSystem_MetersDelegate.sc
// // v0.2.5 ‚Äî 2025-09-21 MD
// // Purpose
// // - Defer meter definitions to MagicDisplay to avoid duplication.
// // Style
// // - var-first; lowercase; no server.sync.
//
// + LivePedalboardSystem {
// 	ensureMeterDefs {
// 		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
// 	}
// }

===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/archived/UserDisplay.sc_OBSOLETE =====
// userFeedbackSystem.sc
// MD 20250806

// Used to display states of the system and such.

UserDisplay {

	var <>window;
	var <>modeText;
	var <>queueText;
	var <>lastCommandText;
	var <>userChoicesText;
	var <>statusText;

	*new{
		^super.new.init
	}

	init{
		"userFeedback created".postln;

		// create window
		window = Window("user display", Rect(10, 400, 800, 600));

		// create the fields:
		modeText = StaticText(window).string_("modeText");
		queueText = StaticText(window).string_("queueText");
		lastCommandText = StaticText(window).string_("lastCommandText");
		userChoicesText = StaticText(window).string_("userChoicesText");
		statusText = StaticText(window).string_(""); // choose appropriate position and size


		// add layouts to the window
		window.layout =
		VLayout(
			modeText,
			queueText,
			lastCommandText,
			userChoicesText,
			statusText
		);

		// bring window to front:
		window.front;
		^this // return instance of UserDisplay
	}

	updateTextField{
		|box, msg|
		switch (box,
			\state, { modeText.string_(msg)},
			\queue, { queueText.string_(msg)},
			\lastCommand, { lastCommandText.string_(msg)},
			\choices, { userChoicesText.string_(msg)}
		);

		postln("box:" + box);
		postln("msg:" + msg);
	}

	updateStatus { |text|
    ("üñ• Status update: " ++ text).postln;
    { this.statusText.string = text; }.defer; // assuming you have a GUI element called statusText
}


} //end of class
===== CommandTree/CircularFileSave_SortByMTime.sc_obsolete =====
// CircularFileSave_SortByMTime.sc
// v1.1 ‚Äî 2025-09-21 MD

// Purpose
// - Ensure latestVersion() is truly latest by sorting entries (mtime desc).
// Style
// - var-first; lowercase; no server.sync.

+ CircularFileSave {
    refreshFileList {
        var pn, entries;
        pn = PathName(folderPath);
        entries = pn.entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
        // sort newest ‚Üí oldest by modification time
        fileList = entries.sortBy({ |f| File.mtime(f.fullPath) }).reverse;
    }

    saveVersion { |content|
        var timestamp, filename, path;
        timestamp = Date.getDate.stamp;
        filename = "%-%".format(prefix, timestamp) ++ ".json";
        path = folderPath +/+ filename;
        File.use(path, "w", { |fh| fh.write(content) });
        this.refreshFileList; // recompute then prune
        if(fileList.size > maxVersions) {
            fileList.copyRange(maxVersions, fileList.size - 1).do(_.delete);
            fileList = fileList.copyRange(0, maxVersions - 1);
        };
        path.postln;
    }
}

===== CommandTree/CircularSaves.sc =====
// circularSaves.sc
// v1.2.1
// MD 20250819

// This allows me to save the last ten trees in a folder, and keep track of the last one. Versions are named after date/time.


CircularFileSave {
	var <>prefix, <>folderPath, <>maxVersions, <fileList;

/*    *new { |prefix = "myTree", folderPath = "~/TreeSaves", maxVersions = 10|
        ^super.new.init(prefix, folderPath, maxVersions);
    }*/

	*new { |prefix = "myTree", folderPath, maxVersions = 10|
		var userStateFolder;

		userStateFolder = (Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/TreeSaves").standardizePath;

		folderPath = (folderPath ? userStateFolder).standardizePath;
		super.new.init(prefix, folderPath, maxVersions)
	}


	init { |prefix, folderPath, maxVersions|
		this.prefix = prefix;
		this.folderPath = folderPath.standardizePath;
		this.maxVersions = maxVersions;
		this.ensureFolderExists;
		this.refreshFileList;
	}

	ensureFolderExists {
		File.mkdir(folderPath);
	}

/*    refreshFileList {
        fileList = PathName(folderPath).entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
    }*/

	// 20250922
/*	refreshFileList {
		var pn, entries;
		pn = PathName(folderPath.standardizePath);
		if (pn.isFolder.not) { File.mkdir(pn.fullPath) };

		entries = pn.entries
		.select(_.isFile)
		.select({ |p| p.fileName.beginsWith(prefix) and: { p.fileName.endsWith(".json") } });

		// robust boolean comparator; no key-function; no .at on PathName
		entries = entries.asArray.sort({ |a, b| a.fileName > b.fileName });

		fileList = entries; // keep PathName objects; callers can use .fullPath / .fileName
		^this
	}*/
// 20250924
	refreshFileList {
    var pathNameRef, entries;

    pathNameRef = PathName(folderPath.standardizePath);
    if (pathNameRef.isFolder.not) { File.mkdir(pathNameRef.fullPath) };

    entries = pathNameRef.entries
        .select({ arg entry; entry.isFile })
        .select({ arg pn; pn.fileName.beginsWith(prefix) and: { pn.fileName.endsWith(".json") } });

    // newest-first assuming timestamped filenames
    entries = entries.asArray.sort({ arg a, b; a.fileName > b.fileName });

    fileList = entries;
    this
}


	saveVersion { |content|
		var timestamp = Date.getDate.stamp;
		var filename = "%-%".format(prefix, timestamp) ++ ".json";
		var path = folderPath +/+ filename;

		File.use(path, "w", { |f| f.write(content) });

		fileList.addFirst(PathName(path));

		if(fileList.size > maxVersions) {
			var toDelete = fileList.copyRange(maxVersions, fileList.size - 1);
			toDelete.do(_.delete);
			fileList = fileList.copyRange(0, maxVersions - 1);
		};

		path.postln;
	}

	listVersions {
		fileList.collect(_.fileName).do(_.postln);
	}

	loadVersion { |index|
		var file, content;

		if(index >= fileList.size or: { index < 0 }) {
			"Invalid index: % (available: 0 to %)".format(index, fileList.size - 1).warn;
			^nil;
		};

		file = fileList[index];
		if(file.isNil) {
			"No file found at index %".format(index).warn;
			^nil;
		};

		File.use(file.fullPath, "r", { |f|
			content = f.readAllString;
		});
		^content;
	}

	latestVersion {
		^this.loadVersion(0);
	}
}


===== CommandTree/CircularSaves.sc.zip =====
PK   ùe[               CircularSaves.scux ˘     UT ∫c§hºc§h∫c§h≠U€n„6}∂øb ¿Ä›8îlÅ6ﬁêv`Å6-êE˚P4∆≈Di  ÈKö∏ﬂﬁ!EK¢b'ﬁ†z±%Œ9úÀ!Oö¬TËÈRr}√W»Ã4Î¶)¸ÚŒFgﬂéæﬂÌ˛ÆÑDè]†g≈5ºøXhÃ≈fHˇÚBf®„vÊﬁÊ|Û;j#
eË5'Ëœ¬ÿI◊CøQ∏ÜGx*¡í˘√gçò°fqüˇMõŸZoR¿xÙ‰	›skñ‘å®ôP¬ˆwô5Ûj†è‹ñ9Dù—APΩõù	√™¸À?ìx5*•~a∆rïqùâ–Ω∑PqÅç∑V*≥‘xÂi⁄Po€îíF3ª™Zﬂ(˜98’=¡ÊgB˜Î¨„vµ∏‡›§)wªÊsl≤P⁄V4Ã†ƒ©oy^7’0G·pÏÔÖ2;√ÑìHNìPœ	€àEïïëâ”0Öl+÷-3Ö∂?<Ùø∞yëâ\Lπ•Ü~s¨´2§Ø–ió‘¥PñR}™în)ö7_PaπEvè÷ˇ˙è†Cs)5ÚÏœÒ(Ç°<C_∆gÔﬁùç+2óµ¢¨ùƒ{ßΩÑ§¢ÁºñlµŸ¿WÏ+öTËE[QpíûTúeúü·“`·%ú¨ÈË¯^Sœ÷ZXÏá
©Q°	áE¥æT¯´Ãb9:z∂(åïj“•6ñ[°y¨gƒ‹¨d¬ù∏àéıv– Ïäv≈zUUHçÛbÖó∂?L¢2îe§0ãı“∂)`I{“´»ßÖt˙$…Ï6`YAØe≠µnd¡≥ÜnÑ pÛz°’·ÚyﬂG¡≈áV
ÌD].æáQ‹à‰ìZq)≤r˝z–Á+.$øì§∂ÿzÉJI>hÿ‚?ÖÒÄ≠πVuSnïê°ñêûÉ4⁄¸ßg˙k≤K›}g¬\%w]î¿ºX™∏UÙ‚Ñ^ﬂΩ“≠ﬂ'_JYﬁ¡âﬁ	∏áÆ∫\ô;xóRﬁ–›¢Ócò—m’}öñS®Û∑tøÌµú/M√«D™÷SÆ†X†fÎoîvÓ
°?¿≠:á+#ËÆÇE!(SëùaµD=¢¿]p∑Ãs‘Â¶nﬂ=∂K_;i:ï‹ØÆΩrx:o3Í ~ªU?wj«◊˘zõv∞Ì.ü£ç⁄o∂ﬂ•Î•£-∫Üº‡œu–>sÆWü]≤QÖ{ΩŸÉsnÕ˚&_ˆ»ŒˇÁ»ûÔe;éj9d ûÁWÆø“qqCπmì«kæ[œËx„}Eù÷Î◊"Ôç˙∂«Ä=‚h˜-ÑÔñÅ-«-«ß‘2‹HìG∏mÃµ◊s£YÔs∞jœ∂]Ï»I°ˇPKà÷›ﬂ    PK   ùe[               __MACOSX/._CircularSaves.scux ˘     UT ∫c§hºc§he§hc`cg`b`MLVVàPÄê'q!É¯ãàé!!AP&H« ÊFS¬àMŒœ’K,(»I’+( /KÕKÃKNe`db›Êø#Û«Ã PKÄ‚V   £   PK   ùe[à÷›ﬂ              §Å    CircularSaves.scux ˘     UT ∫c§hPK   ùe[Ä‚V   £             §Å=  __MACOSX/._CircularSaves.scux ˘     UT ∫c§hPK      ∑   ¸    
===== CommandTree/CommandManager.sc =====
// CommandManager.sc
// v1.6
// MD 20250921-22:40

// Purpose: Central controller; uses injected display (MagicDisplayGUI), does NOT create windows.
// Style: var-first, AppClock.defer for UI, no server.sync. Tree path is configurable in *new/init.

CommandManager {
	var <>currentState;
	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var <>filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver;
	var <>queueExportCallback;

	var launchpadHandlerRef, footHandlerRef, guitarHandlerRef, dawHandlerRef;

	var <>launchpadID, <>footControllerID, <>guitarID;

	*new { arg treePath;
		^super.new.init(treePath);
	}


	init { arg treePath;
		var defaultPath, savedPath, stateDir, stateFile;
		var explicitOk, savedOk;

		currentState = \idle;
		// saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);
		saver = CircularFileSave.new("myTree", nil, 10);
// or simply: saver = CircularFileSave.new("myTree");


		stateDir  = Platform.userExtensionDir ++ "/LivePedalboardSuite/.state";
		stateFile = stateDir ++ "/LastCommandTreePath.txt";

		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		savedPath = this.readLastPath(stateFile); // <- empty/whitespace -> nil

		explicitOk = treePath.isString and: { treePath.size > 0 };
		savedOk    = savedPath.isString and: { savedPath.size > 0 } and: { File.exists(savedPath) };

		filePath = if (explicitOk) { treePath } { if (savedOk) { savedPath } { defaultPath } };

		if (filePath.isString and: { filePath.size > 0 }) {
			this.writeLastPath(stateDir, stateFile, filePath);
		};

		this.createNewTree;        // will harden path again inside
		this.createBuilder;
		this.createCommandQueue;

		// midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager = MIDIInputManager.new(builder, nil, nil, nil, nil);

		midiManager.parentCommandManager = this;


		^this
	}



	// --- Build pieces --------------------------------------------------------

	createNewTree {
		var usePath;
		// final guard before import: ensure a usable String path
		usePath = filePath;
		if (usePath.isString.not or: { usePath.size <= 0 }) {
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};
		if (File.exists(usePath).not) {
			// last resort: keep going with default even if missing (import will warn gracefully)
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};

		tree = MDCommandTree.new("root");
		tree.importJSONFile(usePath);

		if (tree.notNil) {
			"üì• Tree imported from ".post; usePath.postln;
		}{
			"üì• Couldn't create/import tree.".postln;
		};
		^this
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			if (true) { "üîÆ Builder created".postln };
		}{
			"üîÆ Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			if (true) { "üì¶ Queue created".postln };
		}{
			"üì¶ Couldn't create queue".postln;
		}
	}

	// --- Display passthrough -------------------------------------------------

	setStatus { arg text;
		// If a MagicDisplayGUI is injected, use showExpectation (no updateStatus in that class)
		if (display.notNil and: { display.respondsTo(\showExpectation) }) {
			display.showExpectation(text, 0);
		}{
			("Status: " ++ text).postln;
		}
	}

	// Optional hot-reload from a new path
	reloadTreeFromPath { arg path;
		if (path.notNil) { filePath = path; };
		this.createNewTree;
		builder = MDCommandBuilder.new(tree);
		this.setStatus("‚úÖ Tree reloaded from: " ++ filePath);
	}

	// --- tiny helpers (inside the same class) ---

	writeLastPath { arg dirPath, filePath, pathToWrite;
		var okDir;
		// guard: do nothing if not a non-empty String
		if (pathToWrite.isString.not or: { pathToWrite.size <= 0 }) { ^this };

		okDir = PathName(dirPath).isFolder;
		if (okDir.not) { File.mkdir(dirPath) };

		File.use(filePath, "w", { |fh| fh.write(pathToWrite) });
		^this
	}

	readLastPath { arg filePath;
		var content, cleaned, hasNonSpace;
		if (File.exists(filePath)) {
			File.use(filePath, "r", { |fh| content = fh.readAllString });
			// collapse whitespace-only to nil
			cleaned = content ? "";
			hasNonSpace = false;
			cleaned.do { |ch|
				if ((ch != $\ ) and: { ch != $\t } and: { ch != $\n } and: { ch != $\r }) {
					hasNonSpace = true;
				}
			};
			if (hasNonSpace.not) { content = nil };
		};
		^content
	}


/*	updateDisplay {
		var guiRef, modeText, choiceLines;

		guiRef = display;   // may be nil
		if (guiRef.isNil) { ^this };

		modeText = "Mode: " ++ (currentState ? \idle).asString;

		// build "fret X ‚Üí Name" lines from the builder's current node
		choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
			builder.currentNode.children.collect({ |ch|
				("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
			})
		} { [] };

		{
			if (guiRef.respondsTo(\showExpectation)) {
				guiRef.showExpectation(modeText, 0);
			};
			if (guiRef.respondsTo(\updateTextField)) {
				guiRef.updateTextField(\state, modeText);
				guiRef.updateTextField(\choices, choiceLines.join("\n"));
			};
			// NEW: update choices panel in MagicDisplayGUI if present
			if (guiRef.respondsTo(\setOperations)) {
				guiRef.setOperations(choiceLines);
			};
		}.defer;

		^this
	}*/

// updated 20250924-1209
	updateDisplay {
    var guiRef, modeText, choiceLines;
    guiRef = display; // may be nil
    if (guiRef.isNil) { ^this };
    modeText = "Mode: " ++ (currentState ? \idle).asString;

    // build "fret X ‚Üí Name" lines from the builder's current node
    choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
        builder.currentNode.children.collect({ arg ch;
            ("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
        })
    } { [] };

    {
        if (guiRef.respondsTo(\showExpectation)) {
            guiRef.showExpectation(modeText, 0);
        };
        if (guiRef.respondsTo(\updateTextField)) {
            guiRef.updateTextField(\state, modeText);
            guiRef.updateTextField(\choices, choiceLines.join("\n"));
        };
        if (guiRef.respondsTo(\setOperations)) {
            guiRef.setOperations(choiceLines);
        };
    }.defer;
    ^this
}

}

// Back-compat alias
MDCommandMC : CommandManager {}

===== CommandTree/Logging/CommandManagerLogging.sc_OBSOLETE =====
// CommandManagerLogging
// v1.0.1
// MD 20220923-1222

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ CommandManager {

    logInit { |treePathString|
        this.mdlog(2, "CommandManager", "‚úÖ created; treePath=" ++ treePathString);
        ^this
    }

    setStatus { |text|
        if(display.notNil and: { display.respondsTo(\showExpectation) }) {
            display.showExpectation(text, 0);
        }{
            this.mdlog(2, "CommandManager", "Status: " ++ text);
        };
        ^this
    }

    createNewTree {
        tree = MDCommandTree.new("root");
        tree.importJSONFile(filePath);
        if(tree.notNil) {
            this.mdlog(2, "CommandManager", "üì• tree imported: " ++ filePath);
            this.mdlog(3, "CommandManager", "tree pretty-print follows‚Ä¶");
            tree.printTreePretty;
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create/import tree");
        };
        ^this
    }

    createBuilder {
        builder = MDCommandBuilder.new(tree);
        if(builder.notNil) {
            this.mdlog(2, "CommandManager", "üî≠ builder created");
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create builder");
        };
        ^this
    }

    createCommandQueue {
        queue = MDCommandQueue.new;
        if(queue.notNil) {
            this.mdlog(2, "CommandManager", "üì¶ queue created");
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create queue");
        };
        ^this
    }

    reloadTreeFromPath { |path|
        if(path.notNil) { filePath = path; };
        this.createNewTree;
        builder = MDCommandBuilder.new(tree);
        this.setStatus("‚úÖ tree reloaded from: " ++ filePath);
        this.mdlog(2, "CommandManager", "‚úÖ tree reloaded: " ++ filePath);
        ^this
    }


	// added 20250923

	  // Build a slash path (without "root") from the builder's current node, e.g.
  //  "root -> chain -> add -> audio -> timebased -> delay"
  //   -> "/chain/add/audio/timebased/delay"
  buildLongPathFromBuilder { arg builderRef;
    var names, raw, filtered;
    if(builderRef.isNil or: { builderRef.currentNode.isNil }) { ^"/" };
    names = builderRef.currentNode.getPathToRoot; // List from root..current
    // drop "root", to-lower is not required (your names are already lower)
    filtered = names.copyRange(1, names.size - 1);
    raw = "/" ++ filtered.join("/");
    ^raw;
  }

  // Map long tree paths to short canonical "/verb/..." understood by MPB.
  canonicalizeCommandPath { arg rawPath;
    var parts, first;
    parts = rawPath.asString.split($/).reject({ arg s; s.size == 0 });
    if(parts.size == 0) { ^rawPath.asString };
    first = parts[0].asString;

    // switch family ‚Üí "/switch"
    if(first == "switch") { ^"/switch" };

    // chain/*
    if(first == "chain") {
      if(parts.size >= 3) {
        var second = parts[1].asString;
        // /chain/add/audio/.../<effect> -> /add/<effect>
        if(second == "add" and: { parts[2].asString == "audio" }) {
          ^("/add/" ++ parts.last.asString);
        };
        // /chain/setsource/audio/source/<src> -> /setSource/<src>
        if(second == "setsource"
          and: { parts.size >= 5 }
          and: { parts[2].asString == "audio" }
          and: { parts[3].asString == "source" }) {
          ^("/setSource/" ++ parts.last.asString);
        };
      };
      ^rawPath.asString; // fall through
    };

    // already-canonical short forms
    if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
      ^("/" ++ parts.join("/"));
    };

    ^rawPath.asString;
  }

  // One-shot helper from builder ‚Üí CANONICAL short path.
  canonicalPathFromBuilder { arg builderRef;
    var longPath, shortPath;
    longPath = this.buildLongPathFromBuilder(builderRef);
    shortPath = this.canonicalizeCommandPath(longPath);
    ^shortPath;
  }



}

===== CommandTree/Logging/MDCommandBuilderLogging.sc_OBSOLETE =====
// MDCommandBuilderLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandBuilder {

    printChildren {
        var names;
        if(currentNode.children.notEmpty) {
            currentNode.children.do { |item|
                this.mdlog(3, "CommandBuilder", "üéö fret " ++ item.fret ++ " ‚Üí " ++ item.name);
            };
            names = currentNode.children.collect(_.name);
        }{
            this.mdlog(1, "CommandBuilder", "‚ö† no children");
            names = [];
        };
        ^names
    }

    navigateByFret { |stringLevel, fretNumber|
        var nextNode;
        this.mdlog(2, "CommandBuilder", "üé∏ navigateByFret: " ++ fretNumber);
        nextNode = currentNode.getChildByFret(fretNumber);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        }{
            this.mdlog(1, "CommandBuilder", "‚ö† no child for fret " ++ fretNumber);
        };
        ^currentNode
    }

    navigateByName { |stringLevel, childName|
        var nextNode = currentNode.getChildByName(childName);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        }{
            var avail = currentNode.children.collect(_.name).join(", ");
            this.mdlog(1, "CommandBuilder", "‚ö† not found; available: " ++ avail);
        };
        ^currentNode
    }

    printPathToRoot {
        this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
        ^this
    }

    getCurrentName {
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }

    getCurrentPayload {
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }

    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;
        this.mdlog(2, "CommandBuilder", "üîÑ navigation reset");
        ^this
    }

    printfretPath {
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }
}

===== CommandTree/Logging/MDCommandNodeLogging.sc_OBSOLETE =====
// MDCommandNodeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandNode {

    addChild { |child|
        if(child.isKindOf(MDCommandNode)) {
            child.parent = this;
            children.add(child);
            this.mdlog(2, "CommandNode", "‚ûï added child '" ++ child.name ++ "' under '" ++ name ++ "'");
        }{
            this.mdlog(1, "CommandNode", "‚ö† attempted to add non-node child");
        };
        ^this
    }

    createChild { |name, id, fret|
        var child;
        if(name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
            this.mdlog(1, "CommandNode", "‚ùå invalid args for createChild");
            ^nil;
        };
        child = this.getChildByName(name);
        if(child.isNil) {
            child = MDCommandNode.new(name, id, fret);
            this.addChild(child);
            this.mdlog(2, "CommandNode", "‚úÖ created '" ++ name ++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
        }{
            this.mdlog(2, "CommandNode", "‚ÑπÔ∏è child already exists: " ++ name);
        };
        ^child
    }

    removeChildById { |idToRemove|
        var target = children.detect { |c| c.id == idToRemove };
        if(target.notNil) {
            children.remove(target);
            this.mdlog(2, "CommandNode", "üóëÔ∏è removed id " ++ idToRemove);
        }{
            this.mdlog(1, "CommandNode", "‚ö† id not found: " ++ idToRemove);
        };
        ^this
    }

    getNodeByNamePath { |nameList|
        var currentLocal = this;
        nameList.do { |n|
            currentLocal = currentLocal.getChildByName(n);
            if(currentLocal.isNil) {
                this.mdlog(1, "CommandNode", "‚ùå path segment not found: " ++ n);
                ^nil;
            }
        };
        this.mdlog(2, "CommandNode", "‚úÖ found node: " ++ currentLocal.name);
        ^currentLocal
    }

    printPathToRoot {
        this.mdlog(3, "CommandNode", "üìç " ++ this.getPathToRoot.join(" ‚Üí "));
        ^this
    }

    printTreePretty { |level = 0, isLast = true, prefix = ""|
        var sortedChildren, connector, newPrefix, line;
        connector = if(level == 0) { "" } { if(isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
        line = prefix ++ connector ++ this.name
            ++ " (fret:" ++ this.fret
            ++ ", id:" ++ this.id
            ++ ", payload:" ++ this.payload ++ ")";
        this.mdlog(3, "CommandNode", line);

        newPrefix = if(level == 0) { "" } { prefix ++ if(isLast) { "   " } { "‚îÇ  " } };
        sortedChildren = this.children;
        sortedChildren.do { |child, i|
            var last = (i == (sortedChildren.size - 1));
            child.printTreePretty(level + 1, last, newPrefix);
        };
        ^this
    }
}

===== CommandTree/Logging/MDCommandTreeLogging.sc_OBSOLETE =====
// MDCommandTreeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandTree {

    printTreePretty {
        this.mdlog(3, "CommandTree", "pretty-print follows‚Ä¶");
        root.printTreePretty;
        ^this
    }

    findNodeByName { |name|
        var found;
        found = nodeMap.values.detect { |node| node.name == name };
        if(found.notNil) {
            this.mdlog(2, "CommandTree", "üîé found '" ++ found.name ++ "' (id " ++ found.id ++ ")");
            ^found
        }{
            this.mdlog(1, "CommandTree", "‚ö† node not found: " ++ name);
            ^nil
        }
    }

    getNodeByNamePath { |nameList|
        var found = root.getNodeByNamePath(nameList);
        if(found.notNil) { ^found }{
            this.mdlog(1, "CommandTree", "‚ö† path not found: " ++ nameList.join(" ‚Üí "));
            ^nil
        }
    }

    exportJSONFile { |path|
        var jsonString, file;
        jsonString = JSONlib.convertToJSON(root.asDictRecursively);
        file = File(path, "w");
        if(file.isOpen) {
            file.write(jsonString);
            file.close;
            this.mdlog(2, "CommandTree", "üì§ exported to " ++ path);
        }{
            this.mdlog(1, "CommandTree", "‚ö† failed to open for write: " ++ path);
        };
        ^this
    }

    importJSONFile { |path|
        var jsonString, dict, newTree;
        if(File.exists(path).not) {
            this.mdlog(0, "CommandTree", "‚ùå file does not exist: " ++ path);
            ^false;
        };
        jsonString = File(path, "r").readAllString;
        if(jsonString.isNil or: { jsonString.isEmpty }) {
            this.mdlog(1, "CommandTree", "‚ö† file is empty/unreadable: " ++ path);
            ^false;
        };
        dict = JSONlib.convertToSC(jsonString);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "‚ùå failed to parse JSON: " ++ path);
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "üì• imported from " ++ path);
        ^true
    }

    saveVersioned {
        var json = JSONlib.convertToJSON(root.asDictRecursively);
        saver.saveVersion(json);
        this.mdlog(2, "CommandTree", "üíæ versioned save complete");
        ^this
    }

    loadLatestVersion {
        var json, dict, newTree;
        json = saver.latestVersion;
        if(json.isNil or: { json.isEmpty }) {
            this.mdlog(1, "CommandTree", "‚ö† no saved version found");
            ^false;
        };
        dict = JSONlib.convertToSC(json);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "‚ùå failed to parse saved JSON");
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "üì• loaded latest version");
        ^true
    }

    listSavedVersions {
        this.mdlog(2, "CommandTree", "üóÇ listing saved versions‚Ä¶");
        saver.listVersions; // CircularFileSave may still post; optional: move it to logger later
        ^this
    }

    validateTree {
        var seen = Set.new, valid = true;
        nodeMap.values.do { |node|
            if(seen.includes(node.name)) {
                this.mdlog(1, "CommandTree", "‚ö† duplicate node name: " ++ node.name);
                valid = false;
            };
            seen.add(node.name);
        };
        this.mdlog(valid.if(2,0), "CommandTree", valid.if("‚úÖ validation passed", "‚ùå validation failed"));
        ^valid
    }

    assignPayloads {
        var assignRecursively;
        assignRecursively = { |node|
            node.payload = node.name;
            node.children.do { |child| assignRecursively.(child) };
        };
        assignRecursively.(this.root);
        this.mdlog(2, "CommandTree", "üß† payloads assigned");
        ^this
    }

    printPayloads {
        var printRecursively;
        printRecursively = { |node, level = 0|
            var indent = " " ! level;
            this.mdlog(3, "CommandTree", indent.join ++ node.name ++ " ‚Üí payload: " ++ node.payload);
            node.children.do { |child| printRecursively.(child, level + 1) };
        };
        printRecursively.(this.root);
        ^this
    }
}

===== CommandTree/Logging/MDLogFacade.sc =====
// MDLogFacade
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


// Minimal logging facade so any object can call: this.mdlog(level, label, message)
+ Object {
    mdlog { |level = 2, label = "GENERIC", message = ""|
        var logger = MDMiniLogger.get;
        switch(level,
            0, { logger.error(label, message) },
            1, { logger.warn(label, message) },
            2, { logger.info(label, message) },
            3, { logger.debug(label, message) },
            4, { logger.trace(label, message) }
        );
        ^this
    }
}

===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"üóÇ CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "‚úÖ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("‚úÖ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("üóë Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("‚ö†Ô∏è Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "üíæ Tree saved to versioned file.".postln;
} {
    "‚ö†Ô∏è No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "‚úÖ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "‚ùå Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("‚úÖ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"üíæ Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilder_Compat_Ext.sc_OBSOLETE =====
// MDCommandBuilder_Compat_Ext.sc
// v0.1.0
// MD 20250924-1048

/*
Purpose
- Keep older .scd tests running unchanged by mapping legacy selector names to current API.
Style
- class extension; var-first; lowercase; no server.sync.
*/

+ MDCommandBuilder {

  // Old: listChildren -> New: printChildren (returns names)
  listChildren {
    ^this.printChildren
  }

  // Old: navigateToChild(fret) OR navigateToChild(string, fret)
  navigateToChild { arg legacyArgA, legacyArgB = nil;
    var stringLevel, fretNumber;

    if (legacyArgB.isNil) {
      stringLevel = nil;
      fretNumber  = legacyArgA;
    } {
      stringLevel = legacyArgA;
      fretNumber  = legacyArgB;
    };

    ^this.navigateByFret(stringLevel, fretNumber)
  }

  // Old: printCurrentPath -> New: printPathToRoot
  printCurrentPath {
    ^this.printPathToRoot
  }

  // Old: getCurrentCommand -> New: getCurrentPayload
  getCurrentCommand {
    ^this.getCurrentPayload
  }

  // Old: reset -> New: resetNavigation
  reset {
    ^this.resetNavigation
  }

}

===== CommandTree/MDCommandBuilder.sc =====
// MDCommandBuilder.sc
// v0.2
// MD 20250924-1008

/*
Purpose
- Fold mdlog instrumentation into the base class (Option A).
- Keep existing console messages; add small legacy shims so old tests keep working.
Style
- var-first; descriptive variable names; no single-letter locals; lowercase; no server.sync.
- Minimal changes; preserve your current behavior.
*/

MDCommandBuilder {
    var <>tree, <>currentNode, <>currentCommand, <>fretPath;
    var <>navigationComplete = false;

    *new { arg argTree;  ^super.new.init(argTree); }

    init { arg argTree;
        tree = argTree;
        currentNode = tree.root;
        fretPath = List[0];
        "CommandBuilder initialized".postln;
        ^this
    }

/*    printChildren {
        var childrenNames;

        if (currentNode.children.notEmpty) {
            currentNode.children.do({ arg childItem;
                ("üéöÔ∏è Fret: " ++ childItem.fret ++ " ‚Üí " ++ childItem.name).postln;
            });
            childrenNames = currentNode.children.collect({ arg childItem; childItem.name });
            this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
        } {
            "‚ö†Ô∏è No children".postln;
            this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
        };
        ^childrenNames
    }*/

/*    navigateByFret { arg stringLevel, fretNumber;
        var nextNode;

        this.mdlog(2, "CommandBuilder",
            "üé∏ navigateByFret fret=" ++ fretNumber ++ " stringLevel=" ++ stringLevel);

        ("üé∏ Navigating by fret: " ++ fretNumber).postln;
        nextNode = currentNode.getChildByFret(fretNumber);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        } {
            ("‚ö†Ô∏è No child found for fret: " ++ fretNumber).postln;
            this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
        };
        ^currentNode
    }*/

/*    navigateByName { arg stringLevel, childName;
        var nextNode;

        nextNode = currentNode.getChildByName(childName);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            ("Path: " ++ currentNode.getFullPathString).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        } {
            var availableNames;
            availableNames = currentNode.children.collect({ arg childItem; childItem.name }).join(", ");
            ("‚ö†Ô∏è Available children: " ++ availableNames).postln;
            this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
        };
        ^currentNode
    }*/

/*    printPathToRoot {
        currentNode.getPathToRoot.postln;
        this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
        ^this
    }*/

/*    getCurrentName {
        currentNode.name.postln;
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }*/

/*    getCurrentPayload {
        ("Current payload: " ++ currentNode.payload).postln;
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }*/

    isAtLeaf {
        ^currentNode.children.isEmpty
    }

/*    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;  // important; reset the flag
        "üîÑ Navigation reset".postln;
        this.mdlog(2, "CommandBuilder", "navigation reset");
        ^this
    }*/

//superseded
/*    printfretPath {
        ("Fret path: " ++ fretPath).postln;
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }*/

    // ---- Legacy shims (keep old tests working) ----

    // Old: listChildren -> New: printChildren
    listChildren {
        ^this.printChildren
    }

    // Old: navigateToChild(fret) OR navigateToChild(string, fret)
    navigateToChild { arg legacyArgA, legacyArgB = nil;
        var stringLevel, fretNumber;

        if (legacyArgB.isNil) {
            stringLevel = nil;
            fretNumber  = legacyArgA;
        }{
            stringLevel = legacyArgA;
            fretNumber  = legacyArgB;
        };

        ^this.navigateByFret(stringLevel, fretNumber)
    }

    // Old: printCurrentPath -> New: printPathToRoot
    printCurrentPath {
        ^this.printPathToRoot
    }

    // Old: getCurrentCommand -> New: getCurrentPayload
    getCurrentCommand {
        ^this.getCurrentPayload
    }

    // Old: reset -> New: resetNavigation
    reset {
        ^this.resetNavigation
    }

	// newer 20250924 ------
	printChildren {
    var childrenNames;

    if (currentNode.children.notEmpty) {
      currentNode.children.do({ arg item;
        // existing console output
        ("üéöÔ∏è Fret: " ++ item.fret ++ " ‚Üí " ++ item.name).postln;
      });
      childrenNames = currentNode.children.collect(_.name);
      this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
    } {
      "‚ö†Ô∏è No children".postln;
      this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
    };
    ^childrenNames
  }

  navigateByFret { arg stringLevel, fretNumber;
    var nextNode;

    this.mdlog(2, "CommandBuilder", "üé∏ navigateByFret: " ++ fretNumber
      ++ " (stringLevel=" ++ stringLevel ++ ")");

    nextNode = currentNode.getChildByFret(fretNumber);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
    } {
      ("‚ö†Ô∏è No child found for fret: " ++ fretNumber).postln;
      this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
    };
    ^currentNode
  }

  navigateByName { arg stringLevel, childName;
    var nextNode;

    nextNode = currentNode.getChildByName(childName);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      ("Path: " ++ currentNode.getFullPathString).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
      this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
    } {
      var availableNames;
      availableNames = currentNode.children.collect(_.name).join(", ");
      ("‚ö†Ô∏è Available children: " ++ availableNames).postln;
      this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
    };
    ^currentNode
  }

  printPathToRoot {
    currentNode.getPathToRoot.postln;
    this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
    ^this
  }

  getCurrentName {
    currentNode.name.postln;
    this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
    ^currentNode.name
  }

  getCurrentPayload {
    ("Current payload: " ++ currentNode.payload).postln;
    this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
    ^currentNode.payload
  }

  resetNavigation {
    currentNode = tree.root;
    fretPath = List[0];
    navigationComplete = false;
    "üîÑ Navigation reset".postln;
    this.mdlog(2, "CommandBuilder", "navigation reset");
    ^this
  }

  printfretPath {
    ("Fret path: " ++ fretPath).postln;
    this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
    ^this
  }



}

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandNode test.scd =====
(
// Set a fixed random seed for reproducibility
thisThread.randSeed = 12345;

// Global node counter and limit
~nodeLimit = 50;
~nodeCount = 1;
~fixedChildren = 3;

// Create root node
~root = MDCommandNode.new("root", 0);

// Breadth-first queue
~nodeQueue = List[~root];

// Build tree
while {
    (~nodeQueue.notEmpty and: { ~nodeCount < ~nodeLimit })
} {
    var parent = ~nodeQueue.removeAt(0);
    ("Adding " ++ ~fixedChildren ++ " children to " ++ parent.name).postln;

    ~fixedChildren.do {
        if (~nodeCount < ~nodeLimit) {
            var childName = parent.name ++ "_" ++ ~nodeCount;
            var child = MDCommandNode.new(childName, ~nodeCount);
            parent.addChild(child);
            ~nodeQueue.add(child);
            ("Created node: " ++ child.name ++ " | Total nodes: " ++ ~nodeCount).postln;
            ~nodeCount = ~nodeCount + 1;
        };
    };
};

// Print tree
"Generated Tree Structure:".postln;
~root.printTreePretty("", true);

// Check integrity
"Running integrity check...".postln;
~root.checkIntegrity;

// Count total nodes
~countNodes = { |node|
    var count = 1;
    node.children.do { |c|
        count = count + ~countNodes.(c);
    };
    ^count;
};

("‚úÖ Total nodes in tree: " ++ ~countNodes.(~root)).postln;
"Tree printed.".postln;
"end".postln;
)


b = MDCommandTree("root", 0);

===== CommandTree/MDCommandNode_FixIntegrity+DepthTag.sc =====
// MDCommandNode_FixIntegrity+DepthTag.sc
// v1.0 ‚Äî 2025-09-21 MD

// Purpose
// - Accept SortedList in checkIntegrity.
// - Add tagByDepth(depth) used by MDCommandTree.tagDepths.
// Style
// - var-first; lowercase; no server.sync.

+ MDCommandNode {
    // Accept List OR SortedList
    checkIntegrity {
        var failedChild;
        if( (this.children.isKindOf(List).not) && (this.children.isKindOf(SortedList).not) ) {
            ("‚ùå Integrity check failed at node '" ++ this.name ++ "': children is " ++ children.class).postln;
            ^false;
        };
        failedChild = this.children.detect { |c| c.checkIntegrity.not };
        if(failedChild.notNil) {
            ("‚ùå Integrity failed in child: " ++ failedChild.name).postln;
            ^false;
        };
        ^true
    }

    // annotate nodes with a 'depth' entry in payload (non-destructive)
    tagByDepth { |depth|
        var nextDepth = (depth ? 0).asInteger.max(0);
        // if payload is nil or a String, wrap in a simple Event to attach depth safely
        if(this.payload.isNil or: { this.payload.isKindOf(String) }) {
            this.payload = (name: this.name, depth: nextDepth);
        }{
            // if payload is e.g., an Event/Dict, set depth if slot exists
            this.payload.put(\depth, nextDepth);
        };
        this.children.do { |child| child.tagByDepth(nextDepth + 1) };
        ^this
    }
}

===== CommandTree/MDCommandNode.sc =====
// MDCommandNode.sc
// v1.0.1
// MD 20250924

MDCommandNode {
	var <>name, <>id, <>fret, <>parent, <>children;
	var <> payload; // the "command" that will be inserted in the tree


	*new { |name = "default", id = 1, fret = 1, parent = nil|
		^super.new.init(name, id, fret, parent);
	}

	init { |name, id, fret, parent = nil|
		this.name = name;
		this.id = id;
		this.fret = fret;
		this.parent = parent;
		//this.children = List.new; // updated to following:
		this.children = SortedList.new(nil, { |a, b| a.fret < b.fret });

		//if (children.isKindOf(List).not) updated to following:
		if (this.children.isKindOf(SortedList).not) {
			{
				("‚ö†Ô∏è Children is not a SortedList in node '" ++ name ++ "'! It is: " ++ children.class).postln;
			};

			^this
		}
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/*	removeChildByName { |nameToRemove|
		var index = children.findIndex { |c| c.name == nameToRemove };
		if (index.notNil) { children.removeAt(index); }
	}*/


	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Lookup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/*	getChildByName { |name|
		if (name.isKindOf(String).not) {
			("‚ùå getChildByName error: name must be a String").warn;
			^nil;
		};
		^children.detect { |c| c.name == name }
	}*/

	//getChildById { |id| ^children.detect { |c| c.id == id } }

	// getChildByFret { |fret| ^children.detect { |c| c.fret == fret } }

	childNameExists { |name| ^children.any { |c| c.name == name } }

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	getPathToRoot {
		var path = List.new;
		var current = this;
		while { current.notNil } {
			path.addFirst(current.name);
			current = current.parent;
		};
		^path
	}

	printPathToRoot {
		("üìç Path: " ++ this.getPathToRoot.join(" ‚Üí ")).postln;
	}

/*	getNodeByNamePath { |nameList|
		var current = this;
		nameList.do { |name|
			current = current.getChildByName(name);
			if (current.isNil) {
				("‚ùå Node not found at path segment: " ++ name).postln;
				^nil;
			}
		};
		("‚úÖ Found node: " ++ current.name).postln;
		^current
	}*/

	getDepth {
		^this.parent.notNil.if({ this.parent.getDepth + 1 }, { 0 })
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Analysis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	isLeaf {
		^this.children.size == 0
	}


	hasChild { |node|
		^this.children.any { |c| c === node }
	}
	countDescendants {
		if (this.isLeaf) { ^1 } {
			^this.children.sum { |c| c.countDescendants }
		}
	}

	countLeavesOnly {
		^this.isLeaf.if({ 1 }, {
			this.children.sum { |c| c.countLeavesOnly }
		})
	}

	getFullPathString {
		^this.getPathToRoot.join(" ‚Üí ");
	}

	//newer:
	checkIntegrity {
		var okType, failedChild;
		okType = this.children.isKindOf(List) or: { this.children.isKindOf(SortedList) };
		if(okType.not) {
			("‚ùå Integrity check failed at node '" ++ this.name
				++ "': children is " ++ children.class).postln;
			^false;
		};
		failedChild = this.children.detect { |c| c.checkIntegrity.not };
		if(failedChild.notNil) {
			("‚ùå Integrity failed in child: " ++ failedChild.name).postln;
			^false;
		};
		^true;
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Display ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/*	printTreePretty { |level = 0, isLast = true, prefix = ""|
		var sortedChildren, connector, newPrefix;

		// Print current node
		connector = if (level == 0) { "" } { if (isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
		(prefix ++ connector ++ this.name ++
			" (fret: " ++ this.fret ++
			", id: " ++ this.id ++
			", payload: " ++ this.payload ++ ")").postln;

		// Prepare prefix for children
		newPrefix = if (level == 0) { "" } {
			prefix ++ if (isLast) { "    " } { "‚îÇ   " }
		};

		// Use existing sortedChildren logic
		sortedChildren = this.children;

		// Recursively print children
		sortedChildren.do { |child, i|
			var last = (i == (sortedChildren.size - 1));
			child.printTreePretty(level + 1, last, newPrefix);
		};
	}*/

	printTreePretty { |level = 0, isLast = true, prefix = ""|
    var childList, connector, nextPrefix;

    connector = if (level == 0) { "" } { if (isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
    (prefix ++ connector ++ this.name
        ++ " (fret: " ++ this.fret
        ++ ", id: " ++ this.id
        ++ ", payload: " ++ this.payload ++ ")").postln;

    nextPrefix = if (level == 0) { "" } { prefix ++ if (isLast) { "    " } { "‚îÇ   " } };
    childList = this.children;

    childList.do({ arg child, index;
        var lastFlag;
        lastFlag = (index == (childList.size - 1));
        child.printTreePretty(level + 1, lastFlag, nextPrefix);
    });

    this
}


	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Serialization for exporting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	asDictRecursively {
		var childrenDicts;

		childrenDicts = this.children.collect({ arg childNode;
			childNode.asDictRecursively
		});

		^(
			id:       this.id,
			name:     this.name,
			fret:     this.fret,
			payload:  this.payload,    // ‚Üê Added: keep payload in exports
			children: childrenDicts
		)
	}

	addChild { arg child;
		if (child.isKindOf(MDCommandNode)) {
			child.parent = this;
			children.add(child);
			this.mdlog(2, "CommandNode", "‚ûï added child '" ++ child.name
				++ "' under '" ++ name ++ "'");
		} {
			"‚ö†Ô∏è Attempted to add a non-node child.".warn;
			this.mdlog(1, "CommandNode", "attempted to add non-node child");
		}
	}

	createChild { arg name, id, fret;
		var child;

		if (name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
			"‚ùå Invalid arguments for createChild".warn;
			this.mdlog(1, "CommandNode", "invalid args for createChild");
			^nil;
		};

		child = this.getChildByName(name);

		if (child.isNil) {
			child = MDCommandNode.new(name, id, fret);
			this.addChild(child);
			("‚úÖ Created new child node: " ++ name
				++ " (ID: " ++ id ++ ", Fret: " ++ fret ++ ")").postln;
			this.mdlog(2, "CommandNode", "created '" ++ name
				++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
		} {
			("‚ÑπÔ∏è Child node already exists: " ++ name).postln;
			this.mdlog(2, "CommandNode", "child already exists: " ++ name);
		};

		^child
	}

	removeChildById { arg idToRemove;
		var childToRemove;

		childToRemove = children.detect({ arg nodeRef; nodeRef.id == idToRemove });

		if (childToRemove.notNil) {
			children.remove(childToRemove);
			"üóë Child removed".postln;
			this.mdlog(2, "CommandNode", "removed id=" ++ idToRemove);
		} {
			"‚ö†Ô∏è ID not found".postln;
			this.mdlog(1, "CommandNode", "id not found: " ++ idToRemove);
		}
	}






	removeChildByName { |nameToRemove|
		var index;

		index = children.findIndex({ arg c; c.name == nameToRemove });
		if (index.notNil) { children.removeAt(index) };
		this
	}

	getChildByName { |name|
		var result;

		if (name.isKindOf(String).not) {
			"‚ùå getChildByName error: name must be a String".warn;
			result = nil;
		} {
			result = children.detect({ arg c; c.name == name });
		};
		result
	}

	getChildById { |id|
		var result;
		result = children.detect({ arg c; c.id == id });
		result
	}

	getChildByFret { |fret|
		var result;
		result = children.detect({ arg c; c.fret == fret });
		result
	}

	getNodeByNamePath { |nameList|
		var current, ok;

		current = this;
		ok = true;

		nameList.do({ arg segmentName;
			var nextNode;
			nextNode = current.getChildByName(segmentName);
			if (nextNode.isNil) {
				"‚ùå Node not found at path segment: ".post; segmentName.postln;
				ok = false;
			} {
				current = nextNode;
			};
		});

		if (ok) {
			("‚úÖ Found node: " ++ current.name).postln;
			current
		} {
			nil
		}
	}
}
===== CommandTree/MDCommandNodeTest20250731.scd =====
(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 3);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 11);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 7);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 5);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 11);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 11);


// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;

)



/////////////////////
/// BUILD A TREE - older version.
/////////////////////

(
// Setup
var tree, root, lvl1A, lvl1B, lvl2A, lvl2B, lvl3A, lvl3B, lvl3C;
var printSummary;

// üå± Initialize tree and root
tree = MDCommandTree.new("root", 0, 1);
root = tree.root;

// üß© Level 1
lvl1A = tree.addNode(root.id, "Branch A", 2);
lvl1B = tree.addNode(root.id, "Branch B", 3);

// üß© Level 2
lvl2A = tree.addNode(lvl1A.id, "SubBranch A1", 4);
lvl2B = tree.addNode(lvl1B.id, "SubBranch B1", 5);

// üß© Level 3
lvl3A = tree.addNode(lvl2A.id, "Twig A1a", 6);
lvl3B = tree.addNode(lvl2A.id, "Twig A1b", 7);
lvl3C = tree.addNode(lvl2B.id, "Twig B1a", 8);

// üè∑Ô∏è Tag depth from root
tree.root.tagByDepth(0);

// üìã Node Summary
printSummary = {
    tree.nodeMap.values.do { |node|
        (node.name ++ " ‚Üí depthTag: " ++ node.depthTag ++ ", getDepth: " ++ node.getDepth).postln;
    };
};

// üñºÔ∏è Print results
printSummary.();
tree.printTreePretty;

tree.getNodeByName("Twig A1b").printPathToRoot;

)

===== CommandTree/MDCommandQueue_Compat_AddAlias.sc =====
// CommandTree/MDCommandQueue_Compat_AddAlias.sc
// v1.0.1
// MD 20250924-1249
/*
Purpose:
- Keep older tests working: addCommand -> enqueueCommand.
*/

+ MDCommandQueue {
    addCommand { |command|
        var result;
        result = this.enqueueCommand(command);
        result
    }
}

===== CommandTree/MDCommandQueue.sc =====
// MDCommandQueue.sc
// Refactored for clarity and consistency
// MD 20250818



MDCommandQueue {
    var <>commandList;

    *new { ^super.new.init(); }

    init {
        commandList = List.new(8);
        Verbosity.postIf(1, "‚úÖ CommandQueue initialized");
        ^this
    }

    enqueueCommand { |command|
        commandList.add(command);
        Verbosity.postIf(1, "üì• Command added: " ++ command);
        Verbosity.postIf(2, "üì¶ Current queue: " ++ commandList);
        ^commandList
    }

    dequeueLastCommand {
        if (commandList.notEmpty) {
            commandList.removeAt(commandList.size - 1);
            Verbosity.postIf(1, "üóë Last command removed");
        } {
            Verbosity.postIf(0, "‚ö† No command to remove");
        };
        ^commandList
    }

    clearQueue {
        commandList.clear;
        Verbosity.postIf(1, "üßπ Queue cleared");
        ^this
    }

    exportAsOSCPath {
        var oscPath;

        oscPath = "/" ++ commandList.collect { |cmd|
            cmd.asString;
        }.join("/");

        ~commandToSend = oscPath;
        Verbosity.postIf(2, "üöÄ Exported OSC path: " ++ oscPath);
        ^oscPath
    }
}

// MDCommandQueue {
// 	var <>commandList;
//
// 	*new { ^super.new.init(); }
//
// 	init {
// 		commandList = List.new(8);
// 		"CommandQueue initialized".postln;
// 		^this
// 	}
//
// 	enqueueCommand { |command|
// 		commandList.add(command);
// 		("Command added: " ++ command).postln;
// 		("Current queue: " ++ commandList).postln;
// 		^commandList
// 	}
//
// 	dequeueLastCommand {
// 		if (commandList.notEmpty) {
// 			commandList.removeAt(commandList.size - 1);
// 			"Last command removed".postln;
// 		} {
// 			"‚ö†No command to remove".postln;
// 		};
// 		^commandList
// 	}
//
// 	clearQueue {
// 		commandList.clear;
// 		"üßπ Queue cleared".postln;
// 		^this
// 	}
//
//
// 	exportAsOSCPath {
// 		var oscPath;
//
// 		oscPath = "/" ++ commandList.collect { |cmd|
// 			cmd.asString;
// 		}.join("/");
//
// 		~commandToSend = oscPath;
// 		("Exported OSC path: " ++ oscPath).postln;
// 		^oscPath
// 	}
// }
===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandTree.sc =====
// MDCommandTree.sc
// v1.0.1
// MD 20250924-1230

MDCommandTree {
	var <>root, <>nodeLimit = 200, <>nodeCount = 0, <>nodeMap;
	var <>saver;

	*new { |rootName = "root", rootId = 0, nodeLimit|
		^super.new.init(rootName, rootId, nodeLimit);
	}


/*	*fromDict { |dict|
		var tree;

		// Use a default node limit, or extract from dict if available
		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ?? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				tree.rebuildTreeFromDict(childDict, tree.root);
			};
		};
		tree.root.payload = dict[\payload];

		^tree;
	}*/

	*fromDict { |dict|
		var tree;

		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do({ arg childDict;
				tree.rebuildTreeFromDict(childDict, tree.root);
			});
		};

		tree.root.payload = dict[\payload];
		tree
	}

	init { |rootName, rootId, limit|
		root = MDCommandNode.new(rootName, rootId);
		nodeLimit = limit;
		nodeCount = 1;

		nodeMap = IdentityDictionary.new(100);
		nodeMap.put(rootId, root);

		saver = CircularFileSave.new("myTree", "~/TreeSaves", 10); // this is what will manage saves

		^this
	}

	rebuildTreeFromDict { |dict, parent|
		var node;

		node = MDCommandNode.new(dict[\name], dict[\id], dict[\fret]);
		parent.addChild(node);

		nodeMap.put(node.id, node);
		nodeCount = node.id.max(nodeCount);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				this.rebuildTreeFromDict(childDict, node);
			};
		};

		node.payload = dict[\payload];

		^node;
	}

/*	printTreePretty {
		root.printTreePretty;
		^this;
	}*/

	tagDepths {
		root.tagByDepth(0);
		^this;
	}

/*	findNodeByName { |name|
		var found;
		found = nodeMap.values.detect { |node| node.name == name };
		if (found.notNil) {
			("üîç Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			^found
		} {
			"‚ö†Ô∏è Node not found".postln;
			^nil
		}
	}*/

/*	getNodeByNamePath { |nameList|
		var found;
		found = root.getNodeByNamePath(nameList);
		if (found.notNil) {
			^found
		} {
			("‚ö†Ô∏è Node not found at path: " ++ nameList.join(" ‚Üí ")).postln;
			^nil
		}
	}*/

	addNode { |parentId, name, fret|
		var newId, parentNode, newNode;

		newId = nodeCount + 1;
		parentNode = nodeMap.at(parentId);

		if (parentNode.notNil) {
			nodeCount = newId;
			newNode = MDCommandNode.new(name, newId, fret);
			newNode.parent = parentNode;
			parentNode.addChild(newNode);
			nodeMap.put(newId, newNode);
			^newNode
		} {
			("‚ö†Ô∏è Invalid parent ID: " ++ parentId).postln;
			^nil
		}
	}

	removeNode { |nodeId|
		var nodeToRemove, parentNode, found;

		nodeToRemove = nodeMap.at(nodeId);
		parentNode = nodeToRemove.parent;

		if (parentNode.notNil) {
			found = parentNode.children.detect { |c| c === nodeToRemove };
			if (found.notNil) {
				parentNode.removeChildById(found.id);
				nodeMap.removeAt(nodeId);
				("üóë Node " ++ nodeId ++ " removed.").postln;
				^nodeToRemove
			} {
				"‚ö†Ô∏è Node not found in parent's children".postln;
				^nil
			}
		} {
			"‚ö†Ô∏è Cannot remove root node".postln;
			^nil
		}
	}

	swapNodes { |nodeId1, nodeId2|
		var node1, node2, parent1, parent2;

		node1 = nodeMap.at(nodeId1);
		node2 = nodeMap.at(nodeId2);
		parent1 = node1.parent;
		parent2 = node2.parent;

		if (parent1.isNil or: { parent2.isNil }) {
			"‚ö†Ô∏è Both nodes must have parents to swap".postln;
			^nil
		};

		node1 = removeNode(nodeId1);
		node2 = removeNode(nodeId2);

		if (node1.isNil or: { node2.isNil }) {
			"‚ö†Ô∏è Failed to remove nodes for swapping".postln;
			^nil
		};

		parent1.addChild(node2);
		parent2.addChild(node1);

		"üîÑ Nodes swapped".postln;
		^nil
	}

/*	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("üì§ Tree exported to " ++ path).postln;
		} {
			"‚ö†Ô∏è Failed to open file for writing.".warn;
		}
	}*/

	// importJSONFile { |path|
	// 	var jsonString, dict, newTree;
	//
	// 	if (File.exists(path).not) {
	// 		"‚ùå File does not exist: %".format(path).postln;
	// 		^false;
	// 	};
	//
	// 	jsonString = File(path, "r").readAllString;
	//
	// 	if (jsonString.isNil or: { jsonString.isEmpty }) {
	// 		"‚ö†Ô∏è File is empty or unreadable.".postln;
	// 		^false;
	// 	};
	//
	// 	dict = JSONlib.convertToSC(jsonString);
	//
	// 	if (dict.isNil) {
	// 		"‚ö†Ô∏è Failed to parse JSON.".postln;
	// 		^false;
	// 	};
	//
	// 	newTree = MDCommandTree.fromDict(dict);
	// 	this.root = newTree.root;
	// 	this.nodeMap = newTree.nodeMap;
	// 	this.nodeCount = newTree.nodeCount;
	//
	// 	("üì• Tree imported from " ++ path).postln;
	// 	^true;
	// }

	// NEW - added to manage circular saves
/*	saveVersioned {
		var json = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(json);
		"Tree saved to versioned file.".postln;
	}*/
	//---

	// NEW - added to manage circular saves
/*	loadLatestVersion {
		var json = saver.latestVersion;
		var dict, newTree;

		if(json.isNil or: { json.isEmpty }) {
			"‚ö†Ô∏è No saved version found.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(json);

		if(dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		"üì• Tree loaded from latest version.".postln;
		^true;
	}*/
	//---

	// NEW - added to manage circular saves
	listSavedVersions {
		saver.listVersions;
	}

	//---







	// THIS IS NEW. This is so that (for now) we can copy the name of the node into the payload instance variable.
	assignPayloads {
		var assignRecursively;

		assignRecursively = { |node|
			node.payload = node.name;
			node.children.do { |child|
				assignRecursively.(child);
			};
		};

		assignRecursively.(this.root);
		"üß† Payloads assigned to all nodes in tree.".postln;
		^this;
	}

	printPayloads {
		var printRecursively;

		printRecursively = { |node, level = 0|
			var indent = "  " ! level;
			(indent.join ++ node.name ++ " ‚Üí Payload: " ++ node.payload).postln;
			node.children.do { |child|
				printRecursively.(child, level + 1);
			};
		};

		printRecursively.(this.root);
		^this;
	}

	printTreePretty {
		root.printTreePretty;
		this.mdlog(3, "CommandTree", "pretty-print finished");
		^this;
	}

	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("üì§ Tree exported to " ++ path).postln;
			this.mdlog(2, "CommandTree", "exported=" ++ path);
		} {
			"‚ö†Ô∏è Failed to open file for writing.".warn;
			this.mdlog(1, "CommandTree", "failed open for write: " ++ path);
		};
		^this
	}

/*	importJSONFile { |path|
		var jsonString, dict, newTree;

		if (File.exists(path).not) {
			("‚ùå File does not exist: %".format(path)).postln;
			this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
			^false;
		};

		jsonString = File(path, "r").readAllString;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"‚ö†Ô∏è File is empty or unreadable.".postln;
			this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		("üì• Tree imported from " ++ path).postln;
		this.mdlog(2, "CommandTree", "imported=" ++ path);
		^true;
	}*/

	importJSONFile { arg path;
    var jsonString, dict;

    // Basic I/O and parsing guards
    if (File.exists(path).not) {
        ("‚ùå File does not exist: %".format(path)).postln;
        this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
        ^false;
    };

    jsonString = File(path, "r").readAllString;

    if (jsonString.isNil or: { jsonString.isEmpty }) {
        "‚ö†Ô∏è File is empty or unreadable.".postln;
        this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
        ^false;
    };

    dict = JSONlib.convertToSC(jsonString);

    if (dict.isNil) {
        "‚ö†Ô∏è Failed to parse JSON.".postln;
        this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
        ^false;
    };

    // ---- Build *this* tree in-place: reset containers first
    {
        var rootName, rootId, children;

        // tolerant root fields (work even if JSON doesn't carry name/id)
        rootName = dict[\name] ? "root";
        rootId   = (dict[\id] ? 0).asInteger;

        // fresh root + maps
        root = MDCommandNode.new(rootName.asString, rootId, 0);
        nodeMap = IdentityDictionary.new(128);
        nodeMap.put(rootId, root);
        nodeCount = rootId.max(1);

        // recursively build from children if present
        children = dict[\children];
        if (children.isKindOf(Array)) {
            children.do({ |childDict| this.rebuildTreeFromDict(childDict, root) });
        };

        // preserve payload at root if present
        root.payload = dict[\payload];

    }.value;

    ("üì• Tree imported from " ++ path).postln;
    this.mdlog(2, "CommandTree", "imported=" ++ path);
    ^true;
}



	saveVersioned {
		var jsonString;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(jsonString);
		"Tree saved to versioned file.".postln;
		this.mdlog(2, "CommandTree", "versioned save complete");
	}

	loadLatestVersion {
		var jsonString, dict, newTree;

		jsonString = saver.latestVersion;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"‚ö†Ô∏è No saved version found.".postln;
			this.mdlog(1, "CommandTree", "no saved version found");
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse saved JSON");
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		"üì• Tree loaded from latest version.".postln;
		this.mdlog(2, "CommandTree", "loaded latest version");
		^true;
	}

/*  validateTree {
    var seenNames, validFlag;

    seenNames = Set.new;
    validFlag = true;

    nodeMap.values.do({ |nodeRef|
      if (seenNames.includes(nodeRef.name)) {
        ("‚ö†Ô∏è Duplicate node name: " ++ nodeRef.name).postln;
        this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
        validFlag = false;
      };
      seenNames.add(nodeRef.name);
    });

    this.mdlog(validFlag.if(2,0), "CommandTree",
      validFlag.if("‚úÖ validation passed", "‚ùå validation failed"));

    ^validFlag;
  }*/

	findNodeByName { |name|
		var found;

		found = nodeMap.values.detect({ arg nodeRef; nodeRef.name == name });
		if (found.notNil) {
			("üîç Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			found
		} {
			"‚ö†Ô∏è Node not found".postln;
			nil
		}
	}

	getNodeByNamePath { |nameList|
		var found;

		found = root.getNodeByNamePath(nameList);
		if (found.notNil) { found } {
			("‚ö†Ô∏è Node not found at path: " ++ nameList.join(" ‚Üí ")).postln;
			nil
		}
	}

	validateTree {
		var seenNames, validFlag;

		seenNames = Set.new;
		validFlag = true;

		nodeMap.values.do({ arg nodeRef;
			if (seenNames.includes(nodeRef.name)) {
				("‚ö†Ô∏è Duplicate node name: " ++ nodeRef.name).postln;
				this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
				validFlag = false;
			};
			seenNames.add(nodeRef.name);
		});

		this.mdlog(validFlag.if(2, 0), "CommandTree",
			validFlag.if("‚úÖ validation passed", "‚ùå validation failed"));

		validFlag
	}
}

===== CommandTree/MIDIHandlers.sc =====
//MIDIHandlers.sc
// MD 20250818
// taken out of MIDIInputManager.sc to make smaller file and cleaner organisation.

MIDIInputHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}

LaunchpadHandler  {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
	}
}

LaunchpadDAWHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		// Intentionally left blank to ignore DAW messages
	}
}

FootControllerHandler {
	var <>inputManager;

	*new { |inputManager|
		if (inputManager.isNil) {
			Error("FootControllerHandler requires a inputManager").throw;
		};
		^super.new.init(inputManager);
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ FootControllerHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, value|
		("üß™ inputManager class is: " ++ inputManager.class).postln;


		if (type === \noteOn) {
			switch (value,
				36, { inputManager.setMode(inputManager.modes[\idle]) },
				38, { inputManager.setMode(inputManager.modes[\prog]) },
				40, { inputManager.setMode(inputManager.modes[\queue]) },
				41, { inputManager.setMode(inputManager.modes[\send]) },
				{ ("‚ö†Ô∏è No action for note: " ++ value).postln }
			);
		}
	}
}

GuitarMIDIHandler {
	var <>inputManager;

	*new { |inputManager|
		var instance = super.new;
		instance.init(inputManager);
		^instance
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ GuitarMIDIHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, pitch|
		var stringBasePitches, basePitch, fret, stringNumber;

		// ‚úÖ Confirm method is being called
		("üì• handleMessage called with channel: " ++ channel ++ ", type: " ++ type ++ ", pitch: " ++ pitch).postln;

		// ‚úÖ Check type
		if (type === \noteOn) {
			"‚úÖ type is noteOn".postln;
		} {
			"‚ùå type is not noteOn".postln;
		};

		// ‚úÖ Check current mode
		if (inputManager.currentMode == inputManager.modes[\prog]) {
			"‚úÖ currentMode is prog".postln;

			stringBasePitches = (
				0: 40, // E string (6th)
				1: 45, // A
				2: 50, // D
				3: 55, // G
				4: 59, // B
				5: 64  // E (1st)
			);

			basePitch = stringBasePitches[channel];
			if (basePitch.notNil) {
				fret = pitch - basePitch;
				stringNumber = 6 - channel;

				("üé∏ Received MIDI note: " ++ pitch ++
					" on channel: " ++ channel ++
					" ‚Üí string: " ++ stringNumber ++
					", base pitch: " ++ basePitch ++
					", calculated fret: " ++ fret).postln;

				// ‚úÖ Navigation logic
				if (inputManager.waitingForString == stringNumber) {
					inputManager.waitingForString = nil;
					inputManager.navigationCallback.value(fret);
				};
			} {
				("‚ö†Ô∏è Unrecognized channel: " ++ channel ++ ". No base pitch defined.").postln;
			}
		} {
			("‚ùå currentMode is: " ++ inputManager.currentMode).postln;
		};

		{ inputManager.parentCommandManager.updateDisplay; }.defer;
	}
}
===== CommandTree/MIDIInputManager.sc =====
// MIDIInputManager.sc
// v1.1.1
// v1.1 added things in send mode for LivePedalboardSystem
// MD 20250817-1926

MIDIInputManager {
	var <>deviceUIDs;         // Dict: symbolic name -> srcID
	var <>deviceHandlers;     // Dict: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <> builder, <>queue;
	var <> parentCommandManager;
	var <> modes;
	var <>waitingForString, <>navigationCallback;
	var <>lastEnqueuedPayload;


	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	/*
	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|

		this.modes = IdentityDictionary[
			\idle -> \idle,
			\prog -> \prog,
			\queue -> \queue,
			\send -> \send,
			\play -> \play,
			\numeric -> \numeric,
			\capture -> \capture,
			\record -> \record
		];

		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		// this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		// this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		//DEBUG:
		("footControllerHandler manager is: " ++ footControllerHandler.inputManager).postln;

		// this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		// this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;


		this.launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this) };
		this.footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
		this.guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this) };
		this.launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this) };


		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getDeviceSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}
*/

	init { arg argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW;
    var defined;

    // -- modes + basics
    this.modes = IdentityDictionary[
        \idle -> \idle, \prog -> \prog, \queue -> \queue, \send -> \send,
        \play -> \play, \numeric -> \numeric, \capture -> \capture, \record -> \record
    ];
    this.builder = argBuilder;
    this.queue   = MDCommandQueue.new;

    // --- 1) CREATE HANDLERS FIRST (safe fallbacks)
    launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this)      };
    footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
    guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this)     };
    launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this)   };

    // --- 2) MIDI client + device scan/bind
    MIDIClient.init;
    MIDIIn.connectAll;

    deviceUIDs     = Dictionary.new;
    deviceHandlers = Dictionary.new;
    this.scanDevices;

    launchpadID      = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
    launchpadDAWID   = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out);
    footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
    guitarID         = this.getDeviceSrcID(\MD_IAC_to_SC);

    // Bind (guarded inside bindDevice)
    this.bindDevice(launchpadID,      launchpadHandler);
    this.bindDevice(footControllerID, footControllerHandler);
    this.bindDevice(guitarID,         guitarHandler);
    this.bindDevice(launchpadDAWID,   launchpadDAWHandler);

    // --- 3) Optional debug (after creation; nil-safe)
    ("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;
    ("footControllerHandler manager is: "
        ++ (footControllerHandler.notNil.if({ footControllerHandler.inputManager }, { "nil" }))
    ).postln;

    // --- 4) Final MIDIdef
    this.setupMIDIDef;

    ^this
}

	setMode { |newMode|
		currentMode = newMode;
		parentCommandManager.currentState = newMode;
		this.handleModeChange(newMode);
		{ parentCommandManager.updateDisplay }.defer;
	}

	handleModeChange { |mode|
		switch(mode,
			modes[\idle], {
				queue.clear;
				builder.resetNavigation;
				"Tree navigation reset.".postln;
			},

			modes[\prog], {
				var root;

				builder.resetNavigation;

				root = builder.tree.root; // get the root
				if (root.notNil) {
					root.children.do { |child| ("‚Ä¢ " ++ child.name).postln };
				};

				this.startNavigationFromString(6);

				"Tree navigation started.".postln;
			},

			//---


			modes[\queue], {
				var queueText, canonicalPath;

				// NEW: derive canonical short path from current CommandTree selection
				canonicalPath = parentCommandManager.canonicalPathFromBuilder(builder);

				if (canonicalPath != lastEnqueuedPayload) { // reuse dedupe guard
					("Current canonical to queue: " ++ canonicalPath).postln;
					queue.enqueueCommand(canonicalPath);
					lastEnqueuedPayload = canonicalPath;

					if (builder.isAtLeaf) {
						parentCommandManager.setStatus("üåø Leaf ‚Üí " ++ canonicalPath);
					} {
						parentCommandManager.setStatus("üì• Queued node: " ++ canonicalPath);
					};

					queueText = queue.commandList.collect({ arg cmd; "- " ++ cmd.asString }).join("\n");
					{
						parentCommandManager.display.updateTextField(\state, "Mode: queue");
						parentCommandManager.display.updateTextField(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.updateTextField(\lastCommand, "Last Added: " ++ canonicalPath);
					}.defer;

				} {
					("‚ö†Ô∏è Duplicate canonical ignored: " ++ canonicalPath).postln;
					parentCommandManager.setStatus("‚ö†Ô∏è Duplicate canonical ignored");
				};

				builder.resetNavigation;
				"Added canonical to queue and restarted navigation.".postln;
				this.setMode(modes[\prog]); // unchanged
			},

			//---

/*			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;

				("Sent queue as OSC: " ++ path).postln;
				queue.clear;
			},*/

			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;
				("Sent queue as OSC: " ++ path).postln;
				if (parentCommandManager.notNil and: { parentCommandManager.queueExportCallback.notNil }) {
					parentCommandManager.queueExportCallback.value(path);
				};
				queue.clear;
			},

			modes[\play], {
				"üé∏ Play mode: no interaction.".postln;
			},
			modes[\numeric], {
				"üî¢ Numeric input mode (not yet implemented).".postln;
			},
			modes[\capture], {
				"üéº Capture mode (not yet implemented).".postln;
			},
			modes[\record], {
				"üî¥ Record mode (not yet implemented).".postln;
			}
		);
	}
	startNavigationFromString { |stringNum|
		if (stringNum < 1) {
			builder.navigationComplete = true;
			"‚úÖ Navigation complete.".postln;
			^this;
		};

		this.listenForNoteFromString(stringNum, { |fret|
			builder.navigateByFret(stringNum, fret);
			this.startNavigationFromString(stringNum - 1);
		});
	}

	listenForNoteFromString { |stringNum, callback|
		waitingForString = stringNum;
		navigationCallback = callback;
		("üéß Waiting for note on string " ++ stringNum).postln;
	}

	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"üéõ Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getDeviceSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " ‚Üí UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getDeviceSrcID(keyOrID);
			symbol = keyOrID;
		}{
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("‚ö†Ô∏è Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("‚ö†Ô∏è No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("üîó Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}

	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("‚ö†Ô∏è No handler bound for srcID: " + srcID).postln;
			}
		});
	}

} // end of MIDIInputManager class


===== CommandTree/test_circularSaves20250826.scd =====
// test_circularSaves20250826.scd
// MD



(
// Step 1: Load the latest saved tree version
~tree = MDCommandTree.new("root");
~loaded = ~tree.loadLatestVersion;

if (~loaded) {
    "Latest tree loaded.".postln;
    "Tree before modification:".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved tree found. Starting with empty tree.".postln;
};
)

(
// Step 2: Save current version for comparison
~originalJSON = ~tree.saver.latestVersion;
)

(
// Step 3: Modify the tree
~newNode = ~tree.addNode(0, "NewNode", 99);

if (~newNode.notNil) {
    "New node added.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add new node.".postln;
};
)

(
// Step 4: Save the modified tree as a new version
~tree.saveVersioned;
)

(
// Step 5: Compare original and new JSON
~newJSON = ~tree.saver.latestVersion;

if (~originalJSON != ~newJSON) {
    "Change confirmed: tree content has been updated.".postln;
} {
    "‚ö†Ô∏è No change detected between versions.".postln;
};
)













// (
// // Step 1: Create a new tree
// ~tree = MDCommandTree.new("root");
//
// // Step 2: Add some nodes
// ~tree.addNode(0, "A", 1);
// ~tree.addNode(1, "B", 2);
// ~tree.addNode(2, "C", 3);
// "‚úÖ Nodes added.".postln;
// ~tree.printTreePretty;
// )
//
// (
// // Step 3: Save the tree using CircularFileSave
// ~tree.saveVersioned;
// )
//
// (
// // Step 4: List saved versions
// ~tree.listSavedVersions;
// )
//
// (
// // Step 5: Load the latest saved version
// ~tree.loadLatestVersion;
// )
//
// (
// // Step 6: Print the tree to confirm it was restored
// "‚úÖ Tree after loading latest version:".postln;
// ~tree.printTreePretty;
// )

===== CommandTree/testCircularSave_20250819.scd =====
// Create a saver
~saver = CircularFileSave.new("myTree");

// Save a version
~saver.saveVersion("This is version " ++ Date.getDate.stamp);

// List saved versions
~saver.listVersions;

// Load a specific version
~saver.loadVersion(0).postln;

===== CommandTree/Tests/TestLogging_CommandBuilder.scd =====
TestLogging_CommandBuilder.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var jsonPath, tree, builder;

MDMiniLogger.get.setverbosity(3); // DEBUG

jsonPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
tree = MDCommandTree.new("root");
tree.importJSONFile(jsonPath);

builder = MDCommandBuilder.new(tree);
builder.printChildren;
builder.navigateByName(nil, "SomeChildName"); // INFO/WARN depending on your tree
builder.resetNavigation;
builder.printfretPath;
)

===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path ‚Üí " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) ‚Äî informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic ‚Äî print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' ‚Üí " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported ‚Üí " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("‚ö†Ô∏è Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== CommandTree/Tests/TestLogging_FullBringUp.scd =====
TestLogging_FullBringUp.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var lps;
MDMiniLogger.get.setverbosity(2); // INFO

lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;

// Switch to DEBUG if you want more detail for a moment
MDMiniLogger.get.setverbosity(3);

lps.commandManager.setStatus("Sanity check: status via MDMiniLogger");
)

===== CommandTree/TestUserDisplay.scd =====
(
~displayTest = UserDisplay.new;

~displayTest.display(\state, "üß≠ State: treeNav");
~displayTest.display(\queue, "üìã Queue: audio ‚Üí noise ‚Üí 100");
~displayTest.display(\lastCommand, "üïò Last Command: 100");
~displayTest.display(\choices, "üéö Choices:\nFret 7: noise\nFret 9: oscillators");
)

===== CommandTree/testVerbosity.scd =====
// temp

(
// üß™ Set verbosity level to 0 (errors only)
Verbosity.setLevel(0);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 2 (up to input/output)
Verbosity.setLevel(2);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 4 (everything)
Verbosity.setLevel(4);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");
)

Verbosity.help;
===== CommandTree/Verbosity.sc =====
// Verbosity.sc
// MD 20250819

// used to manage verbosity levels of my debugging messages

// Verbosity Levels:
// 0 ‚Üí Errors only
// 1 ‚Üí Actions
// 2 ‚Üí Input/Output
// 3 ‚Üí Object and type reporting
// 4 ‚Üí Full debug (everything)






// Verbosity.sc
Verbosity {
    classvar <level = 2; // Default level

	*help {
    "Verbosity Levels:".postln;
    "0 ‚Üí Errors only".postln;
    "1 ‚Üí Actions".postln;
    "2 ‚Üí Input/Output".postln;
    "3 ‚Üí Object and type reporting".postln;
    "4 ‚Üí Full debug (everything)".postln;
}


    *setLevel { |newLevel|
        level = newLevel;
        ("üîß Verbosity level set to: " ++ level).postln;
    }

    *shouldPost { |requiredLevel|
        ^level >= requiredLevel;
    }

    *postIf { |requiredLevel, msg|
        if (level >= requiredLevel) {
            msg.postln;
        };
    }
}

===== concat-files.sh =====
#!/usr/bin/env bash
#
# concat-files.sh ‚Äî Recursively concatenate files of a given type, with path headers
# Usage:
#   ./concat-files.sh -p '*.txt' [-o out.txt] [-x dirToExclude ...] [--mode header|tsv] [--absolute] [--no-sort]
#
# Defaults:
#   - pattern:     '*.txt'
#   - output:      stdout
#   - excludes:    .git, node_modules
#   - mode:        header   (prints a banner line with the path, then the file contents)
#   - path style:  relative (use --absolute for full absolute paths)
#   - sorting:     NUL-safe if GNU sort/gsort is available; otherwise falls back to unsorted
#
# Notes:
#   - NUL-safe (handles any filenames).
#   - Assumes text files. For binary data, consider filtering or adjusting.
#   - If -o is inside the tree, the script will avoid including the output file in its own output.
set -Eeuo pipefail

print_help() {
  sed -n '2,60p' "$0"
  cat <<'EOF'

Examples:
  # Concatenate all .sc files to out.txt with headers
  ./concat-files.sh -p '*.sc' -o out.txt

  # TSV mode: each line = "<path>\t<content with newlines collapsed>"
  ./concat-files.sh -p '*.md' --mode tsv -o files.tsv

  # Exclude extra directories
  ./concat-files.sh -p '*.py' -x build -x dist -o py-all.txt

  # Absolute paths in headers
  ./concat-files.sh -p '*.txt' --absolute -o abs.txt
EOF
}

# --- Defaults ---
pattern='*.txt'
out=''
mode='header'     # 'header' or 'tsv'
absolute=0
no_sort=0
# Default excludes (directory names, matched anywhere in the tree)
excludes=( ".git" "node_modules" )

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--pattern)
      [[ $# -ge 2 ]] || { echo "Error: -p|--pattern requires a value" >&2; exit 2; }
      pattern=$2; shift 2;;
    -o|--out)
      [[ $# -ge 2 ]] || { echo "Error: -o|--out requires a value" >&2; exit 2; }
      out=$2; shift 2;;
    -x|--exclude)
      [[ $# -ge 2 ]] || { echo "Error: -x|--exclude requires a value" >&2; exit 2; }
      excludes+=("$2"); shift 2;;
    --mode)
      [[ $# -ge 2 ]] || { echo "Error: --mode requires a value" >&2; exit 2; }
      case "$2" in header|tsv) mode=$2;; *) echo "Error: --mode must be 'header' or 'tsv'." >&2; exit 2;; esac
      shift 2;;
    --absolute)
      absolute=1; shift;;
    --no-sort)
      no_sort=1; shift;;
    -h|--help)
      print_help; exit 0;;
    *)
      echo "Unknown option: $1" >&2; print_help; exit 2;;
  esac
done
# Compute absolute path of output (if any) to avoid including it
out_abs=""
if [[ -n "$out" ]]; then
  case "$out" in
    /*) out_abs="$out";;
     *) out_abs="$PWD/$out";;
  esac
fi

# Pick a NUL-safe sort if available: prefer gsort (Homebrew coreutils) then GNU sort; else no sorting.
sort_bin=""
if [[ "$no_sort" -eq 0 ]]; then
  if command -v gsort >/dev/null 2>&1; then
    sort_bin="gsort"
  elif sort -z </dev/null >/dev/null 2>&1; then
    sort_bin="sort"
  else
    echo "Note: No NUL-safe sort ('gsort' or 'sort -z') available; output not sorted." >&2
  fi
fi

# Build the find(1) command with prunes and NUL-separated output
# Correct structure:
#   find . -type d \( -name ex1 -o -name ex2 ... \) -prune -o -type f -name "$pattern" -print0
find_cmd=(find .)

if [[ "${#excludes[@]}" -gt 0 ]]; then
  find_cmd+=(-type d '(')
  first=1
  for ex in "${excludes[@]}"; do
    if [[ $first -eq 1 ]]; then
      find_cmd+=(-name "$ex")
      first=0
    else
      find_cmd+=(-o -name "$ex")
    fi
  done
  find_cmd+=(')' -prune -o)
fi

# Always match files by pattern and print NUL-terminated names
find_cmd+=(-type f -name "$pattern" -print0)

# Function to emit the NUL-separated file list (optionally sorted)
find_out_stream() {
  if [[ -n "$sort_bin" ]]; then
    "${find_cmd[@]}" | "$sort_bin" -z
  else
    "${find_cmd[@]}"
  fi
}

# Stream NUL-terminated file names and format output
{
  find_out_stream
} | while IFS= read -r -d '' f; do
  # Normalize absolute path for comparison and optional display
  file_abs="$PWD/${f#./}"

  # Skip the output file itself if it appears
  if [[ -n "$out_abs" && "$file_abs" -ef "$out_abs" ]]; then
    continue
  fi

  if [[ $absolute -eq 1 ]]; then
    display_path="$file_abs"
  else
    display_path="${f#./}"
  fi

  if [[ "$mode" == "tsv" ]]; then
    # One line per file: <path>\t<content with newlines collapsed>
    printf '%s\t' "$display_path"
    tr '\n' ' ' < "$f" | sed -E 's/[[:space:]]+$//'
    printf '\n'
  else
    # Header banner + full content + blank line
    printf '===== %s =====\n' "$display_path"
    cat -- "$f"
    printf '\n'
  fi
done > "${out:-/dev/stdout}"


===== concat-files2.sh =====
#!/usr/bin/env bash
#
# concat-files2.sh ‚Äî Recursively concatenate files, with path headers
# Usage:
#   ./concat-files2.sh [-p '<glob>'] [-o out.txt] [-x dirToExclude ...] \
#                      [--mode header|tsv] [--absolute] [--no-sort] \
#                      [--include-underscore] [--include-dotfiles]
#
# Defaults:
#   - pattern: '*'             (match ALL files; no filetype filtering)
#   - output: stdout           (prefer -o to avoid self-inclusion)
#   - excludes: .git, node_modules, _*  (ignore underscore-prefixed directories)
#   - dotfiles: ignored by default (basenames starting with '.')
#   - mode: header             (prints a banner line with the path, then contents)
#   - path style: relative     (use --absolute for full absolute paths)
#   - sorting: NUL-safe if GNU sort/gsort is available; otherwise unsorted
#
# Notes:
#   - To avoid self-inclusion, prefer:  ./concat-files2.sh -o out.txt
#     (Avoid: ./concat-files2.sh > out.txt ‚Äî the shell redirect creates the file inside the tree.)
#   - NUL-safe (handles any filenames).
#   - If -o is inside the tree, we prune it from find and write to /tmp first, then move.

set -Eeuo pipefail

print_help() {
  cat <<'EOF'
Examples:
  # Concatenate ALL files to out.txt with headers (underscore dirs ignored; dotfiles ignored)
  ./concat-files2.sh -o out.txt

  # TSV mode: each line = "<path>\t<content with newlines collapsed>"
  ./concat-files2.sh --mode tsv -o files.tsv

  # Exclude extra directories
  ./concat-files2.sh -x build -x dist -o all.txt

  # Absolute paths in headers
  ./concat-files2.sh --absolute -o abs.txt

  # Include underscore-prefixed dirs (override default ignore)
  ./concat-files2.sh --include-underscore -o all_including_underscores.txt

  # Include dotfiles as well (override default ignore of .* files)
  ./concat-files2.sh --include-dotfiles -o all_including_dotfiles.txt

  # Filter to a specific glob (e.g., only .sc files)
  ./concat-files2.sh -p '*.sc' -o sc_all.txt
EOF
}

# --- Defaults ---
pattern='*'       # match ALL files by default
out=''
mode='header'     # 'header' or 'tsv'
absolute=0
no_sort=0
ignore_underscore=1   # default: ignore _* directories
ignore_dotfiles=1     # default: ignore files whose basenames start with '.'

# Default excludes (directory names, matched anywhere in the tree)
excludes=( ".git" "node_modules" )

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--pattern)
      [[ $# -ge 2 ]] || { echo "Error: -p|--pattern requires a value" >&2; exit 2; }
      pattern=$2; shift 2;;
    -o|--out)
      [[ $# -ge 2 ]] || { echo "Error: -o|--out requires a value" >&2; exit 2; }
      out=$2; shift 2;;
    -x|--exclude)
      [[ $# -ge 2 ]] || { echo "Error: -x|--exclude requires a value" >&2; exit 2; }
      excludes+=("$2"); shift 2;;
    --mode)
      [[ $# -ge 2 ]] || { echo "Error: --mode requires a value" >&2; exit 2; }
      case "$2" in header|tsv) mode=$2;; *) echo "Error: --mode must be 'header' or 'tsv'." >&2; exit 2;; esac
      shift 2;;
    --absolute)
      absolute=1; shift;;
    --no-sort)
      no_sort=1; shift;;
    --include-underscore)
      ignore_underscore=0; shift;;
    --include-dotfiles)
      ignore_dotfiles=0; shift;;
    -h|--help)
      print_help; exit 0;;
    *)
      echo "Unknown option: $1" >&2; print_help; exit 2;;
  esac
done

# Add the "_*" ignore (underscore-prefixed directories) unless overridden
if [[ $ignore_underscore -eq 1 ]]; then
  excludes+=("_*")
fi

# Compute absolute path of output (if any)
out_abs=""
out_rel_in_tree=""
if [[ -n "$out" ]]; then
  case "$out" in
    /*) out_abs="$out";;
    *)  out_abs="$PWD/$out";;
  esac
  # If the output path sits under $PWD, compute a "./relative" path for find -path pruning
  if [[ "${out_abs#$PWD/}" != "$out_abs" ]]; then
    out_rel_in_tree="./${out_abs#$PWD/}"
  fi
fi

# Pick a NUL-safe sort if available
sort_bin=""
if [[ "$no_sort" -eq 0 ]]; then
  if command -v gsort >/dev/null 2>&1; then
    sort_bin="gsort"
  elif sort -z </dev/null >/dev/null 2>&1; then
    sort_bin="sort"
  else
    echo "Note: No NUL-safe sort ('gsort' or 'sort -z') available; output not sorted." >&2
  fi
fi

# Build the find(1) command with explicit prunes and NUL-separated output.
# Structure:
#   find . \
#     \( -type d \( -name ex1 -o -name ex2 ... \) -prune \
#        -o -path "./rel/out.txt" -prune \
#        -o -type f -name "$pattern" [ -not -name '.*' ] -print0 \)
find_cmd=(find .)
find_cmd+=( '(' )
if [[ "${#excludes[@]}" -gt 0 ]]; then
  find_cmd+=(-type d '(')
  first=1
  for ex in "${excludes[@]}"; do
    if [[ $first -eq 1 ]]; then
      find_cmd+=(-name "$ex")
      first=0
    else
      find_cmd+=(-o -name "$ex")
    fi
  done
  find_cmd+=(')' -prune)
fi

# Prune the output file itself if it's inside the tree
if [[ -n "$out_rel_in_tree" ]]; then
  if [[ "${#excludes[@]}" -gt 0 ]]; then
    find_cmd+=( -o )
  fi
  find_cmd+=( -path "$out_rel_in_tree" -prune )
fi

# File match branch
if [[ "${#excludes[@]}" -gt 0 || -n "$out_rel_in_tree" ]]; then
  find_cmd+=( -o )
fi
find_cmd+=( -type f -name "$pattern" )
if [[ $ignore_dotfiles -eq 1 ]]; then
  find_cmd+=( -not -name '.*' )
fi
find_cmd+=( -print0 ')' )

# Function to emit the NUL-separated file list (optionally sorted)
find_out_stream() {
  if [[ -n "$sort_bin" ]]; then
    "${find_cmd[@]}" | "$sort_bin" -z
  else
    "${find_cmd[@]}"
  fi
}

# Choose output destination:
# - If -o is given: write to a temp file outside the tree, then move to final path.
# - If no -o: write to stdout (NOTE: avoid shell redirection to a file inside the tree).
tmp_out=""
redirect_target="/dev/stdout"
if [[ -n "$out" ]]; then
  tmp_out="$(mktemp "${TMPDIR:-/tmp}/concat-files2.XXXXXXXX")"
  redirect_target="$tmp_out"
fi

# Stream NUL-terminated file names and format output
{
  find_out_stream
} | while IFS= read -r -d $'\0' f; do
  # Normalize absolute path for comparison and optional display
  file_abs="$PWD/${f#./}"

  # Extra guard: skip the final output path if seen (double-protection)
  if [[ -n "$out_abs" && -e "$out_abs" && "$file_abs" -ef "$out_abs" ]]; then
    continue
  fi

  if [[ $absolute -eq 1 ]]; then
    display_path="$file_abs"
  else
    display_path="${f#./}"
  fi

  if [[ "$mode" == "tsv" ]]; then
    # One line per file: <path>\t<content with newlines collapsed>
    printf '%s\t' "$display_path"
    tr '\n' ' ' < "$f" | sed -E 's/[[:space:]]+$//'
    printf '\n'
  else
    # Header banner + full content + blank line
    printf '===== %s =====\n' "$display_path"
    cat -- "$f"
    printf '\n'
  fi
done > "$redirect_target"

# Finalize: if using -o, move the temp file into place
if [[ -n "$out" ]]; then
  mv -f -- "$tmp_out" "$out"
fi

===== Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd =====
// Sim_MIDIInput_Emulator_For_TreeNav.scd
// v0.1.2
// MD 20250924-1510
/*
Purpose
- Emulate hardware control of your system:
  ‚Ä¢ FOOT controller: mode changes (idle/prog/queue/send).
  ‚Ä¢ MIDI GUITAR: string/fret ‚Üí channel/pitch ‚Üí tree navigation.
- Keep everything in ONE file; evaluate section-by-section.

Style
- var-first in every block/closure; lowercase methods; no server.sync.
- Works with your current LivePedalboardSystem, CommandManager, and adapter bridge.
- Generated audio only (no SoundIn); Option A exclusivity remains enforced by your bring-up.
*/

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [0] Bring-up (idempotent): system + GUI + MagicPedalboard + adapter bridge
//    Evaluate once after a fresh compile (or re-run to refresh).
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var needNew, systemRef;

// If an older system exists, shut it down cleanly.
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) {
    ~system.shutdownAll;
};

// Create (or reuse) the LivePedalboardSystem and bring everything up.
needNew = (~system.isNil);
if(needNew) {
    systemRef = LivePedalboardSystem.new(nil); // nil ‚Üí class default JSON path resolver
    ~system = systemRef;
};

~system.bringUpAll;          // server + GUI + pedalboard + command system + meters
~system.installAdapterBridge; // queueExportCallback routes SHORT canonicals to MPB via adapter

// Convenience handles
~cm  = ~system.commandManager;
~mm  = ~cm.midiManager;
~mpb = ~system.pedalboard;
~gui = ~system.statusDisplay;

"‚úÖ System is up. (~system, ~cm, ~mm, ~mpb, ~gui)".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [1] Emulation helpers (define once)
//    These call your actual handlers‚Äîno MIDI devices required.
//    FOOT MAPPING (noteOn): 36‚Üí\idle, 38‚Üí\prog, 40‚Üí\queue, 41‚Üí\send
//    GUITAR MAPPING (channels 0..5 ‚Üí strings 6..1) with bases [40,45,50,55,59,64]
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var ensure, bases;

// Basic guard so we don't call handlers before bring-up.
ensure = {
    var ok;
    ok = ~system.notNil
     and: { ~system.commandManager.notNil }
     and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run section [0] (bring-up) first.".warn };
    ok
};

// E A D G B E (low‚Üíhigh), per your GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40,  // chan 0 ‚Üí string 6 (E2)
    1 -> 45,  // chan 1 ‚Üí string 5 (A2)
    2 -> 50,  // chan 2 ‚Üí string 4 (D3)
    3 -> 55,  // chan 3 ‚Üí string 3 (G3)
    4 -> 59,  // chan 4 ‚Üí string 2 (B3)
    5 -> 64   // chan 5 ‚Üí string 1 (E4)
];

// FOOT: emulate pressing a foot button (note number).
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    // channel is irrelevant for FootControllerHandler; value = note number.
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);
};

// Foot shortcuts
~toIdle  = { ~fc.(36) };  // idle
~toProg  = { ~fc.(38) };  // prog (tree navigation)
~toQueue = { ~fc.(40) };  // queue (enqueue current canonical)
~toSend  = { ~fc.(41) };  // send  (export & apply queue via bridge)

// GUITAR: emulate ‚Äúplay fret‚Äù on given string (1..6).
// Computes channel = 6 - string, pitch = base + fret; calls your GuitarMIDIHandler.
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "‚ö†Ô∏è Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Convenience alias for navigation (string,fret)
~nav = { arg s, f; ~gm.(s, f) };

// Peek: print the builder‚Äôs path and the canonical short form (e.g., "/add/delay").
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);
    ("‚Ä¢ long=" ++ long ++ "  |  canonical=" ++ short).postln;
};

// Optional: show available choices in GUI (if present)
~refreshChoices = {
    if(~system.notNil) { ~system.commandManager.updateDisplay };
};
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [2] Scenario A ‚Äî Add delay to NEXT via guitar nav, then switch
//    Top-level/children/grandchildren frets per your mapping:
//    string 6 fret 1 ‚Üí "audio", string 5 fret 5 ‚Üí "timebased", string 4 fret 3 ‚Üí "delay"
//    Then queue (note 40) and send (note 41) ‚Üí adapter applies "/add/delay"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();           // enter navigation mode
~refreshChoices.();   // optional UI refresh
~nav.(6, 1);          // 6/1 ‚Üí audio
~nav.(5, 5);          // 5/5 ‚Üí timebased
~nav.(4, 3);          // 4/3 ‚Üí delay
~showNav.();          // should report canonical "/add/delay"
~toQueue.();          // enqueue
~toSend.();           // apply via adapter
done = true;
"‚úÖ Scenario A complete (add delay, then you can use Scenario B to switch).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [3] Scenario B ‚Äî Switch chain from top-level ‚Äúswitch‚Äù
//    string 6 fret 5 ‚Üí "switch" ‚Üí queue ‚Üí send
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 5);      // top-level "switch"
~showNav.();      // should be "/switch"
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario B complete (switch with guarded crossfade).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [4] Scenario C ‚Äî Bypass: chain ‚Üí bypass ‚Üí delay ‚Üí on
//    Adjust frets if your JSON uses slightly different grandchildren numbers.
//    Example: 6/3="chain", 5/9="bypass", 4/3="delay", 3/3="on"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 3);   // "chain"
~nav.(5, 9);   // "bypass"
~nav.(4, 3);   // "delay"
~nav.(3, 3);   // "on"    // change to actual fret if needed
~showNav.();
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario C complete (bypass delay ON).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [5] Quick extras
//    ‚Ä¢ Re-run [2] then [3] to hear the effect.
//    ‚Ä¢ To bypass OFF, redo [4] but pick ‚Äú‚Ä¶/off‚Äù as per your tree‚Äôs leaf fret.
//    ‚Ä¢ Inspect the current queue at any time:
//        ~system.commandManager.midiManager.queue.commandList.postln;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

===== index_vsc_entrypoints.scd =====
// index_vsc_entrypoints.scd
// Project Entry Points Index for LivePedalboardSuite
//
// This file lists the main entry points (scripts, bring-up routines, test harnesses, and editors)
// for all major components in the project. Use this as a reference for launching, testing, or exploring the system.
//
// -----------------------------------------------------------------------------
// System Bring-Up & Main Launchers
// -----------------------------------------------------------------------------
"LivePedalboardSystem/Start_LivePedalboardSystem.scd"      // Main system bring-up (Option B)
"MagicPedalboard/MagicPedalboardNew.scd"                   // Main pedalboard engine
"MagicPedalboardTestRunner.sc"                             // Test/bring-up runner

// -----------------------------------------------------------------------------
// CommandTree System: Editors, Tests, Utilities
// -----------------------------------------------------------------------------
"CommandTree/martinTreeEditor.scd"                         // Interactive tree editor (load, add, remove, save nodes)
"CommandTree/MDCommandSystemTest20250804.scd"              // CommandTree structure and navigation test
"CommandTree/MDCommandSystemTest20250812.scd"              // CommandTree structure and navigation test (string+fret)
"CommandTree/MDCommandBuilderTest.scd"                     // CommandBuilder navigation and queue test

// -----------------------------------------------------------------------------
// Utilities & Simulations
// -----------------------------------------------------------------------------
"utilities/Simulate_CommandTree_Queue_AddDelay.scd"        // Simulate queueing "/add/delay" via CommandTree
"utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd"   // Stepwise navigation and queueing
"utilities/Queue_AddDelay_DirectCanonical.scd"             // Direct canonical command queueing
"utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd"       // Inspect tree and auto-route add/delay

// -----------------------------------------------------------------------------
// MagicPedalboard Troubleshooting & Demos
// -----------------------------------------------------------------------------
"MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd" // GUI, server, probe bring-up
"MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd" // Server/meter bring-up

// -----------------------------------------------------------------------------
// Test Harnesses & Acceptance Suites
// -----------------------------------------------------------------------------
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd" // Health check script
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd"       // One-go acceptance suite

// -----------------------------------------------------------------------------
// Miscellaneous & Example Scripts
// -----------------------------------------------------------------------------
"test 31tp8ve.scd"                                        // 31-tone scale test script

// -----------------------------------------------------------------------------
// Notes
// -----------------------------------------------------------------------------
// - For each entry, evaluate the file in VS Code to launch or test the corresponding component.
// - Most scripts assume you have run the main bring-up (Start_LivePedalboardSystem.scd) first.
// - See README.md and LivePedalboardSystem_README.md for further documentation and workflow details.
===== LivePedalboardSystem/CommandTreeStructure.xml =====
<commands>
  <audio>
    <source>
      <testmelody/>
      <sine/>
      <noise/>
      <!-- Add more sources as needed -->
    </source>
    <timebased>
      <delay>
        <multitap/>
        <pingpong/>
        <!-- More delay types -->
      </delay>
      <chorus/>
    </timebased>
    <modulation>
      <tremolo/>
      <phaser/>
      <flanger/>
    </modulation>
    <dynamics>
      <compressor/>
      <limiter/>
    </dynamics>
    <filter>
      <lowpass/>
      <highpass/>
      <bandpass/>
    </filter>
    <reverb/>
    <drive/>
  </audio>
  <chain>
    <addprocessor/>
    <removeprocessor/>
    <swapprocessors/>
    <bypassprocessor/>
    <clearchain/>
    <setsource/>
    <printchains/>
  </chain>
  <switch>
    <crossfade/>
    <crossfade_customtime/>
  </switch>
  <preset>
    <savepreset/>
    <loadpreset/>
  </preset>
  <system>
    <reset/>
    <healthcheck/>
    <showstatus/>
  </system>
</commands>

===== LivePedalboardSystem/CommandTreeStructureDiagram.scd =====
// updated 20250922-2147

root
‚îú‚îÄ‚îÄ audio (string 6, fret 1)
‚îÇ   ‚îú‚îÄ‚îÄ source      (string 5, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ testmelody (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sine       (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ noise      (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ timebased   (string 5, fret 5)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delay     (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ multitap  (string 3, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pingpong  (string 3, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chorus    (string 4, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ modulation (string 5, fret 7)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tremolo   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phaser    (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ flanger   (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ filter (string 5, fret 9)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lowpass   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ highpass  (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bandpass  (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ reverb (string 5, fret 11)
‚îÇ   ‚îî‚îÄ‚îÄ drive  (string 5, fret 13)

‚îú‚îÄ‚îÄ chain (string 6, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ add         (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ remove      (string 5, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ swap        (string 5, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ bypass      (string 5, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ clear       (string 5, fret 11)
‚îÇ   ‚îú‚îÄ‚îÄ setsource   (string 5, fret 13)
‚îÇ   ‚îî‚îÄ‚îÄ print       (string 5, fret 15)

‚îú‚îÄ‚îÄ switch (string 6, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ crossfade         (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ crossfade_custom  (string 5, fret 5)

‚îú‚îÄ‚îÄ preset (string 6, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ save        (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ load        (string 5, fret 5)

‚îú‚îÄ‚îÄ system (string 6, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ reset       (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ healthcheck (string 5, fret 5)
‚îÇ   ‚îî‚îÄ‚îÄ status      (string 5, fret 7)
===== LivePedalboardSystem/DevelopmentPlan_20250922.md =====

# DevelopmentPlan_20250922

**Project:** MagicPedalboardNew + CommandTree Integration  
**Date:** 2025-09-22

---

## Overview

- MagicPedalboardNew is a JITLib-based SuperCollider pedalboard system with A/B chains, managed by Ndefs and a processor registry.
- CommandTree is a hierarchical command system navigated by a hexaphonic guitar (one string per MIDI channel), allowing the performer to select commands by playing specific frets/strings.
- The system is designed for robust, testable, and modular live performance control.

---

## Current Canonical Files and Classes

- **Main pedalboard:** `MagicPedalboardNew.sc`
- **Processor registry:** `MagicProcessorLibrary.sc` and `MagicProcessorLibrary_defs.scd`
- **Test/bring-up runner:** `MagicPedalboardTestRunner.sc`
- **GUI/console display:** `MagicDisplay.sc`, `MagicDisplayGUI.sc`, `MagicDisplayGUI_GridDemo.sc`, `MagicDisplayGUI_Ext_VisualOnly.sc`
- **CommandTree system:**  
  `CommandManager.sc`, `MDCommandTree.sc`, `MDCommandNode.sc`, `MDCommandBuilder.sc`, `MDCommandQueue.sc`,  
  `MIDIInputManager.sc`, `GuitarMIDIHandler.sc`, `FootControllerHandler.sc`, `LaunchpadHandler.sc`, `UserDisplay.sc`

---

## Versioning and File Policy

- No more v3/v5/v6 in file names. Version numbers are kept in file/class headers only.
- Legacy/obsolete/old/shelved folders are left in place but not referenced by current code or documentation.
- When the project is finalized, all main files will be bumped to version 1.x and filenames cleaned up.

---

## CommandTree to Pedalboard Integration

- **Navigation:** Guitar MIDI input (one string per channel) is used to traverse the command tree. Each string/fret selects a branch.
- Navigation is managed by `MDCommandBuilder`, which tracks the current node and fret path.
- When navigation is complete (all strings traversed or user triggers completion), the payload at the reached node is enqueued in `MDCommandQueue`.
- In `queue` mode, the payload is added to the queue. In `send` mode, the queue is exported as an OSC path (e.g., `/add/delay`) and cleared.
- The exported OSC path is sent to the pedalboard adapter (e.g., `~ct_sendAndApply`).
- Partial queues (not at a leaf) may be valid and sent, e.g., `/audio/time-based/delay` as a generic command, or `/audio/time-based/delay/multi-tap` as a specific one.

---

## Integration Points and APIs

- **CommandManager**
    - `.queue` (`MDCommandQueue`): holds commands to send
    - `.builder` (`MDCommandBuilder`): manages navigation
    - `.midiManager` (`MIDIInputManager`): handles MIDI input and mode switching
    - `.setStatus(text)`: updates status in the display

- **MDCommandQueue**
    - `.enqueueCommand(payload)`: add a command
    - `.exportAsOSCPath`: returns a string like `/add/delay`
    - `.clearQueue`: empties the queue

- **MDCommandBuilder**
    - `.isAtLeaf`: true if navigation is at a leaf node
    - `.getCurrentPayload`: returns the payload at the current node

- **MIDIInputManager**
    - `.setMode(modeSymbol)`: changes mode (`prog`, `queue`, `send`, etc.)
    - `.handleModeChange(modeSymbol)`: triggers navigation, queueing, or sending

- **UserDisplay**
    - `.setStatus(text)`: updates status in the display
    - `.updateTextField(box, msg)`: updates specific display fields

---

## Navigation Completion and Sending

- Navigation is complete when all required strings have been played or the user triggers completion (e.g., via foot controller).
- Success is typically reaching a leaf node (`builder.isAtLeaf`), but partial queues are also valid in some cases.
- The pedalboard adapter should be called when the CommandTree is in `send` mode and the queue is exported.
- The actual call to the pedalboard adapter can be done immediately or scheduled on AppClock for thread safety.

---

## Clock Context

- Navigation and queueing: MIDI input and navigation are handled in real time (MIDI callbacks), but UI updates are deferred to AppClock.
- Sending to pedalboard: The call to the pedalboard adapter can be immediate or scheduled on AppClock.

---

## Device and Mode Routing

- Devices are mapped by symbolic names to source IDs in `MIDIInputManager`.
- Handlers are bound per device (guitar, foot controller, launchpad, etc.).
- Modes:  
  - `prog` (navigation)  
  - `queue` (add payload to queue)  
  - `send` (send queue to pedalboard)

---

## Status Callbacks for Display

- `CommandManager.setStatus(text)`: updates the status field in the display.
- Display fields: `modeText`, `queueText`, `lastCommandText`, `userChoicesText`, `statusText`.
- At every step of navigation, available commands or branches should be shown in the display.

---

## Open Questions / To Be Finalized

1. Pedalboard should be called when CommandTree is in `send` mode and the queue is exported (confirmed).
2. Whether to call the pedalboard adapter synchronously or always on AppClock is still open; use whichever is simplest and most robust.
3. Status updates for MagicDisplay/MagicDisplayGUI HUD: eventually needed, but for now, focus on showing available commands/branches at each navigation step.
4. Partial queues are valid and may be sent, not just at leaf nodes.

---

## Next Steps

- Proceed with Phase 1 cleanup and README updates.
- Prepare Phase 2 logger integration patch and test script.
- Prepare Phase 3 CommandTree-to-pedalboard glue code and headless test script.

---

**End of DevelopmentPlan_20250922**

===== LivePedalboardSystem/LivePedalboardSystem_README.md =====

# LivePedalboardSystem

## Overview
This system integrates the MagicPedalboard audio engine with a hierarchical CommandTree navigated via MIDI guitar input. It is designed for live performance, modular control, and real-time feedback.

## Purpose
The `LivePedalboardSystem` class coordinates the bring-up of:
- MagicPedalboard (audio engine and GUI)
- CommandTree (navigation and command queue)
- MIDI input routing
- Tree loading from JSON

## Directory Structure
```
MDClasses/
  LivePedalboardSystem/
    LivePedalboardSystem.sc         # Main integration class
    Start_LivePedalboardSystem.scd  # Launcher script
    MagicPedalboardCommandTree.json # Command tree definition
```

## Bring-Up Sequence
1. **Initialize MagicPedalboard**
   - Boot server
   - Create pedalboard and GUI/test runner

2. **Load CommandTree**
   - Load `MagicPedalboardCommandTree.json`
   - Build tree structure in memory

3. **Set Up MIDI Input**
   - Initialize MIDI manager
   - Bind guitar and foot controller devices

4. **Connect Tree to Pedalboard**
   - Route queued commands to pedalboard adapter

5. **Enable Feedback Display**
   - Show navigation state, queue, and status

## Class Responsibilities
### `LivePedalboardSystem`
- `.bringUpAll` ‚Äî Initializes all subsystems
- `.shutdownAll` ‚Äî Graceful shutdown (optional)
- `.reloadTree` ‚Äî Reloads tree from JSON
- `.showStatus` ‚Äî Posts current system state

## Launcher Script
Example: `Start_LivePedalboardSystem.scd`
```supercollider
(
~system = LivePedalboardSystem.new;
~system.bringUpAll;
)
```

## Notes
- Tree file uses preferred frets: 1, 3, 5, 7, 9
- Payloads are OSC-style paths usable by MagicPedalboard
- Class name can be changed later (e.g. `MDPerformanceSystem`)

## Next Steps
- Implement `LivePedalboardSystem.sc` class
- Test launcher script
- Confirm MIDI routing and pedalboard command execution


===== LivePedalboardSystem/LivePedalboardSystem-AdapterBridge.sc =====
// LivePedalboardSystem-AdapterBridge.sc
// v0.1.1
// MD 2025-09-26 15:22 BST

/* Purpose
   Install a queueExportCallback that routes SHORT canonical commands
   (e.g., "/add/delay") through your adapter (~ct_applyOSCPathToMPB),
   so they apply to MagicPedalboardNew safely.
   Additionally, if the path starts with "/switch", toggle the HUD's
   current-chain flag so the ACTIVE tint stays solid (no pulsing).

   Style
   - var-first; descriptive variable names; no server.sync; no non-local '^'.
   - Safe no-op if adapter or references are missing.
*/

+ LivePedalboardSystem {

  installAdapterBridge {
    var commandManager, pedalboardRef, statusDisplayRef;
    var adapterAvailable, adapterPath;

    commandManager    = this.commandManager;
    pedalboardRef     = this.pedalboard;
    statusDisplayRef  = this.statusDisplay;

    if(commandManager.isNil or: { pedalboardRef.isNil }) {
      "[LPS] installAdapterBridge: commandManager or pedalboard is nil; skipping.".warn;
      ^this;
    };

    // Ensure the adapter function is available
    adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
    if(adapterAvailable.not) {
      adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
      if(File.exists(adapterPath)) {
        adapterPath.load;
        adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      };
    };

    if(adapterAvailable.not) {
      "[LPS] installAdapterBridge: adapter not found; keep existing queueExportCallback.".warn;
      ^this;
    };

    // Bridge: every queued canonical path is applied via the adapter
    commandManager.queueExportCallback = { |canonicalPathString|
      var pathString, isSwitchPath;

      pathString = canonicalPathString.asString;
      ~ct_applyOSCPathToMPB.(pathString, pedalboardRef, statusDisplayRef);

      // ACTIVE chain rule: if the canonical path starts with "/switch", toggle A/B
      // Known-good assumption: "/switch" is a toggle between A and B.
      isSwitchPath = pathString.beginsWith("/switch");
      if(isSwitchPath) {
        // Use the tiny helper defined in MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd
        if(~md_toggleCurrentChain.isKindOf(Function)) {
          ~md_toggleCurrentChain.();
        }{
          // Fallback: initialize to A if helper is missing
          ~md_currentChain = ~md_currentChain ? \A;
          ~md_currentChain = (~md_currentChain == \A).if({ \B }, { \A });
        };
        ("[LPS] ACTIVE chain toggled to " ++ (~md_currentChain ? \A).asString).postln;
      };

      nil  // explicit nil return, no non-local '^'
    };

    "[LPS] installAdapterBridge: adapter bridge active.".postln;
    ^this
  }

}

===== LivePedalboardSystem/LivePedalboardSystem-AdapterBridge.sc.bak =====
// LivePedalboardSystem-AdapterBridge.sc
// v0.1.0
// MD 20250923-1324

/* Purpose
   Install a queueExportCallback that routes SHORT canonical commands
   (e.g., "/add/delay") through your adapter (~ct_applyOSCPathToMPB),
   so they apply to MagicPedalboardNew safely.

   Style
   - var-first; descriptive variable names; no server.sync.
   - Class extension only; safe no-op if adapter or references are missing.
*/

+ LivePedalboardSystem {

  installAdapterBridge {
    var commandManager, pedalboardRef, statusDisplayRef;
    var adapterAvailable, adapterPath;

    commandManager    = this.commandManager;
    pedalboardRef     = this.pedalboard;
    statusDisplayRef  = this.statusDisplay;

    if(commandManager.isNil or: { pedalboardRef.isNil }) {
      "[LPS] installAdapterBridge: commandManager or pedalboard is nil; skipping.".warn;
      ^this;
    };

    // Ensure the adapter function is available
    adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
    if(adapterAvailable.not) {
      adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
      if(File.exists(adapterPath)) {
        adapterPath.load;
        adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      };
    };

    if(adapterAvailable.not) {
      "[LPS] installAdapterBridge: adapter not found; keep existing queueExportCallback.".warn;
      ^this;
    };

    // Bridge: every queued canonical path is applied via the adapter
    commandManager.queueExportCallback = { |canonicalPathString|
      ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
    };

    "[LPS] installAdapterBridge: adapter bridge active.".postln;
    ^this;
  }

}


===== LivePedalboardSystem/LivePedalboardSystem-AutoMeters.sc =====
// LivePedalboardSystem-AutoMeters.sc
// v0.2.0
// MD 20250924-1905

/*
Purpose
- Make meters "just work":
  1) Install inline amplitude taps on sink proxies Ndef(\chainA) and Ndef(\chainB).
     These taps send /ampA and /ampB directly from the actual sink audio.
  2) Auto-reinstall taps after every "/switch" (post crossfade & audit).
  3) Re-arm GUI meter responders and repaint chains.

Style
- Class extension only; var-first; lowercase; no server.sync.
- Server ops in Server.default.bind; GUI ops via AppClock.sched.
*/

+ LivePedalboardSystem {

    enableAutoMeters { arg rate = 18, postSwitchDelay = 0.35;
        var installTaps, rearmGui, wrapAdapter;

        installTaps = {
            Server.default.bind({
                [\chainA, \chainB].do({ arg key, index;
                    var addr;
                    addr = (index == 0).if({ '/ampA' }, { '/ampB' });
                    Ndef(key).filter(\ampTap, { arg in;
                        var sig, aL, aR, r;
                        sig = in.isArray.if({ in }, { [in, in] }); // mono-safe
                        r   = rate.clip(1, 60);
                        aL  = Amplitude.kr(sig[0]).clip(0, 1);
                        aR  = Amplitude.kr(sig[1]).clip(0, 1);
                        SendReply.kr(Impulse.kr(r), addr, [aL, aR]);
                        in // pass-through
                    });
                });
            });
        };

        rearmGui = {
            AppClock.sched(0.05, {
                var g, p;
                g = this.statusDisplay;
                p = this.pedalboard;
                if(g.notNil and: { g.respondsTo(\enableMeters) }) {
                    g.enableMeters(false);
                    g.enableMeters(true);
                };
                if(p.notNil and: { p.respondsTo(\printChains) }) {
                    p.printChains; // repaint CURRENT/NEXT panels
                };
                nil
            });
        };

        wrapAdapter = {
            // Only if adapter is present in the session (~ct_applyOSCPathToMPB)
            if(~ct_applyOSCPathToMPB.isNil) {
                "‚ö†Ô∏è [AutoMeters] adapter not loaded; run installAdapterBridge first".warn;
            }{
                // Preserve the raw adapter once
                if(~ct_applyOSCPathToMPB_raw.isNil) {
                    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
                };
                // Wrap once to reinstall taps after "/switch"
                if(~ct_applyOSCPathToMPB_withMeters.isNil) {
                    ~ct_applyOSCPathToMPB_withMeters = { arg pathString, mpb, gui;
                        var p, res;
                        p = pathString.asString;
                        res = ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
                        if(p == "/switch") {
                            AppClock.sched(postSwitchDelay, {
                                installTaps.();
                                rearmGui.();
                                nil
                            });
                        };
                        res
                    };
                    ~ct_applyOSCPathToMPB = ~ct_applyOSCPathToMPB_withMeters;
                    "[AutoMeters] post-switch reinstaller active".postln;
                };
            };
        };

        // One-shot now, and set up the post-switch hook
        installTaps.();
        rearmGui.();
        wrapAdapter.();

        "[AutoMeters] Inline taps installed (rate=%), GUI re-armed".format(rate).postln;
        ^this
    }
}

===== LivePedalboardSystem/LivePedalboardSystem-Pathing.sc =====
// LivePedalboardSystem-Pathing.sc
// v0.3.1
// MD 20250923-0959

/*
Purpose
- Make LivePedalboardSystem default to a JSON tree INSIDE the repo so a fresh clone runs.
- Allow optional, per-user overrides in Extensions/MDclasses or UserState.
- Preserve explicit constructor path as the highest priority.

Style
- var-first; lowercase method names; no server.sync.
- Class extension only; pure path logic here.
*/

+ LivePedalboardSystem {

    // 1) Repo default (shipped in Git)
    *defaultTreePath {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 2) Optional per-user override in MDclasses (not in Git)
    *userOverrideMDclasses {
        ^Platform.userExtensionDir
        ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 3) Optional per-user override alongside the code (normally .gitignored)
    *userOverrideUserState {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";
    }

  *resolveTreePath { arg maybePath;
    var candidateUserState, candidateRepoDefault, candidateMdLegacy, resolvedPath;

    // 0) explicit path (caller responsibility)
    resolvedPath = maybePath;
    if (resolvedPath.notNil) { ^resolvedPath };

    // 1) per-user override alongside the code (usually .gitignored)
    candidateUserState   = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";

    // 2) repo default (shipped in Git / symlinked into Extensions)
    candidateRepoDefault = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    // 3) legacy (deprecated) MDclasses location
    candidateMdLegacy    = Platform.userExtensionDir
      ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    if (File.exists(candidateUserState))   { ^candidateUserState };
    if (File.exists(candidateRepoDefault)) { ^candidateRepoDefault };
    if (File.exists(candidateMdLegacy)) {
      MDMiniLogger.get.warn("Pathing",
        "[deprecated] Using MDclasses copy: " ++ candidateMdLegacy);
      ^candidateMdLegacy
    };

    // Last resort: return repoDefault even if missing; importer will warn gracefully.
    ^candidateRepoDefault;
  }

}

===== LivePedalboardSystem/LivePedalboardSystem-Taps_Isolated.sc_OBSOLETE =====
// LivePedalboardSystem-Taps_Isolated.sc
// v0.1.0 (isolated GUI taps: /md/levels_gui)
// MD 2025-09-26 16:10 BST

/* Purpose
   Install stable, sanitised, smoothed, log-like visual taps that send to a
   dedicated address "/md/levels_gui" with unique reply IDs:
     GA=32001, GB=32002, GT=31001
   - Unique filter keys: \mdGuiTapA, \mdGuiTapB, \mdGuiTapT (won‚Äôt clash).
   - Re-applies 3√ó (0.0s, 0.5s, 1.0s) to survive late re-binds.
   - Pass-through audio: always return 'in'.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

+ LivePedalboardSystem {

    installGuiMeters {
        var rateHz, rateClamped, applyOnce, passIndex, passCount;
        var atk, rel, floorAmp, oscPath;
        var idA, idB, idT;

        rateHz      = 24;
        rateClamped = rateHz.asInteger.clip(1, 60);
        atk = 0.01; rel = 0.20; floorAmp = 1e-5;
        oscPath = "/md/levels_gui";
        idA = 32001; idB = 32002; idT = 31001;

        passIndex = 0; passCount = 3;

        applyOnce = {
            Server.default.bind({

                // ----- A -----
                Ndef(\chainA).filter(\mdGuiTapA, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idA);
                    in
                });

                // ----- B -----
                Ndef(\chainB).filter(\mdGuiTapB, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idB);
                    in
                });

                // ----- Test probe -----
                Ndef(\testmelody).filter(\mdGuiTapT, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idT);
                    in
                });

            });
        };

        // Apply now, then again at 0.5s and 1.0s (survive late re-binds)
        AppClock.sched(0.00, { applyOnce.(); 0.50 });
        AppClock.sched(0.50, { applyOnce.(); 0.50 });
        AppClock.sched(1.00, { applyOnce.(); "[LPS] GUI taps active (/md/levels_gui).".postln; nil });

        this
    }

}

===== LivePedalboardSystem/LivePedalboardSystem-Taps_Stable.sc_OBSOLETE =====
// LivePedalboardSystem-Taps_Stable.sc
// v0.1.2 (sanitised + smoothed + boosted)
// MD 2025-09-26 15:58 BST

/* Purpose
   Install stable, visual-scale taps under unique keys, with NaN/Inf sanitised,
   light smoothing, and a more sensitive floor so meters are visibly responsive.
   - Unique keys: \mdVisTapA, \mdVisTapB, \mdVisTapT (won‚Äôt clash with re-installers).
   - Re-applies 3x (0.0s, 0.5s, 1.0s) to outlast late bindings.
   - Pass-through audio: always return 'in'.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync; no non-local '^'.
*/

+ LivePedalboardSystem {

    installStableMeters {
        var rateHz, rateClamped, applyOnce, passIndex, passCount;
        var atk, rel, floorAmp;

        rateHz     = 24;        // slightly faster UI feel
        rateClamped = rateHz.asInteger.clip(1, 60);
        passIndex  = 0; passCount = 3;

        // meter behaviour
        atk = 0.01;             // Amplitude attack
        rel = 0.20;             // Amplitude release
        floorAmp = 1e-5;        // more sensitive floor than 1e-6

        applyOnce = {
            Server.default.bind({

                // ----- CHAIN A -> replyID 2001 -----
                Ndef(\chainA).filter(\mdVisTapA, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    // Log-like visual map + light smoothing (no audio change)
                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    // Sanitize: replace any NaN/Inf with 0 (quietly)
                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 2001);
                    in
                });

                // ----- CHAIN B -> replyID 2002 -----
                Ndef(\chainB).filter(\mdVisTapB, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 2002);
                    in
                });

                // ----- TEST PROBE -> replyID 1001 -----
                Ndef(\testmelody).filter(\mdVisTapT, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 1001);
                    in
                });

            });
        };

        // Apply now, then again at 0.5s and 1.0s to survive late re-binds
        AppClock.sched(0.00, { applyOnce.(); passIndex = passIndex + 1; 0.50 });
        AppClock.sched(0.50, { applyOnce.(); passIndex = passIndex + 1; 0.50 });
        AppClock.sched(1.00, { applyOnce.(); "[LPS] stable taps active (sanitised+smoothed).".postln; nil });

        this
    }

}

===== LivePedalboardSystem/LivePedalboardSystem-UsePerfHUD.sc_OBSOLETE =====
// LivePedalboardSystem-UsePerfHUD.sc
// v0.1.7
// MD 2025-09-26 15:38 BST

/* Purpose / Style
   PerfHUD v0.5.4 bring-up + robust meters (listener + stable taps).
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

+ LivePedalboardSystem {

    bringUpMagicDisplayGUI {
        var baseTroubleshooting, perfHudPath, perfExists, windowsList, pickedWindow;

        baseTroubleshooting = (Platform.userExtensionDir
            ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting").standardizePath;
        perfHudPath = (baseTroubleshooting
            ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd").standardizePath;
        perfExists = File.exists(perfHudPath);

        this.closeExistingMagicDisplayWindows;

        if(perfExists) { perfHudPath.load } { statusDisplay = MagicDisplayGUI_GridDemo.new };

        // sources/sinks
        Server.default.bind({
            if(Ndef(\testmelody).source.isNil) {
                Ndef(\testmelody, {
                    var trig, freq, env, pan, scale, indexSel;
                    trig = Impulse.kr(2.2);
                    scale = [60, 62, 64, 67, 69];
                    indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                    freq = Select.kr(indexSel, scale).midicps;
                    env = Decay2.kr(trig, 0.01, 0.40);
                    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
                });
            };
            Ndef(\testmelody).ar(2);
            if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
            Ndef(\chainA).ar(2);
            Ndef(\chainB).ar(2);
        });
        "[LPS] sources/sinks ensured.".postln;

        // /md/levels listener (HUD-side)
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;

        if(OSCdef.all.at(\md_levels_hud).notNil) { OSCdef.all.at(\md_levels_hud).free };
        OSCdef(\md_levels_hud, { arg msg;
            var replyId, leftVal, rightVal;
            if(msg.size >= 5) {
                replyId  = msg[2];
                leftVal  = msg[3].asFloat.clip(0, 1);
                rightVal = msg[4].asFloat.clip(0, 1);
                ~md_levelsById.put(replyId, [leftVal, rightVal]);
                ~md_lastMsgStamp = SystemClock.seconds.asFloat;
            };
            nil
        }, "/md/levels", recvPort: NetAddr.langPort);
        "[HUD] /md/levels listener installed (key=md_levels_hud)".postln;

        // Inline taps (visual scale)
        this.installStableMeters;
        "[LPS] inline taps armed (visual scale, A=2001, B=2002, T=1001).".postln;
//NEW
		this.installGuiMeters;  // installs isolated GUI taps -> /md/levels_gui

        // Front window & return
        windowsList = Window.allWindows;
        pickedWindow = windowsList.detect({ arg w;
            var titleString = w.tryPerform(\name);
            titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
        });
        if(pickedWindow.notNil) { pickedWindow.front };
        pickedWindow
    }
}

===== LivePedalboardSystem/LivePedalboardSystem.sc =====
// LivePedalboardSystem.sc
// v0.2.8
// MD 2025-09-22 1204

// Purpose: Bring-up MagicPedalboard + CommandManager + single MagicDisplayGUI (no duplicate windows).
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

LivePedalboardSystem : Object {
	var <>pedalboard;
	var <>pedalboardGUI;
	var <>commandManager;
	var <>statusDisplay;   // this will hold a MagicDisplayGUI
	var <>logger;
	var <>treeFilePath;

/*	*new { arg treePath;
		^super.new.init(treePath);
	}*/


	    *new { arg treePath;
        var resolvedPath;
        resolvedPath = LivePedalboardSystem.resolveTreePath(treePath);
        ^super.new.init(resolvedPath);
    }

	init { arg treePath;
		var defaultPath;
		logger = MDMiniLogger.get;

		// Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		treeFilePath = treePath.ifNil { defaultPath };
		^this;
	}


	bringUpAll {
		// ‚úÖ Make sure the server is up and the tree is clean *before* we create MPB
		this.ensureServerReady;

		this.bringUpMagicDisplayGUI;   // 1) GUI first
		this.bringUpPedalboard;        // 2) create MPB (it will create groups)
		this.bringUpCommandSystem;     // 3) hook command system
		this.ensureAudioOn;            // 4) prime sources + play current (no tree reset here)


		// meters last (you already moved this)
/*    if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
        statusDisplay.enableMeters(true);
    };*/

		//v0.2.8
		AppClock.sched(0.35, {    // 350 ms is enough to outlive the initial MPB rebuild
			if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
				statusDisplay.enableMeters(true);
			};
			nil
		});

		logger.info("LivePedalboardSystem", "‚úÖ System is ready.");
		^this;
	}


/*	bringUpPedalboard {
		pedalboard = MagicPedalboard.new;
		pedalboardGUI = MagicPedalboardTestRunner.new(pedalboard, nil);
		pedalboardGUI.bringUp;
		logger.info("Pedalboard", "Pedalboard and GUI initialized.");
	}*/

/*	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}*/

	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}

/*	bringUpCommandSystem {
		commandManager = CommandManager.new(treeFilePath);


		// inject GUI so updateDisplay() can actually update something
		commandManager.display = statusDisplay;

		// Queue export -> pedalboard
		commandManager.queueExportCallback = { |oscPath|
			pedalboard.handleCommand(oscPath);
			logger.info("Integration", "Sent command to pedalboard: " ++ oscPath);
			// If GUI is up, show last command
			if (statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
				statusDisplay.showExpectation("Sent: " ++ oscPath, 0);
			};
		};

		logger.info("CommandSystem", "CommandManager initialized and connected.");
	}*/

	//newer:
	    bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;
        // temporary callback: log only; the bridge will overwrite this
        cm.queueExportCallback = { |path|
            MDMiniLogger.get.info("Integration", "Queued path: " ++ path.asString);
        };
        commandManager = cm;
        MDMiniLogger.get.info("CommandSystem", "CommandManager initialized (bridge pending).");
        ^this
    }

	// --- Single MagicDisplayGUI window, with meters enabled ---


	bringUpMagicDisplayGUI {
		// close any previous MagicDisplayGUI windows to avoid duplicates
		this.closeExistingMagicDisplayWindows;

		statusDisplay = MagicDisplayGUI_GridDemo.new; // existing line
		statusDisplay.showExpectation("System ready.", 0);

		// share GUI with CommandManager so CommandManager:setStatus can target it
		if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };

		this.ensureMeterDefs;
		// meters are enabled later in bringUpAll to avoid node races
	}



	// --- Provide \busMeterA / \busMeterB if they don't exist yet ---
	// replaced with the below, which uses MagicDisplay meters instead:
	ensureMeterDefs {
		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
	}

	// --- Conservative "make sure something is audible" ---
/*	ensureAudioOn {
		var started;
		started = false;

		if (pedalboard.respondsTo(\start)) { pedalboard.start; started = true; }
		{ if (pedalboard.respondsTo(\play)) { pedalboard.play; started = true; } };

		if (started.not) {
			this.tryPlayNdefs([\chainA, \chainB, \testmelody]);
		};

		logger.info("Audio", "ensureAudioOn called (started: %).".format(started));
	}*/


	ensureAudioOn {
		var s;
		s = Server.default;

		// Define sources/sinks idempotently
		Server.default.bind({
			if (Ndef(\testmelody).source.isNil) {
				Ndef(\testmelody, {
					var trig = Impulse.kr(3.2);
					var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
					var f = Demand.kr(trig, 0, seq);
					var env = Decay2.kr(trig, 0.01, 0.35);
					var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
					Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
				});
			};
			Ndef(\testmelody).ar(2);

			if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
			Ndef(\ts0).ar(2);

			// Ensure sink proxies exist at audio rate; MPB wires them
			Ndef(\chainA).ar(2);
			Ndef(\chainB).ar(2);
		});

		// Route CURRENT to \testmelody + Option A
		if (pedalboard.respondsTo(\setSourceCurrent)) {
			pedalboard.setSourceCurrent(\testmelody);
		};
		if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
			pedalboard.enforceExclusiveCurrentOptionA(0.1);
		};

		// Make sure CURRENT sink is actually playing; stop the other
		if (pedalboard.respondsTo(\playCurrent)) {
			pedalboard.playCurrent;
		} {
			Server.default.bind({
				if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
				if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
			});
		};

		// One tiny deferred re-assert (survives any late rebuild)
/*		AppClock.sched(0.10, {
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
            });
        };
        nil*/


		// --- Make sure CURRENT sink is actually playing (single deferred assert) ---
		AppClock.sched(0.25, {     // allow the temp SynthDef add to complete
			if (pedalboard.respondsTo(\playCurrent)) {
				pedalboard.playCurrent;  // MPB decides which (A/B) should be audible
			} {
				Server.default.bind({
					if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
					if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
				});
			};
			nil
		});



		if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
		logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
	}


	ensureServerReady {
		var s, didBoot;

		s = Server.default;
		didBoot = false;

		if (s.serverRunning.not) {
			s.boot;
			s.waitForBoot;   // permitted in your safe-reset pattern
			didBoot = true;
		};

		if (didBoot) {
			// Only wipe the tree on fresh boot, before MPB is constructed
			Server.default.bind({
				s.initTree;
				s.defaultGroup.freeAll;
			});
		};

		^didBoot
	}


	tryPlayNdefs { arg syms;
		syms.do { arg sym;
			var nd = Ndef(sym);
			if (nd.notNil) { nd.play; };
		};
	}

	showStatus {
		logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
			pedalboard, commandManager
		));
	}

/*    shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/


	closeExistingMagicDisplayWindows {
		var wins;
		wins = Window.allWindows.select({ |w|
			var nm = w.tryPerform(\name);
			nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
		});
		AppClock.sched(0.0, {
			wins.do({ |w| w.close });
			nil
		});
		^this
	}



	shutdownAll {
		var runnerClosed;

		runnerClosed = false;

		if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
			pedalboard.free;
		};

		if (pedalboardGUI.notNil) {
			if (pedalboardGUI.respondsTo(\close)) {
				pedalboardGUI.close; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
				pedalboardGUI.stop; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
				pedalboardGUI.free; runnerClosed = true;
			};
		};

		if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
			statusDisplay.close;
		};

		logger.warn("Shutdown", "LivePedalboardSystem shut down.");
	}
}

===== LivePedalboardSystem/LPS_CommandQueueToMPB_Adapter.sc_disabled =====
// LPS_CommandQueueToMPB_Adapter.sc
// v0.1.3
// MD 2025-09-22 23:08 BST

/* Purpose
   - Canonicalize CommandManager's exported path to short verb/object grammar
     for MagicPedalboardNew today.
   Examples:
     "/chain/add/audio/timebased/delay"    -> "/add/delay"
     "/chain/setsource/audio/source/sine"  -> "/setSource/sine"
     "/switch" or "/switch/crossfade*"     -> "/switch"
   Style
   - var-first; lowercase; no server.sync; flat control flow (no nested ^).
*/

+ LivePedalboardSystem {

    canonicalizeCommandPath { |rawPath|
        var parts, first;

        // Tokenize into non-empty segments
        parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
        if(parts.size == 0) { ^rawPath.asString };

        first = parts[0].asString;

        // 1) switch family ‚Üí "/switch"
        if(first == "switch") {
            ^"/switch";
        };

        // 2) chain/* positional mappings
        if(first == "chain") {
            // Guard against short arrays
            if(parts.size >= 3) {
                var second = parts[1].asString;

                // 2a) /chain/add/audio/.../<effect> -> /add/<effect>
                if(second == "add" and: { parts[2].asString == "audio" }) {
                    ^("/add/" ++ parts.last.asString);
                };

                // 2b) /chain/setsource/audio/source/<src> -> /setSource/<src>
                if(second == "setsource"
                   and: { parts.size >= 5 }
                   and: { parts[2].asString == "audio" }
                   and: { parts[3].asString == "source" }) {
                    ^("/setSource/" ++ parts.last.asString);
                };

                // (Extend here for remove/clear/bypass/swap later)
            };

            // If we get here and didn't match any chain rule, fall through to raw.
            ^rawPath.asString;
        };

        // 3) Already-canonical short forms ‚Äî pass through
        if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
            ^("/" ++ parts.join("/"));
        };

        // 4) Fallback: return unchanged
        ^rawPath.asString;
    }

    bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;

        cm.queueExportCallback = { |oscPath|
            var canon;
            canon = this.canonicalizeCommandPath(oscPath);
            pedalboard.handleCommand(canon);
            logger.info("Integration", "Sent command to pedalboard: " ++ canon);
            if(statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
                statusDisplay.showExpectation("Sent: " ++ canon, 0);
            };
        };

        commandManager = cm;
        logger.info("CommandSystem", "CommandManager initialized and connected.");
    }
}

===== LivePedalboardSystem/MagicPedalboardCommandTree_older.json =====
{
  "id": 0,
  "name": "root",
  "fret": 1,
  "payload": "root",
  "children": [
    {
      "id": 1,
      "name": "audio",
      "fret": 3,
      "payload": "audio",
      "children": [
        {
          "id": 2,
          "name": "source",
          "fret": 5,
          "payload": "audio/source",
          "children": [
            {
              "id": 3,
              "name": "testmelody",
              "fret": 7,
              "payload": "audio/source/testmelody",
              "children": []
            },
            {
              "id": 4,
              "name": "sine",
              "fret": 7,
              "payload": "audio/source/sine",
              "children": []
            },
            {
              "id": 5,
              "name": "noise",
              "fret": 7,
              "payload": "audio/source/noise",
              "children": []
            }
          ]
        },
        {
          "id": 6,
          "name": "timebased",
          "fret": 5,
          "payload": "audio/timebased",
          "children": [
            {
              "id": 7,
              "name": "delay",
              "fret": 7,
              "payload": "audio/timebased/delay",
              "children": [
                {
                  "id": 8,
                  "name": "multitap",
                  "fret": 9,
                  "payload": "audio/timebased/delay/multitap",
                  "children": []
                },
                {
                  "id": 9,
                  "name": "pingpong",
                  "fret": 9,
                  "payload": "audio/timebased/delay/pingpong",
                  "children": []
                }
              ]
            },
            {
              "id": 10,
              "name": "chorus",
              "fret": 7,
              "payload": "audio/timebased/chorus",
              "children": []
            }
          ]
        },
        {
          "id": 11,
          "name": "modulation",
          "fret": 5,
          "payload": "audio/modulation",
          "children": [
            {
              "id": 12,
              "name": "tremolo",
              "fret": 7,
              "payload": "audio/modulation/tremolo",
              "children": []
            },
            {
              "id": 13,
              "name": "phaser",
              "fret": 7,
              "payload": "audio/modulation/phaser",
              "children": []
            },
            {
              "id": 14,
              "name": "flanger",
              "fret": 7,
              "payload": "audio/modulation/flanger",
              "children": []
            }
          ]
        },
        {
          "id": 15,
          "name": "filter",
          "fret": 5,
          "payload": "audio/filter",
          "children": [
            {
              "id": 16,
              "name": "lowpass",
              "fret": 7,
              "payload": "audio/filter/lowpass",
              "children": []
            },
            {
              "id": 17,
              "name": "highpass",
              "fret": 7,
              "payload": "audio/filter/highpass",
              "children": []
            },
            {
              "id": 18,
              "name": "bandpass",
              "fret": 7,
              "payload": "audio/filter/bandpass",
              "children": []
            }
          ]
        },
        {
          "id": 19,
          "name": "reverb",
          "fret": 5,
          "payload": "audio/reverb",
          "children": []
        },
        {
          "id": 20,
          "name": "drive",
          "fret": 5,
          "payload": "audio/drive",
          "children": []
        }
      ]
    },
    {
      "id": 21,
      "name": "chain",
      "fret": 3,
      "payload": "chain",
      "children": [
        {
          "id": 22,
          "name": "add",
          "fret": 5,
          "payload": "chain/add",
          "children": []
        },
        {
          "id": 23,
          "name": "remove",
          "fret": 5,
          "payload": "chain/remove",
          "children": []
        },
        {
          "id": 24,
          "name": "swap",
          "fret": 5,
          "payload": "chain/swap",
          "children": []
        },
        {
          "id": 25,
          "name": "bypass",
          "fret": 5,
          "payload": "chain/bypass",
          "children": []
        },
        {
          "id": 26,
          "name": "clear",
          "fret": 5,
          "payload": "chain/clear",
          "children": []
        },
        {
          "id": 27,
          "name": "setsource",
          "fret": 5,
          "payload": "chain/setsource",
          "children": []
        },
        {
          "id": 28,
          "name": "print",
          "fret": 5,
          "payload": "chain/print",
          "children": []
        }
      ]
    },
    {
      "id": 29,
      "name": "switch",
      "fret": 3,
      "payload": "switch",
      "children": [
        {
          "id": 30,
          "name": "crossfade",
          "fret": 5,
          "payload": "switch/crossfade",
          "children": []
        },
        {
          "id": 31,
          "name": "crossfade_custom",
          "fret": 5,
          "payload": "switch/crossfade_custom",
          "children": []
        }
      ]
    },
    {
      "id": 32,
      "name": "preset",
      "fret": 3,
      "payload": "preset",
      "children": [
        {
          "id": 33,
          "name": "save",
          "fret": 5,
          "payload": "preset/save",
          "children": []
        },
        {
          "id": 34,
          "name": "load",
          "fret": 5,
          "payload": "preset/load",
          "children": []
        }
      ]
    },
    {
      "id": 35,
      "name": "system",
      "fret": 3,
      "payload": "system",
      "children": [
        {
          "id": 36,
          "name": "reset",
          "fret": 5,
          "payload": "system/reset",
          "children": []
        },
        {
          "id": 37,
          "name": "healthcheck",
          "fret": 5,
          "payload": "system/healthcheck",
          "children": []
        },
        {
          "id": 38,
          "name": "status",
          "fret": 5,
          "payload": "system/status",
          "children": []
        }
      ]
    }
  ]
}
===== LivePedalboardSystem/MagicPedalboardCommandTree.json =====
{ "children": [ { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 3, "name": "testmelody" }, { "children": [  ], "fret": 5, "id": 4, "name": "sine" }, { "children": [  ], "fret": 7, "id": 5, "name": "noise" } ], "fret": 3, "id": 2, "name": "source" }, { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 8, "name": "multitap" }, { "children": [  ], "fret": 5, "id": 9, "name": "pingpong" } ], "fret": 3, "id": 7, "name": "delay" }, { "children": [  ], "fret": 5, "id": 10, "name": "chorus" } ], "fret": 5, "id": 6, "name": "timebased" }, { "children": [ { "children": [  ], "fret": 3, "id": 12, "name": "tremolo" }, { "children": [  ], "fret": 5, "id": 13, "name": "phaser" }, { "children": [  ], "fret": 7, "id": 14, "name": "flanger" } ], "fret": 7, "id": 11, "name": "modulation" }, { "children": [ { "children": [  ], "fret": 3, "id": 16, "name": "lowpass" }, { "children": [  ], "fret": 5, "id": 17, "name": "highpass" }, { "children": [  ], "fret": 7, "id": 18, "name": "bandpass" } ], "fret": 9, "id": 15, "name": "filter" }, { "children": [  ], "fret": 11, "id": 19, "name": "reverb" }, { "children": [  ], "fret": 13, "id": 20, "name": "drive" } ], "fret": 1, "id": 1, "name": "audio" }, { "children": [ { "children": [  ], "fret": 3, "id": 22, "name": "add" }, { "children": [  ], "fret": 5, "id": 23, "name": "remove" }, { "children": [  ], "fret": 7, "id": 24, "name": "swap" }, { "children": [  ], "fret": 9, "id": 25, "name": "bypass" }, { "children": [  ], "fret": 11, "id": 26, "name": "clear" }, { "children": [  ], "fret": 13, "id": 27, "name": "setsource" }, { "children": [  ], "fret": 15, "id": 28, "name": "print" } ], "fret": 3, "id": 21, "name": "chain" }, { "children": [ { "children": [  ], "fret": 3, "id": 30, "name": "crossfade" }, { "children": [  ], "fret": 5, "id": 31, "name": "crossfade_custom" } ], "fret": 5, "id": 29, "name": "switch" }, { "children": [ { "children": [  ], "fret": 3, "id": 33, "name": "save" }, { "children": [  ], "fret": 5, "id": 34, "name": "load" } ], "fret": 7, "id": 32, "name": "preset" }, { "children": [ { "children": [  ], "fret": 3, "id": 36, "name": "reset" }, { "children": [  ], "fret": 5, "id": 37, "name": "healthcheck" }, { "children": [  ], "fret": 7, "id": 38, "name": "status" } ], "fret": 9, "id": 35, "name": "system" }, { "children": [ { "children": [ { "children": [  ], "fret": 1, "id": 41, "name": "delay" } ], "fret": 1, "id": 40, "name": "add" }, { "children": [ { "children": [ { "children": [  ], "fret": 2, "id": 44, "name": "on" }, { "children": [  ], "fret": 3, "id": 45, "name": "off" } ], "fret": 1, "id": 43, "name": "delay" } ], "fret": 2, "id": 42, "name": "bypass" }, { "children": [  ], "fret": 3, "id": 46, "name": "switch" }, { "children": [ { "children": [  ], "fret": 1, "id": 48, "name": "testmelody" } ], "fret": 4, "id": 47, "name": "setSource" } ], "fret": 10, "id": 39, "name": "commands" } ], "fret": 1, "id": 0, "name": "root" }
===== LivePedalboardSystem/MagicPedalboardCommandTree.json.tmp =====
{ "children": [ { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 3, "name": "testmelody" }, { "children": [  ], "fret": 5, "id": 4, "name": "sine" }, { "children": [  ], "fret": 7, "id": 5, "name": "noise" } ], "fret": 3, "id": 2, "name": "source" }, { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 8, "name": "multitap" }, { "children": [  ], "fret": 5, "id": 9, "name": "pingpong" } ], "fret": 3, "id": 7, "name": "delay" }, { "children": [  ], "fret": 5, "id": 10, "name": "chorus" } ], "fret": 5, "id": 6, "name": "timebased" }, { "children": [ { "children": [  ], "fret": 3, "id": 12, "name": "tremolo" }, { "children": [  ], "fret": 5, "id": 13, "name": "phaser" }, { "children": [  ], "fret": 7, "id": 14, "name": "flanger" } ], "fret": 7, "id": 11, "name": "modulation" }, { "children": [ { "children": [  ], "fret": 3, "id": 16, "name": "lowpass" }, { "children": [  ], "fret": 5, "id": 17, "name": "highpass" }, { "children": [  ], "fret": 7, "id": 18, "name": "bandpass" } ], "fret": 9, "id": 15, "name": "filter" }, { "children": [  ], "fret": 11, "id": 19, "name": "reverb" }, { "children": [  ], "fret": 13, "id": 20, "name": "drive" } ], "fret": 1, "id": 1, "name": "audio" }, { "children": [ { "children": [  ], "fret": 3, "id": 22, "name": "add" }, { "children": [  ], "fret": 5, "id": 23, "name": "remove" }, { "children": [  ], "fret": 7, "id": 24, "name": "swap" }, { "children": [  ], "fret": 9, "id": 25, "name": "bypass" }, { "children": [  ], "fret": 11, "id": 26, "name": "clear" }, { "children": [  ], "fret": 13, "id": 27, "name": "setsource" }, { "children": [  ], "fret": 15, "id": 28, "name": "print" } ], "fret": 3, "id": 21, "name": "chain" }, { "children": [ { "children": [  ], "fret": 3, "id": 30, "name": "crossfade" }, { "children": [  ], "fret": 5, "id": 31, "name": "crossfade_custom" } ], "fret": 5, "id": 29, "name": "switch" }, { "children": [ { "children": [  ], "fret": 3, "id": 33, "name": "save" }, { "children": [  ], "fret": 5, "id": 34, "name": "load" } ], "fret": 7, "id": 32, "name": "preset" }, { "children": [ { "children": [  ], "fret": 3, "id": 36, "name": "reset" }, { "children": [  ], "fret": 5, "id": 37, "name": "healthcheck" }, { "children": [  ], "fret": 7, "id": 38, "name": "status" } ], "fret": 9, "id": 35, "name": "system" }, { "children": [ { "children": [ { "children": [  ], "fret": 1, "id": 41, "name": "delay" } ], "fret": 1, "id": 40, "name": "add" }, { "children": [ { "children": [ { "children": [  ], "fret": 2, "id": 44, "name": "on" }, { "children": [  ], "fret": 3, "id": 45, "name": "off" } ], "fret": 1, "id": 43, "name": "delay" } ], "fret": 2, "id": 42, "name": "bypass" }, { "children": [  ], "fret": 3, "id": 46, "name": "switch" }, { "children": [ { "children": [  ], "fret": 1, "id": 48, "name": "testmelody" } ], "fret": 4, "id": 47, "name": "setSource" } ], "fret": 10, "id": 39, "name": "commands" } ], "fret": 1, "id": 0, "name": "root" }
===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue‚Üíadapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ‚Üê ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil ‚Üí class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;



	    ~system.installAdapterBridge;         // ‚Üê MUST be before enableAutoMeters


	    // *** NEW: inline meter taps + post-switch auto-reinstall + GUI re-arm
    ~system.enableAutoMeters(18, 0.35);
    }.defer;
)


===== LivePedalboardSystem/Tests/Demo_Today_Playbook_FallbackOnly.scd =====
// Demo_Today_Playbook_FallbackOnly.scd
// v0.1.3
// MD 2025-09-22 23:45 BST

/* Purpose
   - Hardware-independent fallback to demonstrate MagicPedalboardNew.
   - Applies canonical commands in sequence, EVEN IF hardware is connected.
   - If your adapter (~ct_applyOSCPathToMPB) is present, it is used; otherwise
     this script calls MagicPedalboardNew methods directly for /add, /setSource,
/switch, /bypass commands.
   - Uses generated audio only (no SoundIn) and enforces Option A exclusivity.

   Style
   - tilde vars ok at top level; var-first in every function/closure.
   - lowercase method names; no server.sync; Server.default.bind for Ndef ops.
   - AppClock-only UI updates; no caret returns in deferred closures.
*/

(

var gapSeconds, playlistA, playlistB,
    systemReady, pedalboardReady,
    logMessage, showGuiHint,
    ensureGeneratedSources,
    tryEnsureAdapter, adapterAvailable, applyViaAdapter,
    applyDirectToPedalboard, applyOneCommand,
    runPlaylist, stopPlaylist, startGeneration;

"[FALLBACK] entered".postln;
thisProcess.nowExecutingPath.postln;  // helps confirm you ran the right file

// ‚îÄ‚îÄ settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gapSeconds = 0.60;
playlistA  = [ "/add/delay", "/switch" ];
playlistB  = [ "/bypass/delay/on", "/bypass/delay/off", "/switch" ];

// ‚îÄ‚îÄ guards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
systemReady     = ~system.notNil;
pedalboardReady = systemReady and: { ~system.pedalboard.notNil };


if(systemReady.not) {
    "‚ö†Ô∏è  Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B)".warn;
    ^nil;
};

// ‚îÄ‚îÄ logging + GUI hint ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logMessage = { |text| ("[FALLBACK] " ++ text).postln };
showGuiHint = { |text|
    var canShow;
    canShow = (~system.notNil)
        and: { ~system.statusDisplay.notNil }
        and: { ~system.statusDisplay.respondsTo(\showExpectation) };
    if(canShow) { ~system.statusDisplay.showExpectation(text, 0) };
};

// ‚îÄ‚îÄ audio sources + option A exclusivity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ensureGeneratedSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
/*            Ndef(\testmelody, {
                var trig, frequencySeq, freq, env, pan;
                trig         = Impulse.kr(3.2);
                frequencySeq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq         = Demand.kr(trig, 0, frequencySeq);
                env          = Decay2.kr(trig, 0.01, 0.35);
                pan          = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });*/

			Ndef(\testmelody, {
    var trig, freq, env, pan, scale, idx;
    trig = Impulse.kr(2.2); // relaxed tempo
    scale = [60, 62, 64, 67, 69]; // C major pentatonic
    idx = Demand.kr(trig, 0, Dwhite(0, scale.size, inf)); // returns control-rate index
    freq = Select.kr(idx, scale).midicps; // safe indexing
    env = Decay2.kr(trig, 0.01, 0.4);
    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
});

        };
        Ndef(\testmelody).ar(2);

        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    if(~mpb.notNil) {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.setSource(\testmelody);
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
    };
};

// ‚îÄ‚îÄ try to use your adapter (~ct_applyOSCPathToMPB) if available ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tryEnsureAdapter = {
    var scriptFolderPath, candidateNames, found;
    if(~ct_applyOSCPathToMPB.notNil) { ^true };

    scriptFolderPath = PathName(thisProcess.nowExecutingPath).pathOnly;
    candidateNames = [
        "adapter_CommandTree_to_MagicPedalboard.scd",
        "adapter_commandtree_to_magicpedalboard.scd"
    ];
    found = candidateNames.detect({ |leaf|
        var fullPath = scriptFolderPath +/+ leaf;
        File.exists(fullPath).if({ fullPath.load; true }, { false })
    });

    (~ct_applyOSCPathToMPB.notNil)
};
adapterAvailable = tryEnsureAdapter.();

applyViaAdapter = { |canonicalPath|
    var guiRef;
    guiRef = ~system.statusDisplay;
    // signature from your existing adapter: (path, mpb, gui)
    ~ct_applyOSCPathToMPB.(canonicalPath, ~system.pedalboard, guiRef);
};

// ‚îÄ‚îÄ direct mapping for the demo verbs if adapter is absent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyDirectToPedalboard = { |canonicalPath|
    var pathSegments, verbName, effectSymbol, sourceSymbol,
        onOffString, bypassState, pedalboardRef;

    pedalboardRef = ~system.pedalboard;
    if(pedalboardRef.isNil) { logMessage.("pedalboard missing"); ^nil };

    pathSegments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(pathSegments.size == 0) { ^nil };
    verbName = pathSegments[0].asString;

    switch(verbName,

        "add", {
            if(pathSegments.size >= 2) {
                effectSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(effectSymbol);
                }{
                    logMessage.("no pedalboard.add; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /add path: " ++ canonicalPath);
            };
        },

        "setSource", {
            if(pathSegments.size >= 2) {
                sourceSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\setSource)) {
                    pedalboardRef.setSource(sourceSymbol);
                }{
                    logMessage.("no pedalboard.setSource; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /setSource path: " ++ canonicalPath);
            };
        },

        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                pedalboardRef.switchChain(0.12);
            }{
                logMessage.("no pedalboard.switchChain; skipped: " ++ canonicalPath);
            };
        },

        "bypass", {
            if(pathSegments.size >= 3) {
                effectSymbol = pathSegments[1].asSymbol;
                onOffString  = pathSegments[2].asString.toLower;
                bypassState  = (onOffString == "on") or: { onOffString == "true" } or: { onOffString == "1" };
                // for demo: act on CURRENT; your adapter usually controls NEXT
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(effectSymbol, bypassState);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        pedalboardRef.bypass(effectSymbol, bypassState);
                    }{
                        logMessage.("no pedalboard.bypass; skipped: " ++ canonicalPath);
                    };
                };
            }{
                logMessage.("bad /bypass path: " ++ canonicalPath);
            };
        },

        { // default
            logMessage.("unhandled verb: " ++ verbName ++ " (path=" ++ canonicalPath ++ ")");
        }
    );
};

// ‚îÄ‚îÄ unified apply: prefer adapter; fall back to direct mapping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyOneCommand = { |canonicalPath|

    "DEBUG: applyOneCommand called with %".format(canonicalPath).postln;

    logMessage.("apply ‚Üí " ++ canonicalPath);
    if(adapterAvailable) { applyViaAdapter.(canonicalPath) } { applyDirectToPedalboard.(canonicalPath) };
    if(~procHud_update.notNil) { ~procHud_update.() }; // optional HUD refresh
};

// ‚îÄ‚îÄ sequenced playlist runner (AppClock; cancel-safe via generation id) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
runPlaylist = { |listOfCanonicalPaths, gap = 0.6|
    var myGeneration, indexCounter, totalCount, stepOnce, scheduleNext;

    // bump global generation to cancel older chains
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    myGeneration = ~fallback_gen;

    indexCounter = 0;
    totalCount   = listOfCanonicalPaths.size;

    stepOnce = {
        if(~fallback_gen != myGeneration) { ^nil }; // cancelled
        applyOneCommand.( listOfCanonicalPaths[indexCounter] );
        indexCounter = indexCounter + 1;
        if(indexCounter < totalCount) { scheduleNext.() } { logMessage.("done.") };
    };

    scheduleNext = {
        var delaySeconds;
        delaySeconds = gap ? 0.6;
        AppClock.sched(delaySeconds, {
            if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
        });
    };

    AppClock.sched(0.0, {
        if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
    });

    ^myGeneration;
};

// ‚îÄ‚îÄ hard stop utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
stopPlaylist = {
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    logMessage.("stopped.");
};

// ‚îÄ‚îÄ go ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showGuiHint.(
    "Fallback-only demo (adapter=" ++ adapterAvailable ++ "):\n" ++
    "A: " ++ playlistA.asString ++ "\n" ++
    "B: " ++ playlistB.asString
);
ensureGeneratedSources.();
startGeneration = runPlaylist.(playlistA, gapSeconds);

// queue playlist B after A with a tail margin
AppClock.sched((playlistA.size * gapSeconds + 1.0).max(1.0), {
    if(~fallback_gen == startGeneration) {
        runPlaylist.(playlistB, gapSeconds);
    };
    nil
});
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail_Delayed.scd =====
// Fallback_Acceptance_PassFail_Delayed.scd
// v0.1.3
// MD 20250923-1534


/*
Purpose
- Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
- Verify A XOR B only AFTER crossfade settles (avoid false FAIL during fade).
- Extra diagnostics: print plan.size, first path, and every step index.
Style
- var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.
- Generated audio only; Option A enforced if available.
*/

(
var say, trace, assertXorAfter;
var ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne;
var plan, idx, gap, settle, runStep, kickOff;

/* logging helpers */
say   = { |msg| ("[ACCEPT] " ++ msg).postln };
trace = { |msg| ("[TRACE] "  ++ msg).postln };

/* delayed assertion to avoid crossfade overlap */
assertXorAfter = { |expectA, expectB, label, delaySeconds|
    var doCheck, delay;
    delay = delaySeconds ? 0.35; // default settle > 0.12 crossfade
    doCheck = {
        var a, b, okFlag, tag;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        okFlag = (a == expectA) and: { b == expectB };
        tag = if(okFlag) { "PASS" }{ "FAIL" };
        (tag ++ " ‚Äî " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    };
    AppClock.sched(delay, { doCheck.value; nil });
};

/* guards */
ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)"); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

/* ensure generated sources & Option A */
ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

/* application modes */
applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

/* plan: Events with optional verify on switch */
plan = [
    ( idx: 1, total: 5, path: "/add/delay" ),
    ( idx: 2, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: false, expectB: true,  label: "after first switch" ),
    ( idx: 3, total: 5, path: "/bypass/delay/on" ),
    ( idx: 4, total: 5, path: "/bypass/delay/off" ),
    ( idx: 5, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: true,  expectB: false, label: "after second switch" )
];

/* extra instrumentation to confirm the plan really exists */
trace.("plan.size = " ++ plan.size);
if(plan.size > 0) {
    trace.("plan[0].path = " ++ plan[0][\path].asString);
} {
    say.("‚ö†Ô∏è plan is empty ‚Äî aborting to avoid a no-op run."); ^nil;
};

idx    = 0;
gap    = 0.60;
settle = 0.35;

/* run one step, then re-schedule next */
runStep = {
    var step, path, haveVerify, label, eA, eB, vd;
    if(idx >= plan.size) { say.("done."); ^nil; };

    step = plan[idx];
    trace.("step " ++ step[\idx] ++ " / " ++ step[\total]);

    path = step[\path].asString;
    applyOne.value(path);

    haveVerify = step.includesKey(\verifyDelay);
    if(haveVerify) {
        vd   = step[\verifyDelay] ? settle;
        eA   = step[\expectA];
        eB   = step[\expectB];
        label= step[\label].asString;
        assertXorAfter.value(eA, eB, label, vd);
        AppClock.sched(vd.max(gap), { idx = idx + 1; runStep.value; nil });
    }{
        AppClock.sched(gap, { idx = idx + 1; runStep.value; nil });
    };
};

/* go */
ensureSources.value;
kickOff = {
    var scheduled;
    trace.("scheduling kickoff in 0.03s on AppClock‚Ä¶");
    scheduled = AppClock.sched(0.03, { runStep.value; nil });
    ("[TRACE] AppClock.sched ‚Üí " ++ scheduled.asString).postln;
};
kickOff.value;
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 ‚Äî 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " ‚Äî " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== LPDisplay/allcombined.txt =====
LivePedalboardDisplay - README (reStructuredText)
=================================================

Overview
--------
LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

- LPDisplayLayoutTestWindow - a 6-pane grid window with two meters (A/B) driven by SendPeakRMS, plus simple control methods.
- LPDisplaySigChain - a helper to wire a symbol chain [sink, ..., source] using Ndef(left) <<> Ndef(right) with stereo pre-arming.
- LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.

Install
-------
Place the .sc files under this path (copy exactly):

::
    .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually symlinked into Extensions). Then recompile the class library:

::
    Language -> Recompile Class Library

When loaded, you should see lines like:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Quick Start
-----------
SuperCollider snippet (copy/paste into the IDE):

::
    (
        var hud = LPDisplayHudMap.new(-6, -60, 1.0);  // top/floor/gamma
        ~inst = LPDisplayLayoutTestWindow.new(hud);
        ~win  = ~inst.open;  // -> a Window
    )

    // Swap tail sources and write a status line
    ~inst.setSourceA(\srcC);
    ~inst.setSourceB(\srcA);
    ~inst.sendPaneText(\diag, "Ready @ " ++ Date.getDate.stamp);

    // HUD on/off
    ~inst.setHudMap(nil);                             // raw 0..1 meters
    ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close
    ~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

Classes
-------
LPDisplayLayoutTestWindow
^^^^^^^^^^^^^^^^^^^^^^^^^^
- Builds a 6-pane grid with top-left/right meters (LevelIndicator).
- Wires two chains: [\outA, \srcA] and [\outB, \srcB] using LPDisplaySigChain.
- Updates meters from SendPeakRMS via OSCdef(\rmsA_toGUI) and OSCdef(\rmsB_toGUI).
- Prints decimated console levels via OSCdef(\rmsA_console) and OSCdef(\rmsB_console).
- Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw values).

Why replyID?
^^^^^^^^^^^^
We keep replyID as A=1 and B=2 in SendPeakRMS.kr(..., '/peakrmsA', 1) and (..., '/peakrmsB', 2) to preserve continuity with older dumps/tools. The OSC addresses already differ; replyID is kept for backward compatibility.

Key instance methods
^^^^^^^^^^^^^^^^^^^^^
- open -> Window, close
- setSourceA(\sym), setSourceB(\sym)
- sendPaneText(\left|\right|\system|\diag|\choices|\recv, "text")
- setHudMap(instanceOrNil), printHud

Class-side utilities
^^^^^^^^^^^^^^^^^^^^^
- .help, .apihelp, .test

LPDisplaySigChain
^^^^^^^^^^^^^^^^^^
- Wires a chain [sink, ..., source] using Ndef(left) <<> Ndef(right).
- Ensures stereo busses and plays the sink.
- Key methods: rebuild, size, symbols (copy), setTailSource(\srcX), chainToString.
- Class-side utilities: .help, .apihelp, .test

LPDisplayHudMap
^^^^^^^^^^^^^^^^
- Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.
- Pass nil to the window's setHudMap to bypass mapping and show raw values.
- Key methods: set(\top|\floor|\gamma, value), mapLinToUi(linearRms), preview(rmsDb), print.
- Class-side utilities: .help, .apihelp, .test

Smoke Tests
------------
Run these in SuperCollider:

::
    LPDisplaySigChain.test;         // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test;           // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips sources, closes

Troubleshooting
---------------
- Meters not moving:
    OSCdef(\rmsA_toGUI).notNil;  OSCdef(\rmsB_toGUI).notNil.
    Sinks must read ``\in.ar(2)``. Chains should be playing (sink Ndef is .play'ed by LPDisplaySigChain.rebuild).
    If you changed sink OSC addresses, update the OSCdef addresses accordingly.

- string_ DNU on nil:
    The window pre-creates views. If you extend it, create views first, then compose the layout; update UI via ``{ ... }.defer`` with notNil guards.

- Compile errors after edits:
    Class-side methods (*help, *apihelp, *test) must be at class scope (not nested).
    Symbol literals use a single backslash: ``\symbol`` (not ``\\symbol``).

Style and Conventions
----------------------
- *new { ^super.new.init(...) }
- var-first in method bodies; clear names
- No non-local returns inside inner Functions
- GUI updates via ``{ ... }.defer``
- JITLib wiring strictly ``Ndef(left) <<> Ndef(right)``
- Sinks read ``\in.ar(2)``

Versioning
----------
Each class defines classVersion and prints a banner at class load time. You should see lines like these after a recompile:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Optional: One-button regression
--------------------------------
Save as this path (copy exactly):

::
    LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::
    (
        var hudPass, sigPass, win, posted;
        hudPass = LPDisplayHudMap.test;
        sigPass = { LPDisplaySigChain.test; true }.value;
        win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, {
            var allGreen = hudPass and: sigPass;
            ("LivePedalboardDisplay SMOKE: " ++ (allGreen.if("PASS", "WARN/FAIL"))).postln;
            nil
        });
    )// LPDisplay_AllInOne_BringUp.scd
// v0.9.8 ‚Äî open the layout test window + export helpers for a guided tour
// MD 2025-10-01

/*
Purpose
- One-file bring-up for the LivePedalboardDisplay demo window:
  * Open a 6-pane GUI with A/B meters driven by SendPeakRMS.
  * Create a HUD mapper (dB headroom + gamma) and allow on/off toggling.
  * Provide safe, readable one-liners to swap sources and send pane text.
  * Keep to known-good wiring: Ndef(left) <<> Ndef(right); sinks read \in.ar(2).

Style / Conventions
- var-first declarations; descriptive names; tilde vars exported for convenience.
- No server.sync; GUI ops are deferred inside the window class.
- Single bring-up block that returns -> a Window.
- No SoundIn; the window defines internal demo sources/sinks (stereo).
- If the classes are missing, recompile after installing them at:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
*/

(
var hud, inst, win;

// --- Create a HUD map (top/floor/gamma), then build the window instance
hud  = LPDisplayHudMap.new(-6, -60, 1.0);         // defaults: headroom -6 dB, floor -60 dB, gamma 1.0
inst = LPDisplayLayoutTestWindow.new(hud);        // pass nil here if you prefer raw 0..1 meters initially

// --- Open the window (the class ensures only one "Layout Test" window is active)
win = inst.open;                                  // -> a Window

// --- Export handles (tilde vars) so you can drive the demo interactively
~hud  = hud;          // current HUD map instance (may be replaced by ~hud_on)
~inst = inst;         // the layout test window controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;          // the Window; optional use

// --- Demo helpers: all nil-safe through the class methods they call
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;
};

~hud_set = { |key, value|
    // Ensure we have a HUD instance, then tweak a single parameter (\top, \floor, \gamma)
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);  // ensure mapping is active while tweaking
    ~hud.set(key, value).print;  // prints settings
};

~hud_preview = { |rmsDb = -9|
    // Convenience to see the UI mapping for a specific RMS dB value
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);
};

~setA = { |sym|  ~inst.setSourceA(sym) };         // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };         // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|
    // paneKey ‚àà: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    // Close the window and free OSCdefs & Ndefs inside the class
    ~inst.close;
};

// --- Friendly banner so the recipient knows what to try next:
"LivePedalboardDisplay ‚Äî bring-up complete. See 'Quick Tour' below for optional steps.".postln;
"Tip: you can now call ~hud_off.(), ~hud_on.(), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

// Return the Window so SC shows '-> a Window'
win
)

// LPDisplay_AllInOne_Demo_Tour.scd
// v0.9.8 ‚Äî single-file bring-up + guided quick tour (evaluate blocks top-to-bottom)
// MD 2025-10-01

/*
Overview
- This single .scd opens the LivePedalboardDisplay demo window and provides a guided "Quick Tour".
- The window shows A/B chains with meters (via SendPeakRMS), optional HUD mapping (dB headroom + gamma),
  and several text panes you can write to.

Prerequisites
- Ensure these classes are installed and you have recompiled the class library:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
    ‚Ä¢ LPDisplayHudMap.sc
    ‚Ä¢ LPDisplaySigChain.sc
    ‚Ä¢ LPDisplayLayoutTestWindow.sc
  SuperCollider menu: Language ‚Üí Recompile Class Library

How to use this file
1) Evaluate the first block (Bring-Up). You should see '-> a Window'.
2) Then evaluate the Quick Tour chunks (00..06) as needed, one line at a time or a few at a time.
3) To close and clean up, evaluate the Close chunk (06) at the end.

Style / Coding rules
- var-first declarations; descriptive names; GUI updates are deferred in the classes.
- JITLib wiring strictly: Ndef(left) <<> Ndef(right). Sinks read \in.ar(2).
- Generated demo sources only (no SoundIn).
*/

(
// --- Bring-Up: create HUD, create instance, open the window, export helpers ---
var hud, inst, win;

hud  = LPDisplayHudMap.new(-6, -60, 1.0);           // defaults: top=-6 dB, floor=-60 dB, gamma=1.0
inst = LPDisplayLayoutTestWindow.new(hud);          // pass nil if you prefer raw meters initially
win  = inst.open;                                   // -> a Window (ensures only one "Layout Test")

// Export handles for interactive use during the tour
~hud  = hud;                                        // current HUD instance (may be replaced)
~inst = inst;                                       // the controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;                                        // the Window

// Helper one-liners used by the tour
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;               // console prints HUD params
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;                  // console: "HUD mapping: none (raw 0..1)"
};

~hud_set = { |key, value|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);
    ~hud.set(key, value).print;                     // tweak \top/\floor/\gamma; prints settings
};

~hud_preview = { |rmsDb = -9|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);                             // prints UI fraction for given dB RMS
};

~setA = { |sym|  ~inst.setSourceA(sym) };           // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };           // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|                        // pane keys: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    ~inst.close;                                     // frees OSCdefs; stops sink Ndefs; closes window
};

"LivePedalboardDisplay ‚Äî bring-up complete. See Quick Tour blocks below.".postln;
"Tip: try ~hud_off.(), ~hud_on.(-9, -60, 1.0), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

win                                                // return -> a Window
)


// =============================
// Quick Tour 00 ‚Äî Sanity checks
// =============================

// LPDisplay_Tour_00_Sanity
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm bring-up ran and helpers exist before running the tour.
// Style
// - Each line prints a boolean; 'true' means you're good to proceed.

(~inst.notNil).postln;                               // expected: true
~inst.respondsTo(\setHudMap).postln;                 // expected: true
(~text.notNil).postln;                               // expected: true
(~hud_on.notNil and: { ~hud_off.notNil }).postln;    // expected: true


// ==========================================
// Quick Tour 01 ‚Äî Verify window + status text
// ==========================================

// LPDisplay_Tour_01_VerifyAndStatus
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm the window is open and panes update.
// Style
// - Evaluate lines one by one; text should appear immediately.

~text.(\diag,   "Ready @ " ++ Date.getDate.stamp);  // diag pane prints timestamp
~text.(\system, "A/B chains running. HUD is ON by default."); // system pane status


// =======================================
// Quick Tour 02 ‚Äî Swap tail sources (A/B)
// =======================================

// LPDisplay_Tour_02_SwapTailSources
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Swap each chain's tail source; you will hear/see changes.
// Style
// - After swap, the window auto-updates the top labels to show the new chain strings.

~setA.(\srcC);                                       // A tail -> \srcC (LFSaw/tanh) ; left meter responds
~setB.(\srcA);                                       // B tail -> \srcA (PinkNoise)  ; right meter responds
~text.(\diag, "Swapped: A->\\srcC, B->\\srcA");     // diag note confirming the change


// ==============================================
// Quick Tour 03 ‚Äî Toggle HUD mapping & preview UI
// ==============================================

// LPDisplay_Tour_03_ToggleHUD
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Show raw meters (no mapping), then enable HUD with new top/floor/gamma.
// - Preview mapping for a specific RMS dB value.
// Style
// - Use helpers created at bring-up.

~hud_off.();                                         // raw linear RMS on meters ; console prints mapping=none
~hud_on.(-9, -60, 1.0);                              // enable mapping top=-9 ; console prints params
~hud_set.(\gamma, 1.2);                              // add curvature ; console prints updated params
~hud_preview.(-9);                                   // prints UI fraction for -9 dB RMS ; e.g., 0.83
~print_hud.();                                       // print current HUD parameters


// ============================================
// Quick Tour 04 ‚Äî Populate the lower text panes
// ============================================

// LPDisplay_Tour_04_Panes_Content
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Simulate a fuller display by writing to \choices and \recv.
// Style
// - Multiline strings using \n.

~text.(\choices, "Choices:\n  1) Swap A/B\n  2) Toggle HUD\n  3) Send message\n  4) Close");            // choices pane shows 4 options

~text.(\recv,"Receiving:\n  /peakrmsA and /peakrmsB @ 20 Hz\n  Console prints ~1 Hz (decimated)"); // recv pane shows OSC info


// =====================================
// Quick Tour 05 ‚Äî Lightweight smoke tests
// =====================================

// LPDisplay_Tour_05_SmokeTests
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Quick PASS/FAIL checks in the Post window.
// Style
// - Run while the main demo window is open. Avoid LPDisplayLayoutTestWindow.test here.

LPDisplayHudMap.test;                                 // expected: prints cases + "LPDisplayHudMap.test: PASS"
LPDisplaySigChain.test;                               // expected: brief run + "LPDisplaySigChain.test: PASS"


// ================================
// Quick Tour 06 ‚Äî Close and cleanup
// ================================

// LPDisplay_Tour_06_Close
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Cleanly close the window and free responders.
// Style
// - Re-run the Bring-Up block to open again.

~close.();                                            // expected: window closes; OSCdefs freed; sinks stopped


// ======================================================
// Optional: One-button smoke runner (evaluate as a block)
// ======================================================

// LPDisplay_Tour_07_OneButtonSmoke
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Minimal automated walk-through: flip sources, post a diag line, print HUD, then stop.
// Style
// - Safe timings via AppClock; does not assume SoundIn.

(
var step1, step2;
step1 = {
    ~setA.(\srcC); ~setB.(\srcA);                    // swap tails
    ~text.(\diag, "Smoke: swapped A/B @ " ++ Date.getDate.stamp);
};
step2 = {
    ~print_hud.();                                    // print active HUD state
    ~text.(\system, "Smoke: HUD printed; closing in 1s");
    AppClock.sched(1.0, { ~close.(); nil });          // close after 1s
};
AppClock.sched(0.5, { step1.(); AppClock.sched(1.0, { step2.(); nil }); nil });
)
// LPDisplay_CompatExports.scd
// v0.9.2 - shims for old tilde variables + bring-up
// MD 20251001

(
var hud, win;

// Create a HUD map (or set to nil to keep raw 0..1 meters)
hud = LPDisplayHudMap.new(-6, -60, 1.0);

// Open the window (-> a Window)
win = LPDisplayLayoutTestWindow.new(hud).open;

// Export legacy one-liners:
~setSourceA = { |sym| win.setSourceA(sym) };
~setSourceB = { |sym| win.setSourceB(sym) };

// Pane text helper (keys: \left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString| win.sendPaneText(paneKey, aString) };

// HUD helpers to mirror your previous patch commands:
~hud_set     = { |key, value| hud.set(key, value) };
~hud_preview = { |db| hud.preview(db) };
~hud_print   = { hud.print };

// Quick ping:
~hud_print.();
// LPDisplayHudMap.sc
// v0.9.7.2 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local variable names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Map raw linear RMS (0..1) from SendPeakRMS into a UI-friendly 0..1 value using a dB window
 *   (topDb/floorDb) and a perceptual gamma curve. This is optional in the display window:
 *   passing nil for the HUD map means "use raw RMS 0..1".
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; numeric helpers return raw values.
 */

LPDisplayHudMap {
    classvar classVersion = "0.9.7.2";

    // Defaults for headroom window and perceptual curve
    classvar defaultTopDb   = -6.0;
    classvar defaultFloorDb = -60.0;
    classvar defaultGamma   = 1.0;

    // Instance configuration
    var topDb;     // dB at which UI reaches 1.0 (top of meter)
    var floorDb;   // dB at which UI reaches 0.0 (floor of meter)
    var gamma;     // perceptual exponent applied in UI domain

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDbArg, floorDbArg, gammaArg|
        // If any parameter is omitted, fall back to defaults above.
        ^super.new.init(
            topDbArg   ?? { defaultTopDb },
            floorDbArg ?? { defaultFloorDb },
            gammaArg   ?? { defaultGamma }
        )
    }

    init { |topDbInit, floorDbInit, gammaInit|
        // Store parameters and keep gamma numerically safe.
        topDb   = topDbInit.asFloat;
        floorDb = floorDbInit.asFloat;
        gamma   = gammaInit.asFloat.max(1e-6);

        // Ensure a valid window (top must be above floor).
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        // Small setter to tweak parameters at runtime (e.g., \top -> -9, \gamma -> 1.2).
        var paramKey = key.asSymbol;
        var paramVal = value.asFloat;

        if (paramKey == \top)   { topDb = paramVal };
        if (paramKey == \floor) { floorDb = paramVal };
        if (paramKey == \gamma) { gamma = paramVal.max(1e-6) };

        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |linearRms|
        /*
         * Convert a raw linear RMS (0..1) into a UI fraction (0..1):
         * 1) Convert linear amplitude to dBFS.
         * 2) Clip to [floorDb, topDb] window.
         * 3) Normalize to [0,1] and apply gamma.
         */
        var linearClamped      = linearRms.max(1e-9);  // avoid -inf dB
        var amplitudeDb        = linearClamped.ampdb;  // linear -> dBFS
        var topDbLimit         = topDb.asFloat;
        var floorDbLimit       = floorDb.asFloat;
        var gammaLocal         = gamma.asFloat.max(1e-6);
        var uiValue;

        amplitudeDb = amplitudeDb.clip(floorDbLimit, topDbLimit);
        uiValue     = (amplitudeDb - floorDbLimit) / (topDbLimit - floorDbLimit);
        uiValue     = uiValue.pow(gammaLocal);
        ^uiValue.clip(0.0, 1.0)
    }

    preview { |rmsDbValue|
        // Convenience: preview the UI value you‚Äôd get for a given RMS dB input.
        var linearFromDb             = rmsDbValue.dbamp.clip(1e-9, 1.0);
        var uiValue                  = this.mapLinToUi(linearFromDb);
        ("HUD UI -> " ++ uiValue.round(0.003) ++ " for " ++ rmsDbValue ++ " dBFS RMS").postln;
        ^uiValue
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }


	/////



	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplayHudMap ‚Äî purpose:",
        "  Map raw linear RMS (0..1) to UI (0..1) using a dB headroom window and gamma.",
        "",
        "Constructor:",
        "  LPDisplayHudMap.new(topDb = -6, floorDb = -60, gamma = 1.0)",
        "",
        "Key methods:",
        "  .set(\\top|\\floor|\\gamma, value)  // tweak mapping",
        "  .mapLinToUi(linearRms)              // 0..1 -> 0..1 UI",
        "  .preview(rmsDb)                     // prints & returns UI for a dB value",
        "  .print()                            // print current mapping",
        "",
        "Tip: In LPDisplayLayoutTestWindow, setHudMap(nil) disables mapping (raw 0..1)."
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplayHudMap.apihelp ‚Äî quick recipes:",
        "  h = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  h.preview(-9);                // see UI at -9 dB RMS",
        "  h.set(\\top, -9).print;        // move top to -9 dB RMS",
        "  h.set(\\gamma, 1.2).print;     // increase perceptual curvature",
        "  // In the layout window:",
        "  //  ~inst.setHudMap(h);         // enable mapping",
        "  //  ~inst.setHudMap(nil);       // disable mapping (raw 0..1)"
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var hud, dbCases, lastUi, passAll;
    hud = this.new(-6, -60, 1.0);
    dbCases = [-60, -30, -18, -12, -9, -6, -3, 0]; // typical points
    lastUi = -1.0;
    passAll = true;

    "LPDisplayHudMap.test ‚Äî monotonicity & bounds:".postln;
    dbCases.do({ |dbVal|
        var uiVal;
        uiVal = hud.preview(dbVal); // prints & returns
        if (uiVal < lastUi) { passAll = false };
        if ((uiVal < 0.0) or: { uiVal > 1.0 }) { passAll = false };
        lastUi = uiVal;
    });

    if (passAll) {
        "LPDisplayHudMap.test: PASS".postln;
    } {
        "LPDisplayHudMap.test: FAIL (non-monotonic or out-of-bounds)".postln;
    };
    ^passAll
}
}// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01
/*
 * 0.9.7.3 move class-side utility methods (*help/*apihelp/*test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}// LPDisplaySigChain.sc
// v0.9.7.2 ‚Äî minimal [sink, ..., source] JITLib chain wrapper
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local/parameter names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Manage a simple symbol chain [sink, ..., source] using JITLib wiring:
 *   Ndef(left) <<> Ndef(right), where the left node reads \in.ar(2).
 * - Ensure stereo busses prior to wiring; play the sink.
 *
 * Typical usage
 *   LPDisplaySigChain.new([\outA, \srcA]).rebuild;       // wires and plays sink
 *   chain.setTailSource(\srcC).rebuild;                  // swap just the tail
 *   chain.chainToString  // "srcC ‚Üí outA"
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; getters return values.
 */

LPDisplaySigChain {
    classvar classVersion = "0.9.7.2";

    var chainSymbols;  // Array(Symbol): [sink, ..., source]

    *initClass {
        ("LPDisplaySigChain v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |chainSymbolsArray|
        ^super.new.init(chainSymbolsArray ?? { [] })
    }

    init { |chainSymbolsArray|
        chainSymbols = chainSymbolsArray.copy;
        ^this
    }

    size {
        ^chainSymbols.size
    }

    ensureStereo { |ndefKey|
        /*
         * Pre-arm an Ndef as a 2-channel audio node if its bus is missing or not stereo.
         * This prevents wiring failures when we connect nodes with <<>.
         */
        var ndefBus = Ndef(ndefKey).bus;
        if (ndefBus.isNil or: { ndefBus.rate != \audio } or: { ndefBus.numChannels != 2 }) {
            Ndef(ndefKey).ar(2);
        };
        ^this
    }

    rebuild {
        /*
         * Wire the chain left-to-right:
         *   chainSymbols = [sink, mid1, mid2, source]
         * becomes:
         *   Ndef(sink) <<> Ndef(mid1);  Ndef(mid1) <<> Ndef(mid2);  Ndef(mid2) <<> Ndef(source)
         * and then play the sink stereo.
         */
        var chainSize  = chainSymbols.size;
        var linkIndex  = 0;

        if (chainSize < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
            ^this
        };

        chainSymbols.do { |ndefSymbol| this.ensureStereo(ndefSymbol) };

        while({ linkIndex < (chainSize - 1) }, {
            Ndef(chainSymbols[linkIndex]) <<> Ndef(chainSymbols[linkIndex + 1]);
            linkIndex = linkIndex + 1;
        });

        Ndef(chainSymbols[0]).play(numChannels: 2);  // play the sink
        ^this
    }

    chainToString {
        // For display we show "source ‚Üí ... ‚Üí sink"
        var forwardList = chainSymbols.copy.reverse;
        ^forwardList.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |tailSourceSymbol|
        // Replace/append the final element (source) and keep the chain consistent.
        var newSourceSymbol = tailSourceSymbol.asSymbol;

        if (chainSymbols.size >= 2) {
            chainSymbols[chainSymbols.size - 1] = newSourceSymbol;
        } {
            chainSymbols = chainSymbols.add(newSourceSymbol);
        };

        ^this.rebuild
    }

    symbols {
        // Read-only copy so external code doesn‚Äôt mutate internal state.
        var symbolsCopy = chainSymbols.copy;
        ^symbolsCopy
    }



	////////
	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplaySigChain ‚Äî purpose:",
        "  Wrap a symbol chain [sink, ..., source] and wire via:",
        "    Ndef(left) <<> Ndef(right)  (sink reads \\in.ar(2))",
        "",
        "Constructor:",
        "  LPDisplaySigChain.new([\\outA, \\srcA])",
        "",
        "Key methods:",
        "  .rebuild()                   // ensure stereo, wire, play sink",
        "  .setTailSource(\\srcC)       // swap the final source and rebuild",
        "  .chainToString               // e.g., 'srcC ‚Üí outA'",
        "  .symbols                     // copy of [sink, ..., source]",
        ""
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplaySigChain.apihelp ‚Äî quick recipes:",
        "  c = LPDisplaySigChain.new([\\outA, \\srcA]).rebuild;",
        "  c.setTailSource(\\srcC);",
        "  c.chainToString.postln;  // 'srcC ‚Üí outA'",
        "",
        "Note: Ensure sinks read \\in.ar(2) and that sources produce stereo."
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var srcKey, sinkKey, chain, okFlag;

    // Use single-backslash for Symbol literals:
    srcKey  = \_lpdisp_test_src;
    sinkKey = \_lpdisp_test_sink;

    okFlag  = true;

    Server.default.waitForBoot({
        // ephemeral test nodes
        Ndef(srcKey,  { PinkNoise.ar(0.02 ! 2) });  // quiet stereo
        Ndef(sinkKey, {
            var sig = \in.ar(2);
            // no SendPeakRMS here to keep test minimal
            sig
        });

        chain = this.new([sinkKey, srcKey]).rebuild;

        // brief run, then cleanup
        AppClock.sched(0.4, {
            var busOk;
            busOk = Ndef(sinkKey).bus.notNil and: { Ndef(sinkKey).isPlaying };
            if (busOk.not) { okFlag = false };

            Ndef(sinkKey).stop;
            Ndef(srcKey).clear(0.2);  // fade out

            ("LPDisplaySigChain.test: " ++ (okFlag.if("PASS", "FAIL"))).postln;
            nil
        });
    });
    ^this
}

}
===== LPDisplay/LPDisplay_AllInOne_BringUp.scd =====
// LPDisplay_AllInOne_BringUp.scd
// v0.9.8 ‚Äî open the layout test window + export helpers for a guided tour
// MD 2025-10-01

/*
Purpose
- One-file bring-up for the LivePedalboardDisplay demo window:
  * Open a 6-pane GUI with A/B meters driven by SendPeakRMS.
  * Create a HUD mapper (dB headroom + gamma) and allow on/off toggling.
  * Provide safe, readable one-liners to swap sources and send pane text.
  * Keep to known-good wiring: Ndef(left) <<> Ndef(right); sinks read \in.ar(2).

Style / Conventions
- var-first declarations; descriptive names; tilde vars exported for convenience.
- No server.sync; GUI ops are deferred inside the window class.
- Single bring-up block that returns -> a Window.
- No SoundIn; the window defines internal demo sources/sinks (stereo).
- If the classes are missing, recompile after installing them at:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
*/

(
var hud, inst, win;

// --- Create a HUD map (top/floor/gamma), then build the window instance
hud  = LPDisplayHudMap.new(-6, -60, 1.0);         // defaults: headroom -6 dB, floor -60 dB, gamma 1.0
inst = LPDisplayLayoutTestWindow.new(hud);        // pass nil here if you prefer raw 0..1 meters initially

// --- Open the window (the class ensures only one "Layout Test" window is active)
win = inst.open;                                  // -> a Window

// --- Export handles (tilde vars) so you can drive the demo interactively
~hud  = hud;          // current HUD map instance (may be replaced by ~hud_on)
~inst = inst;         // the layout test window controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;          // the Window; optional use

// --- Demo helpers: all nil-safe through the class methods they call
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;
};

~hud_set = { |key, value|
    // Ensure we have a HUD instance, then tweak a single parameter (\top, \floor, \gamma)
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);  // ensure mapping is active while tweaking
    ~hud.set(key, value).print;  // prints settings
};

~hud_preview = { |rmsDb = -9|
    // Convenience to see the UI mapping for a specific RMS dB value
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);
};

~setA = { |sym|  ~inst.setSourceA(sym) };         // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };         // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|
    // paneKey ‚àà: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    // Close the window and free OSCdefs & Ndefs inside the class
    ~inst.close;
};

// --- Friendly banner so the recipient knows what to try next:
"LivePedalboardDisplay ‚Äî bring-up complete. See 'Quick Tour' below for optional steps.".postln;
"Tip: you can now call ~hud_off.(), ~hud_on.(), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

// Return the Window so SC shows '-> a Window'
win
)

===== LPDisplay/LPDisplay_AllInOne_Demo_Tour.scd =====

// LPDisplay_AllInOne_Demo_Tour.scd
// v0.9.8.1 added check that GUI window is open at start of last block
// v0.9.8 ‚Äî single-file bring-up + guided quick tour (evaluate blocks top-to-bottom)
// MD 2025-10-01

/*
Overview
- This single .scd opens the LivePedalboardDisplay demo window and provides a guided "Quick Tour".
- The window shows A/B chains with meters (via SendPeakRMS), optional HUD mapping (dB headroom + gamma),
  and several text panes you can write to.

Prerequisites
- Ensure these classes are installed and you have recompiled the class library:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
    ‚Ä¢ LPDisplayHudMap.sc
    ‚Ä¢ LPDisplaySigChain.sc
    ‚Ä¢ LPDisplayLayoutTestWindow.sc
  SuperCollider menu: Language ‚Üí Recompile Class Library

How to use this file
1) Evaluate the first block (Bring-Up). You should see '-> a Window'.
2) Then evaluate the Quick Tour chunks (00..06) as needed, one line at a time or a few at a time.
3) To close and clean up, evaluate the Close chunk (06) at the end.

Style / Coding rules
- var-first declarations; descriptive names; GUI updates are deferred in the classes.
- JITLib wiring strictly: Ndef(left) <<> Ndef(right). Sinks read \in.ar(2).
- Generated demo sources only (no SoundIn).
*/

(
// --- Bring-Up: create HUD, create instance, open the window, export helpers ---
var hud, inst, win;

hud  = LPDisplayHudMap.new(-6, -60, 1.0);           // defaults: top=-6 dB, floor=-60 dB, gamma=1.0
inst = LPDisplayLayoutTestWindow.new(hud);          // pass nil if you prefer raw meters initially
win  = inst.open;                                   // -> a Window (ensures only one "Layout Test")

// Export handles for interactive use during the tour
~hud  = hud;                                        // current HUD instance (may be replaced)
~inst = inst;                                       // the controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;                                        // the Window

// Helper one-liners used by the tour
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;               // console prints HUD params
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;                  // console: "HUD mapping: none (raw 0..1)"
};

~hud_set = { |key, value|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);
    ~hud.set(key, value).print;                     // tweak \top/\floor/\gamma; prints settings
};

~hud_preview = { |rmsDb = -9|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);                             // prints UI fraction for given dB RMS
};

~setA = { |sym|  ~inst.setSourceA(sym) };           // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };           // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|                        // pane keys: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    ~inst.close;                                     // frees OSCdefs; stops sink Ndefs; closes window
};

"LivePedalboardDisplay ‚Äî bring-up complete. See Quick Tour blocks below.".postln;
"Tip: try ~hud_off.(), ~hud_on.(-9, -60, 1.0), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

win                                                // return -> a Window
)


// =============================
// Quick Tour 00 ‚Äî Sanity checks
// =============================

// LPDisplay_Tour_00_Sanity
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm bring-up ran and helpers exist before running the tour.
// Style
// - Each line prints a boolean; 'true' means you're good to proceed.

(~inst.notNil).postln;                               // expected: true
~inst.respondsTo(\setHudMap).postln;                 // expected: true
(~text.notNil).postln;                               // expected: true
(~hud_on.notNil and: { ~hud_off.notNil }).postln;    // expected: true


// ==========================================
// Quick Tour 01 ‚Äî Verify window + status text
// ==========================================

// LPDisplay_Tour_01_VerifyAndStatus
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm the window is open and panes update.
// Style
// - Evaluate lines one by one; text should appear immediately.

~text.(\diag,   "Ready @ " ++ Date.getDate.stamp);  // diag pane prints timestamp
~text.(\system, "A/B chains running. HUD is ON by default."); // system pane status


// =======================================
// Quick Tour 02 ‚Äî Swap tail sources (A/B)
// =======================================

// LPDisplay_Tour_02_SwapTailSources
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Swap each chain's tail source; you will hear/see changes.
// Style
// - After swap, the window auto-updates the top labels to show the new chain strings.

~setA.(\srcC);                                       // A tail -> \srcC (LFSaw/tanh) ; left meter responds
~setB.(\srcA);                                       // B tail -> \srcA (PinkNoise)  ; right meter responds
~text.(\diag, "Swapped: A->\\srcC, B->\\srcA");     // diag note confirming the change


// ==============================================
// Quick Tour 03 ‚Äî Toggle HUD mapping & preview UI
// ==============================================

// LPDisplay_Tour_03_ToggleHUD
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Show raw meters (no mapping), then enable HUD with new top/floor/gamma.
// - Preview mapping for a specific RMS dB value.
// Style
// - Use helpers created at bring-up.

~hud_off.();                                         // raw linear RMS on meters ; console prints mapping=none
~hud_on.(-9, -60, 1.0);                              // enable mapping top=-9 ; console prints params
~hud_set.(\gamma, 1.2);                              // add curvature ; console prints updated params
~hud_preview.(-9);                                   // prints UI fraction for -9 dB RMS ; e.g., 0.83
~print_hud.();                                       // print current HUD parameters


// ============================================
// Quick Tour 04 ‚Äî Populate the lower text panes
// ============================================

// LPDisplay_Tour_04_Panes_Content
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Simulate a fuller display by writing to \choices and \recv.
// Style
// - Multiline strings using \n.

~text.(\choices, "Choices:\n  1) Swap A/B\n  2) Toggle HUD\n  3) Send message\n  4) Close");            // choices pane shows 4 options

~text.(\recv,"Receiving:\n  /peakrmsA and /peakrmsB @ 20 Hz\n  Console prints ~1 Hz (decimated)"); // recv pane shows OSC info


// =====================================
// Quick Tour 05 ‚Äî Lightweight smoke tests
// =====================================

// LPDisplay_Tour_05_SmokeTests
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Quick PASS/FAIL checks in the Post window.
// Style
// - Run while the main demo window is open. Avoid LPDisplayLayoutTestWindow.test here.

LPDisplayHudMap.test;                                 // expected: prints cases + "LPDisplayHudMap.test: PASS"
LPDisplaySigChain.test;                               // expected: brief run + "LPDisplaySigChain.test: PASS"


// ================================
// Quick Tour 06 ‚Äî Close and cleanup
// ================================

// LPDisplay_Tour_06_Close
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Cleanly close the window and free responders.
// Style
// - Re-run the Bring-Up block to open again.

~close.();                                            // expected: window closes; OSCdefs freed; sinks stopped


// ======================================================
// Optional: One-button smoke runner (evaluate as a block,
// keeping first block running.)
// ======================================================

// LPDisplay_Tour_07_OneButtonSmoke
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Minimal automated walk-through: flip sources, post a diag line, print HUD, then stop.
// Style
// - Safe timings via AppClock; does not assume SoundIn.

(
var step1, step2;

// Ensure GUI is up before scheduling steps:
if (~inst.isNil or: { ~win.isNil } or: { ~win.isClosed }) {
    var hud = LPDisplayHudMap.new(-6, -60, 1.0);
    ~inst = LPDisplayLayoutTestWindow.new(hud);
    ~win  = ~inst.open;
    ~hud  = hud;
};

step1 = {
    ~setA.(\srcC); ~setB.(\srcA);                    // swap tails
    ~text.(\diag, "Smoke: swapped A/B @ " ++ Date.getDate.stamp);
};
step2 = {
    ~print_hud.();                                    // print active HUD state
    ~text.(\system, "Smoke: HUD printed; closing in 1s");
    AppClock.sched(1.0, { ~close.(); nil });          // close after 1s
};
AppClock.sched(0.5, { step1.(); AppClock.sched(1.0, { step2.(); nil }); nil });
)

===== LPDisplay/LPDisplay_CompatExports.scd =====
// LPDisplay_CompatExports.scd
// v0.9.2 - shims for old tilde variables + bring-up
// MD 20251001

(
var hud, win, inst;

// Create a HUD map (or set to nil to keep raw 0..1 meters)
hud = LPDisplayHudMap.new(-6, -60, 1.0);

// Open the window (-> a Window)
win = LPDisplayLayoutTestWindow.new(hud).open; // the window
win = inst.open; // the controller for the window

// Export legacy one-liners:
~setSourceA = { |sym| inst.setSourceA(sym) };
~setSourceB = { |sym| inst.setSourceB(sym) };

// Pane text helper (keys: \left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString| win.sendPaneText(paneKey, aString) };

// HUD helpers to mirror your previous patch commands:
~hud_set     = { |key, value| hud.set(key, value) };
~hud_preview = { |db| hud.preview(db) };
~hud_print   = { hud.print };

// Quick ping:
~hud_print.();
)
===== LPDisplay/LPDisplayClasses_tests.scd =====
// LPDisplayClasses_tests.scd
// v0.9
// MD 20251002

LPDisplayHudMap.help;
LPDisplayLayoutTestWindow.help;
LPDisplaySigChain.help;



LPDisplayHudMap.apihelp
LPDisplayLayoutTestWindow.apihelp;
LPDisplaySigChain.apihelp;


LPDisplayHudMap.test;
LPDisplayLayoutTestWindow.test;
LPDisplaySigChain.test;
===== LPDisplay/LPDisplayHudMap.sc =====
// LPDisplayHudMap.sc
// v0.9.7.2 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local variable names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Map raw linear RMS (0..1) from SendPeakRMS into a UI-friendly 0..1 value using a dB window
 *   (topDb/floorDb) and a perceptual gamma curve. This is optional in the display window:
 *   passing nil for the HUD map means "use raw RMS 0..1".
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; numeric helpers return raw values.
 */

LPDisplayHudMap {
    classvar classVersion = "0.9.7.2";

    // Defaults for headroom window and perceptual curve
    classvar defaultTopDb   = -6.0;
    classvar defaultFloorDb = -60.0;
    classvar defaultGamma   = 1.0;

    // Instance configuration
    var topDb;     // dB at which UI reaches 1.0 (top of meter)
    var floorDb;   // dB at which UI reaches 0.0 (floor of meter)
    var gamma;     // perceptual exponent applied in UI domain

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDbArg, floorDbArg, gammaArg|
        // If any parameter is omitted, fall back to defaults above.
        ^super.new.init(
            topDbArg   ?? { defaultTopDb },
            floorDbArg ?? { defaultFloorDb },
            gammaArg   ?? { defaultGamma }
        )
    }

    init { |topDbInit, floorDbInit, gammaInit|
        // Store parameters and keep gamma numerically safe.
        topDb   = topDbInit.asFloat;
        floorDb = floorDbInit.asFloat;
        gamma   = gammaInit.asFloat.max(1e-6);

        // Ensure a valid window (top must be above floor).
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        // Small setter to tweak parameters at runtime (e.g., \top -> -9, \gamma -> 1.2).
        var paramKey = key.asSymbol;
        var paramVal = value.asFloat;

        if (paramKey == \top)   { topDb = paramVal };
        if (paramKey == \floor) { floorDb = paramVal };
        if (paramKey == \gamma) { gamma = paramVal.max(1e-6) };

        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |linearRms|
        /*
         * Convert a raw linear RMS (0..1) into a UI fraction (0..1):
         * 1) Convert linear amplitude to dBFS.
         * 2) Clip to [floorDb, topDb] window.
         * 3) Normalize to [0,1] and apply gamma.
         */
        var linearClamped      = linearRms.max(1e-9);  // avoid -inf dB
        var amplitudeDb        = linearClamped.ampdb;  // linear -> dBFS
        var topDbLimit         = topDb.asFloat;
        var floorDbLimit       = floorDb.asFloat;
        var gammaLocal         = gamma.asFloat.max(1e-6);
        var uiValue;

        amplitudeDb = amplitudeDb.clip(floorDbLimit, topDbLimit);
        uiValue     = (amplitudeDb - floorDbLimit) / (topDbLimit - floorDbLimit);
        uiValue     = uiValue.pow(gammaLocal);
        ^uiValue.clip(0.0, 1.0)
    }

    preview { |rmsDbValue|
        // Convenience: preview the UI value you‚Äôd get for a given RMS dB input.
        var linearFromDb             = rmsDbValue.dbamp.clip(1e-9, 1.0);
        var uiValue                  = this.mapLinToUi(linearFromDb);
        ("HUD UI -> " ++ uiValue.round(0.003) ++ " for " ++ rmsDbValue ++ " dBFS RMS").postln;
        ^uiValue
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }


	/////



	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplayHudMap ‚Äî purpose:",
        "  Map raw linear RMS (0..1) to UI (0..1) using a dB headroom window and gamma.",
        "",
        "Constructor:",
        "  LPDisplayHudMap.new(topDb = -6, floorDb = -60, gamma = 1.0)",
        "",
        "Key methods:",
        "  .set(\\top|\\floor|\\gamma, value)  // tweak mapping",
        "  .mapLinToUi(linearRms)              // 0..1 -> 0..1 UI",
        "  .preview(rmsDb)                     // prints & returns UI for a dB value",
        "  .print()                            // print current mapping",
        "",
        "Tip: In LPDisplayLayoutTestWindow, setHudMap(nil) disables mapping (raw 0..1)."
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplayHudMap.apihelp ‚Äî quick recipes:",
        "  h = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  h.preview(-9);                // see UI at -9 dB RMS",
        "  h.set(\\top, -9).print;        // move top to -9 dB RMS",
        "  h.set(\\gamma, 1.2).print;     // increase perceptual curvature",
        "  // In the layout window:",
        "  //  ~inst.setHudMap(h);         // enable mapping",
        "  //  ~inst.setHudMap(nil);       // disable mapping (raw 0..1)"
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var hud, dbCases, lastUi, passAll;
    hud = this.new(-6, -60, 1.0);
    dbCases = [-60, -30, -18, -12, -9, -6, -3, 0]; // typical points
    lastUi = -1.0;
    passAll = true;

    "LPDisplayHudMap.test ‚Äî monotonicity & bounds:".postln;
    dbCases.do({ |dbVal|
        var uiVal;
        uiVal = hud.preview(dbVal); // prints & returns
        if (uiVal < lastUi) { passAll = false };
        if ((uiVal < 0.0) or: { uiVal > 1.0 }) { passAll = false };
        lastUi = uiVal;
    });

    if (passAll) {
        "LPDisplayHudMap.test: PASS".postln;
    } {
        "LPDisplayHudMap.test: FAIL (non-monotonic or out-of-bounds)".postln;
    };
    ^passAll
}
}
===== LPDisplay/LPDisplayLayoutTestWindow.sc =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.4 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints gated
// MD 2025-10-01
/*
 * 0.9.7.4 add consoleLevelsOn flag (default false) to gate console prints
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
 - builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
 - sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
 - receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
 - posts decimated level prints to the console for A/B (~1 Hz),
 - has methods
   open, close
   setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
   sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
   setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping
Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/
LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.4"; // printed at class-load time

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // NEW: console print gate (default OFF)
    var consoleLevelsOn;

    // --- Meter mapping (optional)
    // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
    var meterHudMap;

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |meterHudMapInstance|
        // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
        ^super.new.init(meterHudMapInstance)
    }

    *open { |meterHudMapInstance|
        // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
        ^this.new(meterHudMapInstance).open
    }

    init { |meterHudMapInstance|
        // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
        meterHudMap = meterHudMapInstance;
        paneColor = Color(0.0, 0.35, 0.0);

        // OSCdef keys (names) for GUI and console responders
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;

        // NEW: default OFF
        consoleLevelsOn = false;

        ^this
    }

    // --- Public API -----------------------------------------------------------

    open {
        Window.allWindows.do { |existingWindow|
            if (existingWindow.name == "Layout Test") { existingWindow.close }
        }; // ensure only one with this title
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        // Free any live OSCdefs and stop sinks before closing the window
        var oscGuiDefA = OSCdef(oscNameA);
        var oscGuiDefB = OSCdef(oscNameB);
        var oscConsoleDefA = OSCdef(oscConsoleA);
        var oscConsoleDefB = OSCdef(oscConsoleB);

        if (oscGuiDefA.notNil) { oscGuiDefA.free };
        if (oscGuiDefB.notNil) { oscGuiDefB.free };
        if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
        if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup: onClose will not call back into close()
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |sourceSymbol|
        if (chainA.notNil) {
            chainA.setTailSource(sourceSymbol);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |sourceSymbol|
        if (chainB.notNil) {
            chainB.setTailSource(sourceSymbol);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var paneKeySymbol = paneKey.asSymbol;
        var textString = aString.asString;
        {
            if (paneKeySymbol == \left   and: { topLeftText.notNil  }) { topLeftText.string_(textString) };
            if (paneKeySymbol == \right  and: { topRightText.notNil }) { topRightText.string_(textString) };
            if (paneKeySymbol == \system and: { systemText.notNil   }) { systemText.string_(textString) };
            if (paneKeySymbol == \diag   and: { diagText.notNil     }) { diagText.string_(textString) };
            if (paneKeySymbol == \choices and: { choicesText.notNil }) { choicesText.string_(textString) };
            if (paneKeySymbol == \recv   and: { recvText.notNil     }) { recvText.string_(textString) };
        }.defer;
        ^this
    }

    setHudMap { |hudMapOrNil|
        // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
        // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
        meterHudMap = hudMapOrNil;
        ^this
    }

    printHud {
        if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // NEW: convenience setter to toggle console prints
    setConsoleLevelsOn { |flag = false|
        consoleLevelsOn = flag.asBoolean;
        ^this
    }

    // --- Internal build steps -------------------------------------------------

    /* Make one labeled pane (internal helper)
     * Returns a UserView that draws a border and hosts a label + provided content.
     */
    makePane { |content, label|
        var labelView, inner, pane, inset;
        labelView = StaticText()
            .string_(label)
            .align_(\center)
            .stringColor_(Color.white)
            .background_(paneColor);
        inner = VLayout(labelView, content);
        pane  = UserView().layout_(inner);
        pane.drawFunc_({ |view|
            inset = 0.5;
            Pen.use {
                Pen.color = paneColor;
                Pen.width = 1;
                Pen.addRect(Rect(
                    inset, inset,
                    view.bounds.width - (2 * inset),
                    view.bounds.height - (2 * inset)
                ));
                Pen.stroke;
            };
        });
        ^pane
    }

    buildWindow {
        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText  = TextView().editable_(false);
        topLeftMeter = LevelIndicator().fixedWidth_(30);
        topRightText = TextView().editable_(false);
        topRightMeter= LevelIndicator().fixedWidth_(30);
        systemText   = TextView();
        diagText     = TextView();
        choicesText  = TextView();
        recvText     = TextView();

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var oscGuiDefA = OSCdef(oscNameA);
            var oscGuiDefB = OSCdef(oscNameB);
            var oscConsoleDefA = OSCdef(oscConsoleA);
            var oscConsoleDefB = OSCdef(oscConsoleB);

            if (oscGuiDefA.notNil) { oscGuiDefA.free };
            if (oscGuiDefB.notNil) { oscGuiDefB.free };
            if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
            if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var extractLinearRmsFromOscMessage;
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
            extractLinearRmsFromOscMessage = { |oscMessage|
                var linearRms = 0.0, messageSize;
                if (oscMessage.notNil) {
                    messageSize = oscMessage.size;
                    if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
                };
                linearRms.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
            OSCdef(oscNameA, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation), now gated by 'consoleLevelsOn'
            OSCdef(oscConsoleA, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpA) {
                        ("A first msg: %".format(oscMessage)).postln;
                        firstDumpA = false;
                    };
                    countA = countA + 1;
                    if (countA >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countA = 0;
                    };
                } {
                    // printing disabled ‚Äî keep counters steady or reset if you prefer
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpB) {
                        ("B first msg: %".format(oscMessage)).postln;
                        firstDumpB = false;
                    };
                    countB = countB + 1;
                    if (countB >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countB = 0;
                    };
                } {
                    // printing disabled ‚Äî keep counters steady or reset if you prefer
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 2) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
        // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
        // but keeping these IDs preserves compatibility with prior tools and logs.
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
            sig
        });
        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
            sig
        });
        ^this
    }

    // --- Utility: docs & smoke test (add-only) --------------------------------

    *help {
        var lines;
        lines = [
            "LPDisplayLayoutTestWindow ‚Äî purpose:",
            " Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
            " wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
            "",
            "Constructor & convenience:",
            " w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open; // -> a Window",
            " w = LPDisplayLayoutTestWindow.open(nil); // raw meters (no HUD mapping)",
            "",
            "Key methods (instance):",
            " .open -> a Window .close",
            " .setSourceA(\\sym) .setSourceB(\\sym)",
            " .sendPaneText(\\diag, \"...\")",
            " .setHudMap( mapOrNil ) .printHud",
            "",
            "Notes:",
            " - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
            " - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
        ];
        lines.do(_.postln);
        ^this
    }

    *apihelp {
        var lines;
        lines = [
            "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
            " // bring-up (HUD mapped):",
            " ~hud = LPDisplayHudMap.new(-6, -60, 1.0);",
            " ~inst = LPDisplayLayoutTestWindow.new(~hud);",
            " ~win = ~inst.open; // -> a Window",
            "",
            " // swap sources:",
            " ~inst.setSourceA(\\srcC);",
            " ~inst.setSourceB(\\srcA);",
            "",
            " // pane text:",
            " ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
            "",
            " // HUD on/off:",
            " ~inst.setHudMap(nil);",
            " ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
            "",
            " // console levels on/off:",
            " ~inst.setConsoleLevelsOn(true);   // enable A/B level prints",
            " ~inst.setConsoleLevelsOn(false);  // disable prints (default)",
            "",
            " // class-side one-liner:",
            " LPDisplayLayoutTestWindow.open(nil); // raw meters"
        ];
        lines.do(_.postln);
        ^this
    }

    *test {
        var inst, win, passOsc, posted;
        inst = this.new(nil); // raw meters (no HUD)
        win  = inst.open;     // -> a Window
        // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
        AppClock.sched(0.5, {
            passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };
            inst.setSourceA(\srcC);
            inst.setSourceB(\srcA);
            inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);
            AppClock.sched(1.0, {
                inst.close;
                posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
                posted.postln;
                nil
            });
            nil
        });
        ^win // handy if you want to keep the window reference
    }
}
===== LPDisplay/LPDisplayLayoutTestWindow.sc.txt =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping


Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}
===== LPDisplay/LPDisplaySigChain.sc =====
// LPDisplaySigChain.sc
// v0.9.7.2 ‚Äî minimal [sink, ..., source] JITLib chain wrapper
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local/parameter names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Manage a simple symbol chain [sink, ..., source] using JITLib wiring:
 *   Ndef(left) <<> Ndef(right), where the left node reads \in.ar(2).
 * - Ensure stereo busses prior to wiring; play the sink.
 *
 * Typical usage
 *   LPDisplaySigChain.new([\outA, \srcA]).rebuild;       // wires and plays sink
 *   chain.setTailSource(\srcC).rebuild;                  // swap just the tail
 *   chain.chainToString  // "srcC ‚Üí outA"
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; getters return values.
 */

LPDisplaySigChain {
    classvar classVersion = "0.9.7.2";

    var chainSymbols;  // Array(Symbol): [sink, ..., source]

    *initClass {
        ("LPDisplaySigChain v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |chainSymbolsArray|
        ^super.new.init(chainSymbolsArray ?? { [] })
    }

    init { |chainSymbolsArray|
        chainSymbols = chainSymbolsArray.copy;
        ^this
    }

    size {
        ^chainSymbols.size
    }

    ensureStereo { |ndefKey|
        /*
         * Pre-arm an Ndef as a 2-channel audio node if its bus is missing or not stereo.
         * This prevents wiring failures when we connect nodes with <<>.
         */
        var ndefBus = Ndef(ndefKey).bus;
        if (ndefBus.isNil or: { ndefBus.rate != \audio } or: { ndefBus.numChannels != 2 }) {
            Ndef(ndefKey).ar(2);
        };
        ^this
    }

    rebuild {
        /*
         * Wire the chain left-to-right:
         *   chainSymbols = [sink, mid1, mid2, source]
         * becomes:
         *   Ndef(sink) <<> Ndef(mid1);  Ndef(mid1) <<> Ndef(mid2);  Ndef(mid2) <<> Ndef(source)
         * and then play the sink stereo.
         */
        var chainSize  = chainSymbols.size;
        var linkIndex  = 0;

        if (chainSize < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
            ^this
        };

        chainSymbols.do { |ndefSymbol| this.ensureStereo(ndefSymbol) };

        while({ linkIndex < (chainSize - 1) }, {
            Ndef(chainSymbols[linkIndex]) <<> Ndef(chainSymbols[linkIndex + 1]);
            linkIndex = linkIndex + 1;
        });

        Ndef(chainSymbols[0]).play(numChannels: 2);  // play the sink
        ^this
    }

    chainToString {
        // For display we show "source ‚Üí ... ‚Üí sink"
        var forwardList = chainSymbols.copy.reverse;
        ^forwardList.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |tailSourceSymbol|
        // Replace/append the final element (source) and keep the chain consistent.
        var newSourceSymbol = tailSourceSymbol.asSymbol;

        if (chainSymbols.size >= 2) {
            chainSymbols[chainSymbols.size - 1] = newSourceSymbol;
        } {
            chainSymbols = chainSymbols.add(newSourceSymbol);
        };

        ^this.rebuild
    }

    symbols {
        // Read-only copy so external code doesn‚Äôt mutate internal state.
        var symbolsCopy = chainSymbols.copy;
        ^symbolsCopy
    }



	////////
	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplaySigChain ‚Äî purpose:",
        "  Wrap a symbol chain [sink, ..., source] and wire via:",
        "    Ndef(left) <<> Ndef(right)  (sink reads \\in.ar(2))",
        "",
        "Constructor:",
        "  LPDisplaySigChain.new([\\outA, \\srcA])",
        "",
        "Key methods:",
        "  .rebuild()                   // ensure stereo, wire, play sink",
        "  .setTailSource(\\srcC)       // swap the final source and rebuild",
        "  .chainToString               // e.g., 'srcC ‚Üí outA'",
        "  .symbols                     // copy of [sink, ..., source]",
        ""
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplaySigChain.apihelp ‚Äî quick recipes:",
        "  c = LPDisplaySigChain.new([\\outA, \\srcA]).rebuild;",
        "  c.setTailSource(\\srcC);",
        "  c.chainToString.postln;  // 'srcC ‚Üí outA'",
        "",
        "Note: Ensure sinks read \\in.ar(2) and that sources produce stereo."
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var srcKey, sinkKey, chain, okFlag;

    // Use single-backslash for Symbol literals:
    srcKey  = \_lpdisp_test_src;
    sinkKey = \_lpdisp_test_sink;

    okFlag  = true;

    Server.default.waitForBoot({
        // ephemeral test nodes
        Ndef(srcKey,  { PinkNoise.ar(0.02 ! 2) });  // quiet stereo
        Ndef(sinkKey, {
            var sig = \in.ar(2);
            // no SendPeakRMS here to keep test minimal
            sig
        });

        chain = this.new([sinkKey, srcKey]).rebuild;

        // brief run, then cleanup
        AppClock.sched(0.4, {
            var busOk;
            busOk = Ndef(sinkKey).bus.notNil and: { Ndef(sinkKey).isPlaying };
            if (busOk.not) { okFlag = false };

            Ndef(sinkKey).stop;
            Ndef(srcKey).clear(0.2);  // fade out

            ("LPDisplaySigChain.test: " ++ (okFlag.if("PASS", "FAIL"))).postln;
            nil
        });
    });
    ^this
}

}
===== LPDisplay/older versions/LPDisplayHudMap copy.sc_v0.9.4 =====
// LPDisplayHudMap
// v0.9.4 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 20251001


// This class at the moment is just rescaling values between 0 and 1 for the meters to more perceptually correct relationships. Top, floor, gamma. It is optional.

LPDisplayHudMap {
    classvar classVersion = "0.9.4";

    var topDb;
    var floorDb;
    var gamma;

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDb, floorDb, gamma|
        ^super.new.init(
            topDb ?? { -6.0 },
            floorDb ?? { -60.0 },
            gamma  ?? { 1.0 }
        )
    }

    init { |t, f, g|
        topDb   = t.asFloat;
        floorDb = f.asFloat;
        gamma   = g.asFloat.max(1e-6);
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        var k = key.asSymbol;
        var v = value.asFloat;
        if (k == \top)   { topDb = v };
        if (k == \floor) { floorDb = v };
        if (k == \gamma) { gamma = v.max(1e-6) };
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |lin|
        var v   = lin.max(1e-9);
        var vdb = v.ampdb;
        var tdb = topDb, fdb = floorDb, g = gamma;
        vdb = vdb.clip(fdb, tdb);
        ^(((vdb - fdb) / (tdb - fdb)).pow(g)).clip(0.0, 1.0)
    }

    preview { |db|
        var lin = db.dbamp.clip(1e-9, 1.0);
        var u   = this.mapLinToUi(lin);
        ("HUD UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
        ^u
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }
}
===== LPDisplay/older versions/LPDisplayHudMap.sc_buggy =====
// LPDisplayHudMap.sc
// v0.9.2 - dB‚ÜíUI mapping for meters (top/floor/gamma) + preview/print
// MD 20251001

/* Purpose
 - Provide a reusable mapping from linear RMS (0..1) to UI (0..1) using dB headroom
   and a perceptual gamma. Includes helpers to set, preview and print.
 Style
 - var-first declarations in every method block
 - lowercase method names
 - no non-local returns (^) in function blocks; normal method returns via last expr
*/

LPDisplayHudMap {
    classvar <>version;
    classvar <>defaultTopDb = -6.0, <>defaultFloorDb = -60.0, <>defaultGamma = 1.0;

    var topDb;
    var floorDb;
    var gamma;

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplayHudMap v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDb, floorDb, gamma|
        var obj, t, f, g;
        t = topDb ?? { defaultTopDb };
        f = floorDb ?? { defaultFloorDb };
        g = gamma  ?? { defaultGamma };
        obj = super.new;
        obj.init(t, f, g);
        obj
    }

    init { |t, f, g|
        var tg;
        topDb = t.asFloat;
        floorDb = f.asFloat;
        tg = g.asFloat.max(1e-6);
        gamma = tg;
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            ("LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.").postln;
        };
        this
    }

    set { |key, value|
        var k, v, tmp;
        k = key.asSymbol;
        v = value.asFloat;
        if (k == \top) { topDb = v };
        if (k == \floor) { floorDb = v };
        if (k == \gamma) { gamma = v.max(1e-6) };
        if (topDb <= floorDb) {
            tmp = topDb;
            topDb = floorDb + 0.1;
            ("LPDisplayHudMap: adjusted top to floor+0.1 (was " ++ tmp ++ ")").postln;
        };
        this
    }

    mapLinToUi { |lin|
        var v, vdb, tdb, fdb, g, u;
        v = lin.max(1e-9);
        vdb = v.ampdb;
        tdb = topDb.asFloat;
        fdb = floorDb.asFloat;
        g = gamma.asFloat.max(1e-6);
        vdb = vdb.clip(fdb, tdb);
        u = (vdb - fdb) / (tdb - fdb);
        u = u.pow(g);
        u.clip(0.0, 1.0)
    }

    preview { |db|
        var lin, dbClipped, u;
        lin = db.dbamp.clip(1e-9, 1.0);
        dbClipped = lin.ampdb.clip(floorDb, topDb);
        u = (dbClipped - floorDb) / (topDb - floorDb);
        u = u.pow(gamma);
        ("HUD UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
        u
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        this
    }
}

===== LPDisplay/older versions/LPDisplayLayoutTestWindow copy.txt =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.1 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1‚ÄØHz),
- has methods
        open, close
        setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
        sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
        setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
    LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
    LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
 */

LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.1";

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // optional; if nil, the meters take raw SendPeakRMS linear RMS.

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } }; //closes any same name window
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------


	/* Make one labeled pane (internal helper)
 * Returns a UserView that draws a border and hosts a label + provided content.
 */
makePane { |content, label|
    var labelView, inner, pane, inset;

    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);

    inner = VLayout(labelView, content);

    pane = UserView().layout_(inner);

    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(
                inset, inset,
                v.bounds.width  - (2 * inset),
                v.bounds.height - (2 * inset)
            ));
            Pen.stroke;
        };
    });

    ^pane
}


    buildWindow {
        //var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

/*        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };*/

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 2) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
			var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_buggy =====
// LPDisplayLayoutTestWindow.sc
// v0.9.2 - Grid window with A/B chains, LevelIndicators, OSC responders & console prints
// MD 20251001

/* Purpose
 - Recreate (and organize) the Layout Test window as a class with:
   labeled panes (left/right/system/diag/choices/recv), moving meters for A/B via
   SendPeakRMS, readable chain labels, quick methods to change tail sources, optional HUD mapping.
 - Keeps console level printers with ~1 Hz decimation and first-message dumps.
 Style
 - var-first declarations in every method block
 - lowercase method names; no non-local returns (^) inside function blocks
 - GUI updates via AppClock.defer; sinks read \in.ar(2)
 - JITLib operator strictly Ndef(left) <<> Ndef(right)
*/

LPDisplayLayoutTestWindow {
    classvar version;

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC names/defs
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // LPDisplayHudMap or nil

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplayLayoutTestWindow v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        var obj;
        obj = super.new;
        obj.init(hudMapInstance);
        obj
    }

    init { |hudMapInstance|
        var hm;
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        hm = hudMapInstance;
        hudMap = hm;
        paneColor = Color(0.0, 0.35, 0.0);
        this
    }

    // -------------------------- Public API --------------------------

    open {
        var wasOpen;
        wasOpen = false;
        Window.allWindows.do({ |w| if (w.name == "Layout Test", { wasOpen = true; w.close }) });
        this.buildWindow;
        this.bootAndBuildGraph;
        window // -> a Window
    }

    close {
        var a, b, ca, cb;
        if (window.notNil) {
            a = OSCdef(oscNameA);
            b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA);
            cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
            window.close;
            window = nil;
        };
        this
    }

    setSourceA { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainA.notNil) {
            chainA.setTailSource(s);
            { topLeftText.string_(chainA.chainToString) }.defer;
        };
        this
    }

    setSourceB { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainB.notNil) {
            chainB.setTailSource(s);
            { topRightText.string_(chainB.chainToString) }.defer;
        };
        this
    }

    sendPaneText { |paneKey, aString|
        var k, t;
        k = paneKey.asSymbol;
        t = aString.asString;
        if (k == \left)  { { topLeftText.string_(t)  }.defer };
        if (k == \right) { { topRightText.string_(t) }.defer };
        if (k == \system)  { { systemText.string_(t)  }.defer };
        if (k == \diag)    { { diagText.string_(t)    }.defer };
        if (k == \choices) { { choicesText.string_(t) }.defer };
        if (k == \recv)    { { recvText.string_(t)    }.defer };
        this
    }

    setHudMap { |mapOrNil|
        var m;
        m = mapOrNil;
        hudMap = m;
        this
    }

    printHud {
        var m;
        m = hudMap;
        if (m.notNil) { m.print } { "HUD mapping: none (raw 0..1)".postln };
        this
    }

    // ------------------------ Internal build steps ------------------------

    buildWindow {
        var buildLabeledPane;

        buildLabeledPane = { |content, label|
            var labelViewLocal, innerLocal, paneLocal, inset;
            labelViewLocal = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            innerLocal = VLayout(labelViewLocal, content);
            paneLocal = UserView().layout_(innerLocal);
            paneLocal.drawFunc_({ |v|
                var insetLocal;
                insetLocal = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(insetLocal, insetLocal, v.bounds.width - (2 * insetLocal), v.bounds.height - (2 * insetLocal)));
                    Pen.stroke;
                };
            });
            paneLocal
        };

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                buildLabeledPane.(HLayout(
                    topLeftText  = TextView().editable_(false),
                    topLeftMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Left Pane"),
                buildLabeledPane.(HLayout(
                    topRightText  = TextView().editable_(false),
                    topRightMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Right Pane")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), systemText  = TextView()), "System State"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), diagText    = TextView()), "Diagnostic Messages")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), choicesText = TextView()), "Choices"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), recvText    = TextView()), "Receiving Commands")
            ]
        );

        window.onClose = {
            var a, b, ca, cb;
            a = OSCdef(oscNameA); b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA); cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        this
    }

    bootAndBuildGraph {
        var valueFromMsg;

        Server.default.waitForBoot({
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI
            {
                topLeftText.string_(chainA.chainToString);
                topRightText.string_(chainB.chainToString);
            }.defer;

            // (Re)bind OSC responders (avoid duplicates)
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Extract last numeric value (typically RMS)
            valueFromMsg = { |msg|
                var v, sz;
                v = 0.0;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meter updaters (20 Hz)
            OSCdef(oscNameA, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topLeftMeter.value_(ui) }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topRightMeter.value_(ui) }.defer;
            }, '/peakrmsB');

            // Console printers (~1 Hz via decimation) + first-message dump
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (must read \in.ar(2)) + SendPeakRMS
        // Keep replyIDs A=1, B=2 to match earlier dumps.
        Ndef(\outA, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        this
    }
}

===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.4 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.2 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01
/*
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.2";  // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms     = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi  = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms     = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi  = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.6 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.6 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.6

 * - Pre-create pane views before composing layout to avoid nil during deferred updates
 * - Nil-safe deferred UI writes
 * - onClose only frees resources; close() handles actual window close
 * - Conventional SC class style (*new, *open, ^this / ^window)
 */

LPDisplayLayoutTestWindow {
    classvar version;

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // LPDisplayHudMap or nil

    *initClass {
        version = "0.9.6";
        ("LPDisplayLayoutTestWindow v" ++ version ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } };
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------

    buildWindow {
        var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.7.1 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.1 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.7.1 move makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1‚ÄØHz),
- has methods
        open, close
        setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
        sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
        setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
    LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
    LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
 */

LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.1";

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // optional; if nil, the meters take raw SendPeakRMS linear RMS.

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } }; //closes any same name window
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------


	/* Make one labeled pane (internal helper)
 * Returns a UserView that draws a border and hosts a label + provided content.
 */
makePane { |content, label|
    var labelView, inner, pane, inset;

    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);

    inner = VLayout(labelView, content);

    pane = UserView().layout_(inner);

    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(
                inset, inset,
                v.bounds.width  - (2 * inset),
                v.bounds.height - (2 * inset)
            ));
            Pen.stroke;
        };
    });

    ^pane
}


    buildWindow {
        //var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

/*        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };*/

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc.0.9.7.3 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping


Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}
===== LPDisplay/older versions/LPDisplaySigChain.sc_buggy =====
// LPDisplaySigChain.sc
// v0.9.2 - minimal [sink, ..., source] chain wrapper with JITLib wiring
// MD 20251001

/* Purpose
 - Manage a simple symbol chain [sink, ... , source] using Ndef and <<> wiring.
 - Ensure stereo busses for nodes prior to wiring; play the sink.
 - Provide a readable string form and a method to switch the tail source.
 Style
 - var-first declarations in every method block
 - lowercase method names / descriptive names
 - JITLib operator strictly Ndef(left) <<> Ndef(right)
 - no non-local returns (^) in function blocks
*/

LPDisplaySigChain {
    classvar <>version;

    var chainArray; // [sink, ..., source] (Symbols)

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplaySigChain v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |symbolsArray|
        var obj;
        obj = super.new;
        obj.init(symbolsArray ?? { [] });
        obj
    }

    init { |symbolsArray|
        var arr;
        arr = symbolsArray.copy;
        chainArray = arr;
        this
    }

    size {
        var n;
        n = chainArray.size;
        n
    }

    ensureStereo { |key|
        var bus;
        bus = Ndef(key).bus;
        if (bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2); // pre-arm
        };
        this
    }

    rebuild {
        var i, n;
        n = chainArray.size;
        if (n < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
        } {
            chainArray.do({ |sym| this.ensureStereo(sym) });
            i = 0;
            while({ i < (n - 1) }, {
                Ndef(chainArray[i]) <<> Ndef(chainArray[i + 1]); // sink receives from next
                i = i + 1;
            });
            Ndef(chainArray[0]).play(numChannels: 2);
        };
        this
    }

    chainToString {
        var forward;
        forward = chainArray.copy.reverse; // [source ... sink] for display
        forward.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |srcSym|
        var newSym;
        newSym = srcSym.asSymbol;
        if (chainArray.size >= 2) {
            chainArray[chainArray.size - 1] = newSym;
        } {
            chainArray = chainArray.add(newSym);
        };
        this.rebuild
    }

    symbols {
        var copy;
        copy = chainArray.copy;
        copy
    }
}

===== LPDisplay/older versions/starting files/allfiles.txt =====
// commands.scd

// Make a -6 dBFS sine (‚âà -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ‚âà -9 dB RMS
~hud_preview.(-18);
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       ‚Ä¢ 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       ‚Ä¢ pulse clicks and decaying tone pulses for echo testing
       ‚Ä¢ band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       ‚Ä¢ switch A/B sources quickly
       ‚Ä¢ update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready ‚Äî quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands‚Ä¶");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" ‚Üí ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== LPDisplay/older versions/starting files/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (‚âà -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ‚âà -9 dB RMS
~hud_preview.(-18);

===== LPDisplay/older versions/starting files/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== LPDisplay/older versions/starting files/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       ‚Ä¢ 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       ‚Ä¢ pulse clicks and decaying tone pulses for echo testing
       ‚Ä¢ band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       ‚Ä¢ switch A/B sources quickly
       ‚Ä¢ update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready ‚Äî quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands‚Ä¶");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== LPDisplay/older versions/starting files/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" ‚Üí ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== LPDisplay/README_LivePedalboardDisplay.md =====
# LivePedalboardDisplay - README (reStructuredText)

## Overview

LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

-   LPDisplayLayoutTestWindow - a 6-pane grid window with two meters
    (A/B) driven by SendPeakRMS, plus simple control methods.
-   LPDisplaySigChain - a helper to wire a symbol chain \[sink, \...,
    source\] using Ndef(left) \<\<\> Ndef(right) with stereo pre-arming.
-   LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to
    UI (0..1) using a dB window (top/floor) and gamma.

## Install

Place the .sc files under this path (copy exactly):

::

:   \.../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually
symlinked into Extensions). Then recompile the class library:

::

:   Language -\> Recompile Class Library

When loaded, you should see lines like:

::

:   LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

## Quick Start

SuperCollider snippet (copy/paste into the IDE):

::

:   

    (

    :   var hud = LPDisplayHudMap.new(-6, -60, 1.0); // top/floor/gamma
        \~inst = LPDisplayLayoutTestWindow.new(hud); \~win =
        \~inst.open; // -\> a Window

    )

    // Swap tail sources and write a status line
    \~inst.setSourceA(srcC); \~inst.setSourceB(srcA);
    \~inst.sendPaneText(diag, \"Ready @ \" ++ Date.getDate.stamp);

    // HUD on/off \~inst.setHudMap(nil); // raw 0..1 meters
    \~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close \~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

## Classes

### LPDisplayLayoutTestWindow

-   Builds a 6-pane grid with top-left/right meters (LevelIndicator).
-   Wires two chains: \[outA, srcA\] and \[outB, srcB\] using
    LPDisplaySigChain.
-   Updates meters from SendPeakRMS via OSCdef(rmsA_toGUI) and
    OSCdef(rmsB_toGUI).
-   Prints decimated console levels via OSCdef(rmsA_console) and
    OSCdef(rmsB_console).
-   Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw
    values).

### Why replyID?

We keep replyID as A=1 and B=2 in SendPeakRMS.kr(\..., \'/peakrmsA\', 1)
and (\..., \'/peakrmsB\', 2) to preserve continuity with older
dumps/tools. The OSC addresses already differ; replyID is kept for
backward compatibility.

### Key instance methods

-   open -\> Window, close
-   setSourceA(sym), setSourceB(sym)
-   sendPaneText(leftsystemchoices\|recv, \"text\")
-   setHudMap(instanceOrNil), printHud

### Class-side utilities

-   .help, .apihelp, .test

### LPDisplaySigChain

-   Wires a chain \[sink, \..., source\] using Ndef(left) \<\<\>
    Ndef(right).
-   Ensures stereo busses and plays the sink.
-   Key methods: rebuild, size, symbols (copy), setTailSource(srcX),
    chainToString.
-   Class-side utilities: .help, .apihelp, .test

### LPDisplayHudMap

-   Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor)
    and gamma.
-   Pass nil to the window\'s setHudMap to bypass mapping and show raw
    values.
-   Key methods: set(topgamma, value), mapLinToUi(linearRms),
    preview(rmsDb), print.
-   Class-side utilities: .help, .apihelp, .test

## Smoke Tests

Run these in SuperCollider:

::

:   LPDisplaySigChain.test; // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test; // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips
    sources, closes

## Troubleshooting

-   

    Meters not moving:

    :   OSCdef(rmsA_toGUI).notNil; OSCdef(rmsB_toGUI).notNil. Sinks must
        read `\in.ar(2)`. Chains should be playing (sink Ndef is
        .play\'ed by LPDisplaySigChain.rebuild). If you changed sink OSC
        addresses, update the OSCdef addresses accordingly.

-   

    [string]() DNU on nil:

    :   The window pre-creates views. If you extend it, create views
        first, then compose the layout; update UI via `{ ... }.defer`
        with notNil guards.

-   

    Compile errors after edits:

    :   Class-side methods (*help,*apihelp, \*test) must be at class
        scope (not nested). Symbol literals use a single backslash:
        `\symbol` (not `\\symbol`).

## Style and Conventions

-   \*new { \^super.new.init(\...) }
-   var-first in method bodies; clear names
-   No non-local returns inside inner Functions
-   GUI updates via `{ ... }.defer`
-   JITLib wiring strictly `Ndef(left) <<> Ndef(right)`
-   Sinks read `\in.ar(2)`

## Versioning

Each class defines classVersion and prints a banner at class load time.
You should see lines like these after a recompile:

::

:   LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

## Optional: One-button regression

Save as this path (copy exactly):

::

:   LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::

:   

    (

    :   var hudPass, sigPass, win, posted; hudPass =
        LPDisplayHudMap.test; sigPass = { LPDisplaySigChain.test; true
        }.value; win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, { var allGreen = hudPass and: sigPass;
        (\"LivePedalboardDisplay SMOKE: \" ++ (allGreen.if(\"PASS\",
        \"WARN/FAIL\"))).postln; nil });

    )

===== LPDisplay/README_LivePedalboardDisplay.rst =====
LivePedalboardDisplay - README (reStructuredText)
=================================================

Overview
--------
LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

- LPDisplayLayoutTestWindow - a 6-pane grid window with two meters (A/B) driven by SendPeakRMS, plus simple control methods.
- LPDisplaySigChain - a helper to wire a symbol chain [sink, ..., source] using Ndef(left) <<> Ndef(right) with stereo pre-arming.
- LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.

Install
-------
Place the .sc files under this path (copy exactly):

::
    .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually symlinked into Extensions). Then recompile the class library:

::
    Language -> Recompile Class Library

When loaded, you should see lines like:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Quick Start
-----------
SuperCollider snippet (copy/paste into the IDE):

::
    (
        var hud = LPDisplayHudMap.new(-6, -60, 1.0);  // top/floor/gamma
        ~inst = LPDisplayLayoutTestWindow.new(hud);
        ~win  = ~inst.open;  // -> a Window
    )

    // Swap tail sources and write a status line
    ~inst.setSourceA(\srcC);
    ~inst.setSourceB(\srcA);
    ~inst.sendPaneText(\diag, "Ready @ " ++ Date.getDate.stamp);

    // HUD on/off
    ~inst.setHudMap(nil);                             // raw 0..1 meters
    ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close
    ~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

Classes
-------
LPDisplayLayoutTestWindow
^^^^^^^^^^^^^^^^^^^^^^^^^^
- Builds a 6-pane grid with top-left/right meters (LevelIndicator).
- Wires two chains: [\outA, \srcA] and [\outB, \srcB] using LPDisplaySigChain.
- Updates meters from SendPeakRMS via OSCdef(\rmsA_toGUI) and OSCdef(\rmsB_toGUI).
- Prints decimated console levels via OSCdef(\rmsA_console) and OSCdef(\rmsB_console).
- Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw values).

Why replyID?
^^^^^^^^^^^^
We keep replyID as A=1 and B=2 in SendPeakRMS.kr(..., '/peakrmsA', 1) and (..., '/peakrmsB', 2) to preserve continuity with older dumps/tools. The OSC addresses already differ; replyID is kept for backward compatibility.

Key instance methods
^^^^^^^^^^^^^^^^^^^^^
- open -> Window, close
- setSourceA(\sym), setSourceB(\sym)
- sendPaneText(\left|\right|\system|\diag|\choices|\recv, "text")
- setHudMap(instanceOrNil), printHud

Class-side utilities
^^^^^^^^^^^^^^^^^^^^^
- .help, .apihelp, .test

LPDisplaySigChain
^^^^^^^^^^^^^^^^^^
- Wires a chain [sink, ..., source] using Ndef(left) <<> Ndef(right).
- Ensures stereo busses and plays the sink.
- Key methods: rebuild, size, symbols (copy), setTailSource(\srcX), chainToString.
- Class-side utilities: .help, .apihelp, .test

LPDisplayHudMap
^^^^^^^^^^^^^^^^
- Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.
- Pass nil to the window's setHudMap to bypass mapping and show raw values.
- Key methods: set(\top|\floor|\gamma, value), mapLinToUi(linearRms), preview(rmsDb), print.
- Class-side utilities: .help, .apihelp, .test

Smoke Tests
------------
Run these in SuperCollider:

::
    LPDisplaySigChain.test;         // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test;           // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips sources, closes

Troubleshooting
---------------
- Meters not moving:
    OSCdef(\rmsA_toGUI).notNil;  OSCdef(\rmsB_toGUI).notNil.
    Sinks must read ``\in.ar(2)``. Chains should be playing (sink Ndef is .play'ed by LPDisplaySigChain.rebuild).
    If you changed sink OSC addresses, update the OSCdef addresses accordingly.

- string_ DNU on nil:
    The window pre-creates views. If you extend it, create views first, then compose the layout; update UI via ``{ ... }.defer`` with notNil guards.

- Compile errors after edits:
    Class-side methods (*help, *apihelp, *test) must be at class scope (not nested).
    Symbol literals use a single backslash: ``\symbol`` (not ``\\symbol``).

Style and Conventions
----------------------
- *new { ^super.new.init(...) }
- var-first in method bodies; clear names
- No non-local returns inside inner Functions
- GUI updates via ``{ ... }.defer``
- JITLib wiring strictly ``Ndef(left) <<> Ndef(right)``
- Sinks read ``\in.ar(2)``

Versioning
----------
Each class defines classVersion and prints a banner at class load time. You should see lines like these after a recompile:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Optional: One-button regression
--------------------------------
Save as this path (copy exactly):

::
    LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::
    (
        var hudPass, sigPass, win, posted;
        hudPass = LPDisplayHudMap.test;
        sigPass = { LPDisplaySigChain.test; true }.value;
        win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, {
            var allGreen = hudPass and: sigPass;
            ("LivePedalboardDisplay SMOKE: " ++ (allGreen.if("PASS", "WARN/FAIL"))).postln;
            nil
        });
    )
===== MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation‚Äôs audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through ‚Äúprocessor‚Äù that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) ‚Üí short delay ‚Üí mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through ‚Äúprocessor‚Äù you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== MagicPedalboard/Adapter_UIHook_Install.scd =====
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)

===== MagicPedalboard/bootstrap_audio_and_fx_min.scd =====
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) ‚Äì guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) ‚Äì matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)

===== MagicPedalboard/compat/Compat_MagicDisplayGUI_QueueUi_Ext.sc =====
// Compat_MagicDisplayGUI_QueueUi_Ext.sc
// v0.1.1
// MD 2025-09-23

+MagicDisplayGUI {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

+MagicDisplayGUI_GridDemo {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

===== MagicPedalboard/demo_apply_after_fix.scd =====
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_hotfix.scd =====
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON ‚Üí OFF ‚Üí final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_now.scd =====
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_milestone.scd =====
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)

===== MagicPedalboard/demo_commandtree_preformed_queues.scd =====
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <‚Äî Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)

===== MagicPedalboard/Demo_Install_MinProcessors.scd =====
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)

===== MagicPedalboard/Diag_BusChannel_Map.scd =====
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2‚Üí1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)

===== MagicPedalboard/docs and references/cheatsheet.scd =====
// cheatsheet.cd
// MD 20250913-1037

// Inspect
~pedalboard.printChains;            // or use your display adaptor

// Build NEXT non-destructively
~pedalboard.add(\delay);
~pedalboard.bypass(\delay, true);
~pedalboard.swap(1, 2);

// Go live with a short crossfade
~pedalboard.switchChain(0.1);

// Adjust CURRENT temporarily
~pedalboard.bypassAtCurrent(1, false);

// Change sources
~pedalboard.setSource(\ts1);
~pedalboard.setSourceCurrent(\ts2);

// Panic-safe reset
~pedalboard.reset;

===== MagicPedalboard/docs and references/README.md =====

# MagicPedalboardNew ‚Äì JITLib/Ndef A/B Pedalboard

**Versions**
- `MagicPedalboardNew.sc` **v0.3.8**
- `MagicDisplay.sc` **v0.1.2**
- `MagicDisplayGUI.sc` **v0.2.3**

## Overview
`MagicPedalboardNew` manages two parallel JITLib Ndef chains (`\chainA` and `\chainB`) for live performance. One chain is CURRENT (audible), the other is NEXT (prepared silently). You can mutate NEXT and then switch to it using a short crossfade.

## Architecture
- Chains are Arrays of Symbols: `[sink, ‚Ä¶ processors ‚Ä¶, source]`
- Sinks: `\chainA`, `\chainB`
- Sources/processors: other Ndef keys (e.g., `	sSaw`, `	remolo`)
- Bypass tracked per chain using dictionaries
- Effective list excludes bypassed processors

## Display Adaptors
### MagicDisplay
- Console logger with `logLevel`
- Methods: `showInit`, `showRebuild`, `showPlay`, `showStop`, `showSwitch`, etc.

### MagicDisplayGUI
- Two columns: CURRENT (green) and NEXT (neutral)
- Top-down flow: source ‚Üí processors ‚Üí sink
- Expectation field + visual countdown
- Operations panel with Next button
- Embedded level meters
- UI-ready queue prevents nil errors

## Style Rules
- Methods start lowercase; no leading underscore
- All `var` declarations first in every method and block
- Descriptive variable names
- No `server.sync`
- Use `Server.default.bind { ‚Ä¶ }` for server ops
- Safe reset only in `reset` using `Server.default.waitForBoot { ‚Ä¶ }`
- Space after accessors (e.g., `classvar < version;`)
- File headers include filename and timestamp like `//MD 20250912-1544`

## Quick Start
```supercollider
Ndef(	s0,  { Silent.ar(2) });
Ndef(	sSaw,{ Saw.ar(200, 0.18) ! 2 });
m = MagicPedalboardNew.new;
m.setSourceCurrent(	sSaw);
m.playCurrent;
m.setSource(	sSaw);
Ndef(	remolo, { arg rate = 4, depth = 0.8; var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1) });
m.add(	remolo);
m.switchChain(0.1);
```

## Troubleshooting
- No sound: check source Ndefs and output device
- Meters update but silent: check routing
- GUI errors: use latest GUI with UI-ready queue
- `'s' not defined`: use `Server.default` in class files

## Version Highlights
- v0.3.8: No reference to `s`; safe reset only in `reset`
- v0.3.5‚Äì0.3.7: Crossfade switching, server ops cleanup
- MagicDisplayGUI v0.2.3: GUI with countdown, ops list, meters

===== MagicPedalboard/docs and references/README2.md =====

# MagicPedalboardNew ‚Äì A/B Chain Manager for Live Audio in SuperCollider

## Introduction
MagicPedalboardNew is a SuperCollider class designed to manage two parallel audio chains using JITLib's Ndef system. It is intended for live performance scenarios where one chain is actively producing sound (CURRENT), and the other is being prepared silently (NEXT). This allows performers to build or modify effects chains in real time and switch between them seamlessly.

## Design Philosophy
The system is built around the idea of non-destructive, real-time manipulation of audio chains. It avoids server resets during normal operation, ensuring stability and continuity of sound. All server interactions are safely wrapped using `Server.default.bind`, and resets are only performed in the `reset` method using `Server.default.waitForBoot`.

## Core Concepts
- **Chains**: Arrays of Symbols representing Ndef keys. Each chain is ordered `[sink, ...processors..., source]`.
- **CURRENT and NEXT**: Two chains, one active and audible (CURRENT), the other silent and editable (NEXT).
- **Switching**: A crossfade mechanism allows smooth transitions from CURRENT to NEXT.
- **Bypassing**: Individual processors can be bypassed without removing them.
- **Effective List**: The chain with bypassed processors removed, used for actual signal routing.

## Class Details
### MagicPedalboardNew
- `currentChain`, `nextChain`: Pointers to the active and editable chains.
- `chainAList`, `chainBList`: Concrete arrays for each chain.
- `bypassA`, `bypassB`: Dictionaries tracking bypassed processors.
- `defaultNumChannels`: Number of audio channels (typically 2).
- `defaultSource`: Default source Ndef key.
- `display`: Optional display adaptor (console or GUI).

### Methods
- `add`, `addAt`, `removeAt`, `swap`, `clearChain`: Modify NEXT chain.
- `bypass`, `bypassAt`: Bypass processors in NEXT.
- `bypassCurrent`, `bypassAtCurrent`: Bypass processors in CURRENT.
- `setSource`, `setSourceCurrent`: Set source for NEXT or CURRENT.
- `switchChain`: Crossfade from CURRENT to NEXT.
- `reset`: Safely reset server and chains.
- `rebuild`, `rebuildUnbound`: Wire chains using `<<>`.

## GUI Explanation
### MagicDisplayGUI
This GUI provides a visual representation of the CURRENT and NEXT chains:
- **Two Columns**: CURRENT (highlighted in green) and NEXT.
- **Top-Down Flow**: Chains are displayed from source (top) to sink (bottom), matching audio signal flow.
- **Expectation Field**: A text area describing what the user should hear. This helps performers anticipate changes.
- **Visual Countdown**: A numeric and graphical countdown timer appears before a change, allowing the performer to shift attention.
- **Operations Panel**: Lists upcoming actions with a "Next" button. Pressing it starts a 3-second countdown before executing the action.
- **Embedded Meters**: Real-time level indicators for chainA and chainB, helping monitor audio activity.

## Style Rules
- Methods start lowercase; no leading underscores.
- All `var` declarations appear first in every method and block.
- Descriptive variable names; no single-letter variables.
- No `server.sync`.
- Use `Server.default.bind { ... }` for server operations.
- Safe reset only in `reset` using `Server.default.waitForBoot { ... }`.
- Space after accessors (e.g., `classvar < version;`).
- File headers include filename and timestamp like `//MD 20250912-1544`.

## Quick Start
```supercollider
Ndef(	s0,  { Silent.ar(2) });
Ndef(	sSaw,{ Saw.ar(200, 0.18) ! 2 });
m = MagicPedalboardNew.new;
m.setSourceCurrent(	sSaw);
m.playCurrent;
m.setSource(	sSaw);
Ndef(	remolo, { arg rate = 4, depth = 0.8; var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1) });
m.add(	remolo);
m.switchChain(0.1);
```

## Advanced Usage
- Use `bypass` to temporarily disable processors.
- Use `swap` to reorder processors.
- Use `clearChain` to reset NEXT to `[sink, source]`.
- Use `printChains` or GUI to inspect chain structure.

## Troubleshooting
- No sound: Ensure sources are defined and server is running.
- Meters update but silent: Check audio routing and output device.
- GUI errors: Use latest GUI with UI-ready queue.
- `'s' not defined`: Use `Server.default` in class files.

## Version History
- v0.3.8: No reference to `s`; safe reset only in `reset`.
- v0.3.5‚Äì0.3.7: Crossfade switching, server ops cleanup.
- MagicDisplayGUI v0.2.3: GUI with countdown, ops list, meters.

===== MagicPedalboard/docs and references/RUNBOOK.md =====
# MagicPedalboardNew ‚Äì RUNBOOK (v0.3.8) ‚Äî Test‚ÄëSignal Only

**Today‚Äôs rule:** NO MIC. `\ts0` is overridden to an internal test source.

## Steps
1) Boot the server.
2) Open `MPB_Scenarios_v6.scd` in SuperCollider.
3) Evaluate from the top, **line by line**.
4) Audio sanity:
```supercollider
~pedalboard.reset;
~pedalboard.setSource(\testmelody);
~pedalboard.switchChain(0.1);
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
Ndef(\delay).set(\mix, 0.55, \time, 0.45, \fb, 0.4);

===== MagicPedalboard/docs and references/usingLibraryWithMagicPedalboard.scd =====
// usingLibraryWithMagicPedalboard.scd
// MD 20250915-0914


(
// If you‚Äôve loaded MagicProcessorLibrary_defs.scd already:
~procLib.ensureMany([\ts0, \delay, \tremolo, \reverb, \chorus, \drive], 2);

// Then (re)build your pedalboard chains knowing those symbols resolve:
~pedalboard.reset;
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
)

===== MagicPedalboard/editor_commandtree_add_demo_verbs.scd =====
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "‚úÖ Loaded tree for editing.".postln;
} {
    "‚ùå Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)

===== MagicPedalboard/MagicDisplay.sc =====
/* MagicDisplay.sc  v0.1.3
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

	classvar < version, < metersReady, < meterChannels;

	var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose


	*initClass {
		version = "v0.1.3";
		("MagicDisplay " ++ version).postln;

		// default compile-time meter channel count
		meterChannels = 2;
		metersReady = false;

		// define (or re-define) the meter SynthDefs now
		this.ensureMeterDefs(meterChannels);
	}


	*new { |level = 1|
		^super.new.init(level)
	}

	init { |level|
		var initialLevel;
		initialLevel = level ? 1;
		logLevel = initialLevel;
		^this
	}

	help {
		var text;
		text = "MagicDisplay " ++ version
		++ "\nMethods:\n"
		++ "  showInit(pedalboard, versionString, current, next)\n"
		++ "  showRebuild(which, fullChain, effective)\n"
		++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
		++ "  showMutation(action, args, nextChain)\n"
		++ "  showBypass(which, key, state, chain, bypassKeys)\n"
		++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
		++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
		++ "  showError(message)\n";
		text.postln;
	}

	showInit { |pedalboard, versionString, current, next|
		if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
	}

	showRebuild { |which, fullChain, effective|
		if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
	}

	showPlay { |sinkKey|
		if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
	}

	showStop { |sinkKey|
		if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
	}

	showSwitch { |oldSink, newSink, current, next|
		if(logLevel > 0) {
			("[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink
				++ "  current=" ++ current ++ "  next=" ++ next).postln;
		};
	}

	showMutation { |action, args, nextChain|
		if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
	}

	showBypass { |which, key, state, chain, bypassKeys|
		if(logLevel > 0) {
			("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
				++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
		};
	}

	showReset { |current, next|
		if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
	}

	showChains { |current, next, bypassAKeys, bypassBKeys|
		if(logLevel > 0) {
			"MagicPedalboardNew.printChains:".postln;
			("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
			("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
		};
	}

	showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
		var header, formatOne;

		if(logLevel <= 0) { ^this };

		header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

		formatOne = { |titleString, listRef, bypassKeys, effective|
			var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

			lastIndex = listRef.size - 1;
			sinkKey = listRef[0];
			sourceKey = listRef[lastIndex];

			header.(titleString);
			("sink : " ++ sinkKey).postln;

			indexCounter = 1;
			if(listRef.size > 2) {
				"procs:".postln;
				listRef.copyRange(1, lastIndex - 1).do { |procKey|
					var isBypassed, mark;
					isBypassed = bypassKeys.includes(procKey);
					mark = if(isBypassed) { "BYP" } { "ON " };
					lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
					lineText.postln;
					indexCounter = indexCounter + 1;
				};
			}{
				"procs: (none)".postln;
			};

			("src  : " ++ sourceKey).postln;
			("eff  : " ++ effective.join("  ->  ")).postln;
			"".postln;
		};

		formatOne.("CURRENT", current, bypassAKeys, effCurrent);
		formatOne.("NEXT",    next,    bypassBKeys, effNext);
	}

	showError { |message|
		("[MPB:error] " ++ message).warn;
	}

	// ----- meter SynthDefs (class-level) -----

	*ensureMeterDefs { arg ch = 2;
		var n;
		// clamp to a sensible positive integer
		n = ch.asInteger.max(1);
		meterChannels = n;

		// Define (or re-define) once per class init (safe to call again after recompile).
		// Uses compile-time channel count 'n' inside the UGen graph.
		Server.default.bind({
			SynthDef(\busMeterA, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);                 // compile-time 'n'
				var amp  = Amplitude.ar(sig).clip(0, 1);    // per-channel amplitude
				SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
			}).add;

			SynthDef(\busMeterB, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);
				var amp  = Amplitude.ar(sig).clip(0, 1);
				SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
			}).add;
		});

		metersReady = true;
	}

	*setMeterChannels { arg ch = 2;
		// convenience: re-emit defs with a new compile-time channel count
		this.ensureMeterDefs(ch);
	}

}

===== MagicPedalboard/MagicDisplayGUI_Ext_VisualOnly.sc =====
// MagicDisplayGUI_Ext_VisualOnly.sc
// v0.1.1 (fixed: no ivar; uses window property bag instead)
// MD 20250919-08:05 BST

/*
Purpose
- Add "visual-only" layout controls to MagicDisplayGUI without modifying the class file.
- setVisualOnly(true): hides Ops area; recomputes A/B panel heights so they stop above
  the expectation/countdown block; meters group remains at the bottom.
- relayoutVisualOnly: recompute bounds; attachResize wires window.onResize -> relayout.

Style
- AppClock for UI; no server.sync; methods live in a class extension.
- Uses window.setProperty/getProperty(\visualOnlyFlag) instead of new ivars.
*/

+ MagicDisplayGUI {

    // -- helpers to read/write the visual-only flag using the window as property bag
    getVisualOnlyFlag {
        var v;
        v = false;
        if(window.notNil) {
            v = window.getProperty(\visualOnlyFlag) ? false;
        };
        ^v
    }

    setVisualOnly { arg flag = true;
        var on;
        on = flag ? true;
        this.queueUi({
            if(window.notNil) { window.setProperty(\visualOnlyFlag, on) };

            // Hide or show ops widgets
            if(opsListView.notNil)   { opsListView.visible_(on.not) };
            if(opsNextButton.notNil) { opsNextButton.visible_(on.not) };
            if(opsStatusText.notNil) { opsStatusText.visible_(on.not) };

            this.relayoutVisualOnly;  // recompute layout now
        });
        ^this
    }

    relayoutVisualOnly {
        var pad, metersH, expH, expGap, countH, winRect, colGap;
        var visualOnly, rightW, usableW, colW, colH, leftX, rightX;
        var groupLeft, groupTop, groupW, labelW, barW;

        // Geometry constants (aligned to your class)
        pad     = 10;
        metersH = 86;   // meters block height in your class
        expH    = 52;   // expectation text height
        expGap  = 6;    // spacing between expectation and countdown bar row
        countH  = 20;   // countdown row height
        colGap  = 40;   // gap between columns

        visualOnly = this.getVisualOnlyFlag;

        // Window rect fallback if not created yet
        winRect = (window.notNil).if({ window.view.bounds }, { Rect(0, 0, 980, 520) });

        // If visual-only, reclaim the ops panel width
        rightW  = (visualOnly ? 0 : 320);

        // Compute column widths
        usableW = winRect.width - (2 * pad) - rightW - colGap;
        colW    = (usableW / 2).max(220);

        // Compute column heights so panels stop ABOVE the expectation + countdown region
        colH = winRect.height
            - (2 * pad)   // top + bottom padding
            - metersH     // meters area at bottom
            - expH        // expectation text
            - expGap      // spacing
            - countH      // countdown row
            - 12;         // small margin

        colH = colH.max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        this.queueUi({
            // Left/right column panels
            if(leftPanel.notNil)  { leftPanel.bounds  = Rect(leftX,  pad, colW, colH) };
            if(rightPanel.notNil) { rightPanel.bounds = Rect(rightX, pad, colW, colH) };

            // Expectation + countdown spans both columns
            if(expectationText.notNil) {
                expectationText.bounds = Rect(leftX, leftPanel.bounds.bottom + 6, colW*2 + colGap, expH)
            };
            if(countdownLabel.notNil)   {
                countdownLabel.bounds    = Rect(leftX, expectationText.bounds.bottom + expGap, 120, 20)
            };
            if(countdownBarView.notNil) {
                countdownBarView.bounds  = Rect(leftX + 130, expectationText.bounds.bottom + expGap,
                                                (colW*2 + colGap) - 140, 20)
            };

            // Ops area only when not visual-only
            if(visualOnly.not and: { opsListView.notNil }) {
                opsListView.bounds = Rect(expectationText.bounds.right + pad, pad,
                                          rightW - pad, winRect.height - 2 * pad);
                if(opsStatusText.notNil) {
                    opsStatusText.bounds = Rect(opsListView.bounds.left,
                                                opsListView.bounds.bottom - 52,
                                                opsListView.bounds.width - 110, 20)
                };
                if(opsNextButton.notNil) {
                    opsNextButton.bounds = Rect(opsListView.bounds.right - 100,
                                                opsListView.bounds.bottom - 56, 100, 28)
                };
            };

            // Meters group: reuse the parent of meterViewA/B
            if(meterViewA.notNil and: { meterViewB.notNil } and: { meterViewA.parent.notNil }) {
                groupLeft = pad;
                groupTop  = winRect.height - metersH - pad;
                groupW    = winRect.width  - 2*pad;
                meterViewA.parent.bounds = Rect(groupLeft, groupTop, groupW, metersH);

                // child bars
                labelW = 60;
                barW   = groupW - labelW - 10;
                meterViewA.bounds = Rect(labelW + 6, 4, barW, 20);
                meterViewB.bounds = Rect(labelW + 6, 4 + 38, barW, 20);
            };
        });

        ^this
    }

    attachResize {
        this.queueUi({
            if(window.notNil) {
                window.onResize = { this.relayoutVisualOnly };
            };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_FixChoicesColors_Ext.sc =====
// MagicDisplayGUI_FixChoicesColors_Ext.sc
// v0.1.2  ‚Äî MD 2025-09-24 23:10 BST
/*
Purpose
- Make the "Choices" text high-contrast no matter how it is updated:
  updateTextField(\choices, ...) or setOperations([...]).
Style
- Class extension only; NO new ivars; var-first in every method; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    ensureChoicesPanel {
        var host, build;
        host = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        build = {
            var x, y, w, h;
            x = host.bounds.width - 360; y = 8; w = 352; h = 200;

            this.choicesPanel = this.choicesPanel ?? { CompositeView(host) };
            this.choicesPanel
                .background_(Color(0.15, 0.15, 0.15))
                .resize_(5)
                .bounds_(Rect(x, y, w, h));

            this.choicesTitle = this.choicesTitle ?? { StaticText(this.choicesPanel) };
            this.choicesTitle
                .string_("Choices")
                .stringColor_(Color(0.85, 0.85, 0.85))
                .align_(\left)
                .bounds_(Rect(8, 6, w - 16, 20));

            this.choicesText = this.choicesText ?? { TextView(this.choicesPanel) };
            this.choicesText
                .background_(Color(0.15, 0.15, 0.15))
                .stringColor_(Color.white)
                .font_(Font("Monaco", 12))
                .autoscroll_(true)
                .editable_(false)
                .bounds_(Rect(8, 28, w - 16, h - 36));
        };

        AppClock.sched(0.0, { build.value; nil });
        ^this
    }

    md_applyChoicesText { arg textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            this.ensureChoicesPanel;
            if(this.choicesText.notNil) {
                this.choicesText.stringColor_(Color.white);  // force high contrast
                this.choicesText.string_(txt);
            };
            nil
        });
        ^this
    }

    updateTextField { arg key, textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            switch(key,
                \choices, { this.md_applyChoicesText(txt) },
                \state,   { if(this.expectationView.notNil) { this.expectationView.string = txt } },
                \queue,   { if(this.expectationView.notNil) { this.expectationView.string = "Queue:\n" ++ txt } },
                \lastCommand, { if(this.expectationView.notNil) { this.expectationView.string = "Last: " ++ txt } },
                { /* no-op */ }
            );
            nil
        });
        ^this
    }

    setOperations { arg itemsArray;
        var s;
        s = (itemsArray ? []).collect(_.asString).join("\n");
        this.md_applyChoicesText(s);
        ^this
    }

    // optional manual nudge
    forceHighContrastChoices {
        this.md_applyChoicesText(this.choicesText.tryPerform(\string) ? "");
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd =====
// MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd
// v0.1.0
// MD 2025-09-24 23:55 BST

/*
Purpose
- Ensure the Choices panel uses light text on a dark background.
Style
- Class extension only; var-first; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  fixChoicesContrast { arg fg = Color(0.96,0.96,0.96), bg = Color(0.12,0.12,0.12,0.92);
    var apply;
    apply = {
      if(choicesPanel.notNil) { choicesPanel.background = bg };
      if(choicesTitle.notNil) { choicesTitle.stringColor = fg };
      if(choicesText.notNil)  { choicesText.stringColor  = fg };
    };
    AppClock.sched(0.0, { apply.value; nil });
    ^this
  }

  // Keep existing behavior but guarantee readable \choices text
  updateTextField { arg box, msg;
    var doIt;
    doIt = {
      if(box == \choices) {
        if(choicesText.notNil) {
          choicesText.string = msg.asString;
          choicesText.stringColor = Color(0.96,0.96,0.96);  // light text
          if(choicesTitle.notNil) { choicesTitle.stringColor = Color(0.96,0.96,0.96) };
        };
      }{
        if(expectationView.notNil) {
          expectationView.string = "[" ++ box.asString ++ "] " ++ msg.asString;
        };
      };
    };
    AppClock.sched(0.0, { doIt.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Markers.sc_disabled =====
// MagicDisplayGUI_GridDemo_Ext_Markers.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Place a simple, colored rectangle as a "marker" INSIDE the right CURRENT/NEXT panel
  (middle-right column), directly BELOW the "eff:" row, without touching any layouts.
- Provide simple helpers to show/hide a thin border around the right panel and to post layout info.

Style
- Class extension only; known-good SC syntax.
- Var-first in every block; descriptive variable names (>= 3 chars).
- No layout adds; the marker is an absolutely positioned CompositeView.
*/

+ MagicDisplayGUI_GridDemo {

  // -------- remove marker if present --------
  rp_removeMarker {
    var markerView, childView, childName;

    if(rightPanel.isNil) { "rp_removeMarker: rightPanel is nil".warn; ^this };

    markerView = nil;
    rightPanel.children.do({ arg childViewLocal;
      var nameMaybe;
      nameMaybe = childViewLocal.tryPerform(\name);
      if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
    });

    if(markerView.notNil) { markerView.remove };
    ^this
  }

  // -------- place a colored marker BELOW the 'eff:' line in the RIGHT panel --------
  rp_placeMarkerBelowEff { arg barHeight = 24, fillColor = Color(1, 0.30, 0.20, 0.90);
    var placeFunc;

    if(rightPanel.isNil) { "rp_placeMarkerBelowEff: rightPanel is nil".warn; ^this };
    if(rightEff.isNil)   { "rp_placeMarkerBelowEff: rightEff is nil".warn; ^this };

    placeFunc = {
      var panelBounds, effBounds, leftInset, rightInset, topGap, targetRect;
      var markerView;

      panelBounds = rightPanel.bounds;
      effBounds   = rightEff.bounds;

      leftInset  = 6;
      rightInset = 6;
      topGap     = 4;

      targetRect = Rect(
        leftInset,
        effBounds.bottom + topGap,
        (panelBounds.width - (leftInset + rightInset)).max(8),
        barHeight.max(8)
      );

      // remove any previous marker
      this.rp_removeMarker;

      // create a simple colored view at the computed rectangle
      markerView = CompositeView(rightPanel).name_("MDG_MARKER");
      markerView.background = fillColor;
      markerView.bounds = targetRect;
      markerView.front;  // ensure on top

      ("[marker] placed at " ++ targetRect).postln;
    };

    // schedule after 0 so layout has a chance to settle
    AppClock.sched(0.0, { placeFunc.value; nil });
    ^this
  }

  // -------- raise marker to front (if it was covered) --------
  rp_raiseMarker {
    var markerView;

    if(rightPanel.isNil) { "rp_raiseMarker: rightPanel is nil".warn; ^this };

    markerView = nil;
    rightPanel.children.do({ arg childViewLocal;
      var nameMaybe;
      nameMaybe = childViewLocal.tryPerform(\name);
      if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
    });

    if(markerView.notNil) { markerView.front };
    ^this
  }

  // -------- toggle a thin border overlay around the RIGHT panel (no child iteration) --------
  rp_showRightPanelBorder { arg showBorder = true;
    var ensureFunc;

    if(rightPanel.isNil) { "rp_showRightPanelBorder: rightPanel is nil".warn; ^this };

    ensureFunc = {
      var existingOverlay, borderView;

      // remove existing
      existingOverlay = nil;
      rightPanel.children.do({ arg childViewLocal;
        var nameMaybe;
        nameMaybe = childViewLocal.tryPerform(\name);
        if(nameMaybe == "MDG_BORDER_OVERLAY") { existingOverlay = childViewLocal };
      });
      if(existingOverlay.notNil) { existingOverlay.remove };

      if(showBorder) {
        borderView = UserView(rightPanel).name_("MDG_BORDER_OVERLAY");
        borderView.background = Color.clear;

        // place full-panel; use current bounds (no layout control)
        borderView.bounds = Rect(0, 0, rightPanel.bounds.width, rightPanel.bounds.height);

        borderView.drawFunc = { arg viewLocal;
          var viewBounds;
          viewBounds = viewLocal.bounds;
          Pen.color = Color(1, 0, 0, 0.40);
          Pen.width = 2;
          Pen.strokeRect(Rect(1, 1, viewBounds.width - 2, viewBounds.height - 2));
        };

        borderView.front;
      };
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // -------- print simple layout info for key right-panel subviews --------
  rp_postRightPanelLayoutReport {
    var postFunc;

    if(rightPanel.isNil) { "rp_postRightPanelLayoutReport: rightPanel is nil".warn; ^this };

    postFunc = {
      var markerView;

      "‚Äî‚Äî Right Panel Layout ‚Äî‚Äî".postln;
      ("rightPanel.bounds:     " ++ rightPanel.bounds).postln;

      if(this.respondsTo(\rightHeader) and: { rightHeader.notNil }) {
        ("rightHeader.bounds:    " ++ rightHeader.bounds).postln;
      };

      if(this.respondsTo(\rightListView) and: { rightListView.notNil }) {
        ("rightListView.bounds:  " ++ rightListView.bounds).postln;
      };

      if(rightEff.notNil) {
        ("rightEff.bounds:       " ++ rightEff.bounds).postln;
      };

      markerView = nil;
      rightPanel.children.do({ arg childViewLocal;
        var nameMaybe;
        nameMaybe = childViewLocal.tryPerform(\name);
        if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
      });
      if(markerView.notNil) {
        ("marker.bounds:         " ++ markerView.bounds).postln;
      };
    };

    AppClock.sched(0.0, { postFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.sc_DISABLED =====
// MagicDisplayGUI_GridDemo_Ext_Meters.sc
// v0.1.1
// MD 2025-09-24 20:10 BST

/*
Purpose
- Install direct OSC responders on '/ampA' and '/ampB' and update the GUI meter bars.
- Keeps logic inside the GUI class (cleaner than external glue).
- Safe to call multiple times (responders are replaced). Platform-agnostic.

Style
- Class extension; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    installDirectMeterResponders {
        var updateA, updateB, makeResponder;

        updateA = { arg vals;
            var v;
            v = (vals.asArray[0] ? 0).asFloat.clip(0, 1);
            this.queueUi({
                if(meterViewA.notNil) {
                    meterViewA.tryPerform(\value_, v);
                    meterViewA.tryPerform(\refresh);
                };
            });
        };

        updateB = { arg vals;
            var v;
            v = (vals.asArray[0] ? 0).asFloat.clip(0, 1);
            this.queueUi({
                if(meterViewB.notNil) {
                    meterViewB.tryPerform(\value_, v);
                    meterViewB.tryPerform(\refresh);
                };
            });
        };

        // Free prior defs if present, then (re)install
        if(OSCdef(\mdg_ampA).notNil) { OSCdef(\mdg_ampA).free };
        if(OSCdef(\mdg_ampB).notNil) { OSCdef(\mdg_ampB).free };

        // Accept from any src (robust across platforms); GUI updates are AppClock-safe
        OSCdef(\mdg_ampA, { |msg| updateA.(msg[3..]) }, '/ampA');
        OSCdef(\mdg_ampB, { |msg| updateB.(msg[3..]) }, '/ampB');

        "‚úÖ MagicDisplayGUI meters bound to /ampA /ampB".postln;
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.scd =====
// MagicDisplayGUI_GridDemo_Ext_Meters.scd
// v0.3.0
// MD 2025-09-24 23:56 BST

/*
Purpose
- Provide enableMeters(true): listen to /ampA and /ampB (from SendReply.kr)
  and draw two moving bars in meterStrip.
Style
- Class extension only; var-first; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  enableMeters { arg on = true;
    var state, setupUI, install, remove;

    // Simple per-window state (no ivars added)
    state = (
      valA: 0.0,   // 0..1 (A bar)
      valB: 0.0,   // 0..1 (B bar)
      rxA:  nil,   // OSCdef handles
      rxB:  nil
    );

    setupUI = {
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds, pad = 8, w = b.width - (pad*2), h = b.height;
          var barH = ((h - (pad*2) - 4)/2).clip(8,14);
          var top1 = pad, top2 = pad + barH + 4;
          var a = state[\valA].clip(0,1), bb = state[\valB].clip(0,1);

          // backgrounds
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top1, w, barH)); Pen.fill;
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top2, w, barH)); Pen.fill;

          // dynamic fills
          Pen.color = Color(0.20, 0.70, 0.20); Pen.addRect(Rect(pad, top1, w * a,  barH)); Pen.fill;  // A
          Pen.color = Color(0.20, 0.40, 0.90); Pen.addRect(Rect(pad, top2, w * bb, barH)); Pen.fill;  // B

          // border
          Pen.color = Color.gray(0.5); Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
        };
      };
    };

    install = {
      setupUI.value;

      // IMPORTANT: these paths must match the ones used in SendReply.kr
      state[\rxA] = OSCdef(\mdAmpA, { |msg|
        // SendReply places floats after some metadata; first value is msg[3]
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        // quick smoothing
        state[\valA] = (state[\valA] * 0.7) + (max(l, r) * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampA');

      state[\rxB] = OSCdef(\mdAmpB, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var mean = ((l + r) * 0.5).clip(0,1);
        state[\valB] = (state[\valB] * 0.7) + (mean * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampB');
    };

    remove = {
      if(state[\rxA].notNil) { state[\rxA].free; state[\rxA] = nil };
      if(state[\rxB].notNil) { state[\rxB].free; state[\rxB] = nil };
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds;
          Pen.color = Color.gray(0.7);
          Pen.strokeRect(Rect(0.5,0.5,b.width-1,b.height-1));
        };
        meterStrip.refresh;
      };
    };

    AppClock.sched(0.0, { if(on) { install.value } { remove.value }; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_SetOperations.sc =====
// MagicDisplayGUI_GridDemo_Ext_SetOperations.sc
// v0.1.0
// MD 2025-09-22 22:36 BST

/* Purpose
   - Let CommandManager.updateDisplay push the current fret‚Üíchoice list
     into MagicDisplayGUI_GridDemo's "Choices" panel.
   Style
   - AppClock-only UI; var-first; lowercase; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {
    setOperations { |lines|
        var text;
        text = (lines ? []).join("\n");
        this.queueUi({
            if(choicesText.notNil) { choicesText.string = text };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMarker.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMarker.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw unambiguous landmarks INSIDE the right CURRENT/NEXT panel (middle-right column):
  ‚Ä¢ Fuchsia border built from 4 thin CompositeViews (no drawFunc)
  ‚Ä¢ Yellow highlight inside the 'eff' row (anchor)
  ‚Ä¢ Marker bar near 'eff': ORANGE below (clamped) or SKY-BLUE above (clamped)
- Absolutely no layout mutations; no drawing math inside drawFuncs; only known-good SC GUI.

Style
- Class extension; var-first in all methods; descriptive variable names.
- Views are created as named children of rightPanel so we can remove them safely.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- helpers: find/remove named child on rightPanel ----------
  tm_findChildByName { arg childNameString;
    var foundView, childCount, childIndex, childView, childNameMaybe;
    foundView = nil;
    if(rightPanel.notNil) {
      childCount = rightPanel.children.size;
      childIndex = 0;
      childCount.do({
        childView = rightPanel.children[childIndex];
        childNameMaybe = if(childView.respondsTo(\name), { childView.name }, { nil });
        if(childNameMaybe == childNameString) { foundView = childView };
        childIndex = childIndex + 1;
      });
    };
    ^foundView
  }

  tm_removeChildByName { arg childNameString;
    var viewToRemove;
    viewToRemove = this.tm_findChildByName(childNameString);
    if(viewToRemove.notNil) { viewToRemove.remove };
    ^this
  }

  // ---------- clear all test markers/borders ----------
  testMarker_clear {
    this.tm_removeChildByName("MDG_TM_BORDER_TOP");
    this.tm_removeChildByName("MDG_TM_BORDER_BOTTOM");
    this.tm_removeChildByName("MDG_TM_BORDER_LEFT");
    this.tm_removeChildByName("MDG_TM_BORDER_RIGHT");
    this.tm_removeChildByName("MDG_TM_EFF_HI");
    this.tm_removeChildByName("MDG_TM_MARKER");
    ^this
  }

  // ---------- show a bold fuchsia border (4 thin views) ----------
  testMarker_showPanelBorder {
    var ensureFunc;

    if(rightPanel.isNil) { "testMarker_showPanelBorder: rightPanel is nil".warn; ^this };

    ensureFunc = {
      var panelBounds, thickness, topView, bottomView, leftView, rightView, colorFuchsia;

      // clean previous
      this.testMarker_clear;

      panelBounds   = rightPanel.bounds;
      thickness     = 3;
      colorFuchsia  = Color(1.0, 0.0, 1.0, 0.85);

      topView = CompositeView(rightPanel).name_("MDG_TM_BORDER_TOP");
      topView.background = colorFuchsia;
      topView.bounds = Rect(0, 0, panelBounds.width, thickness);

      bottomView = CompositeView(rightPanel).name_("MDG_TM_BORDER_BOTTOM");
      bottomView.background = colorFuchsia;
      bottomView.bounds = Rect(0, panelBounds.height - thickness, panelBounds.width, thickness);

      leftView = CompositeView(rightPanel).name_("MDG_TM_BORDER_LEFT");
      leftView.background = colorFuchsia;
      leftView.bounds = Rect(0, 0, thickness, panelBounds.height);

      rightView = CompositeView(rightPanel).name_("MDG_TM_BORDER_RIGHT");
      rightView.background = colorFuchsia;
      rightView.bounds = Rect(panelBounds.width - thickness, 0, thickness, panelBounds.height);

      // bring to front in a stable order
      topView.front; bottomView.front; leftView.front; rightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- highlight the 'eff' row (yellow translucent) ----------
  testMarker_highlightEff {
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_highlightEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var effBounds, highlightView, colorYellow;

      // remove old eff highlight only
      this.tm_removeChildByName("MDG_TM_EFF_HI");

      effBounds = rightEff.bounds;
      colorYellow = Color(1.0, 1.0, 0.0, 0.45);

      highlightView = CompositeView(rightPanel).name_("MDG_TM_EFF_HI");
      highlightView.background = colorYellow;
      highlightView.bounds = Rect(
        effBounds.left + 2,
        effBounds.top + 2,
        (effBounds.width - 4).max(4),
        (effBounds.height - 4).max(4)
      );
      highlightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- place a marker bar NEAR the 'eff' row (positionSymbol: \below or \above) ----------
  testMarker_showNearEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_showNearEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var panelBounds, effBounds, leftInset, rightInset, gapPixels;
      var desiredTop, finalTop, finalHeight, markerRect, markerView;
      var colorOrange, colorSkyBlue, markerColor;

      // remove any previous marker (keep border/eff highlight)
      this.tm_removeChildByName("MDG_TM_MARKER");

      panelBounds = rightPanel.bounds;
      effBounds   = rightEff.bounds;

      leftInset   = 6;
      rightInset  = 6;
      gapPixels   = 4;
      colorOrange = Color(1.0, 0.50, 0.0, 0.90);
      colorSkyBlue= Color(0.10, 0.65, 1.0, 0.90);

      if(positionSymbol == \below) {
        markerColor = colorOrange;
        desiredTop  = effBounds.bottom + gapPixels;
        finalHeight = barHeight.max(8);
        if(desiredTop + finalHeight > panelBounds.height) {
          finalHeight = (panelBounds.height - desiredTop).max(8);
        };
        finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
      } {
        markerColor = colorSkyBlue;  // \above
        finalHeight = barHeight.max(8);
        desiredTop  = effBounds.top - gapPixels - finalHeight;
        if(desiredTop < 0) {
          finalHeight = (effBounds.top - gapPixels).max(8);
          desiredTop  = 0;
        };
        finalTop = desiredTop;
      };

      markerRect = Rect(
        leftInset,
        finalTop,
        (panelBounds.width - (leftInset + rightInset)).max(8),
        finalHeight
      );

      markerView = CompositeView(rightPanel).name_("MDG_TM_MARKER");
      markerView.background = markerColor;
      markerView.bounds = markerRect;
      markerView.front;

      "‚Äî‚Äî TestMarker ‚Äî‚Äî".postln;
      ("rightPanel.bounds: " ++ panelBounds).postln;
      ("rightEff.bounds:   " ++ effBounds).postln;
      ("marker.bounds:     " ++ markerRect).postln;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMeter.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMeter.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw a small horizontal "debug meter" inside the right CURRENT/NEXT panel (middle-right column),
  positioned relative to the 'eff:' row (just BELOW by default; clamped to stay inside the panel).
- Step 1: run with a smoothed RANDOM driver to prove GUI refresh + horizontal motion.
- Step 2: attach to live audio via SendReply.kr paths '/ampA' or '/ampB'.

Style
- Class extension; known-good SuperCollider only.
- Var-first in all blocks; descriptive variable names (>=3 chars).
- Minimal state stored in Library under category \MD_TM and key this.identityHash.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- tiny state bag in Library (per GUI instance) ----------
  tm2_state {
    var categorySymbol, keyInt, dict;
    categorySymbol = \MD_TM;
    keyInt = this.identityHash;
    dict = Library.at(categorySymbol, keyInt);
    if(dict.isNil) {
      dict = IdentityDictionary.new;
      Library.put(categorySymbol, keyInt, dict);
    };
    ^dict
  }

  tm2_put { arg keySymbol, valueObject;
    var stateDict;
    stateDict = this.tm2_state;
    stateDict.put(keySymbol, valueObject);
    ^this
  }

  tm2_get { arg keySymbol, defaultValue = nil;
    var stateDict;
    stateDict = this.tm2_state;
    ^(stateDict.includesKey(keySymbol).if({ stateDict.at(keySymbol) }, { defaultValue }))
  }

  // ---------- compute the meter rectangle relative to 'eff' (below or above) ----------
  tm2_computeMeterRect { arg positionSymbol = \below, barHeight = 24;
    var panelBounds, effBounds;
    var leftInset, rightInset, gapPixels;
    var desiredTop, finalTop, finalHeight, rectResult;

    if(rightPanel.isNil or: { rightEff.isNil }) { ^Rect(0,0,0,0) };

    panelBounds = rightPanel.bounds;
    effBounds   = rightEff.bounds;

    leftInset   = 6;
    rightInset  = 6;
    gapPixels   = 4;

    if(positionSymbol == \below) {
      desiredTop  = effBounds.bottom + gapPixels;
      finalHeight = barHeight.max(8);
      if(desiredTop + finalHeight > panelBounds.height) {
        finalHeight = (panelBounds.height - desiredTop).max(8);
      };
      finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
    } {
      // \above
      finalHeight = barHeight.max(8);
      desiredTop  = effBounds.top - gapPixels - finalHeight;
      if(desiredTop < 0) {
        finalHeight = (effBounds.top - gapPixels).max(8);
        desiredTop  = 0;
      };
      finalTop = desiredTop;
    };

    rectResult = Rect(
      leftInset,
      finalTop,
      (panelBounds.width - (leftInset + rightInset)).max(8),
      finalHeight
    );
    ^rectResult
  }

  // ---------- create the meter UserView at the computed rectangle ----------
  testMeter_showAtEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMeter_showAtEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var meterRect, meterUserView;

      // remove any previous meter view
      this.testMeter_remove;

      meterRect = this.tm2_computeMeterRect(positionSymbol, barHeight);

      meterUserView = UserView(rightPanel).name_("MDG_TM2_METER");
      meterUserView.background = Color.clear;
      meterUserView.bounds = meterRect;

      // drawFunc: trough + horizontal fill
      meterUserView.drawFunc = { arg viewLocal;
        var viewBounds, padPixels, troughRect, valueNow, fillWidth, fillRect;

        viewBounds = viewLocal.bounds;
        padPixels  = 2;

        troughRect = Rect(
          padPixels, padPixels,
          viewBounds.width  - (padPixels * 2),
          viewBounds.height - (padPixels * 2)
        );

        // trough
        Pen.color = Color(0.80, 0.82, 0.86, 0.60);
        Pen.addRect(troughRect); Pen.fill;

        // horizontal fill
        valueNow  = (this.tm2_get(\meterVal, 0.0)).clip(0, 1);
        fillWidth = (troughRect.width * valueNow).max(0);
        fillRect  = Rect(troughRect.left, troughRect.top, fillWidth, troughRect.height);

        Pen.color = Color(0.15, 0.65, 0.25, 0.95);  // green-ish
        Pen.addRect(fillRect); Pen.fill;

        // border
        Pen.color = Color.gray(0.20);
        Pen.strokeRect(Rect(0.5, 0.5, viewBounds.width - 1, viewBounds.height - 1));
      };

      meterUserView.front;

      this.tm2_put(\meterView, meterUserView);
      this.tm2_put(\meterVal, 0.0);
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- random driver (prove GUI refresh + orientation) ----------
  testMeter_startRandom {
    var startFunc;

    startFunc = {
      var existingTask, meterUserView, meterTaskRoutine;

      // stop any prior driver
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_startRandom: meter not shown‚Äîcall testMeter_showAtEff first.".warn; ^this };

      meterTaskRoutine = Routine({
        var currentVal, targetVal, stepSeconds;
        currentVal = this.tm2_get(\meterVal, 0.0);
        stepSeconds = 0.06;  // ~16 Hz
        inf.do {
          targetVal  = 1.0.rand;
          currentVal = (currentVal * 0.75) + (targetVal * 0.25);
          this.tm2_put(\meterVal, currentVal);
          AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
          stepSeconds.wait;
        }
      });

      this.tm2_put(\meterTask, meterTaskRoutine);
      meterTaskRoutine.play(AppClock);
    };

    AppClock.sched(0.0, { startFunc.value; nil });
    ^this
  }

  // ---------- attach to live audio via '/ampA' or '/ampB' ----------
  testMeter_attach { arg whichChain = \A;
    var attachFunc;

    attachFunc = {
      var meterUserView, oscKeyA, oscKeyB, oscDefAmpA, oscDefAmpB;

      this.testMeter_stop;  // stop prior drivers

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_attach: meter not shown‚Äîcall testMeter_showAtEff first.".warn; ^this };

      // unique OSCdef keys per GUI instance
      oscKeyA = ("mdTmAmpA_" ++ this.identityHash).asSymbol;
      oscKeyB = ("mdTmAmpB_" ++ this.identityHash).asSymbol;

      oscDefAmpA = OSCdef(oscKeyA, { arg msg;
        var leftVal, rightVal, peakVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        peakVal  = max(leftVal, rightVal).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (peakVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampA');

      oscDefAmpB = OSCdef(oscKeyB, { arg msg;
        var leftVal, rightVal, meanVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        meanVal  = ((leftVal + rightVal) * 0.5).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (meanVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampB');

      this.tm2_put(\oscA, oscDefAmpA);
      this.tm2_put(\oscB, oscDefAmpB);

      // enable only one path
      if(whichChain == \A) { oscDefAmpB.disable } { oscDefAmpA.disable };
    };

    AppClock.sched(0.0, { attachFunc.value; nil });
    ^this
  }

  // ---------- stop drivers (random and OSC) ----------
  testMeter_stop {
    var stopFunc;

    stopFunc = {
      var existingTask, oscDefA, oscDefB;

      existingTask = this.tm2_get(\meterTask);
      if(existingTask.notNil) { existingTask.stop; this.tm2_put(\meterTask, nil) };

      oscDefA = this.tm2_get(\oscA);
      if(oscDefA.notNil) { oscDefA.free; this.tm2_put(\oscA, nil) };

      oscDefB = this.tm2_get(\oscB);
      if(oscDefB.notNil) { oscDefB.free; this.tm2_put(\oscB, nil) };
    };

    AppClock.sched(0.0, { stopFunc.value; nil });
    ^this
  }

  // ---------- remove the meter view ----------
  testMeter_remove {
    var removeFunc;

    removeFunc = {
      var meterUserView;
      // stop activity first
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.notNil) { meterUserView.remove; this.tm2_put(\meterView, nil) };
    };

    AppClock.sched(0.0, { removeFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo.sc =====
// MagicDisplayGUI_GridDemo.sc
// v0.1.6
// MD 20250919-10:46 BST

/*
Purpose
- GridLayout-based GUI for VISUAL-ONLY demos (no audio, meters disabled).
- Row 0: CURRENT | NEXT (two equal columns).
- Rows 1..4: full-width using addSpanning (expectation, countdown, thin meters=30px, processors).
- Extra height only goes to Row 0 (chains row).

Debug
- debugGuides(true): overlays red outlines + row labels; postLayoutReport() prints rects.

Style
- var-first; lowercase; AppClock-only UI ops; no caret returns in closures; no server.sync.
*/

MagicDisplayGUI_GridDemo : MagicDisplay {
	classvar <versionGUI;
	var <window;

	// root + top-level row views (children of window.view)
	var rootLayout;
	var leftPanel, rightPanel;
	var expectationView, countdownHolder, meterStrip, bottomHudView;

	// children within panels
	var leftHeader, leftListView, leftEff;
	var rightHeader, rightListView, rightEff;
	var countdownLabel, countdownBar;
	var bottomCurText, bottomNextText;

	// debug overlay
	var debugOn = false;
	var overlayRow0, overlayRow1, overlayRow2, overlayRow3, overlayRow4;

	var metersEnabled;

	//new
	var <choicesPanel, <choicesTitle, <choicesText;
	var buildChoices;

	*initClass {
		var s;
		versionGUI = "v0.1.5";
		s = "MagicDisplayGUI_GridDemo " ++ versionGUI;
		s.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var reqW, reqH, sb, maxW, maxH, winW, winH, rect;
		var metersRowH, hudRowH;
		var buildLeft, buildRight, buildExpectation, buildCountdown, buildMeters, buildBottomHud;

		// window sizing (fits iPad side-screen limit)
		reqW = 1200; reqH = 760;
		sb   = Window.screenBounds ? Rect(0, 0, 1920, 1080);
		maxW = (2560).min(sb.width);
		maxH = (1666).min(sb.height);
		winW = reqW.clip(640, maxW);
		winH = reqH.clip(480, maxH);
		rect = Rect(
			sb.left + ((sb.width - winW) * 0.5),
			sb.top  + ((sb.height - winH) * 0.5),
			winW, winH
		);

		metersRowH = 30;   // thin strips
		hudRowH    = 88;

		window = Window("MagicDisplayGUI ‚Äì GridDemo", rect).front.alwaysOnTop_(true);
		metersEnabled = false;

		// root GridLayout on the VIEW (not the Window)
		rootLayout = GridLayout.new;
		window.view.layout = rootLayout;

		// equal columns globally (row 0 uses them)
		rootLayout.setColumnStretch(0, 1);
		rootLayout.setColumnStretch(1, 1);

		// ---- Row 0: CURRENT / NEXT (two equal columns) ----
		buildLeft = {
			var grid;
			grid = GridLayout.new;
			leftPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			leftPanel.layout = grid;

			leftHeader   = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
			leftListView = ListView(leftPanel).items_([]);
			leftEff      = StaticText(leftPanel).string_("eff: ‚Äî").align_(\center);

			grid.add(leftHeader,   0, 0);
			grid.add(leftListView, 1, 0);
			grid.add(leftEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildRight = {
			var grid;
			grid = GridLayout.new;
			rightPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			rightPanel.layout = grid;

			rightHeader   = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
			rightListView = ListView(rightPanel).items_([]);
			rightEff      = StaticText(rightPanel).string_("eff: ‚Äî").align_(\center);

			grid.add(rightHeader,   0, 0);
			grid.add(rightListView, 1, 0);
			grid.add(rightEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildLeft.value;
		buildRight.value;
		rootLayout.add(leftPanel,  0, 0);
		rootLayout.add(rightPanel, 0, 1);
		rootLayout.setRowStretch(0, 1); // only row allowed to grow

		// ---- Row 1: expectation (FULL width) ----
		buildExpectation = {
			expectationView = TextView(window.view)
			.background_(Color(1, 1, 0.9))
			.string_("Command:");
		};
		buildExpectation.value;
		// rootLayout.addSpanning(expectationView, 1, 0, 1, 2);
		// rootLayout.setRowStretch(1, 0);
		// rootLayout.setMinRowHeight(1, 36);

		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
		// rootLayout.add(choicesPanel, 4, 0);     // left column
		// rootLayout.add(bottomHudView, 4, 1);    // right column

		// Tweaks for row/column growth
		// rootLayout.setRowStretch(4, 0);         // fixed height for bottom row
		// rootLayout.setMinRowHeight(4, hudRowH); // keep same height as before


		// ---- Row 2: countdown (FULL width) ----
		buildCountdown = {
			var sub;
			countdownHolder = CompositeView(window.view);
			sub = GridLayout.new; countdownHolder.layout = sub;
			countdownLabel = StaticText(countdownHolder).string_("Ready");
			countdownBar   = UserView(countdownHolder);
			sub.add(countdownLabel, 0, 0);
			sub.add(countdownBar,   0, 1);
			sub.setColumnStretch(0, 0);
			sub.setColumnStretch(1, 1);
		};
		buildCountdown.value;
		rootLayout.addSpanning(countdownHolder, 2, 0, 1, 2);
		rootLayout.setRowStretch(2, 0);
		rootLayout.setMinRowHeight(2, 24);

		// ---- Row 3: meters (FULL width; 30 px) ----
		buildMeters = {
			meterStrip = UserView(window.view);
			meterStrip.background = Color(0.96, 0.96, 0.96);
			meterStrip.drawFunc = { |view|
				var b, pad, h, barH, top1, top2;
				b   = view.bounds;
				pad = 8;
				h   = b.height;
				barH = (h - (pad * 2) - 4) / 2;
				barH = barH.clip(8, 14);
				top1 = pad;
				top2 = pad + barH + 4;
				Pen.color = Color.gray(0.3);
				Pen.addRect(Rect(pad, top1, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.5);
				Pen.addRect(Rect(pad, top2, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.7);
				Pen.strokeRect(Rect(0.5, 0.5, b.width - 1, b.height - 1));
			};
		};
		buildMeters.value;
		rootLayout.addSpanning(meterStrip, 3, 0, 1, 2);
		rootLayout.setRowStretch(3, 0);
		rootLayout.setMinRowHeight(3, metersRowH);

		// new
		// --- Row 4 (left column): Choices panel (new) ---

		buildChoices = {
			var sub; // nested layout for the choices panel

			choicesPanel = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));

			// install a GridLayout into the choices panel
			sub = GridLayout.new;
			choicesPanel.layout = sub;

			choicesTitle = StaticText(choicesPanel)
			.string_("Choices")
			.stringColor_(Color(0.96, 0.96, 0.96));  // was Color(0.12,0.12,0.12) ... what a pain that was.

			choicesText  = TextView(choicesPanel)
			.string_("‚Äî")
			.editable_(false)
			.stringColor_(Color(0.96,0.96,0.96))     // add this line
			.hasVerticalScroller_(true)
			.background_(Color(0.98, 0.98, 0.98, 0.96))  // very light
			.stringColor_(Color(0.10, 0.10, 0.10))       // near-black text
			.font_(Font("Menlo", 12));





			// add to nested grid: title on row 0, text on row 1 (stretches)
			sub.add(choicesTitle, 0, 0);
			sub.add(choicesText, 1, 0);
			sub.setRowStretch(0, 0);   // title fixed
			sub.setRowStretch(1, 1);   // text grows to fill
			sub.setColumnStretch(0, 1);
		};
		///////
		buildChoices.value;


		// ---- Row 4: processors (FULL width) ----
		buildBottomHud = {
			var grid, title, curLabel, nextLabel;
			bottomHudView = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));
			grid = GridLayout.new; bottomHudView.layout = grid;

			title          = StaticText(bottomHudView).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
			curLabel       = StaticText(bottomHudView).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
			bottomCurText  = StaticText(bottomHudView).string_("‚Äì").stringColor_(Color(0.90, 0.90, 0.90));
			nextLabel      = StaticText(bottomHudView).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
			bottomNextText = StaticText(bottomHudView).string_("‚Äì").stringColor_(Color(0.80, 0.80, 0.80));

			grid.add(title,          0, 0, 1, 2);
			grid.add(curLabel,       1, 0);
			grid.add(bottomCurText,  1, 1);
			grid.add(nextLabel,      2, 0);
			grid.add(bottomNextText, 2, 1);
			grid.setColumnStretch(0, 0);
			grid.setColumnStretch(1, 1);
			grid.hSpacing = 10;
			grid.vSpacing = 4;
		};

		/////////
		buildBottomHud.value;

		// rootLayout.add(choicesPanel, 4, 0);   // left column
		// rootLayout.add(bottomHudView, 4, 1);  // right column
		rootLayout.setRowStretch(4, 0);
		rootLayout.setMinRowHeight(4, hudRowH);

/*        rootLayout.addSpanning(bottomHudView, 4, 0, 1, 2);
        rootLayout.setRowStretch(4, 0);
        rootLayout.setMinRowHeight(4, hudRowH);*/

		//new
		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
/*		rootLayout.add(choicesPanel, 4, 0);     // left column
		rootLayout.add(bottomHudView, 4, 1);    // right column
		rootLayout.setRowStretch(4, 0);         // fixed bottom-row height
		rootLayout.setMinRowHeight(4, hudRowH);*/


		this.attachResizeHandler;
		^this
	}

	// -------- Public (visual-only) --------
	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var fmt, effCText, effNText, aIsCurrent;

		fmt = { arg listRef, bypassKeys, effList;
			var itemsOut, lastIndex, processors, indexCounter;
			itemsOut = Array.new;
			lastIndex = listRef.size - 1;
			itemsOut = itemsOut.add("src : " ++ listRef[lastIndex]);
			if(listRef.size > 2) {
				itemsOut = itemsOut.add("procs:");
				processors = listRef.copyRange(1, lastIndex - 1).reverse;
				indexCounter = 1;
				processors.do({ arg key;
					var byp, badge, lineText;
					byp = bypassKeys.includes(key);
					badge = byp.if({ "[BYP]" }, { "[ON]" });
					lineText = " [" ++ indexCounter ++ "] " ++ key ++ " " ++ badge;
					itemsOut = itemsOut.add(lineText);
					indexCounter = indexCounter + 1;
				});
			}{
				itemsOut = itemsOut.add("procs: (none)");
			};
			itemsOut = itemsOut.add("sink : " ++ listRef[0]);
			itemsOut
		};

		effCText = "eff: " ++ effCurrent.join(" -> ");
		effNText = "eff: " ++ effNext.join(" -> ");

		if(leftListView.notNil)  { leftListView.items_(fmt.value(current, bypassAKeys, effCurrent)) };
		if(rightListView.notNil) { rightListView.items_(fmt.value(next,    bypassBKeys, effNext))    };
		if(leftEff.notNil)  { leftEff.string_(effCText) };
		if(rightEff.notNil) { rightEff.string_(effNText) };

		aIsCurrent = (current[0] == \chainA);
		if(leftHeader.notNil)  { leftHeader.string_((aIsCurrent).if({ "CHAIN A ACTIVE" }, { "CHAIN A NEXT" })) };
		if(rightHeader.notNil) { rightHeader.string_((aIsCurrent).if({ "CHAIN B NEXT"   }, { "CHAIN B ACTIVE" })) };

		// no .trim (SC String has no trim); keep plain join
		if(bottomCurText.notNil)  { bottomCurText.string_(" " ++ effCurrent.copyRange(1, effCurrent.size-1).join(" -> ")) };
		if(bottomNextText.notNil) { bottomNextText.string_(" " ++ effNext.copyRange(1, effNext.size-1).join(" -> ")) };

		^this
	}

	highlightCurrentColumn { arg currentSinkSym;
		var greenBg, neutralBg, isA;
		greenBg   = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		isA = (currentSinkSym == \chainA);
		if(leftPanel.notNil)  { leftPanel.background_((isA).if({ greenBg }, { neutralBg })) };
		if(rightPanel.notNil) { rightPanel.background_((isA).if({ neutralBg }, { greenBg })) };
		^this
	}

/*    showExpectation { arg textString, seconds = 0;
        var secs;
        secs = seconds ? 0;
        if(expectationView.notNil) { expectationView.string_(textString.asString) };
        if(countdownLabel.notNil)  { countdownLabel.string_((secs > 0).if({ "Listen in‚Ä¶ (" ++ secs ++ "s)" }, { "Ready" })) };
        ^this
    }*/

	showExpectation { |text, seconds = 0|
		var messageText;

		messageText = text.asString;
		this.queueUi({
			if (expectationView.notNil) { expectationView.string = messageText };
		});
		this
	}

	//new:
	// Add inside MagicDisplayGUI_GridDemo class:
	setOperations { arg itemsArray;
		var s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
		AppClock.sched(0.0, {
			if(choicesText.notNil) {
				choicesText.string_( (s.size > 0).if({ s }, { "‚Äî" }) );
				// Re-assert color to be safe across themes (match dark/light choice you used)
				choicesText.stringColor_(Color(0.96, 0.96, 0.96));  // dark panel
				// or choicesText.stringColor_(Color(0.10, 0.10, 0.10));  // light panel
			}{
				if(expectationView.notNil) {
					expectationView.string_("Choices:\n" ++ ((s.size > 0).if({ s }, { "‚Äî" })));
				};
			};
			nil
		});
		^this
	}




	enableMeters { arg flag = false; metersEnabled = (flag ? false); ^this }

	attachResizeHandler {
		var run;
		run = {
			var v;
			v = window.tryPerform(\view);
			if(v.notNil) {
				v.onResize = {
					if(debugOn) { this.debugGuides(true) };
				};
			};
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	// -------- Debug overlay --------

	debugGuides { arg on = true;
		var mkOverlay, labelText;
		debugOn = (on ? true);

		mkOverlay = { arg ov;
			var out;
			out = ov;
			if(out.isNil or: { out.isClosed }) {
				out = UserView(window.view);
				out.drawFunc = { |v|
					var b;
					b = v.bounds;
					Pen.color = Color(1, 0, 0, 0.35);
					Pen.width = 2;
					Pen.strokeRect(Rect(1, 1, b.width - 2, b.height - 2));
				};
				out.background = Color.clear;
			};
			out
		};

		AppClock.sched(0.00, {
			overlayRow0 = mkOverlay.value(overlayRow0);
			overlayRow1 = mkOverlay.value(overlayRow1);
			overlayRow2 = mkOverlay.value(overlayRow2);
			overlayRow3 = mkOverlay.value(overlayRow3);
			overlayRow4 = mkOverlay.value(overlayRow4);

			rootLayout.addSpanning(overlayRow0, 0, 0, 1, 2);
			rootLayout.addSpanning(overlayRow1, 1, 0, 1, 2);
			rootLayout.addSpanning(overlayRow2, 2, 0, 1, 2);
			rootLayout.addSpanning(overlayRow3, 3, 0, 1, 2);
			rootLayout.addSpanning(overlayRow4, 4, 0, 1, 2);

			AppClock.sched(0.02, {
				var r0, r1, r2, r3, r4;
				var mkLabel;
				mkLabel = { arg parent, text;
					var st;
					st = StaticText(parent).string_(text).stringColor_(Color(1, 0.2, 0.2)).align_(\left);
					st.background = Color(1, 1, 1, 0.20);
					st  // no caret return in closures
				};

				overlayRow0.children.do(_.remove);
				overlayRow1.children.do(_.remove);
				overlayRow2.children.do(_.remove);
				overlayRow3.children.do(_.remove);
				overlayRow4.children.do(_.remove);

				r0 = overlayRow0.bounds; r1 = overlayRow1.bounds; r2 = overlayRow2.bounds; r3 = overlayRow3.bounds; r4 = overlayRow4.bounds;
				mkLabel.value(overlayRow0, "row 0  " ++ r0.width.round(1) ++ "√ó" ++ r0.height.round(1));
				mkLabel.value(overlayRow1, "row 1  " ++ r1.width.round(1) ++ "√ó" ++ r1.height.round(1));
				mkLabel.value(overlayRow2, "row 2  " ++ r2.width.round(1) ++ "√ó" ++ r2.height.round(1));
				mkLabel.value(overlayRow3, "row 3  " ++ r3.width.round(1) ++ "√ó" ++ r3.height.round(1) ++ " (meters)");
				mkLabel.value(overlayRow4, "row 4  " ++ r4.width.round(1) ++ "√ó" ++ r4.height.round(1) ++ " (processors)");
				nil
			});
			nil
		});

		^this
	}

	postLayoutReport {
		var run;
		run = {
			var r0, r1, r2, r3, r4, unionRow0;
			unionRow0 = leftPanel.bounds.union(rightPanel.bounds);
			r0 = unionRow0; r1 = expectationView.bounds; r2 = countdownHolder.bounds; r3 = meterStrip.bounds; r4 = bottomHudView.bounds;
			("[layout] row0=" ++ r0).postln;
			("[layout] row1=" ++ r1).postln;
			("[layout] row2=" ++ r2).postln;
			("[layout] row3=" ++ r3).postln;
			("[layout] row4=" ++ r4).postln;
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	updateTextField { |box, msg|
		// fallback: write to expectationView only
		if(expectationView.notNil) {
			expectationView.string_("[" ++ box.asString ++ "] " ++ msg.asString);
		};
		^this;
	}



	//new
	// Add inside MagicDisplayGUI_GridDemo class:
	// setOperations { arg itemsArray;
	// 	var s;
	// 	// build a visible list; accept nil and non-strings defensively
	// 	s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
	// 	if(choicesText.notNil) {
	// 		AppClock.sched(0.0, {
	// 			choicesText.string_( (s.size > 0).if({ s }, { "‚Äî" }) );
	// 			nil
	// 		});
	// 	};
	// 	^this
	// }

}

===== MagicPedalboard/MagicDisplayGUI_Meters_Responders_Ext.sc_disabled =====
// MagicDisplayGUI_Meters_Draw_Ext.sc
// v0.3.0
// MD 2025-09-24 22:58 BST

/*
Purpose
- Provide enableMeters(flag=true) without adding ivars.
- Draw simple A/B bars into the existing meterStrip : UserView and keep them
  updated from /reply packets sent by SendReply.kr in your AutoMeters helper.
Style
- Class extension only; var-first; AppClock UI; no server.sync; NO ^ inside closures.
*/

+ MagicDisplayGUI_GridDemo {

    // per-window state bag (no new ivars on the class)
    md_meterState {
        var bag, key, dict;
        bag = ~md_meterState ? IdentityDictionary.new;
        key = this.window.identityHash;
        dict = bag[key] ? IdentityDictionary.new;
        bag[key] = dict;
        ~md_meterState = bag;
        ^dict
    }

    // prepare the UserView and its drawFunc
    md_installMeterUserView {
        var state, host, setup;
        state = this.md_meterState;
        host  = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        setup = {
            var uv, ownUV, makeOwn, w, h, y;
            uv = state[\uv]; ownUV = state[\own];
            if(uv.isNil) {
                uv = this.meterStrip; // preferred: reuse your existing strip
                if(uv.isNil) {
                    // fall back: create a new one at bottom
                    w = host.bounds.width;  h = host.bounds.height; y = h - 46;
                    makeOwn = UserView(host);
                    makeOwn.bounds_(Rect(8, y, w - 16, 38));
                    uv = makeOwn; ownUV = true;
                };
                uv.background_(Color(0.12, 0.12, 0.12));
                uv.drawFunc = { |view|
                    var st, vw, vh, a, b, barW, barH, leftX, rightX, midY, titleY;
                    st = this.md_meterState;
                    vw = view.bounds.width;  vh = view.bounds.height;
                    a = (st[\valA] ? 0.0).clip(0, 1);
                    b = (st[\valB] ? 0.0).clip(0, 1);
                    barW = ((vw * 0.45) - 40).max(80);
                    barH = (vh * 0.40);
                    leftX  = 24;
                    rightX = (vw * 0.50) + 24;
                    midY   = (vh * 0.30);
                    titleY = (vh * 0.18);

                    Pen.color = Color(0.85,0.85,0.85);
                    Pen.stringAtPoint("A", Point(leftX - 18, titleY));
                    Pen.stringAtPoint("B", Point(rightX - 18, titleY));

                    Pen.color = Color(0.30, 0.90, 0.30); // A green
                    Pen.addRect(Rect(leftX, midY, barW * a, barH)); Pen.fill;

                    Pen.color = Color(0.30, 0.60, 0.90); // B blue
                    Pen.addRect(Rect(rightX, midY, barW * b, barH)); Pen.fill;
                };
                state[\uv] = uv; state[\own] = ownUV ? true : false;
                uv.refresh;
            };
        };

        AppClock.sched(0.0, { setup.value; nil });
        ^this
    }

    enableMeters { arg flag = true;
        var state, idStr, oscNameA, oscNameB, install, remove;

        state    = this.md_meterState;
        idStr    = this.window.identityHash.asString;
        oscNameA = ("md_ampA_" ++ idStr).asSymbol;
        oscNameB = ("md_ampB_" ++ idStr).asSymbol;

        remove = {
            var oa, ob, uv;
            oa = OSCdef(oscNameA); if(oa.notNil) { oa.free };
            ob = OSCdef(oscNameB); if(ob.notNil) { ob.free };
            state[\valA] = 0.0; state[\valB] = 0.0;
            uv = state[\uv]; if(uv.notNil) { uv.refresh };
            state[\enabled] = false;
        };

        install = {
            var uv;

            this.md_installMeterUserView;

            OSCdef.new(oscNameA, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampA") || (label == "ampA")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valA] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            OSCdef.new(oscNameB, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampB") || (label == "ampB")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valB] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            state[\enabled] = true;
        };

        AppClock.sched(0.0, { if(flag) { install.value } { remove.value }; nil });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd
// v0.1.2
// MD 2025-09-26 15:36 BST

/* Purpose
   Provide a tiny, explicit CURRENT chain flag for the HUD (no pulsing).
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_setCurrentChain = { arg chainSymbol;
    var valid;
    valid = (chainSymbol == \A) or: { chainSymbol == \B };
    if(valid) { ~md_currentChain = chainSymbol };
    nil
};

~md_toggleCurrentChain = {
    var now;
    now = ~md_currentChain ? \A;
    ~md_currentChain = (now == \A).if({ \B }, { \A });
    nil
};

~md_isChainAActive = { (~md_currentChain ? \A) == \A };
~md_isChainBActive = { (~md_currentChain ? \A) == \B };
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd
// v0.1.1 (robust attach + returns view)
// MD 2025-09-26 15:58 BST

/* Purpose
   A thin ACTIVE overlay bar at the top of the HUD.
   - A = green, B = blue-ish.
   - Robust window lookup (name contains "MagicDisplayGUI" or "PerfHUD").
   - Returns the overlay view (so "-> a UserView" shows in post).
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_attachActiveOverlay = {
    var windowsList, hudWindow, nameString, barHeight, overlayView, refreshRoutine;
    windowsList = Window.allWindows;

    hudWindow = windowsList.detect({ arg w;
        var n;
        n = w.tryPerform(\name);
        nameString = n.notNil.if({ n.asString }, { "" });
        (nameString.contains("MagicDisplayGUI") or: { nameString.contains("PerfHUD") })
    });

    if(hudWindow.isNil) {
        "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn;
        ^nil
    };

    barHeight = 8;

    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color;
        Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height));
        Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    ~md_activeOverlayView = overlayView;
    ~md_activeOverlayRoutine = refreshRoutine;

    "[HUD] active overlay attached (top bar)".postln;
    overlayView   // IMPORTANT: return the view (not nil)
};

~md_detachActiveOverlay = {
    var view, routine;
    view = ~md_activeOverlayView; routine = ~md_activeOverlayRoutine;
    if(routine.notNil) { routine.stop };
    if(view.notNil) { view.remove };
    ~md_activeOverlayView = nil; ~md_activeOverlayRoutine = nil;
    "[HUD] active overlay removed".postln;
    nil
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Keep the Chain A/B panel backgrounds in sync with ~md_currentChain (solid green).
   - Finds the A/B panels by locating "Chain A"/"Chain B" StaticText labels.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_findHudPanels = {
    var windowRef, collectViews, allViews, panelForLabel, aPanel, bPanel;

    windowRef = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });
    if(windowRef.isNil) { ^[nil, nil] };

    collectViews = { arg rootView, list;
        var children;
        children = rootView.children ? [];
        children.do({ arg c; list.add(c); collectViews.(c, list) });
        list
    };

    allViews = collectViews.(windowRef.view, List.new);

    panelForLabel = { arg labelString;
        var labelView, panelView;
        labelView = allViews.detect({ arg v; v.isKindOf(StaticText) and: { v.string == labelString } });
        panelView = labelView.notNil.if({ labelView.parent }, { nil });
        panelView
    };

    aPanel = panelForLabel.("Chain A");
    bPanel = panelForLabel.("Chain B");
    [aPanel, bPanel]
};

~md_startActiveTintOverlay = {
    var panels, aPanel, bPanel, winRef, routine, activeColor, idleColor;

    panels = ~md_findHudPanels.();
    aPanel = panels[0]; bPanel = panels[1];

    if(aPanel.isNil or: { bPanel.isNil }) {
        "‚ö†Ô∏è Could not locate Chain A/B panels; tint overlay not installed.".warn;
        ^nil
    };

    winRef = aPanel.window;
    activeColor = Color(0.18, 0.28, 0.18);
    idleColor   = Color.grey(0.15);

    routine = Routine({
        var keepRunning, isA, isB;
        keepRunning = true;
        while({ keepRunning and: { winRef.notNil and: { winRef.isClosed.not } } }, {
            isA = (~md_currentChain ? \A) == \A;
            isB = (~md_currentChain ? \A) == \B;
            aPanel.background_( isA.if({ activeColor }, { idleColor }) );
            bPanel.background_( isB.if({ activeColor }, { idleColor }) );
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] ACTIVE tint overlay running (current=" ++ (~md_currentChain ? \A).asString ++ ")".postln;
    routine
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd =====
// MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd
// v0.1.0
// MD 2025-09-26 16:10 BST

/* Purpose
   Listen to /md/levels_gui (GA=32001, GB=32002), fill ~md_gui_levelsById,
   and provide a tiny overlay + helpers that read from that dict.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_gui_levelsById  = ~md_gui_levelsById  ? IdentityDictionary.new;
~md_gui_lastStamp   = ~md_gui_lastStamp   ? SystemClock.seconds.asFloat;

~md_installGuiLevelsListener = {
    var key, existing;
    key = \md_levels_gui_listener;

    existing = OSCdef.all.at(key);
    if(existing.notNil) { existing.free };

    OSCdef(key, { arg msg;
        var replyId, l, r, safeL, safeR, now;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        l = msg[3].asFloat; r = msg[4].asFloat;
        safeL = l.isFinite.if({ l.clip(0, 1) }, { 0.0 });
        safeR = r.isFinite.if({ r.clip(0, 1) }, { 0.0 });
        ~md_gui_levelsById.put(replyId, [safeL, safeR]);
        now = SystemClock.seconds.asFloat;
        ~md_gui_lastStamp = now;
        nil
    }, "/md/levels_gui", recvPort: NetAddr.langPort);

    "[HUD] /md/levels_gui listener installed (key=md_levels_gui_listener)".postln;
    nil
};

~md_attachGuiOverlayMeters = {
    var hudWindow, overlayView, barWidth, pad, height, refreshRoutine;

    // robust window search
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    pad = 8; barWidth = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, barWidth, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        aPair = ~md_gui_levelsById.at(32001) ? [0, 0];
        bPair = ~md_gui_levelsById.at(32002) ? [0, 0];

        aL = aPair[0]; aR = aPair[1];
        bL = bPair[0]; bR = bPair[1];

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B top half
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] overlay meters (GUI) attached (top-left)".postln;
    overlayView  // return view
};

~md_currentChain = ~md_currentChain ? \A;
~md_attachActiveOverlay = {  // reuse name, returns a UserView
    var hudWindow, overlayView, barHeight, refreshRoutine;
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    barHeight = 8;
    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color; Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height)); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    "[HUD] active overlay attached (top bar)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext_V0.1.0.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.1
// MD 2025-09-29 16:58 BST

/* Purpose
   Install language-side OSC responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters. Also install HUD
   meter mapping helpers so UI levels have headroom and do not peg at 1.0.

   Keeper notes
   - 2025-09-29: Ensure ampA/ampB responders auto-install on HUD bring-up (after reset).
                 Added ~hud_map_linear_to_ui (and dB sibling) with defaults:
                 floor -60 dB, top -6 dB, gamma 1.0. Apply at UI write-site.
                 Without responders, ~md_levelsById may be stale/empty ‚Üí solid green meters.

Style
   - var-first; descriptive lowercase names; AppClock-only for UI; no server.sync; no non-local returns.
*/

(
var ensureAmpRespondersInstalled, installHudMeterMappingHelpers;

~md_installAmpToModelResponders = {
    var ensureModelReady, existingResponderA, existingResponderB;

    ensureModelReady = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModelReady.();

    // /ampA -> model[2001]
    existingResponderA = OSCdef.all.at(\ampA_to_model);
    if(existingResponderA.notNil) { existingResponderA.free };
    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingResponderB = OSCdef.all.at(\ampB_to_model);
    if(existingResponderB.notNil) { existingResponderB.free };
    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};

ensureAmpRespondersInstalled = {
    var hasResponderA, hasResponderB;
    hasResponderA = OSCdef.all.at(\ampA_to_model).notNil;
    hasResponderB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasResponderA.not or: { hasResponderB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Keeper defaults (adjust to taste across sessions)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 lifts lows; >1 tames lows

    // Linear (0..1) ‚Üí UI 0..1 via dB mapping + optional perceptual curve
    ~hud_map_linear_to_ui = ~hud_map_linear_to_ui ? { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear ‚Üí dBFS
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dBFS ‚Üí 0..1
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);
        curvedValue
    };

    // dB (e.g., -60..0) ‚Üí UI 0..1 (sibling helper if a dB route is used anywhere)
    ~hud_map_db_to_ui = ~hud_map_db_to_ui ? { arg dbValue;
        var floorDb, topDb, gammaValue, normalizedValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0).clip(0.0, 1.0);
        normalizedValue.pow(gammaValue)
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

// Schedule both on AppClock so they are present after HUD bring-up and after a reset
AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Install language-side responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(

	//new
	var ensureAmpRespondersInstalled;
var installHudMeterMappingHelpers;


~md_installAmpToModelResponders = {
    var ensureModel, existingA, existingB;




    ensureModel = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModel.();

    // /ampA -> model[2001]
    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};


ensureAmpRespondersInstalled = {
    var hasAmpA, hasAmpB;

    hasAmpA = OSCdef.all.at(\ampA_to_model).notNil;
    hasAmpB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasAmpA.not or: { hasAmpB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Display calibration (keeper defaults; tweak to taste)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 raises lows; >1 tames lows

    // Linear (0..1) ‚Üí UI value (0..1) with dB headroom and optional curve
    ~hud_map_linear_to_ui = { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db;
        topDb      = ~hud_meter_top_db;
        gammaValue = ~hud_meter_gamma;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear ‚Üí dB
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dB ‚Üí 0..1 (with top < 0 dBFS)
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);                // perceptual shaping (optional)
        curvedValue
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });

)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_Meters_Ext.scd =====
// MagicDisplayGUI_PerfHUD_Meters_Ext.scd
// v0.1.0
// MD 2025-09-26 15:05 BST

/* Purpose / Style
   Provide a small dbScale helper and an optional overlay you can attach to the HUD.
   - var-first; descriptive lowercase; AppClock-only; no server.sync; no non-local '^'.
*/

(
~md_dbScale = { arg linAmp, dbMin = -60.0;
    var safeAmp, dbVal, norm;
    safeAmp = (linAmp ? 0.0).max(1e-6);
    dbVal   = safeAmp.ampdb;                      // language-side conversion
    norm    = ((dbVal - dbMin) / (0 - dbMin)).clip(0.0, 1.0);
    norm
};

~md_attachOverlayMeters = {
    var hudWindow, pad, width, height, overlayView;

    hudWindow = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });

    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI window found.".warn; ^nil };

    pad = 8; width = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, aLs, aRs, bLs, bRs, h, halfW;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0]; aR = aPair[1]; bL = bPair[0]; bR = bPair[1];

        aLs = ~md_dbScale.(aL, -60.0); aRs = ~md_dbScale.(aR, -60.0);
        bLs = ~md_dbScale.(bL, -60.0); bRs = ~md_dbScale.(bR, -60.0);

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aLs), halfW, (h/2 * aLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aRs), halfW, (h/2 * aRs))); Pen.fill;

        // B top half (lighter)
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bLs), halfW, (h/2 * bLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bRs), halfW, (h/2 * bRs))); Pen.fill;
    });

    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left; dB-scaled)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicDisplayGUI.sc =====
/* MagicDisplayGUI.sc v0.2.7
 CURRENT column highlighted in green; top-down list (src ‚Üí procs ‚Üí sink);
 expectation text + visual countdown; operations list with 3s pre-roll;
 embedded meters (A/B). UI-ready queue prevents touching nil views.
 No server.sync; server ops inside Server.default.bind.
 // MD 20250912-1738
*/
MagicDisplayGUI : MagicDisplay {
	classvar <versionGUI;

	var <window;

	// layout elements
	var leftPanel, rightPanel;
	var leftHeader, rightHeader;
	var leftListView, rightListView;
	var leftEffective, rightEffective;

	// expectation + countdown
	var expectationText;
	var countdownLabel, countdownBarView, countdownTask, countdownSecondsDefault;

	// operations panel
	var opsListView, opsNextButton, opsStatusText;
	var opsItems, opsIndexNext, opsCallback, opsCountdownSeconds;

	// meters
	var meterViewA, meterViewB;
	var meterSynthA, meterSynthB, oscA, oscB;
	var enableMetersFlag;

	// ui-ready machinery
	var uiReadyFlag;
	var uiPendingActions;

	*initClass {
		var text;
		versionGUI = "v0.2.7";
		text = "MagicDisplayGUI " ++ versionGUI;
		text.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var windowRect, panelWidth, listHeight, headerHeight, footerHeight, pad;
		var opsWidth, opsRect;
		var buildWindow;

		windowRect = Rect(100, 100, 980, 520);
		panelWidth = 300;
		listHeight = 300;
		headerHeight = 28;
		footerHeight = 22;
		pad = 10;

		opsWidth = 320;
		opsRect = Rect(2 * pad + 2 * panelWidth + 40, pad, opsWidth, windowRect.height - 2 * pad);

		countdownSecondsDefault = 3.0;
		opsCountdownSeconds = 3.0;
		enableMetersFlag = true;

		uiReadyFlag = false;
		uiPendingActions = Array.new;

		buildWindow = {
			var metersHeight, greenBg, neutralBg;
			var buildColumn, buildMeters, applyInitialHighlight;
			var columnLeftX, columnRightX;
			var columnLeftDict, columnRightDict;

			metersHeight = 86;
			greenBg = Color(0.85, 1.0, 0.85);
			neutralBg = Color(0.92, 0.92, 0.92);

			columnLeftX = pad;
			columnRightX = pad + panelWidth + 40;

			buildColumn = { arg xPos, title;
				var panel, header, listView, effectiveLabel;
				var headerRect, listRect, effRect, resultDict;

				panel = CompositeView(window, Rect(xPos, pad, panelWidth, windowRect.height - 2 * pad - metersHeight));
				panel.background_(neutralBg);

				headerRect = Rect(0, 0, panelWidth, headerHeight);
				header = StaticText(panel, headerRect).string_(title);
				header.align_(\center);

				listRect = Rect(0, headerHeight + 6, panelWidth, listHeight);
				listView = ListView(panel, listRect).items_([]);

				effRect = Rect(0, headerHeight + 6 + listHeight + 6, panelWidth, footerHeight);
				effectiveLabel = StaticText(panel, effRect).string_("eff: ‚Äî");
				effectiveLabel.align_(\center);

				resultDict = (panel: panel, header: header, list: listView, eff: effectiveLabel);
				resultDict
			};

			buildMeters = {
				var metersGroup, labelA, labelB, row1, row2, labelWidth, barWidth, rowHeight;

				labelWidth = 60;
				barWidth = windowRect.width - 2 * pad - labelWidth - 10;
				rowHeight = 30;

				metersGroup = CompositeView(window, Rect(pad, windowRect.height - metersHeight - pad, windowRect.width - 2 * pad, metersHeight));
				metersGroup.background_(Color(0.96, 0.96, 0.96));

				row1 = CompositeView(metersGroup, Rect(0, 0, metersGroup.bounds.width, rowHeight));
				labelA = StaticText(row1, Rect(0, 4, labelWidth, 20)).string_("chainA");
				meterViewA = LevelIndicator(row1, Rect(labelWidth + 6, 4, barWidth, 20));

				row2 = CompositeView(metersGroup, Rect(0, rowHeight + 8, metersGroup.bounds.width, rowHeight));
				labelB = StaticText(row2, Rect(0, 4, labelWidth, 20)).string_("chainB");
				meterViewB = LevelIndicator(row2, Rect(labelWidth + 6, 4, barWidth, 20));
			};

			applyInitialHighlight = {
				var currentBg, nextBg;
				currentBg = greenBg;
				nextBg = neutralBg;
				if(leftPanel.notNil) { leftPanel.background_(currentBg) };
				if(rightPanel.notNil) { rightPanel.background_(nextBg) };
			};

			window = Window("MagicDisplayGUI ‚Äì CURRENT / NEXT", windowRect).front.alwaysOnTop_(true);

			columnLeftDict = buildColumn.value(columnLeftX, "CURRENT");
			leftPanel      = columnLeftDict[\panel];
			leftHeader     = columnLeftDict[\header];
			leftListView   = columnLeftDict[\list];
			leftEffective  = columnLeftDict[\eff];

			columnRightDict = buildColumn.value(columnRightX, "NEXT");
			rightPanel      = columnRightDict[\panel];
			rightHeader     = columnRightDict[\header];
			rightListView   = columnRightDict[\list];
			rightEffective  = columnRightDict[\eff];

			expectationText = TextView(window, Rect(pad, leftPanel.bounds.bottom + 6, 2 * panelWidth + 40, 52));
			expectationText.background_(Color(1, 1, 0.9));
			expectationText.string_("Command:");

			countdownLabel = StaticText(window, Rect(pad, expectationText.bounds.bottom + 6, 120, 20)).string_("Ready");

			countdownBarView = UserView(window, Rect(pad + 130, expectationText.bounds.bottom + 6, panelWidth - 10, 20));
			countdownBarView.background_(Color(0.9, 0.9, 0.9));
			countdownBarView.drawFunc_({ arg view;
				var barWidthNow, fullWidth, progressFraction, colorFill, progressStored;
				progressStored = view.getProperty(\progress) ? 0.0;
				progressFraction = progressStored.clip(0, 1);
				fullWidth = view.bounds.width;
				barWidthNow = fullWidth * progressFraction;
				colorFill = Color(0.3, 0.8, 0.3);
				Pen.fillColor = colorFill;
				Pen.addRect(Rect(0, 0, barWidthNow, view.bounds.height));
				Pen.fill;
			});
			countdownBarView.setProperty(\progress, 0.0);

			opsItems = Array.new;
			opsIndexNext = 0;
			opsCallback = nil;

			opsListView = ListView(window, opsRect).items_([]);
			opsStatusText = StaticText(window, Rect(opsRect.left, opsRect.bottom - 52, opsRect.width - 110, 20)).string_("Next: ‚Äî");
			opsNextButton = Button(window, Rect(opsRect.right - 100, opsRect.bottom - 56, 100, 28))
			.states_([["Next (3s)", Color.white, Color(0, 0.5, 0)]])
			.action_({
				var nextIndexLocal, totalCountLocal, nextLabel;
				nextIndexLocal = opsIndexNext;
				totalCountLocal = opsItems.size;
				if(nextIndexLocal >= totalCountLocal) { "No more operations.".postln; ^nil };
				nextLabel = opsItems[nextIndexLocal];
				this.startCountdown(opsCountdownSeconds, "Next: " ++ nextLabel, {
					var clampedIndex;
					clampedIndex = opsIndexNext.clip(0, opsItems.size - 1);
					this.runNextOperation(clampedIndex);
				});
			});

			buildMeters.value;
			applyInitialHighlight.value;

			uiReadyFlag = true;
			this.flushUiPendingActions;
		};

		AppClock.sched(0, {
			var enableNow;
			buildWindow.value;
			enableNow = enableMetersFlag;
			if(enableNow) { this.enableMeters(true) };
			nil
		});

		^this
	}

	// ui-ready helpers
	queueUi { arg func;
		var fn;
		fn = func;
		if(uiReadyFlag) {
			AppClock.sched(0, { fn.value; nil });
		}{
			uiPendingActions = uiPendingActions.add(fn);
		};
	}

	flushUiPendingActions {
		var actionsToRun;
		actionsToRun = uiPendingActions;
		uiPendingActions = Array.new;
		actionsToRun.do({ arg f;
			AppClock.sched(0, { f.value; nil });
		});
	}


	// visuals

// highlight whichever sink is CURRENT
highlightCurrentColumn { arg currentSinkSym;
    var greenBg, neutralBg, isA;
    greenBg   = Color(0.85, 1.0, 0.85);
    neutralBg = Color(0.92, 0.92, 0.92);
    isA = (currentSinkSym == \chainA);

    this.queueUi({
        if(leftPanel.notNil)  { leftPanel.background_(if(isA) { greenBg } { neutralBg }) };
        if(rightPanel.notNil) { rightPanel.background_(if(isA) { neutralBg } { greenBg }) };
    });
}

/*	highlightCurrentColumn {
		var greenBg, neutralBg;
		greenBg = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		this.queueUi({
			if(leftPanel.notNil) { leftPanel.background_(greenBg) };
			if(rightPanel.notNil) { rightPanel.background_(neutralBg) };
		});
	}*/

	formatListTopDown { arg listRef, bypassKeys, effectiveList;
		var itemsOut, lastIndex, processorsList, indexCounter, sourceKey, sinkKey, isBypassed, badge, lineText;
		itemsOut = Array.new;
		lastIndex = listRef.size - 1;
		sinkKey = listRef[0];
		sourceKey = listRef[lastIndex];

		itemsOut = itemsOut.add("src  : " ++ sourceKey);

		if(listRef.size > 2) {
			itemsOut = itemsOut.add("procs:");
			processorsList = listRef.copyRange(1, lastIndex - 1).reverse;
			indexCounter = 1;
			processorsList.do({ arg procKey;
				isBypassed = bypassKeys.includes(procKey);
				badge = if(isBypassed) { "[BYP]" } { "[ON]" };
				lineText = "  [" ++ indexCounter ++ "] " ++ procKey ++ " " ++ badge;
				itemsOut = itemsOut.add(lineText);
				indexCounter = indexCounter + 1;
			});
		}{
			itemsOut = itemsOut.add("procs: (none)");
		};

		itemsOut = itemsOut.add("sink : " ++ sinkKey);
		itemsOut = itemsOut.add("eff  : " ++ effectiveList.join(" -> "));
		^itemsOut
	}

	// expectation + countdown
	showExpectation { arg textString, seconds = 0;
		var secondsLocal, hasCountdown;
		secondsLocal = seconds ? 0;
		hasCountdown = secondsLocal > 0;

		this.queueUi({
			var labelNow;
			if(expectationText.notNil) { expectationText.string_(textString.asString) };
			if(hasCountdown) {
				this.startCountdown(secondsLocal, "Listen in‚Ä¶", { nil });
			}{
				labelNow = "Ready";
				if(countdownLabel.notNil) { countdownLabel.string_(labelNow) };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, 0.0);
					countdownBarView.refresh;
				};
			};
		});
	}

	startCountdown { arg seconds, labelText, onFinishedFunc;
		var secondsClamped, startTime, stopTime;
		secondsClamped = seconds.clip(0.5, 10.0);
		startTime = Main.elapsedTime;
		stopTime = startTime + secondsClamped;

		if(countdownTask.notNil) { countdownTask.stop; countdownTask = nil };

		this.queueUi({
			var finishedFlag, delaySeconds, updateAndCheckDone;

			if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ secondsClamped.asString ++ "s)") };
			if(countdownBarView.notNil) {
				countdownBarView.setProperty(\progress, 0.0);
				countdownBarView.refresh;
			};

			finishedFlag = false;
			delaySeconds = 0.05;

			updateAndCheckDone = {
				var nowTime, remainingSeconds, progressFraction;
				nowTime = Main.elapsedTime;
				remainingSeconds = (stopTime - nowTime).max(0);
				progressFraction = ((secondsClamped - remainingSeconds) / secondsClamped).clip(0.0, 1.0);

				if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ remainingSeconds.round(0.1).asString ++ "s)") };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, progressFraction);
					countdownBarView.refresh;
				};

				if(remainingSeconds <= 0) { finishedFlag = true };
			};

			countdownTask = Task({
				var localFinished;
				localFinished = false;
				while({ localFinished.not }, {
					updateAndCheckDone.value;
					localFinished = finishedFlag;
					delaySeconds.wait;
				});
				if(countdownLabel.notNil) { countdownLabel.string_("Now") };
				if(onFinishedFunc.notNil) { onFinishedFunc.value };
			}, AppClock).play;
		});
	}

	// operations
	setOperations { arg itemsArray;
		var itemsSafe, entryStrings;
		itemsSafe = itemsArray ? Array.new;
		entryStrings = itemsSafe.collect({ arg it; it.asString });

		this.queueUi({
			opsItems = entryStrings;
			if(opsListView.notNil) { opsListView.items_(opsItems) };
			opsIndexNext = 0;
			this.updateOpsHighlight;
		});
	}

	setNextAction { arg func;
		var f;
		f = func;
		opsCallback = f;
	}

	runNextOperation { arg indexToRun;
		var totalCount, nextIndexComputed;
		totalCount = opsItems.size;

		if(opsCallback.notNil) {
			opsCallback.value(indexToRun);
		}{
			("[ops] No callback for index " ++ indexToRun).warn;
		};

		nextIndexComputed = (indexToRun + 1).clip(0, totalCount);
		opsIndexNext = nextIndexComputed;
		this.updateOpsHighlight;
	}

	updateOpsHighlight {
		var totalCount, entryStrings, nextIndexLocal, statusText;
		totalCount = opsItems.size;
		nextIndexLocal = opsIndexNext.min(totalCount);

		entryStrings = opsItems.collect({ arg item, idx;
			var marker;
			marker = if(idx == opsIndexNext) { "‚Üí " } { "   " };
			marker ++ item
		});

		statusText = if(opsIndexNext < totalCount) {
			"Next: " ++ opsItems[opsIndexNext]
		}{
			"Done."
		};

		this.queueUi({
			if(opsListView.notNil) { opsListView.items_(entryStrings) };
			if(opsStatusText.notNil) { opsStatusText.string_(statusText) };
		});
	}

	/////////////////
	// meters
	// --- canonical enableMeters: waits until sinks are audio-rate, then attaches meters ---
// MagicDisplayGUI.sc
// canonical enableMeters: resend SynthDefs every time; wait until sinks are audio-rate

	enableMeters { arg flag = true;
    var shouldEnable, busA, busB;

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        // Guard: wait until sinks are audio-rate and server is up
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        if(
            Server.default.serverRunning.not
            or: { busA.isNil or: { busB.isNil } }
            or: { busA.rate != \audio or: { busB.rate != \audio } }
        ) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };

        // Meters rely on SynthDefs provided by MagicDisplay.ensureMeterDefs(...)
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };
            meterSynthA = Synth(\busMeterA, [\inBus, Ndef(\chainA).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, Ndef(\chainB).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free }; if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');

        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');

        ^this;
    }{
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}

/*
enableMeters { arg flag = true;
    var shouldEnable, aOK, bOK, busA, busB;

    // When enabling, wait until sinks are audio-rate (no control-rate bus warnings)
    if(flag) {
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        aOK = busA.notNil and: { busA.rate == \audio };
        bOK = busB.notNil and: { busB.rate == \audio };
        if(aOK.not or: { bOK.not }) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
        // Also guard against server being off
        if(Server.default.serverRunning.not) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
    };

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        Server.default.bind({
            var busA_local, busB_local;

            // Always (re)send SynthDefs so they exist on the server now.
            SynthDef(\busMeterA, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
            }).add;
            SynthDef(\busMeterB, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
            }).add;

            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };

            busA_local = Ndef(\chainA).bus;
            busB_local = Ndef(\chainB).bus;

            meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free };
        if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');
        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');
        ^this;

    } {
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}*/
//////
/*	enableMeters { arg flag = true;
		var shouldEnable, aOK, bOK, busA, busB;

		// Only guard when enabling
		if(flag) {
			// read buses once
			busA = Ndef(\chainA).bus;
			busB = Ndef(\chainB).bus;
			// both must exist and be audio-rate
			aOK = busA.notNil and: { busA.rate == \audio };
			bOK = busB.notNil and: { busB.rate == \audio };
			if(aOK.not or: { bOK.not }) {
				// retry shortly on AppClock; do not mutate the audio tree here
				AppClock.sched(0.20, { this.enableMeters(true); nil });
				^this;
			};
		};

		shouldEnable = flag ? true;
		enableMetersFlag = shouldEnable;

		if(shouldEnable) {
			// --- enable path (unchanged except for the pre-check above) ---
			Server.default.bind({
				var hasA, hasB, busA_local, busB_local;
				hasA = SynthDescLib.global.at(\busMeterA).notNil;
				hasB = SynthDescLib.global.at(\busMeterB).notNil;
				if(hasA.not) {
					SynthDef(\busMeterA, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
					}).add;
				};
				if(hasB.not) {
					SynthDef(\busMeterB, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
					}).add;
				};
				if(meterSynthA.notNil) { meterSynthA.free };
				if(meterSynthB.notNil) { meterSynthB.free };
				// read buses post-guard
				busA_local = Ndef(\chainA).bus;
				busB_local = Ndef(\chainB).bus;
				meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
				meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
			});

			if(oscA.notNil) { oscA.free };
			if(oscB.notNil) { oscB.free };
			oscA = OSCdef(\ampA, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
			}, '/ampA');
			oscB = OSCdef(\ampB, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
			}, '/ampB');
			^this;

		} {
			// --- disable path (unchanged) ---
			Server.default.bind({
				if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
				if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
			});
			if(oscA.notNil) { oscA.free; oscA = nil; };
			if(oscB.notNil) { oscB.free; oscB = nil; };
			AppClock.sched(0, {
				if(meterViewA.notNil) { meterViewA.value_(0.0) };
				if(meterViewB.notNil) { meterViewB.value_(0.0) };
				nil
			});
			^this;
		};
	}
*/

	///////////////

	// display hooks
	showInit { arg pedalboard, versionString, current, next;
		var titleText;
		titleText = "MagicDisplayGUI ‚Äì " ++ versionString;
		this.queueUi({
			if(window.notNil) { window.name_(titleText) };
		});
	}

	showRebuild { arg which, fullChain, effective;
		var infoText;
		infoText = "[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ " effective=" ++ effective;
		AppClock.sched(0, { infoText.postln; nil });
	}

	showPlay { arg sinkKey;
		var text;
		text = "[MPB:play] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showStop { arg sinkKey;
		var text;
		text = "[MPB:stop] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showSwitch { arg oldSink, newSink, current, next;
    var infoText;
    infoText = "[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink;
    this.queueUi({
        // was: this.highlightCurrentColumn;
        this.highlightCurrentColumn(newSink);               // <-- pass which sink is now CURRENT

        if(opsStatusText.notNil) {
            opsStatusText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
        }{
            if(expectationText.notNil) {
                expectationText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
            };
        };
    });
    AppClock.sched(0, { infoText.postln; nil });
}

	// showSwitch { arg oldSink, newSink, current, next;
	// 	var infoText;
	// 	infoText = "[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink;
	// 	this.queueUi({
	// 		// keep window title stable; show transient text in labels instead
	// 		this.highlightCurrentColumn;
	// 		if(opsStatusText.notNil) {
	// 			opsStatusText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
	// 		}{
	// 			if(expectationText.notNil) {
	// 				expectationText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
	// 			};
	// 		};
	// 	});
	// 	AppClock.sched(0, { infoText.postln; nil });
	// }


	showMutation { arg action, args, nextChain;
		var text;
		text = "[MPB:mutate] " ++ action ++ " " ++ args ++ " next=" ++ nextChain;
		AppClock.sched(0, { text.postln; nil });
	}

	showBypass { arg which, key, state, chain, bypassKeys;
		var text;
		text = "[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state ++ " active=" ++ bypassKeys;
		AppClock.sched(0, { text.postln; nil });
	}

	showReset { arg current, next;
		var text;
		text = "[MPB:reset] current=" ++ current ++ " next=" ++ next;
		AppClock.sched(0, { text.postln; nil });
	}

	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
    var currentItems, nextItems, effCurrentText, effNextText, aIsPlaying, bIsPlaying, aIsCurrent;

    currentItems   = this.formatListTopDown(current, bypassAKeys, effCurrent);
    nextItems      = this.formatListTopDown(next,   bypassBKeys, effNext);
    effCurrentText = "eff: " ++ effCurrent.join(" -> ");
    effNextText    = "eff: " ++ effNext.join(" -> ");

    // detect which sink is CURRENT by the actual play state of the sink Ndef
    aIsPlaying = Ndef(\chainA).isPlaying;
    bIsPlaying = Ndef(\chainB).isPlaying;
    aIsCurrent = (aIsPlaying and: { bIsPlaying.not });  // Option A expects XOR; if both stopped, keep previous
    this.queueUi({
        if(leftHeader.notNil)  { leftHeader.string_(if(aIsCurrent) { "CHAIN A ACTIVE" } { "CHAIN A NEXT" }) };
        if(rightHeader.notNil) { rightHeader.string_(if(aIsCurrent) { "CHAIN B NEXT"  } { "CHAIN B ACTIVE" }) };

        if(leftListView.notNil)  { leftListView.items_(currentItems) };
        if(rightListView.notNil) { rightListView.items_(nextItems) };

        if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
        if(rightEffective.notNil) { rightEffective.string_(effNextText) };
    });
}

/*	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var currentItems, nextItems, effCurrentText, effNextText;
		currentItems = this.formatListTopDown(current, bypassAKeys, effCurrent);
		nextItems = this.formatListTopDown(next,   bypassBKeys, effNext);
		effCurrentText = "eff: " ++ effCurrent.join(" -> ");
		effNextText    = "eff: " ++ effNext.join(" -> ");

		this.queueUi({
			if(leftHeader.notNil)  { leftHeader.string_("CHAIN A ACTIVE") };
			if(rightHeader.notNil) { rightHeader.string_("CHAIN B NEXT") };
			if(leftListView.notNil)  { leftListView.items_(currentItems) };
			if(rightListView.notNil) { rightListView.items_(nextItems) };
			if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
			if(rightEffective.notNil) { rightEffective.string_(effNextText) };
		});
	}*/

	showError { arg message;
		var text;
		text = "[MPB:error] " ++ message;
		AppClock.sched(0, { text.warn; nil });
	}
}

===== MagicPedalboard/MagicPedalboard.sc =====
// MagicPedalboard.sc
// v0.1.0
// MD 2025-09-21 17:05

// Purpose: Compatibility alias for MagicPedalboardNew
// Style: Minimal, non-breaking, avoids renaming existing class

MagicPedalboard : MagicPedalboardNew {
    // No additional code needed
}

===== MagicPedalboard/MagicPedalboardNew.sc =====
/* MagicPedalboardNew.sc v0.4.8
 A/B pedalboard chain manager built on Ndefs.

 - Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
 // MD 20250912-1838
*/
MagicPedalboardNew : Object {

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// class metadata
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	classvar <version;

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// instance state
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	var < currentChain;     // read-only pointer to Array of Symbols
	var <nextChain;        // read-only pointer to Array of Symbols
	var chainAList;        // [\chainA, ...processors..., source]
	var chainBList;        // [\chainB, ...processors..., source]
	var bypassA;           // IdentityDictionary: key(Symbol) -> Bool
	var bypassB;           // IdentityDictionary: key(Symbol) -> Bool
	var < defaultNumChannels;
	var < defaultSource;
	var < display;          // optional display adaptor
	var < processorLib;
	var < ready;              // <-- ADD this line

	*initClass {
		var text;
		version = "v0.4.7";
		text = "MagicPedalboardNew " ++ version;
		text.postln;
	}

	*new { arg disp = nil;
		var instance;
		instance = super.new;
		^instance.init(disp);
	}

	init { arg disp;
		var sinkFunc;
		display = disp;
		defaultNumChannels = 2;
		defaultSource = \ts0;

		// less good than the version below
		// sinkFunc = { arg inSignal; inSignal };


		sinkFunc = {
			var inputSignal;
			inputSignal = \in.ar(defaultNumChannels);
			inputSignal
		};

		Ndef(\chainA, sinkFunc);
		Ndef(\chainB, sinkFunc);

		// Guarantee sink buses are audio-rate early (prevents kr-meter races)
		Server.default.bind({
			Ndef(\chainA).ar(defaultNumChannels);  // typically 2
			Ndef(\chainB).ar(defaultNumChannels);
		});


		chainAList = [\chainA, defaultSource];
		chainBList = [\chainB, defaultSource];

		bypassA = IdentityDictionary.new;
		bypassB = IdentityDictionary.new;

		currentChain = chainAList;
		nextChain = chainBList;

		Server.default.bind({
			this.rebuildUnbound(nextChain); // stays stopped
			this.rebuildUnbound(currentChain); // plays
		});

/*		this.rebuild(currentChain);
		this.rebuild(nextChain);*/

/*        Server.default.bind({
            Ndef(\chainA).play(numChannels: defaultNumChannels);
        });*/

		if(display.notNil) {
			display.showInit(this, version, currentChain, nextChain);
		};

		// enforce exclusive invariant (Option A) at first bring-up
		this.enforceExclusiveCurrentOptionA(0.1);



		// set initial state; the poll will flip it once conditions are true
		ready = false;

		// OPTION A: enable background poll (comment out if you prefer Option B)
		this.startReadyPoll;


		^this
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// public API
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


	// add a setter (public)
	setProcessorLib { arg lib;
		processorLib = lib;
	}

	setDisplay { arg disp;
		var shouldShow;
		display = disp;
		shouldShow = display.notNil;
		if(shouldShow) {
			display.showInit(this, version, currentChain, nextChain);
		};
	}

	help {
		var text;
		text = String.new;
		text = text
		++ "MagicPedalboardNew " ++ version ++ "\n"
		++ "Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].\n"
		++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
		++ "Core methods (operate mostly on the *next* chain):\n"
		++ " printChains\n"
		++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
		++ " add(key), addAt(key, index)\n"
		++ " removeAt(index), swap(indexA, indexB)\n"
		++ " bypass(key, state=true), bypassAt(index, state=true)\n"
		++ " clearChain\n"
		++ "Current-chain bypass helpers:\n"
		++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
		++ "Diagnostics/helpers:\n"
		++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
		++ "Source setters:\n"
		++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
		text.postln;
	}

	// Detailed printing routed through display if available
	printChains {
		var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
		var headerFunc, formatOne;

		bypassAKeys = this.bypassKeysForListInternal(chainAList);
		bypassBKeys = this.bypassKeysForListInternal(chainBList);
		effectiveA = this.effectiveListForInternal(chainAList);
		effectiveB = this.effectiveListForInternal(chainBList);
		hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };

		if(hasDisplay) {
			display.showChainsDetailed(
				chainAList, chainBList,
				bypassAKeys, bypassBKeys,
				effectiveA, effectiveB
			);
		}{
			headerFunc = { arg titleString;
				var lineText;
				lineText = "==== " ++ titleString ++ " ====";
				lineText.postln;
			};

			formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
				var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
				lastIndex = listRef.size - 1;
				sinkKey = listRef[0];
				sourceKey = listRef[lastIndex];

				headerFunc.(titleString);
				("src : " ++ sourceKey).postln;

				if(listRef.size > 2) {
					"procs:".postln;
					processorsList = listRef.copyRange(1, lastIndex - 1);
					indexCounter = 1;
					processorsList.do({ arg procKey;
						isBypassed = bypassKeys.includes(procKey);
						markText = if(isBypassed) { "BYP" } { "ON " };
						lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
						lineText.postln;
						indexCounter = indexCounter + 1;
					});
				}{
					"procs: (none)".postln;
				};

				("sink: " ++ sinkKey).postln;
				("eff : " ++ effectiveList.join(" -> ")).postln;
				"".postln;
			};

			formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
			formatOne.("NEXT",    chainBList, bypassBKeys, effectiveB);
		};
	}

	playCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		this.rebuild(currentChain);
		Server.default.bind({
			Ndef(sinkKey).play(numChannels: defaultNumChannels);
		});
		if(display.notNil) {
			display.showPlay(sinkKey);
		};
		// enforce exclusive invariant (Option A) after play
		this.enforceExclusiveCurrentOptionA(0.1);

	}

	stopCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		Server.default.bind({
			Ndef(sinkKey).stop;
		});
		if(display.notNil) {
			display.showStop(sinkKey);
		};
	}

	// Crossfading chain switch (default 0.1 s, clamped to ~80‚Äì200 ms)
	switchChain { arg fadeTime = 0.1;
		var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		actualFadeTime = fadeTime.clip(0.08, 0.2);
		oldSinkKey = currentChain[0];
		newSinkKey = nextChain[0];

		Server.default.bind({
			// set fade durations
			Ndef(oldSinkKey).fadeTime_(actualFadeTime);
			Ndef(newSinkKey).fadeTime_(actualFadeTime);

			// prebuild NEXT so it is ready, then start it (will fade in)
			this.rebuildUnbound(nextChain);
			Ndef(newSinkKey).play(numChannels: defaultNumChannels);

			// stop OLD (will fade out)
			Ndef(oldSinkKey).stop;

			// swap pointers
			temporaryList = currentChain;
			currentChain = nextChain;
			nextChain = temporaryList;

			// ensure both chains are in correct post-swap state
			this.rebuildUnbound(currentChain);
			this.rebuildUnbound(nextChain);
		});

		// enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
		this.enforceExclusiveCurrentOptionA(actualFadeTime);

		if(display.notNil) {
			display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
		};
	}

	// ‚îÄ‚îÄ‚îÄ next-chain mutations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	add { arg key;
		var insertIndex;
		insertIndex = nextChain.size - 1;
		this.addAt(key, insertIndex);
		if(display.notNil) { display.showMutation(\add, [key], nextChain) };
	}

	addAt { arg key, index;
		var indexClamped, newList;
		indexClamped = index.clip(1, nextChain.size - 1);
		newList = nextChain.insert(indexClamped, key);
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
	}

	removeAt { arg index;
		var sizeNow, lastIndex, newList, removedKey;
		sizeNow = nextChain.size;
		lastIndex = sizeNow - 1;

		if(sizeNow <= 2) {
			if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
			{ "refuse to remove: need at least [sink, source]".postln };
		}{
			if((index == 0) or: { index == lastIndex }) {
				if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
				{ "refuse to remove sink or source".postln };
			}{
				removedKey = nextChain[index];
				newList = nextChain.copy;
				newList.removeAt(index);
				this.setNextListInternal(newList);
				this.bypassDictForListInternal(nextChain).removeAt(removedKey);
				this.rebuild(nextChain);
				if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
			};
		};
	}

	swap { arg indexAParam, indexBParam;
		var lastIndex, indexA, indexB, newList, tempKey;
		lastIndex = nextChain.size - 1;
		indexA = indexAParam.clip(1, lastIndex - 1);
		indexB = indexBParam.clip(1, lastIndex - 1);

		if(indexA == indexB) {
			// nothing to do
		}{
			newList = nextChain.copy;
			tempKey = newList[indexA];
			newList[indexA] = newList[indexB];
			newList[indexB] = tempKey;
			this.setNextListInternal(newList);
			this.rebuild(nextChain);
			if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
		};
	}

	clearChain {
		var sinkKey, sourceKey, newList;
		if(nextChain.size < 2) { ^this };
		sinkKey = nextChain[0];
		sourceKey = nextChain[nextChain.size - 1];
		newList = [sinkKey, sourceKey];
		this.setNextListInternal(newList);
		this.bypassDictForListInternal(nextChain).clear;
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
	}

	bypass { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(nextChain);
		dict[key] = state;
		this.rebuild(nextChain);
		if(display.notNil) {
			display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
		};
	}

	bypassAt { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = nextChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = nextChain[clampedIndex];
		this.bypass(keyAtIndex, state);
	}

	// ‚îÄ‚îÄ‚îÄ current-chain bypass ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	bypassCurrent { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(currentChain);
		dict[key] = state;
		this.rebuild(currentChain);
		if(display.notNil) {
			display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
		};
	}

	bypassAtCurrent { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = currentChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = currentChain[clampedIndex];
		this.bypassCurrent(keyAtIndex, state);
	}

	// ‚îÄ‚îÄ‚îÄ source setters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	setSource { arg key;
		var newList, lastIndex;
		lastIndex = nextChain.size - 1;
		newList = nextChain.copy;
		newList[lastIndex] = key;
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
	}

	setSourceCurrent { arg key;
		var newList, lastIndex, isAList;
		lastIndex = currentChain.size - 1;
		newList = currentChain.copy;
		newList[lastIndex] = key;
		isAList = (currentChain === chainAList);
		if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
		this.rebuild(currentChain);
		if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
	}



	setSourcesBoth { arg key;
		var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;

		// pick a sensible key (today we want \testmelody)
		k = key ? \testmelody;

		// guard: require [sink, source] minimum on both chains
		sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
		if(sizeOk.not) { ^this };

		// remember which concrete list object was CURRENT/NEXT *before* we replace them
		curWasA  = (currentChain === chainAList);
		nextWasA = (nextChain    === chainAList);

		// compute last indices
		lastA = chainAList.size - 1;
		lastB = chainBList.size - 1;

		// replace the *source symbol* (last position) on both lists
		newA = chainAList.copy; newA[lastA] = k;
		newB = chainBList.copy; newB[lastB] = k;

		// publish new lists and restore CURRENT/NEXT pointers to the matching list
		chainAList = newA;
		chainBList = newB;
		currentChain = if(curWasA)  { chainAList } { chainBList };
		nextChain    = if(nextWasA) { chainAList } { chainBList };

		// rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
		this.rebuild(currentChain);
		this.rebuild(nextChain);

		// (optional) inform display
		if(display.notNil and: { display.respondsTo(\showMutation) }) {
			display.showMutation(\setSourcesBoth, [k], nextChain);
		};

		^this
	}

	setDefaultSource { arg key;
		var k;
		// update the instance default; does not modify existing chains immediately
		k = key ? \testmelody;
		defaultSource = k;
		^this
	}


	// ‚îÄ‚îÄ‚îÄ diagnostics helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
	effectiveNext    { ^this.effectiveListForInternal(nextChain) }
	bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
	bypassKeysNext    { ^this.bypassKeysForListInternal(nextChain) }

	reset {
		var sinkAKey, sinkBKey, canRun;
		sinkAKey = \chainA;
		sinkBKey = \chainB;

		chainAList = [sinkAKey, defaultSource];
		chainBList = [sinkBKey, defaultSource];

		bypassA.clear;
		bypassB.clear;

		currentChain = chainAList;
		nextChain = chainBList;

		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			// soft reset: stop both, then rebuild clean connections
			Ndef(sinkAKey).stop;
			Ndef(sinkBKey).stop;

			// Rebuild NEXT first (stays stopped), then CURRENT (plays)
			this.rebuildUnbound(nextChain);
			this.rebuildUnbound(currentChain);
		});

		// enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
		this.enforceExclusiveCurrentOptionA(0.1);

		if(display.notNil) { display.showReset(currentChain, nextChain) };
	}



/*    OLDreset {
        var sinkAKey, sinkBKey;
        sinkAKey = \chainA;
        sinkBKey = \chainB;

        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];

        bypassA.clear;
        bypassB.clear;

        currentChain = chainAList;
        nextChain = chainBList;

        // SAFE server reset ONLY here, using Server.default.* (not 's')
        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;

                this.rebuildUnbound(nextChain);
                this.rebuildUnbound(currentChain);

                Ndef(sinkBKey).stop;
                Ndef(sinkAKey).play(numChannels: defaultNumChannels);
            });
        });

        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }*/

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// internal helpers (lowercase, no leading underscore)
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	setNextListInternal { arg newList;
		var isAList;
		isAList = nextChain === chainAList;
		if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
	}

	bypassDictForListInternal { arg listRef;
		^if(listRef === chainAList) { bypassA } { bypassB }
	}

	bypassKeysForListInternal { arg listRef;
		var dict, keysBypassed;
		dict = this.bypassDictForListInternal(listRef);
		keysBypassed = Array.new;
		dict.keysValuesDo({ arg key, state;
			if(state == true) { keysBypassed = keysBypassed.add(key) };
		});
		^keysBypassed
	}

	ensureStereoInternal { arg key;
		var proxyBus, needsInit;
		proxyBus = Ndef(key).bus;
		needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
		if(needsInit) {
			Ndef(key).ar(defaultNumChannels);
		};
	}

	// Non-destructive: guard only; do not reset here
	ensureServerTree {
		var serverIsRunning;
		serverIsRunning = Server.default.serverRunning;
		^serverIsRunning
	}

	//
	// v0.4.6 change


	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink    = nextChain[0];
		chans       = defaultNumChannels;
		fadeCur     = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust \in.ar, stereo shape pinned, playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).mold(chans, \audio);   // authoritative shape
			Ndef(currentSink).fadeTime_(fadeCur);
			if(Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans);
			};

			// NEXT: hard-silence + ensure flag drops
			// 1) silence source, then .stop (no audio either way)
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).mold(chans, \audio);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;

			// 2) drop monitor/flag deterministically, then re-establish silent sink
			Ndef(nextSink).end;                      // frees inner players, "stop listen" (NodeProxy help)
			Ndef(nextSink, { Silent.ar(chans) });    // keep NEXT present & silent for prebuild
			Ndef(nextSink).mold(chans, \audio);
			// do NOT play NEXT
		});

		^this
	}

/*	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink = nextChain[0];
		chans = defaultNumChannels;
		fadeCur = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust sink that consumes embedded input; ensure playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).ar(chans);
			Ndef(currentSink).fadeTime_(fadeCur);
			if (Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans)
			};

			// NEXT: hard silence at the sink source; stop its monitor quickly
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).ar(chans);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;
		});

		^this
	}*/


	effectiveListForInternal { arg listRef;
		var dict, resultList, lastIndex, isProcessor, isBypassed;
		dict = this.bypassDictForListInternal(listRef);
		resultList = Array.new;
		lastIndex = listRef.size - 1;

		listRef.do({ arg key, indexPosition;
			isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
			isBypassed = isProcessor and: { dict[key] == true };

			if((indexPosition == 0) or: { indexPosition == lastIndex }) {
				resultList = resultList.add(key);
			}{
				if(isBypassed.not) { resultList = resultList.add(key) };
			};
		});
		^resultList
	}

	// Public rebuild: bundles server ops; guard only
	rebuild { arg listRef;
		var whichChain, canRun;
		whichChain = if(listRef === currentChain) { \current } { \next };
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			this.rebuildUnbound(listRef);
		});

		if(display.notNil) {
			display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
		};
	}


	// Internal rebuild that assumes we are already inside a server bind (no resets)

	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		// (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
		if(processorLib.notNil) {
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};

		// From here on, this is your original "effective / do / connect"
		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}


/*	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/*	// At end of rebuildUnbound
	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;


/*		if(processorLib.notNil) {
			// Ask the lib to make sure each symbol in this chain has an Ndef with a function.
			// It will quietly do nothing for unknown keys.
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};*/


		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;

		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/* OLD   rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };

        effective = this.effectiveListForInternal(listRef);

        effective.do({ arg keySymbol;
            this.ensureStereoInternal(keySymbol);
        });

        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });

		// sinkKey = effective[0];
		// if(listRef === currentChain) {
		// 	Ndef(sinkKey).play(numChannels: defaultNumChannels);
		// }{
		// 	Ndef(sinkKey).stop;
		// };
		// At the end of rebuildUnbound:
		sinkKey = effective[0];
		if(listRef === currentChain) {
			if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		} {
			if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
		};

    }*/

	// ---- Ready helpers (public API) ----
	// boolean snapshot (no server ops)
	isReady {
		^ready
	}

	// AppClock polling; onReadyFunc is optional
	waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
		var startTime, tick;
		startTime = Main.elapsedTime;

		AppClock.sched(0, {
			tick = {
				if(this.readyConditionOk) {
					ready = true;
					if(onReadyFunc.notNil) { onReadyFunc.value };
					nil
				}{
					if((Main.elapsedTime - startTime) > timeoutSec) {
						// timed out; leave 'ready' as-is
						nil
					}{
						AppClock.sched(pollSec, tick)
					}
				}
			};
			tick.value;
			nil
		});
		^this
	}

	// ---- Ready helpers (internal; no leading underscore) ----

	// light background poll started from init (OPTION A)
	startReadyPoll {
		var alreadyTrue;
		alreadyTrue = this.readyConditionOk;
		if(alreadyTrue) { ready = true; ^this };
		this.waitUntilReady(2.0, 0.05, { nil });
		^this
	}

	// compute the readiness condition; no server ops here
	readyConditionOk {
		var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;

		curSink = currentChain[0];
		nxtSink = nextChain[0];

		serverOk = Server.default.serverRunning;

		curBus = Ndef(curSink).bus;
		nxtBus = Ndef(nxtSink).bus;

		busesOk = curBus.notNil and: { nxtBus.notNil }
		and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };

		currentPlaying = Ndef(curSink).isPlaying;

		^(serverOk and: { busesOk } and: { currentPlaying })
	}

	// handleCommand { |oscPath|
	// 	var path;
	// 	path = oscPath.asString;
	//
	// 	// Route to your existing mutation logic
	// 	// Update this if you use a different handler name
	// 	if(this.respondsTo(\applyOSCPath)) {
	// 		this.applyOSCPath(path);
	// 	} {
	// 		("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
	// 	};
	//
	// 	^this;
	// }
handleCommand { |oscPath|
    var path;
    path = oscPath.asString;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(path, this, display);
    } {
        ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
    };

    ^this;
}




}

===== MagicPedalboard/MagicPedalboardTestRunner.sc =====
// MagicPedalboardTestRunner.sc
// v0.2.2
// MD 20250919

/*
Purpose:
- Unified bring-up, audio reset, GUI sync, and test runner for MagicPedalboardNew.
- Replaces StartHere_CleanBoot_OneWindow_BringUp.scd.
- Logs all steps using MDMiniLogger.
- Extensible with new test methods.

Style:
- var-first; lowercase methods; no server.sync.
- Server ops inside Server.default.bind; GUI ops on AppClock.
- No single-letter vars; all var declarations at top of each block.
*/

MagicPedalboardTestRunner : Object {
    var <logger, <pedalboard, <>gui;

    *new { arg mpb, gui;
        ^super.new.init(mpb, gui);
    }

    init { arg mpb, gui;
        pedalboard = mpb;
        this.gui = gui;
        logger = MDMiniLogger.new("MagicPedalboardTestRunner");
        ^this;
    }

    bringUp {
        var trigger, sequence, freqDemand, envelope, toneSignal, panPosition;
        var isPlayingA, isPlayingB, currentSink;

        logger.info("Starting full bring-up...");

        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;
                logger.info("Server tree initialized.");
            });
        });

        Server.default.bind({
            Ndef(\chainA, { \in.ar(2) }).ar(2);
            Ndef(\chainB, { \in.ar(2) }).ar(2);
            Ndef(\ts0, { Silent.ar(2) }).ar(2);
            Ndef(\testmelody, {
                trigger = Impulse.kr(3.2);
                sequence = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
                freqDemand = Demand.kr(trigger, 0, sequence);
                envelope = Decay2.kr(trigger, 0.01, 0.35);
                toneSignal = SinOsc.ar(freqDemand) * envelope * 0.25;
                panPosition = ToggleFF.kr(trigger).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(toneSignal, panPosition);
            }).ar(2);
            logger.info("Sinks and sources defined.");
        });

        pedalboard.reset;
        pedalboard.setSourceCurrent(\testmelody);
        pedalboard.playCurrent;
        pedalboard.enforceExclusiveCurrentOptionA(0.1);

        if(gui.notNil) {
            gui.enableMeters(false);
            gui.enableMeters(true);
            gui.window.front;
            gui.showExpectation("System ready", 0);
        };

        pedalboard.printChains;

        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Playback state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
        logger.info("Bring-up complete.");
    }

    audioReset {
        logger.info("Running ~audioReset...");
        if(~audioReset.notNil) {
            ~audioReset.();
            logger.info("~audioReset complete.");
        } {
            logger.warn("~audioReset is not defined.");
        };
    }

    syncGui {
        var currentSink;
        if(gui.notNil) {
            currentSink = pedalboard.effectiveCurrent[0];
            gui.window.front;
            gui.highlightCurrentColumn(currentSink);
            gui.showChainsDetailed(
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext,
                pedalboard.bypassKeysCurrent,
                pedalboard.bypassKeysNext,
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext
            );
            logger.info("GUI synced with audio state.");
        };
    }

    runAcceptanceTest {
        logger.info("Running acceptance test...");
        pedalboard.add(\delay);
        pedalboard.switchChain(0.12);
        pedalboard.bypassCurrent(\delay, true);
        pedalboard.bypassCurrent(\delay, false);
        pedalboard.switchChain(0.12);
        pedalboard.printChains;
        logger.info("Acceptance test complete.");
    }

    verifyAudioState {
        var isPlayingA, isPlayingB;
        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Audio state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
    }

    help {
        "Available methods: bringUp, audioReset, syncGui, runAcceptanceTest, verifyAudioState".postln;
    }
}

===== MagicPedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects ‚Äì same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== MagicPedalboard/MagicProcessorLibrary.sc =====
/* MagicProcessorLibrary.sc
   Holds a registry of processor/source functions and can ensure Ndefs exist.
   MD 20250913
*/
MagicProcessorLibrary : Object {
    var <defs;           // IdentityDictionary: Symbol -> Function
    var <defaultNumChannels;

    *new { ^super.new.init }

    init {
        var empty;
        defaultNumChannels = 2;
        empty = IdentityDictionary.new;
        defs = empty;
        ^this
    }

    register { arg key, func;
        defs[key] = func;
        ^this
    }

    has { arg key;
        ^defs.includesKey(key)
    }

    get { arg key;
        ^defs[key]
    }

    keys { ^defs.keys }

    // Create or update an Ndef for key
    ensure { arg key, chans;
        var func, numCh, canRun;
        func = defs[key];
        if(func.isNil) { ^this }; // silently ignore if not registered
        numCh = chans ? defaultNumChannels;
        canRun = Server.default.serverRunning;
        if(canRun) {
            Server.default.bind({
                Ndef(key, func);
                Ndef(key).ar(numCh);
            });
        };
        ^this
    }

    // Ensure many keys at once
    ensureMany { arg keyArray, chans;
        keyArray.do({ arg key; this.ensure(key, chans) });
        ^this
    }

    // Convenience: ensure whatever appears in a chain array
    ensureFromChain { arg chainArray, chans;
        var lastIndex, idx;
        if(chainArray.isNil or: { chainArray.size < 2 }) { ^this };
        lastIndex = chainArray.size - 1;
        idx = 0;
        while({ idx <= lastIndex }, {
            this.ensure(chainArray[idx], chans);
            idx = idx + 1;
        });
        ^this
    }
}

===== MagicPedalboard/Manage_MagicDisplayGUI_Singleton.scd =====
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)

===== MagicPedalboard/MPBTest/Classes/MPBTest_AcceptanceSuites.sc =====
// MPBTest_AcceptanceSuites.sc
// v0.1.1
// MD 20250920-1608

// Purpose
// - Ready-made, extensible step lists for acceptance.
// Style
// - var-first; lowercase; data-only class methods.

MPBTest_AcceptanceSuites : Object {
    *classic { arg fade = 0.12;
        ^[
            (verb:\add,           args:[\delay]),
            (verb:\switch,        args:[fade]),
            (verb:\bypassCurrent, args:[\delay, true]),
            (verb:\bypassCurrent, args:[\delay, false]),
            (verb:\switch,        args:[fade])
        ]
    }

    *mutatorsBasic { arg fade = 0.12;
        ^[
            (verb:\insert,   args:[\chorus]),
            (verb:\addAt,    args:[\reverb, 1]),
            (verb:\swap,     args:[1, 2]),
            (verb:\removeAt, args:[2]),
            (verb:\switch,   args:[fade])
        ]
    }

    *bypassNextCycle {
        ^[
            (verb:\add,    args:[\delay]),
            (verb:\bypass, args:[\delay, \on]),
            (verb:\bypass, args:[\delay, \off]),
            (verb:\switch, args:[0.12])
        ]
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Assertions.sc =====
// MPBTest_Assertions.sc
// v0.1.0
// MD 20250920-1540
//
// Purpose
// - Centralized assertions used across scenarios (A XOR B, single \delay in list, NEXT audible tail...)
// Style
// - var-first; lowercase; no server.sync; no single-letter locals.

MPBTest_Assertions : Object {
    *xorPlaying { arg expectA = true, expectB = false;
        var a, b, ok;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ok = (a == expectA) and: { b == expectB };
        ("[ASSERT] XOR A="++a++" B="++b++" expect("++expectA++","++expectB++") -> "++
            (ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }

    *countKey { arg list, key;
        var count = 0;
        list.do({ arg k; if(k == key) { count = count + 1 } });
        ^count
    }

    *exactlyOne { arg list, key, label="count";
        var n, pass;
        n = this.countKey(list, key);
        pass = (n == 1);
        ("[ASSERT] "++label++" '"++key.asString++"' = "++n++" -> "++
            (pass.if({"PASS"},{"FAIL"}))).postln;
        ^pass
    }

    *nextTailNotTs0 { arg mpb;
        var last, ok;
        last = mpb.effectiveNext.last;
        ok = (last != \ts0);
        ("[ASSERT] NEXT tail != \\ts0 -> "++(ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_BringUp.sc =====
// MPBTest_BringUp.sc
// v0.1.9
// MD 20250920-1919

// Purpose
// - Fresh-boot bring-up with Grid GUI by default; avoids display=nil and close/create races.
// Style
// - var-first; lowercase; AppClock for GUI; Server.default.bind for audio; no server.sync.

MPBTest_BringUp : Object {
    classvar < version;
    var < logger, < pedalboard, < gui, < readyFlag, < numChannels, < testAmp;

    *initClass { version = "v0.1.9"; ("MPBTest_BringUp " ++ version).postln; }

    *new {
        arg useGui = true, channels = 2, sourceAmp = 0.40, publishToTildes = true,
            freshBoot = true, guiClassSym = \MagicDisplayGUI_GridDemo, closeExistingGUIs = true;
        ^super.new.init(useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs)
    }

    init { arg useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs;
        var s, doFreshBoot, startBoot, afterBoot, scheduleGuiClose, scheduleGuiCreate;
        var ensureSinks, ensureSources, setSourcesAndPlay, enforceOptionA, attachMeters, postBaseline, maybePublish;

        logger     = MDMiniLogger.new("MPBTest_BringUp");
        readyFlag  = false;
        numChannels = (channels ? 2).asInteger.max(1);
        testAmp     = (sourceAmp ? 0.40).asFloat.clip(0.05, 1.0);
        s = Server.default;

        // --- audio preparation ---
        ensureSinks = {
            Server.default.bind({
                Ndef(\chainA, { \in.ar(numChannels) }); Ndef(\chainA).ar(numChannels);
                Ndef(\chainB, { \in.ar(numChannels) }); Ndef(\chainB).ar(numChannels);
            });
        };

        ensureSources = {
            Server.default.bind({
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f    = Demand.kr(trig, 0, seq);
                    var env  = Decay2.kr(trig, 0.01, 0.35);
                    var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                    Pan2.ar(SinOsc.ar(f) * env * testAmp, pan)
                });
                Ndef(\testmelody).ar(numChannels);
                Ndef(\ts0, { Silent.ar(numChannels) }).ar(numChannels);
            });
        };

        setSourcesAndPlay = {
            pedalboard.setDefaultSource(\testmelody);
            pedalboard.setSourceCurrent(\testmelody);
            pedalboard.playCurrent;
        };

        enforceOptionA = {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
            Server.default.bind({
                var nextSink = pedalboard.nextChain[0];
                Ndef(nextSink).end;
                Ndef(nextSink).mold(numChannels, \audio);
            });
        };

        attachMeters = {
            if(gui.notNil and: { gui.respondsTo(\enableMeters) }) {
                gui.enableMeters(false); gui.enableMeters(true);
            };
        };

        postBaseline = {
            pedalboard.printChains;
            ("[[PLAY]] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            readyFlag = true;
        };

        maybePublish = {
            if(publishToTildes) { ~bring = this; ~mpb = pedalboard; ~gui = gui };
        };

        // --- GUI sequencing to avoid races ---
        scheduleGuiClose = {
            if(closeExistingGUIs and: { useGui }) {
                AppClock.sched(0.00, {
                    var wins = Window.allWindows.select({ arg w;
                        var nm = w.tryPerform(\name) ? "";
                        nm.asString.beginsWith("MagicDisplayGUI")
                    });
                    wins.do(_.close);
                    nil
                });
            };
        };

        scheduleGuiCreate = {
            if(useGui) {
                AppClock.sched(0.05, {
                    gui = guiClassSym.asClass.new;   // MagicDisplayGUI_GridDemo by default
                    gui.window.front.alwaysOnTop_(true);
                    // Build pedalboard only **after** GUI exists so display is bound at construction
                    pedalboard = MagicPedalboardNew.new(gui);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    attachMeters.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            }{
                // Headless: create pedalboard immediately (no display)
                AppClock.sched(0.00, {
                    pedalboard = MagicPedalboardNew.new(nil);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            };
        };

        // --- boot choreography ---
        afterBoot = {
            ensureSinks.value;
            ensureSources.value;
            scheduleGuiClose.value;
            scheduleGuiCreate.value;
        };

        startBoot = {
            s.doWhenBooted({ afterBoot.value });
            if(s.serverRunning.not) { s.boot };
        };

        doFreshBoot = {
            var waitDown;
            if(s.serverRunning) {
                if(gui.notNil and: { gui.respondsTo(\enableMeters) }) { gui.enableMeters(false) };
                s.quit;
                waitDown = {
                    if(s.serverRunning.not) { startBoot.value; nil } {
                        AppClock.sched(0.05, waitDown)
                    }
                };
                AppClock.sched(0.05, waitDown);
            }{
                startBoot.value;
            };
        };

        if(freshBoot) { doFreshBoot.value } { startBoot.value };
        ^this
    }

    isReady { ^readyFlag }
    getPedalboard { ^pedalboard }
    getGui { ^gui }
    getChannels { ^numChannels }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Scenario.sc =====
// MPBTest_Scenario.sc
// v0.2.2
// MD 20250920-2015

// Purpose
// - Timed acceptance runner (add/insert/addAt/removeAt/swap/bypass/.../switch/wait)
//   with optional CommandTree path hook via .setPathApplier.
// - Removes caret-returns from AppClock closures to avoid OutOfContextReturnError.
// Style
// - var-first; lowercase; AppClock scheduling; no server.sync.

MPBTest_Scenario : Object {
    classvar < version;
    var < pedalboard, < gui, < logger;
    var pathApplierFunc;

    *initClass { version = "v0.2.2" }

    *new { arg mpb, guiObj = nil; ^super.new.init(mpb, guiObj) }

    init { arg mpb, guiObj;
        var lg;
        pedalboard = mpb;
        gui = guiObj;
        logger = MDMiniLogger.new("MPBTest_Scenario");
        pathApplierFunc = nil;
        ^this
    }

    setPathApplier { arg func;
        pathApplierFunc = func;
        ^this
    }

    useDefaultAdapterIfPresent {
        if(pathApplierFunc.isNil and: { ~ct_applyOSCPathToMPB.notNil }) {
            pathApplierFunc = { arg pathString;
                ~ct_applyOSCPathToMPB.(pathString.asString, pedalboard, gui);
            };
            logger.info("Using ~ct_applyOSCPathToMPB as default path applier.");
        };
        ^this
    }

    run { arg stepsArray;
        var indexCounter, totalCount, runOne;

        this.useDefaultAdapterIfPresent;

        indexCounter = 0;
        totalCount   = stepsArray.size;

        runOne = {
            var stepDict, verb, args, hasMore;

            hasMore = indexCounter < totalCount;

            if(hasMore) {
                stepDict = stepsArray[indexCounter];
                verb = stepDict[\verb];
                args = stepDict[\args] ? [];

                this.applyStep(verb, args);

                indexCounter = indexCounter + 1;

                // Schedule next step tick; explicit \wait steps still add their own delay.
                AppClock.sched(0.20, { runOne.value; nil });
            }{
                // finished; nothing to return from a scheduled closure
                logger.info("scenario complete (" ++ totalCount ++ " steps).");
            };
            nil
        };

        AppClock.sched(0.00, { runOne.value; nil });
        ^this
    }

    applyStep { arg verb, args;
        var v, brief;
        v = verb;
        brief = {
            pedalboard.printChains;
            this.refreshGui;
        };

        switch(v,
            \wait, {
                var delaySec;
                delaySec = (args[0] ? 0.25).asFloat.max(0.0);
                AppClock.sched(delaySec, { nil }); // no return
            },

            \add, {
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \insert, { // alias of add
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \addAt, {
                var proc, idx;
                proc = args[0];
                idx  = (args[1] ? 1).asInteger;
                pedalboard.addAt(proc, idx);
                brief.value;
            },

            \removeAt, {
                var idx;
                idx = (args[0] ? 1).asInteger;
                pedalboard.removeAt(idx);
                brief.value;
            },

            \swap, {
                var idxA, idxB;
                idxA = (args[0] ? 1).asInteger;
                idxB = (args[1] ? 2).asInteger;
                pedalboard.swap(idxA, idxB);
                brief.value;
            },

            \bypass, { // NEXT chain
                var key, stateSym, state;
                key = args[0];
                stateSym = args[1] ? \on;
                state = (stateSym == \on) or: { stateSym == \true } or: { stateSym == 1 };
                pedalboard.bypass(key, state);
                brief.value;
            },

            \unbypass, {
                var key;
                key = args[0];
                pedalboard.bypass(key, false);
                brief.value;
            },

            \bypassCurrent, {
                var key, state;
                key   = args[0];
                state = (args[1] ? true);
                pedalboard.bypassCurrent(key, state);
                brief.value;
            },

            \bypassAt, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAt(indexParam, stateParam);
                brief.value;
            },

            \bypassAtCurrent, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAtCurrent(indexParam, stateParam);
                brief.value;
            },

            \setSource, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSource(key);
                brief.value;
            },

            \setSourceCurrent, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSourceCurrent(key);
                brief.value;
            },

            \switch, {
                var fade;
                fade = (args[0] ? 0.12).asFloat.clip(0.08, 0.20);
                if(pedalboard.effectiveNext.last == \ts0) {
                    if(pathApplierFunc.notNil) { pathApplierFunc.value("/setSource/testmelody") } {
                        pedalboard.setSource(\testmelody);
                    };
                };
                pedalboard.switchChain(fade);
                this.refreshGui;
            },

            \ctPath, {
                var path;
                path = args[0].asString;
                if(pathApplierFunc.notNil) { pathApplierFunc.value(path) } {
                    logger.warn("[ctPath] adapter missing; ignored: " ++ path);
                };
                this.refreshGui;
            },

            { logger.warn("Unknown step: " ++ v.asString) }
        );
    }

    refreshGui {
        if(gui.notNil and: { gui.respondsTo(\showChainsDetailed) }) {
            var effC, effN;
            effC = pedalboard.effectiveCurrent;
            effN = pedalboard.effectiveNext;
            gui.highlightCurrentColumn(effC[0]);
            gui.showChainsDetailed(effC, effN, pedalboard.bypassKeysCurrent, pedalboard.bypassKeysNext, effC, effN);
        };
    }
}

===== MagicPedalboard/MPBTest/docs/README_MPBTest.md =====
# MPBTest: Test Harness and Acceptance Suite

This folder contains the modular test harness and acceptance suite for the MagicPedalboard project. It is organized for clarity, reproducibility, and ease of extension.

---

## Folder Structure

- `Classes/`  
  Main test harness classes:
    - `MPBTest_BringUp.sc`
    - `MPBTest_Scenario.sc`
    - `MPBTest_AcceptanceSuites.sc`
    - `MPBTest_Assertions.sc`
- `Scripts/`  
  Utility and acceptance scripts:
    - `MPBTest_Run_HealthCheck.scd`
    - `MPBTest_Run_OneGo.scd`
    - `MPBTest_Record_WorkingState.scd`
    - `MPBTest_FreshBootBringUp_Now.scd`
    - `MPBTest_RebindAndFillGUI.scd`
    - `MPBTest_CloseRecreateBind_GUI_GridDemo.scd`
- `docs/`  
  Working state snapshots and documentation (add your Markdown or JSON here).
- `_archive/`  
  For archiving old or superseded test scripts and snapshots.

---

## Usage

```shell
# Health Check
sclang MPBTest/Scripts/MPBTest_Run_HealthCheck.scd

# Bring-Up
sclang MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd

# Record Working State
sclang MPBTest/Scripts/MPBTest_Record_WorkingState.scd

# Run All Acceptance Tests
sclang MPBTest/Scripts/MPBTest_Run_OneGo.scd
```

---

## Conventions

- All test harness classes are in `Classes/` and use the `MPBTest_` prefix.
- Scripts in `Scripts/` are named for their function and are safe to run independently.
- Snapshots and documentation should be placed in `docs/`.
- Archive old scripts in `_archive/` to keep the suite clean.

_Last updated: 2025-09-20_

===== MagicPedalboard/MPBTest/docs/WorkingState_250921-111637.json =====
('timestamp': "250921-111637", 'environment': ('sampleRate': 48000.0, 'blockSize': 64, 'outDevice': "default"), 'versions': ('MPBTest_BringUp': "v0.1.9", 'MagicDisplayGUI': "v0.1.3", 'MPBTest_Assertions': "unknown", 'MagicDisplayGUI_GridDemo': "v0.1.3", 
  'MagicPedalboardNew': "v0.4.7", 'MPBTest_AcceptanceSuites': "unknown", 'MPBTest_Scenario': "v0.2.2", 'MagicDisplay': "v0.1.3"), 'classFiles': [])
===== MagicPedalboard/MPBTest/docs/WorkingState_250921-111637.md =====
# MagicPedalboard ‚Äì Working State (250921-111637)

## Versions
- MPBTest_BringUp: v0.1.9
- MPBTest_Scenario: v0.2.2
- MPBTest_AcceptanceSuites: unknown
- MPBTest_Assertions: unknown
- MagicPedalboardNew: v0.4.7
- MagicDisplay: v0.1.3
- MagicDisplayGUI: v0.1.3
- MagicDisplayGUI_GridDemo: v0.1.3

## Environment
- output device: default
- sample rate: 48000.0
- block size: 64

## Class Files
- 

## Chain Snapshot
- no ~mpb

===== MagicPedalboard/MPBTest/Scripts/MPBTest_CloseRecreateBind_GUI_GridDemo.scd =====
// MPBTest_CloseRecreateBind_GUI_GridDemo.scd
// v0.1.0
// MD 20250920-1919
(
var closeExisting, createGrid, bindAndFill;

/*closeExisting = {
    AppClock.sched(0.00, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            var nm = w.tryPerform(\name) ? "";
            nm.asString.beginsWith("MagicDisplayGUI")
        });
        wins.do(_.close);
        nil
    });
};*/

closeExisting = {
    AppClock.sched(0.00, {
        var windowList;

        windowList = Window.allWindows.select({ arg w;
            var nameString;
            nameString = w.tryPerform(\name) ? "";
            nameString.asString.beginsWith("MagicDisplayGUI")
        });

        windowList.do({ arg w; w.close });
        nil
    });
};

createGrid = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
        nil
    });
};

bindAndFill = {
    AppClock.sched(0.10, {
        if(~mpb.notNil and: { ~gui.notNil }) {
            ~mpb.setDisplay(~gui);
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            ~mpb.printChains;
            ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
        }{
            "[REBIND] ~mpb or ~gui missing".warn;
        };
        nil
    });
};

closeExisting.value;
createGrid.value;
bindAndFill.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd =====
// MPBTest_FreshBootBringUp_Now.scd
// v0.1.1
// MD 20250920-1642

(
var s, startBoot, afterBoot, waitDown, doFreshBoot;

s = Server.default;

afterBoot = {
    AppClock.sched(0.00, {
        ~bring = MPBTest_BringUp.new(true, 2, 0.40, true); // use loud test source & publish tildes
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };
        nil
    })
};

startBoot = {
    s.doWhenBooted({ afterBoot.value });
    if(s.serverRunning.not) { s.boot };
};

waitDown = {
    if(s.serverRunning.not) { startBoot.value; nil } {
        AppClock.sched(0.05, waitDown)
    }
};

doFreshBoot = {
    if(s.serverRunning) {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };
        s.quit;
        AppClock.sched(0.05, waitDown);
    }{
        startBoot.value;
    };
};

doFreshBoot.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_RebindAndFillGUI.scd =====
// MPBTest_RebindAndFillGUI.scd
// v0.1.0
// MD 20250920-1919

(
var need;

// 0) Precondition: we want ~mpb and ~gui alive
need = (~mpb.notNil) && (~gui.notNil);
if(need.not) {
    "[REBIND] need ~mpb and ~gui; run MPBTest_BringUp first.".warn;
    ^nil;
};

// 1) If the GUI was created after MPB, bind it now
if(~mpb.display.isNil or: { ~mpb.display !== ~gui }) {
    ~mpb.setDisplay(~gui);
    "[REBIND] bound ~gui to ~mpb".postln;
};

// 2) Make sure it‚Äôs in front (and visible)
AppClock.sched(0.02, {
    var w;
    w = ~gui.tryPerform(\window);
    if(w.notNil) { w.front; w.alwaysOnTop_(true) };
    nil
});

// 3) Reattach meters (guards inside GUI)
AppClock.sched(0.04, {
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
    nil
});

// 4) Fill the chains view now
AppClock.sched(0.06, {
    ~mpb.printChains; // drives showChainsDetailed when a display is bound
    // highlight current column for good measure
    ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
    nil
});
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Record_WorkingState.scd =====
// MPBTest_Record_WorkingState.scd
// v0.1.1
// MD 20250920-1930

(
var now, stamp, docDir, mdPath, jsonPath, mkDir;
var s, o, outDev, sr, blk, scv, lines, md, js;
var v_mpbtest_bring, v_mpbtest_scen, v_mpbtest_suites, v_mpbtest_assert;
var v_mpb, v_md, v_mdgui, v_mdgrid;
var fileList, classPaths;

/*// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930
docDir = PathName(thisProcess.nowExecutingPath ?? thisProcess.cwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;*/

// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930

// Use script location if available, else current working directory
docDir = PathName(thisProcess.nowExecutingPath ? File.getcwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;


mkDir = { |p|
    var pn = PathName(p);
    if(pn.isFolder.not) {
        File.mkdir(p);
    };
};


// 1) Ensure docs dir
mkDir.(docDir);

// 2) Environment
s  = Server.default;
o  = s.options;
outDev = o.outDevice ? "default";
sr  = s.sampleRate ? 0;
blk = o.blockSize;
/*scv = Main.scVersionString ? Main.scVersion;*/
/*scv = Platform.version.asString;*/
scv = thisProcess.interpreter.version;


// 3) Versions
v_mpbtest_bring  = (MPBTest_BringUp.respondsTo(\version)).if({ MPBTest_BringUp.version },{ "unknown" });
v_mpbtest_scen   = (MPBTest_Scenario.respondsTo(\version)).if({ MPBTest_Scenario.version },{ "unknown" });
v_mpbtest_suites = (MPBTest_AcceptanceSuites.respondsTo(\version)).if({ MPBTest_AcceptanceSuites.version },{ "unknown" });
v_mpbtest_assert = (MPBTest_Assertions.respondsTo(\version)).if({ MPBTest_Assertions.version },{ "unknown" });

v_mpb    = (MagicPedalboardNew.respondsTo(\version)).if({ MagicPedalboardNew.version },{ "unknown" });
v_md     = (MagicDisplay.respondsTo(\version)).if({ MagicDisplay.version },{ "unknown" });
v_mdgui  = (MagicDisplayGUI.respondsTo(\version)).if({ MagicDisplayGUI.version },{ "unknown" });
v_mdgrid = (MagicDisplayGUI_GridDemo.respondsTo(\version)).if({ MagicDisplayGUI_GridDemo.version },{ "unknown" });

// 4) Class file paths (confirm there‚Äôs only one of each)
classPaths = Class.allClasses
    .select({ |c| ["MPBTest_BringUp","MPBTest_Scenario","MPBTest_AcceptanceSuites","MPBTest_Assertions"].includes(c.name.asString) })
    .collect(_.filenameSymbol.asString);

// 5) Chain snapshot
~mpb = ~mpb ?? { nil };
fileList = if(~mpb.notNil, {
    var effC = ~mpb.effectiveCurrent, effN = ~mpb.effectiveNext;
    [
        "CURRENT=" ++ effC.asString,
        "NEXT   =" ++ effN.asString,
        "[PLAY] A=" ++ Ndef(\chainA).isPlaying ++ " B=" ++ Ndef(\chainB).isPlaying
    ]
}, { ["no ~mpb"] });

// 6) Write Markdown + JSON
mdPath   = docDir +/+ ("WorkingState_" ++ stamp ++ ".md");
jsonPath = docDir +/+ ("WorkingState_" ++ stamp ++ ".json");

// Markdown
md = String.new;
md = md
++ "# MagicPedalboard ‚Äì Working State (" ++ stamp ++ ")\n\n"
++ "## Versions\n"
++ "- MPBTest_BringUp: "   ++ v_mpbtest_bring  ++ "\n"
++ "- MPBTest_Scenario: "  ++ v_mpbtest_scen   ++ "\n"
++ "- MPBTest_AcceptanceSuites: " ++ v_mpbtest_suites ++ "\n"
++ "- MPBTest_Assertions: "++ v_mpbtest_assert ++ "\n"
++ "- MagicPedalboardNew: "++ v_mpb ++ "\n"
++ "- MagicDisplay: "      ++ v_md  ++ "\n"
++ "- MagicDisplayGUI: "   ++ v_mdgui  ++ "\n"
++ "- MagicDisplayGUI_GridDemo: " ++ v_mdgrid ++ "\n\n"
++ "## Environment\n"
++ "- sclang: " ++ scv ++ "\n"
++ "- output device: " ++ outDev ++ "\n"
++ "- sample rate: " ++ sr ++ "\n"
++ "- block size: " ++ blk ++ "\n\n"
++ "## Class Files\n- " ++ classPaths.join("\n- ") ++ "\n\n"
++ "## Chain Snapshot\n- " ++ fileList.join("\n- ") ++ "\n";

File.writeText(mdPath, md);

// JSON (minimal)
js = (
    timestamp: stamp,
    versions: (
        MPBTest_BringUp: v_mpbtest_bring, MPBTest_Scenario: v_mpbtest_scen,
        MPBTest_AcceptanceSuites: v_mpbtest_suites, MPBTest_Assertions: v_mpbtest_assert,
        MagicPedalboardNew: v_mpb, MagicDisplay: v_md,
        MagicDisplayGUI: v_mdgui, MagicDisplayGUI_GridDemo: v_mdgrid
    ),
    environment: (
        sclang: scv, outDevice: outDev, sampleRate: sr, blockSize: blk
    ),
    classFiles: classPaths
).asCompileString;

File.writeText(jsonPath, js);

("[RECORD] wrote\n- " ++ mdPath ++ "\n- " ++ jsonPath).postln;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== MagicPedalboard/old but good/Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd
// MD 20250912-1527

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets; no double /n_free


(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight (avoid double free: only clear Ndefs)
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var exists;
            exists = proxyRef.notNil;
            if(exists) {
                proxyRef.clear; // no proxy.stop here ‚Üí avoids duplicate /n_free
            };
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (GUI queues until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== MagicPedalboard/PERFHUD_UIWriter_Headroom_Overlay.scd =====
// PERFHUD_UIWriter_Headroom_Overlay.scd
// v0.1.0
// MD 2025-09-29

(
var disableLegacyHudOsc, findPerfHudWindow, collectIndicatorsRecursively;
var bindMetersOnce, updateMetersFromModelMapped, startHudTicker;
var desiredFps, mappingExists, meterOrderNote;

// Desired HUD update cadence
desiredFps = 24.0;

// 1) Disable the legacy /md/levels HUD OSCdef so it cannot overwrite our mapped values
disableLegacyHudOsc = {
    var existingHudOsc, resultText;
    existingHudOsc = OSCdef.all.at(\md_levels_hud);
    if(existingHudOsc.notNil) {
        existingHudOsc.free;
        resultText = "[HUD] Disabled legacy OSCdef(\\md_levels_hud) for /md/levels to prevent raw 0..1 pegging.";
    }{
        resultText = "[HUD] Legacy OSCdef(\\md_levels_hud) not present (nothing to disable).";
    };
    resultText.postln;
    nil
};

// 2) Utilities to find the PerfHUD window and collect all LevelIndicators
findPerfHudWindow = {
    var perfWindow;
    perfWindow = Window.allWindows.detect({ arg eachWindow;
        var windowNameString;
        windowNameString = (eachWindow.tryPerform(\name) ? "").asString;
        windowNameString.beginsWith("MagicDisplayGUI")
    });
    perfWindow
};

collectIndicatorsRecursively = { arg rootView;
    var allIndicators, recurseChildren;
    allIndicators = List.new;
    recurseChildren = { arg viewToScan;
        if(viewToScan.isKindOf(LevelIndicator)) { allIndicators.add(viewToScan) };
        viewToScan.children.do({ arg childView; recurseChildren.(childView) });
    };
    recurseChildren.(rootView);
    allIndicators.asArray
};

// 3) Cache references to the first 4 meters (A L, A R, B L, B R)
//    Adjust here if your layout uses a different order or more meters.
bindMetersOnce = {
    var perfWindow, rootView, allMeters, bindOk;
    bindOk = false;

    perfWindow = findPerfHudWindow.();
    if(perfWindow.isNil) {
        "PerfHUD window not found (MagicDisplayGUI...). Will retry.".warn;
    }{
        rootView = perfWindow.tryPerform(\view);
        if(rootView.isNil) {
            "PerfHUD host view missing. Will retry.".warn;
        }{
            allMeters = collectIndicatorsRecursively.(rootView);
            if(allMeters.size < 4) {
                ("[HUD] Found only " ++ allMeters.size ++ " LevelIndicators; expecting ‚â• 4. Will retry.").warn;
            }{
                // Cache the first four meters (override if you have a specific order)
                ~hud_meterA_left   = allMeters[0];
                ~hud_meterA_right  = allMeters[1];
                ~hud_meterB_left   = allMeters[2];
                ~hud_meterB_right  = allMeters[3];

                meterOrderNote = "[HUD] Bound meters: [0]=A_L  [1]=A_R  [2]=B_L  [3]=B_R (override if your layout differs)";
                meterOrderNote.postln;
                bindOk = true;
            };
        };
    };
    bindOk
};

// 4) Mapped update from model ‚Üí LevelIndicators
updateMetersFromModelMapped = {
    var levelsA, levelsB;
    var mappedAL, mappedAR, mappedBL, mappedBR;

    // Ensure mapping helper exists (installed by your responders extender file)
    mappingExists = (~hud_map_linear_to_ui.notNil);
    if(mappingExists.not) {
        "‚ö†Ô∏è ~hud_map_linear_to_ui is not defined. Evaluate MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd first.".warn;
        ^nil;
    };

    // Pull linear A/B pairs from model; default to zeros
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });

    // Map linear (0..1) ‚Üí UI value (0..1) using your headroom + gamma
    mappedAL = ~hud_map_linear_to_ui.(levelsA[0]);
    mappedAR = ~hud_map_linear_to_ui.(levelsA[1]);
    mappedBL = ~hud_map_linear_to_ui.(levelsB[0]);
    mappedBR = ~hud_map_linear_to_ui.(levelsB[1]);

    // Assign to cached meters (guards in case binding failed)
    if(~hud_meterA_left.notNil)   { ~hud_meterA_left.value   = mappedAL };
    if(~hud_meterA_right.notNil)  { ~hud_meterA_right.value  = mappedAR };
    if(~hud_meterB_left.notNil)   { ~hud_meterB_left.value   = mappedBL };
    if(~hud_meterB_right.notNil)  { ~hud_meterB_right.value  = mappedBR };
    nil
};

// 5) Start/replace one AppClock ticker that updates HUD at desiredFps
startHudTicker = {
    var makeTicker;

    // Stop a previous ticker if present
    if(~hud_tickerRoutine.notNil) {
        ~hud_tickerRoutine.stop;
        ~hud_tickerRoutine = nil;
        "[HUD] Replaced previous HUD ticker.".postln;
    };

    makeTicker = {
        ~hud_tickerRoutine = Routine({
            var waitSeconds;
            waitSeconds = 1.0 / desiredFps;
            while({ true }) {
                updateMetersFromModelMapped.();
                waitSeconds.yield;
            }
        });
        ~hud_tickerRoutine.play(AppClock);
        ("[HUD] HUD ticker active @ " ++ desiredFps.round(0.1) ++ " fps.").postln;
        nil
    };

    makeTicker.();
};

// Execute overlay
AppClock.sched(0.0, {
    var bound;
    disableLegacyHudOsc.();
    bound = bindMetersOnce.();
    if(bound.not) {
        // try again shortly in case the window just spawned
        AppClock.sched(0.25, {
            if(bindMetersOnce.()) { startHudTicker.() }{ "[HUD] Binding failed again; run this block once the HUD window is visible.".warn };
            nil
        });
    }{
        startHudTicker.();
    };
    nil
});
)

===== MagicPedalboard/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "‚ö†Ô∏è queueExportCallback missing.".warn };
)

===== MagicPedalboard/QuickRestore_AudioAndExclusive.scd =====
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== MagicPedalboard/README_DesignAndAPI_20250915.md =====
<!-- Filename: README_DesignAndAPI_20250915.md -->

# Design highlights (SC 3.14, macOS, Qt)

- All GUI work is scheduled on AppClock.
- No `server.sync`.
- No watchers or background polling in the runner.
- Exactly one GUI window: duplicates are closed or a live one is reused.
- Deterministic runs are token-gated; stale scheduled steps are ignored.
- Scripts/tests follow style: tilde interpreter vars, lowercase names, `var` at top of each block, no single-letter locals, and no `^` in .scd scripts.
- Do not override or monkey-patch `queueUi`. Call it if present; otherwise skip.

## Architecture

- MagicPedalboardNew manages two chains (`\chainA`, `\chainB`) built from Ndefs.
- Chains are arrays of symbols: `[sink, ... processors ..., source]`.
- Crossfading `switchChain` swaps CURRENT and NEXT with a short fade.
- MagicDisplay is a console adaptor.
- MagicDisplayGUI is a Qt GUI that shows CURRENT / NEXT lists, an expectation box, countdown, and optional meters.
- MagicProcessorLibrary registers processors/sources and ensures the corresponding Ndefs exist.

---

# Class summaries & key API

## MagicPedalboardNew (Object)

- Role: Manage A/B chains of Ndefs; maintain bypass state; rebuild non-destructively; notify display.
- Construction:
  - `MagicPedalboardNew.new(displayOrNil)`
- Playback:
  - `playCurrent`
  - `stopCurrent`
  - `switchChain(fadeTime = 0.1)`  // short crossfade, clamps to a safe range
- Mutators (operate on NEXT):
  - `add(key)`
  - `addAt(key, index)`
  - `removeAt(index)`
  - `swap(indexA, indexB)`
  - `clearChain`
- Bypass:
  - NEXT: `bypass(key, state=true)`, `bypassAt(index, state=true)`
  - CURRENT: `bypassCurrent(key, state=true)`, `bypassAtCurrent(index, state=true)`
- Sources:
  - `setSource(key)`            // NEXT
  - `setSourceCurrent(key)`     // CURRENT
- Diagnostics:
  - `printChains`
  - `effectiveCurrent`, `effectiveNext`
  - `bypassKeysCurrent`, `bypassKeysNext`
  - `reset`
- Notes:
  - Rebuilds run in `Server.default.bind { ... }` after `ensureServerTree`.
  - A small helper normalizes Ndef channel counts before connections.
  - Pair connections use JITLib‚Äôs `<<>>` operator to embed/patch Ndefs.

## MagicDisplay (Object)

- Role: Console display adaptor.
- Selected methods:
  - `showInit(ped, versionString, current, next)`
  - `showRebuild(which, fullChain, effective)`
  - `showPlay(sink)`, `showStop(sink)`
  - `showSwitch(oldSink, newSink, current, next)`
  - `showMutation(action, args, nextChain)`
  - `showBypass(which, key, state, chain, bypassKeys)`
  - `showReset(current, next)`
  - `showChains`, `showChainsDetailed(...)`
  - `showError(message)`

## MagicDisplayGUI (MagicDisplay)

- Role: Visual GUI for CURRENT/NEXT chains, expectation/countdown, operations list, optional A/B meters.
- Construction:
  - `MagicDisplayGUI.new()`   // builds the window from `initGui` on AppClock
- UI queue:
  - `queueUi { |f| ... }`     // buffers until views exist; then runs on AppClock
- Visualization:
  - `highlightCurrentColumn`
  - `formatListTopDown(listRef, bypassKeys, effectiveList)`
- Expectation & countdown:
  - `showExpectation(text, seconds=0)`
  - `startCountdown(seconds, labelText, onFinished)`
- Operations pane:
  - `setOperations(items)`
  - `setNextAction(func)`
  - `runNextOperation(index)`
  - `updateOpsHighlight`
- Meters:
  - `enableMeters(flag=true)`  // may define lightweight meter SynthDefs on demand
- Display hooks:
  - Overrides `showInit / showRebuild / showPlay / showStop / showSwitch / showMutation / showBypass / showReset / showChainsDetailed / showError`.

## MagicProcessorLibrary (Object)

- Role: Registry for processors/sources; server helpers to ensure Ndefs exist.
- API:
  - `register(key, func)`
  - `has(key)`, `get(key)`, `keys`
  - `ensure(key, chans=2)`
  - `ensureMany(keyArray, chans=2)`
  - `ensureFromChain(chainArray, chans=2)`

===== MagicPedalboard/README_MagicPedalboard_Demo.md =====

# Magic Pedalboard (SuperCollider) ‚Äì Demo Readme

**Status**: demo-ready (visual + audio) ‚Ä¢ **Date**: 2025-09-19 09:27

This document explains what the Magic Pedalboard system does, how its demo works, how to run it, how the pieces fit together, and what to improve next. It is written for a third‚Äëparty developer who needs to understand and reproduce today‚Äôs demo in SuperCollider.

---

## 1) What the system is

Magic Pedalboard is a SuperCollider system for live guitar processing split into three layers:

1) Audio Engine (SC / JITLib)
   - Two processing chains using Ndef: Chain A (CURRENT) and Chain B (NEXT).
   - Option A safety: NEXT is muted at the source (built silently) and becomes audible only when switched.
   - Effects are attached with Ndef(\chainX).filter from a small effect dictionary (delay, reverb, chorus, tremolo).
   - A small set of helpers controls NEXT‚Äôs effect and toggles CURRENT/NEXT.

2) Display GUI (MagicDisplayGUI_GridDemo)
   - A single window named ‚ÄúMagicDisplayGUI ‚Äì GridDemo‚Äù using GridLayout.
   - Row 0: two equal columns (CURRENT left, NEXT right).
   - Rows 1‚Äì4: full‚Äëwidth blocks for expectation, countdown, thin meters (~30 px), and a bottom Processors panel.
   - No mouse interaction required; it reflects state changes from code.

3) Command Tree + MIDI (classes provided)
   - CommandManager / MDCommandTree / MDCommandNode / MDCommandBuilder / MDCommandQueue / MIDIInputManager
   - Modes: \idle, \prog (navigate by fretted notes), \queue (enqueue payload), \send (export OSC path).
   - A bridge maps the exported OSC path tail (e.g. single-delay, freeverb) to an effect symbol and applies it to NEXT.

---

## Resume Prompt

Resume: Magic Pedalboard (SuperCollider) ‚Äî continue where we left off.

Context snapshot:
- Audio working with JITLib Ndefs: Chain A (CURRENT, audible) and Chain B (NEXT, Option A muted at source). Effects via Ndef(\chainX).filter.
- GUI = MagicDisplayGUI_GridDemo using GridLayout. Row 0 is two equal columns; rows 1‚Äì4 are full width (expectation, countdown, thin meters ~30 px, bottom Processors). Visual-only (no clicks).
- Command Tree classes present: CommandManager, MDCommandTree, MDCommandNode, MDCommandBuilder, MDCommandQueue, MIDIInputManager (+ handlers). Modes: \idle ‚Üí \prog ‚Üí \queue ‚Üí \send. Bridge maps OSC tail tokens (e.g. single-delay, freeverb) to effect symbols and applies to NEXT.
- Runtime helpers: ~applyCTEffect.(\effect), ~clearNext.(), ~switchNow.(), ~audioReset.(). GUI‚Äìaudio sync patch installed so headers/highlight/lists match ~currentIsA, and NEXT shows ~nextEffectSym.

Prescriptions / rules (must follow):
- SuperCollider style: var-first in every block/closure; method names lowercase; avoid single-letter locals; interpreter vars are ~lowercase; no loadRelative.
- GUI ops on AppClock only; no server.sync. Server ops inside Server.default.bind at boot. Safe resets: s.waitForBoot; s.initTree; s.defaultGroup.freeAll.
- For demos/tests: generated audio only; NO SoundIn.
- GUI: single window whose name begins with ‚ÄúMagicDisplayGUI‚Äù. Use GridLayout. Keep meters thin strips.
- Audio safety: enforce Option A (NEXT silent at source) until switched.
- When negating a var, multiply by -1 (e.g., depth * -1) instead of a bare unary minus on identifiers.

What to do next (priority):
1) Implement a 50‚Äì100 ms crossfade in ~switchNow (dual-gain fade, no clicks).
2) Map Command Tree payload parameters to effect params (e.g., delay time/feedback), with safe ranges and GUI reflection.
3) Confirm hex guitar MIDI routing (ch 0‚Äì5 ‚Üí strings 6‚Üí1) and live fret navigation in \prog; integrate foot controller mode changes.
4) Optional: real meters (audio-driven) while keeping thin-strip look.

===== MagicPedalboard/README20250915.md =====
<!-- Filename: README20250915.md -->

# MagicPedalboardNew + MagicDisplayGUI (SC 3.14, macOS / Qt)

This repo contains:
- **MagicPedalboardNew**: a JITLib (Ndef) A/B pedalboard manager.
- **MagicDisplay**: console display adaptor.
- **MagicDisplayGUI**: Qt GUI displaying CURRENT and NEXT chains, with optional meters.
- **MagicProcessorLibrary**: registry for sources/effects and helpers to ensure Ndefs.

All GUI work is scheduled on **AppClock**. No `server.sync`. No watchers/pollers. One window.

---

## Versions (as printed by classes at init)

- MagicPedalboardNew **v0.3.8**
- MagicDisplay **v0.1.2**
- MagicDisplayGUI **v0.2.4**

(Your test runner may show a separate runner version string.)

---

## Quick start

1. **Boot the server** (if your scenarios need audio), or let the GUI run meterless.
2. **Create the GUI** using the constructor (no args). The GUI builds its window on AppClock internally:

```supercollider
~gui = MagicDisplayGUI.new();   // builds window during initGui on AppClock

3. Create the pedalboard and attach the display:

~pedalboard = MagicPedalboardNew(~gui);
~pedalboard.printChains;  // also drives GUI detailed view

4. Run the one-button runner (if present in your test scripts):

~md_bootProbeScenario.();   // ensures 1 window, shows PROBE FRAME, runs Scenario 1 (fast)

===== MagicPedalboard/retargetMeters.scd_OBSOLETE =====
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)

===== MagicPedalboard/RMS_From_ChainAB_Busses_ToHUD.scd_OBSOLETE =====
// RMS_From_ChainAB_Busses_ToHUD.scd
// v0.1.0
// MD 2025-09-29

/* Purpose
   - Read audio at the *ends* of chainA and chainB via their Ndef output busses.
   - Compute RMS per channel using RMS.ar(sig, 500).
   - Convert to dBFS, map to 0..1 for display headroom, and send to /md/levels
     (the standard PerfHUD path: [A_L, A_R, B_L, B_R]).
   - Also send raw dBFS to /md/rms_db so we can verify numbers in the console.

Style
   - var-first; descriptive lowercase; Server.default.bind for server ops; AppClock for UI; no server.sync.
*/

(
var getProxyBusInfo, chainAProxy, chainBProxy, busAIndex, busBIndex, channelsA, channelsB;
var uiFloorDb, uiTopDb, updatesPerSecond;
var installSynthDef, startRmsMeter, installDbPrinter, stopExisting, sanityReport;

// --- configuration (adjust only these if needed) ---
uiFloorDb        = -72.0;  // visual floor
uiTopDb          =   3.0;  // 0 dBFS maps to 1.0 (use +3.0 for extra headroom)
updatesPerSecond = 15;     // HUD refresh cadence

// Helpers
getProxyBusInfo = { arg symbol;
    var proxy, busObject, infoDict;
    proxy = Ndef(symbol);
    busObject = proxy.bus;
    infoDict = (
        symbol: symbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    infoDict
};

// 0) Inspect chain busses (so we *know* what we‚Äôre reading)
chainAProxy = getProxyBusInfo.(\chainA);
chainBProxy = getProxyBusInfo.(\chainB);
busAIndex   = chainAProxy[\busIndex];
busBIndex   = chainBProxy[\busIndex];
channelsA   = chainAProxy[\numChannels];
channelsB   = chainBProxy[\numChannels];

sanityReport = "[RMS] chainA bus=" ++ (busAIndex ? "nil")
    ++ "  chans=" ++ channelsA
    ++ "   |   chainB bus=" ++ (busBIndex ? "nil")
    ++ "  chans=" ++ channelsB;
sanityReport.postln;

if(busAIndex.isNil or: { busBIndex.isNil }) {
    "‚ö†Ô∏è Could not get Ndef bus indices (are chainA/chainB playing?). Aborting RMS bring-up.".warn;
    ^nil;
};

// 1) Define one synth to read both busses, compute RMS‚ÜídB‚ÜíUI and send to HUD
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15, floorDb = -72, topDb = 0;

            var sigA, sigB, aL, aR, bL, bR;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var uiAL, uiAR, uiBL, uiBR;
            var tick, minLin;

            // Read 2 channels from each bus; duplicate left if mono
            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aL = sigA[0];
            aR = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });

            bL = sigB[0];
            bR = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS at audio rate (user-specified: RMS.ar(sig, 500) ~ 500 Hz lowpass)
            rmsAL = RMS.ar(aL, 500);
            rmsAR = RMS.ar(aR, 500);
            rmsBL = RMS.ar(bL, 500);
            rmsBR = RMS.ar(bR, 500);

            // Convert to dBFS (guard floor)
            minLin = 1e-9;
            dbAL = (max(rmsAL, minLin)).log10 * 20.0;
            dbAR = (max(rmsAR, minLin)).log10 * 20.0;
            dbBL = (max(rmsBL, minLin)).log10 * 20.0;
            dbBR = (max(rmsBR, minLin)).log10 * 20.0;

            // Map dBFS -> 0..1 for HUD (headroom)
            uiAL = ((dbAL - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiAR = ((dbAR - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiBL = ((dbBL - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiBR = ((dbBR - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);

            // Emit both: raw dB (for console) and mapped UI (for HUD)
            tick = Impulse.kr(fps);

            // For verification
            SendReply.kr(tick, "/md/rms_db", [dbAL, dbAR, dbBL, dbBR]);

            // For HUD: /md/levels expects [A_L, A_R, B_L, B_R]
            SendReply.kr(tick, "/md/levels", [uiAL, uiAR, uiBL, uiBR]);
        }).add;
    });
    "[RMS] SynthDef \\md_rms_from_busses installed.".postln;
};

// 2) Stop any previous RMS meter synth; start a fresh one on the detected busses
stopExisting = {
    if(~md_rmsSynth.notNil) {
        ~md_rmsSynth.free; ~md_rmsSynth = nil;
        "[RMS] previous md_rms_from_busses stopped.".postln;
    };
};

startRmsMeter = {
    Server.default.bind({
        ~md_rmsSynth = Synth(\md_rms_from_busses, [
            \inBusA, busAIndex,
            \inBusB, busBIndex,
            \fps, updatesPerSecond,
            \floorDb, uiFloorDb,
            \topDb, uiTopDb
        ]);
    });
    ("[RMS] started on A=" ++ busAIndex ++ "  B=" ++ busBIndex
        ++ "  floor=" ++ uiFloorDb ++ " dB  top=" ++ uiTopDb ++ " dB").postln;
};

// 3) Print a few dB lines to console so we *see* the measured numbers
installDbPrinter = {
    var keyName, linesRemaining;
    keyName = \md_rms_db_console;
    linesRemaining = 8;

    if(OSCdef(keyName).notNil) { OSCdef(keyName).free };
    OSCdef(keyName, { arg message;
        var dbAL, dbAR, dbBL, dbBR, line;
        if(message.size >= 5) {
            dbAL = message[3].round(0.1);
            dbAR = message[4].round(0.1);
            dbBL = message[5].round(0.1);
            dbBR = message[6].round(0.1);
            line = "[RMS dB]  A: L=" ++ dbAL ++ "  R=" ++ dbAR
                ++ "   |   B: L=" ++ dbBL ++ "  R=" ++ dbBR;
            line.postln;
            linesRemaining = linesRemaining - 1;
            if(linesRemaining <= 0) {
                OSCdef(keyName).free;
                "[RMS dB] console printer finished.".postln;
            };
        };
    }, '/md/rms_db');
};

// Execute
installSynthDef.();
stopExisting.();
startRmsMeter.();
installDbPrinter.();
)

===== MagicPedalboard/switchDelayCheck.scd =====
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optional Final) probes using your stereo BUS INDICES.
   - A uses replyID 2001, B uses 2002, Final uses 2101.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain stereo bus base index (e.g., 16)
busB = -1;      // TODO: set to your B chain stereo bus base index (e.g., 24)
busFinal = -1;  // optional final mix stereo bus base index (e.g., 32)

ok = true;

if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd
// v0.3.13
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter filters to avoid duplicate /md/levels.
   - Announce everything in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, aResult, bResult, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, def1, def2;

    ok2 = true;

    // mono probe
    def1 = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // silent synth
        Silent.ar(1).mute;
    }).add;

    // stereo probe
    def2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        Silent.ar(2).mute;
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any in-proxy meter/tap filters to identity (no duplicate SendReply)
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Collect Ndef info: exists, playing, bus index, channel count, group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2; // default to stereo if unknown
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, tagSym, outVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            // Free previous probe if any
            freeIfPlaying.value(thisProcess.interpreter.getVar(outVarSym));

            // Ensure a fresh group placed after the Ndef's group
            grp = Group.after(groupTarget);

            // Attach appropriate probe
            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            // Publish references
            thisProcess.interpreter.setVar(tagSym, grp);
            thisProcess.interpreter.setVar(outVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

// Ensure our probe SynthDefs exist
ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, ~md_probeGroupA, ~md_probeA);
attachAfterNdef.value(bInfo, 2002, ~md_probeGroupB, ~md_probeB);

("Attach_ProbesAfterNdefs: done.").postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd
// v0.3.14
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announces itself in the console so logs show what ran and in what order.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe (no Out, just SendReply)
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output; silent by design
    }).add;

    // stereo probe (no Out, just SendReply)
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output; silent by design
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any prior filters (meter/tap) to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Gather Ndef info: existence, playing, bus index, channel count (clamped 1..2), and group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, groupVarSym, synthVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            freeIfPlaying.value(thisProcess.interpreter.getVar(synthVarSym));
            thisProcess.interpreter.setVar(synthVarSym, nil);

            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            thisProcess.interpreter.setVar(groupVarSym, grp);
            thisProcess.interpreter.setVar(synthVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, \~md_probeGroupA, \~md_probeA);
attachAfterNdef.value(bInfo, 2002, \~md_probeGroupB, \~md_probeB);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd
// v0.3.15
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (mono or stereo).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announce actions in console so logs clearly show what ran.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyFilters,
    detectInfo, freeIfPlaying, attachAfterNdef,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe: reads 1 channel, sends a single float
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output
    }).add;

    // stereo probe: reads 2 channels, sends an array of two floats
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output
    }).add;

    ok2;
};

neutralizeInProxyFilters = {
    var ok2;

    ok2 = true;

    // Overwrite prior filters/taps to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Inspect an Ndef and report (exists, playing, bus index, channel count, group)
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group AFTER the Ndef's group and attach the proper probe synth.
// Uses setter closures to store references in ~vars (no reflection).
attachAfterNdef = { |info, replyID, setGroupFunc, setSynthFunc, freeOldSynthFunc|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        // free the previous synth if any (quietly)
        freeOldSynthFunc.value;

        s.bind({
            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };
        });

        setGroupFunc.value(grp);
        setSynthFunc.value(synth);

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Ensure our base routing exists WITHOUT clearing your Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy filters/taps
neutralizeInProxyFilters.value;

// Detect chains (prints status)
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes AFTER the Ndef groups (ordering-safe)
attachAfterNdef.value(
    aInfo, 2001,
    { |g| ~md_probeGroupA = g },            // set group
    { |sy| ~md_probeA = sy },               // set synth
    { freeIfPlaying.value(~md_probeA); ~md_probeA = nil }  // free old synth if any
);

attachAfterNdef.value(
    bInfo, 2002,
    { |g| ~md_probeGroupB = g },
    { |sy| ~md_probeB = sy },
    { freeIfPlaying.value(~md_probeB); ~md_probeB = nil }
);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd =====
// MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - For JITLib chains Ndef(\chainA) and Ndef(\chainB), install .filter taps
     that mirror their outputs to private 2ch busses for metering.
   - Attach probes to those busses (replyID 2001 for A, 2002 for B).
   - Provides a removal helper for the taps and busses.

   Style
   - var-first in every block; no non-local returns (^).
   - Uses .filter as you prefer; does not alter chain sound (passes input through).
*/

(
var setupBusTaps, removeBusTaps;

setupBusTaps = {
    var ok, haveA, haveB;

    ok = true;
    haveA = false;
    haveB = false;

    // preflight: Ndefs must exist
    if (Ndef(\chainA).notNil) { haveA = true; } { "Ndef(\\chainA) not found.".postln; };
    if (Ndef(\chainB).notNil) { haveB = true; } { "Ndef(\\chainB) not found.".postln; };

    if (haveA.not and: { haveB.not }) {
        "Neither chainA nor chainB found; nothing to attach.".postln;
    } {
        // free previous busses if any
        if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
        if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

        // allocate new private 2ch busses
        ~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
        ~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

        // install taps using .filter; each tap writes to its bus, then passes input through
        if (haveA) {
            Ndef(\chainA).filter(\mdProbeTapA, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busA.index, outSig);
                outSig
            });
        };
        if (haveB) {
            Ndef(\chainB).filter(\mdProbeTapB, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busB.index, outSig);
                outSig
            });
        };

        // attach probes to those busses
        if (~md_attachProbesAB.notNil) {
            ~md_attachProbesAB.value(
                busA: (if (haveA) { ~md_busA.index } { -1 }),
                busB: (if (haveB) { ~md_busB.index } { -1 })
            );
            ("Attached A bus=" ++ (if (haveA) { ~md_busA.index.asString } { "none" })
             ++ " B bus=" ++ (if (haveB) { ~md_busB.index.asString } { "none" })).postln;
        } {
            "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
        };
    };

    ok;
};

removeBusTaps = {
    var ok;

    ok = true;

    // remove taps if present
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).removeFilter(\mdProbeTapA);
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).removeFilter(\mdProbeTapB);
    };

    // free private busses
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    ok;
};

// ---------- run setup now ----------
setupBusTaps.value;

// Later, to remove taps + free busses:
// removeBusTaps.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optionally Final) probes by BUS INDICES you provide.
   - Leaves the window unchanged; meters switch to A/B once replies arrive.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain bus index (stereo base index)
busB = -1;      // TODO: set to your B chain bus index (stereo base index)
busFinal = -1;  // optional: set to your final mix bus index

ok = true;

// sanity check
if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    } {
        "Final bus not set; skipping.".postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd =====
// MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Fix "sound but meters not moving" by:
     * ensuring OUR routing non-destructively
     * reinstalling receiver
     * auto-attaching A(2001)/B(2002) probes to Ndef buses
     * printing quick status
   - Assumes your chains are Ndef(\chainA) and Ndef(\chainB) and are PLAYING.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, detectBusIndex, aIdx, bIdx, reinstallReceiver, postStatus;

("MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd").postln;
ok = true;

if (~md_ensureRouting.isNil or: { ~md_attachProbesAB.isNil }) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure our bus/groups/probe exist without killing your Ndefs
    ~md_ensureRouting.value;

    // reinstall receiver safely
    reinstallReceiver = {
        var existing;
        existing = OSCdef(\md_levels);
        if (existing.notNil) { existing.free; };
        ~md_levelsById = IdentityDictionary.new;
        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = Main.elapsedTime;

        OSCdef(
            \md_levels,
            { |msg, time, addr, recvPort|
                var nodeId, replyId, count, i, outArray;

                nodeId = 0;
                replyId = 0;
                count = 0;
                i = 0;
                outArray = nil;

                if (msg.size >= 3) {
                    nodeId = msg[1].asInteger;
                    replyId = msg[2].asInteger;
                    count = msg.size - 3;
                    outArray = Array.newClear(count);
                    i = 0;
                    while { i < count } {
                        outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                        i = i + 1;
                    };
                    ~md_levelsById[replyId] = outArray;
                    ~levels = outArray;
                    ~md_lastLevelAt = Main.elapsedTime;
                };
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );

        true;
    };

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid when proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    postStatus = {
        var keys, msg;
        keys = ~md_levelsById.keys.asArray.sort;
        msg = "Active replyIDs: " ++ keys.asString;
        msg.postln;
        if (~md_levelsById[2001].notNil) { ("A: " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B: " ++ ~md_levelsById[2002].asString).postln; };
    };

    reinstallReceiver.value;

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected Ndef buses ‚Üí A=" ++ aIdx.asString ++ "  B=" ++ bIdx.asString).postln;

    // attach probes directly to those buses (skip -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // small delayed status check (allow first /md/levels to arrive)
    AppClock.sched(0.5, {
        postStatus.value;
        nil;
    });
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd =====
// MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Add simple HUD labels inside the existing MagicDisplayGUI A/B window.
   - Top-left anchored, no FlowLayout; read-only labels for the demo.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, win, content, hudTitle, hudA, hudB;

ok = true;

win = ~mdGui_window;

if (win.isNil) {
    "No MagicDisplayGUI window found. Open MagicDisplayGUI_New_Window_AB_v0.3.7.scd first.".postln;
} {
    content = win.view;

    // Title HUD
    hudTitle = StaticText(content, Rect(16, 0, 400, 12));
    hudTitle.string = "HUD: A=replyID 2001 | B=replyID 2002 | fallback=test 1001";
    hudTitle.stringColor = Color.gray(0.8);
    hudTitle.background = Color.clear;
    hudTitle.align = \left;

    // Chain labels (editable here if you want different names)
    hudA = StaticText(content, Rect(16, 24, 200, 12));
    hudA.string = "A: Ndef(\\chainA)";
    hudA.stringColor = Color.gray(0.8);
    hudA.background = Color.clear;
    hudA.align = \left;

    hudB = StaticText(content, Rect(292, 24, 200, 12));
    hudB.string = "B: Ndef(\\chainB)";
    hudB.stringColor = Color.gray(0.8);
    hudB.background = Color.clear;
    hudB.align = \left;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.1.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.1.scd
// v0.3.1
// MD timestamp: 2025-09-25

/* Purpose
   - Fast way to remove GUI, OSC receiver, synths, groups, bus; leave server running clean.
*/

(
var ok;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// Receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Synths
if (~md_testSynth.notNil) { ~md_testSynth.free; ~md_testSynth = nil; };
if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };

// Groups
if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

s.defaultGroup.freeAll;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.5.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Close GUI, free OSC receiver, clear server nodes/bus, and reset state.
   - Silent and idempotent: safe to run multiple times; no 'Node not found' noise.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, hadServer;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// OSC receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Server nodes (only if server running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
}

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// ensure final expression is a simple boolean
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.6.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.6.scd
// v0.3.6
// MD timestamp: 2025-09-25

/* Purpose
   - Close MagicDisplayGUI windows, stop GUI ticker, free OSC receiver.
   - Clear server default group (if running), free private bus, reset state vars.
   - Silent and idempotent; final expression is 'true' (never returns a Window).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, hadServer, windows, i, w, nameString;

ok = true;

// stop GUI ticker if present
if (~mdGui_ticker.notNil) {
    ~mdGui_ticker.stop;
    ~mdGui_ticker = nil;
};

// close any MagicDisplayGUI windows (explicitly; this does not return the window)
windows = Window.allWindows;
i = 0;
while { i < windows.size } {
    w = windows[i];
    nameString = w.name.asString;
    if (nameString.beginsWith("MagicDisplayGUI")) {
        w.close;
    };
    i = i + 1;
};

// free OSC receiver if present
if (OSCdef(\md_levels).notNil) {
    OSCdef(\md_levels).free;
};

// clear server nodes (only if server is running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
};

// free private bus if allocated
if (~md_mixBus.notNil) {
    ~md_mixBus.free;
    ~md_mixBus = nil;
};

// nil any cached node/bus references
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

// final value: simple boolean (prevents '-> a Window')
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot the server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create a private bus, groups, relay-to-hardware and a level probe.
   - Install an OSC receiver bound to '/md/levels' (matches SendReply).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probe reads a private bus; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // Close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // Reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = 0.0;
    ~md_testSynth = nil;
    ~md_probe = nil;
    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // Reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // Test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // Relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // Level probe (2ch fixed) ‚Üí '/md/levels'
    // Message format: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// Install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// Create routing (fresh bus + fresh groups + relay + probe). Clears default group first.
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // Clear any stale nodes from previous runs
        s.defaultGroup.freeAll;

        // Fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // Fresh groups in strict order: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // Relay and probe (safe even without source)
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // No source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    // Always rebuild routing to avoid stale groups after a server reboot
    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // Clean everything (leave server running)
    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  OSC: listening on /md/levels".postln;

    ok;
};

// ---------- Run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
// ~md_ensureRouting.value;
// ~md_reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd
// v0.3.7
// MD 2025-09-25 15:10 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Returns input unchanged (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz;

var windowNote, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        // free old one if present (idempotent reset)
        existing = OSCdef(defName);
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var each;
    each = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    each.value(\chainA, ids[\A]);
    each.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId, ~slotName;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ~md_probeA = ~md_probeA ? { makeOne.value(\chainA, ids[\A]) } !? { ~md_probeA };
    ~md_probeB = ~md_probeB ? { makeOne.value(\chainB, ids[\B]) } !? { ~md_probeB };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
        // leave signal path untouched; if silent they‚Äôll still meter 0.0
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> You can switch to Plan B by calling: ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};
apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:22 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Pass-through (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        existing = OSCdef(defName); // returns nil or the OSCdef
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var installOne;
    installOne = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    installOne.value(\chainA, ids[\A]);
    installOne.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ensureDef.value;
    if(~md_probeA.isNil) { ~md_probeA = makeOne.value(\chainA, ids[\A]) };
    if(~md_probeB.isNil) { ~md_probeB = makeOne.value(\chainB, ids[\B]) };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

// expose helpers as requested
~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> To switch to Plan B later:
//    ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.1.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels‚Ä¶";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views‚Äô bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels‚Ä¶";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views‚Äô bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd
// v0.4.4
// MD 2025-09-25 16:48 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, meterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay, startTicker, stopTicker, tickerFlag;
var identityBanner;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === identity banner (after var-first) ======================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;
labelWidth = 84;   // wider, more readable
meterWidth = 360;

// init meter values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, getLevelFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, meterWidth, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD string with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    stepFunc = {
        readLevelsAndUpdateDisplay.value;
        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;
        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// compute total height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + labelWidth + 8 + meterWidth + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=false, border=true -> proper title bar visible
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.4)", windowRect, false, true);

// HUD
hudLabel = StaticText(windowRef, Rect(paddingX, paddingY, labelWidth + 8 + meterWidth, headerHeight));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame area that draws section boxes
meterFrameView = makeFrameView.value(windowRef, Rect(
    paddingX,
    paddingY + headerHeight + rowGap,
    (labelWidth + 8 + meterWidth),
    (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)
));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

// Deterministic Y positions (no dependency on .bounds of other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// Chain A
chainATitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainATitleY, 120, sectionTitleHeight));
chainATitleLabel.string = "Chain A";

chainALabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight));
chainALabelLeft.string = "A-L";
barViewALeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar1Y, { displayALevelLeft });

chainALabelRight = StaticText(windowRef, Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight));
chainALabelRight.string = "A-R";
barViewARight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar2Y, { displayALevelRight });

// Chain B
chainBTitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainBTitleY, 120, sectionTitleHeight));
chainBTitleLabel.string = "Chain B";

chainBLabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight));
chainBLabelLeft.string = "B-L";
barViewBLeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar1Y, { displayBLevelLeft });

chainBLabelRight = StaticText(windowRef, Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight));
chainBLabelRight.string = "B-R";
barViewBRight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar2Y, { displayBLevelRight });

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd
// v0.4.5
// MD 2025-09-25 16:58 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout akin to your previous GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch HORIZONTALLY as you resize.
  (No FlowLayout; manual top-left anchored layout on AppClock.)

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rect metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, minMeterWidth, maxMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics)
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;            // readable label width
minMeterWidth = 260;         // minimum bar width
maxMeterWidth = 900;         // clamp to keep drawing pleasant

// deterministic Y positions (do not depend on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- layout that responds to window width (manual, no FlowLayout) ------------
computeAndApplyLayout = {
    var innerWidth, currentMeterWidth, frameWidth, frameHeight;

    // NOTE: keep vertical metrics fixed; stretch horizontally
    innerWidth = windowRef.bounds.width - (paddingX * 2);
    currentMeterWidth = (innerWidth - (labelWidth + 8)).clip(minMeterWidth, maxMeterWidth);

    frameWidth  = (labelWidth + 8 + currentMeterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, currentMeterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, currentMeterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, currentMeterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, currentMeterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with a reasonable initial width; height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + minMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=true, border=true -> proper title + resizeable window
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.5)", windowRect, true, true);

// HUD label
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10)); // will be set by computeAndApplyLayout
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame + section titles + bars (create; exact bounds set in computeAndApplyLayout)
meterFrameView = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string = "Chain A";
chainALabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string  = "A-L";
barViewALeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelLeft });
chainALabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string = "A-R";
barViewARight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelRight });

chainBTitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string = "Chain B";
chainBLabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string  = "B-L";
barViewBLeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelLeft });
chainBLabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string = "B-R";
barViewBRight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker will keep it current on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd
// v0.4.6
// MD 2025-09-25 17:10 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout similar to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch horizontally and ALWAYS fit within the content area
  (no FlowLayout; manual top-left anchored layout on AppClock).

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed vertical metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, defaultMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics; match ‚Äúyesterday‚Äù proportions)
paddingX = 12; paddingY = 10;
rowGap = 10;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;           // readable label width (yesterday‚Äôs GUI was ~72‚Äì100)
defaultMeterWidth = 340;    // comfortable default; will stretch or shrink to fit

// deterministic Y positions (no dependency on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- responsive layout (bars always fit horizontally) -----------------------
computeAndApplyLayout = {
    var interiorWidth, meterWidth, frameWidth, frameHeight;

    // Keep vertical metrics fixed; stretch/shrink horizontally to ALWAYS fit
    interiorWidth = windowRef.bounds.width - (paddingX * 2);
    meterWidth = (interiorWidth - (labelWidth + 8)).max(40); // lower bound only; never off-screen
    frameWidth  = (labelWidth + 8 + meterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, meterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, meterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, meterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, meterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with proportions like yesterday‚Äôs GUI (fits on first open)
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + defaultMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B
    + paddingY
);

// resizable=true, border=true -> proper title + resizable window
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.6)", windowRect, true, true);

// HUD label (bounds set by computeAndApplyLayout)
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame + section titles + bars (create once; bounds set in computeAndApplyLayout)
meterFrameView    = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string  = "Chain A";
chainALabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string   = "A-L";
barViewALeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelLeft });
chainALabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string  = "A-R";
barViewARight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelRight });

chainBTitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string  = "Chain B";
chainBLabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string   = "B-L";
barViewBLeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelLeft });
chainBLabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string  = "B-R";
barViewBRight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker keeps it updated on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.10.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.10.scd
// v0.3.10
// MD 2025-09-25 15:48 BST

/*
Purpose
- Single window "MagicDisplayGUI ..." with 4 bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- If A/B are effectively silent, mirror test(1001) into the bars (visual fallback) for the demo.
- HUD top-left; AppClock ticker ~30 Hz; fixed rects; single-window policy.

Style
- var-first in every block; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC API only; final expression -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var dAL=0.0, dAR=0.0, dBL=0.0, dBR=0.0; // displayed values after fallback logic
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;
var fallbackThreshold, uiGamma;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum below this = "effectively zero" for demo
uiGamma = 1.0;               // 1.0 = linear; you can set 0.5 for sqrt visual boost if needed

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.10)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        // optional gamma for low-level visibility (uiGamma <= 1 boosts lows)
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { dAL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { dAR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { dBL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { dBR });

// read levels and compute display values with fallback
readLevels = {
    var a, b, t, sumAB, sumT, txt, showAL, showAR, showBL, showBR;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // Fallback rule: if both A and B effectively zero, mirror test into both A and B displays
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        showAL = tL; showAR = tR;
        showBL = tL; showBR = tR;
    } {
        showAL = aL; showAR = aR;
        showBL = bL; showBR = bR;
    };

    dAL = showAL.clip(0, 1);
    dAR = showAR.clip(0, 1);
    dBL = showBL.clip(0, 1);
    dBR = showBR.clip(0, 1);

    // HUD with finer precision so quiet values are visible
    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.7.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window with FOUR meters:
       A-L, A-R (replyID 2001), B-L, B-R (replyID 2002)
     and fall back to the default test probe (replyID 1001) if A/B not attached.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        labelA, aLeft, aRight, aDbL, aDbR,
        labelB, bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî A/B Window (v0.3.7)";

    window = Window.new(titleString, Rect(60, 60, 560, 260), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // A section
    labelA = StaticText(content, Rect(16, 12, 240, 22));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    // B section
    labelB = StaticText(content, Rect(292, 12, 240, 22));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    barWidth = 26;
    barHeight = 160;

    // A meters
    aLeft  = LevelIndicator(content, Rect(40,  44, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    aLeft.warning = (-6).dbamp; aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(32, 210, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(92, 210, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(316, 44, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(376, 44, barWidth, barHeight));
    bLeft.warning = (-6).dbamp; bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(308, 210, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(368, 210, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age
    statusA = StaticText(content, Rect(180, 44, 100, 18));
    statusA.string = "A rx: ‚Äî";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, 44, 100, 18));
    statusB.string = "B rx: ‚Äî";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // test controls (optional)
    startButton = Button(content, Rect(180, 80, 100, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    stopButton = Button(content, Rect(180, 114, 100, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbL, aDbR, bDbL, bDbR,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbL = ampToDbString.value(aL);
            aDbR = ampToDbString.value(aR);
            bDbL = ampToDbString.value(bL);
            bDbR = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbL; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbR; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbL; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbR; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.8.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:10 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001); B-L, B-R (replyID 2002).
- HUD at top-left; AppClock ticker ~30 Hz; fallback to test (1001) if A/B absent.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).
Style
- var-first; AppClock only; fixed rects (no FlowLayout); no non-local returns.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver, w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = { ~md_levelsById ? IdentityDictionary.new }!(); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var have;
    have = (OSCdef(\md_levels) !? { true }) ? false; // just to probe
    ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } // idempotent
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.8)", rect, false, false);
w.alwaysOnTop_(false);

w.drawFunc = { }; // no background drawing; keep it simple

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// Row helpers
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

makeBars = { arg left, top;
    var v;
    v = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var b, vNorm;
        b = uv.bounds;
        // caller sets a closure to draw current level (0..1)
        vNorm = uv.userCanDraw.value(uv);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm.clip(0,1), b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)));
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)));
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)));
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)));

viewAL.userCanDraw = { arg v; aL };
viewAR.userCanDraw = { arg v; aR };
viewBL.userCanDraw = { arg v; bL };
viewBR.userCanDraw = { arg v; bR };

// read levels (with fallback to test=1001 if A/B missing)
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    // update 4 numbers
    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];

    // HUD line
    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";
    // Fallback annotate if both A/B are zeros but test moves
    if((aL+aR+bL+bR) <= 0.0001 && (t[0]+t[1]) > 0.0, {
        txt = txt ++ "  (fallback: test " ++ t.collect(_.round(0.01)) ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, go;
    period = 1.0 / fps;
    go = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { ticker !? { go.value } });
        nil
    };
    ticker = true;
    AppClock.sched(0.0, { go.value; nil });
};

killTicker = {
    ticker = nil;
};

// clean close
w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.9.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.9.scd
// v0.3.9
// MD 2025-09-25 15:34 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- HUD top-left; AppClock ticker ~30 Hz; fallback shows test(1001) hint if A/B are zero.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).

Style
- var-first in every block; descriptive lowercase names; AppClock only for GUI.
- Known-good SC syntax only; no custom slots on views; no server.sync.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.9)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, vNorm;
        b = v.bounds;
        vNorm = getLevelFunc.value.clip(0, 1);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { aL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { aR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { bL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { bR });

// read levels from shared dict (set by /md/levels receiver)
// fallback shows test=1001 if both A and B sum to ~0
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";

    if(((aL+aR+bL+bR) <= 0.0001) and: { (tL+tR) > 0.0 }, {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.01), tR.round(0.01)] ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd
// v0.5.0
// MD 2025-09-25 17:35 BST

/*
Purpose
- Performance HUD window for live use (single, resizable "MagicDisplayGUI ..." window).
- Top row: Chain A (left) and Chain B (right) panels.
  * Active chain panel shows a green background (CURRENT inferred from Ndef.isPlaying).
  * Per-chain vertical meters (L/R) at each panel‚Äôs outer edge (A: left; B: right).
- Second row: full-width yellow status box (‚Äúsystem read‚Äù by default).
- Bottom-left: Choices pane (safe: reads CommandManager builder if present).
- Bottom-right: Messages/Next pane (safe: shows md/levels rate & last values; optional queued canonical).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- GUI uses AppClock only; no server.sync; avoids destructive operations.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var borderWidth, minTextWidth, minMeterWidth;
var headerString;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var statusLabel;
var chainAPanel, chainBPanel, chainAMeterView, chainBMeterView;
var choicesTitle, choicesText, messagesTitle, messagesText;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
var makePanelView, makeVerticalMeterView, drawVerticalMeters, setPanelActiveColor, setPanelNeutralColor;
var readLevelsAndUpdate, refreshChoicesFromBuilder, refreshMessages;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;
var identityBanner;

// === console identity (var-first ensured) ====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd";
identityBanner.postln;

// --- constants / state -------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B quiet, mirror test for display continuity (demo-safe)
uiGamma = 1.0;               // 1.0 linear; 0.7..0.5 boosts low levels

// layout metrics (tuned for iPad side-screen; adjust as needed)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 10;

topRowHeight    = 120;       // Chain A/B row height
statusRowHeight = 26;        // yellow status row
bottomRowHeight = 160;       // bottom panes row height
borderWidth     = 1;
minTextWidth    = 180;       // minimal inner text panel width per side
minMeterWidth   = 18;        // slim vertical meter (two bars drawn inside this view)

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;  testLevelRight  = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existing;
    existing = Window.allWindows.select({ arg w;
        var title;
        title = w.tryPerform(\name);
        title.notNil and: { title.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existing.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// simple panel with border whose background we can recolor for "active"
makePanelView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.94,0.94,0.94)); // neutral; greener when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

// slim vertical meter container; draw two vertical bars (L/R)
makeVerticalMeterView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        drawVerticalMeters.value(uv);
    };
    v
};

drawVerticalMeters = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    // A or B values are injected by caller through display* variables
    // Decide which pair to draw by reading a tag on the view name (set below)
    if(uv.name == \metersA) {
        leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    } {
        leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    };

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    // backgrounds
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    // dynamic fills (bottom-up)
    Pen.color = Color(0.20, 0.70, 0.20); // green-ish for visibility
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    // borders
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

setPanelActiveColor = { arg uv;
    uv.background = Color(0.86, 0.97, 0.86); // soft green for "active"
};

setPanelNeutralColor = { arg uv;
    uv.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // demo-safe fallback: if A/B are effectively zero but test is alive, mirror test
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // active chain (CURRENT) visual
    isAActive = Ndef(\chainA).isPlaying; // safe, non-blocking check
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil and: { chainBPanel.notNil }) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // lightweight HUD text
    statusLabel.string = "system read"; // change to "system ready" if you prefer
};

// bottom-left: print current navigation choices if CommandManager is present
refreshChoicesFromBuilder = {
    var haveSystem, cm, builder, lines, text;
    haveSystem = (~system.notNil);
    if(haveSystem.not) {
        text = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = ~system.commandManager;
        builder = (cm.notNil).if({ cm.builder }, { nil });
        if(builder.notNil and: { builder.currentNode.notNil }) {
            lines = builder.currentNode.children.collect({ arg ch;
                ("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
            });
            text = "Choices:\n" ++ lines.join("\n");
        } {
            text = "Choices:\n(n/a ‚Äî no builder or no node)";
        };
    };
    choicesText.string = text;
};

// bottom-right: last A/B values + optional canonical ‚Äúnext‚Äù
refreshMessages = {
    var cm, canonicalPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ",R=" ++ chainALevelRight.round(0.01) ++ "]  " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ",R=" ++ chainBLevelRight.round(0.01) ++ "]";
    cm = (~system.notNil).if({ ~system.commandManager }, { nil });
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        canonicalPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesText.string = base ++ "\nNext: " ++ canonicalPath.asString;
    } {
        messagesText.string = base;
    };
};

// --- layout ------------------------------------------------------------------
computeAndApplyLayout = {
    var w, h, contentW, contentH;
    var halfW, meterW, textW, panelY, statusY, bottomY;

    // guard window bounds
    w = windowRef.bounds.width; h = windowRef.bounds.height;
    if((w.isNumber.not) or: { h.isNumber.not }) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (w - (paddingX * 2)).max(320);
        contentH = (h - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + rowGap*3);

        halfW = ((contentW - columnGap) / 2).max(minTextWidth + minMeterWidth + 20);
        meterW = minMeterWidth;                    // fixed slim meter strip
        textW  = (halfW - meterW - 10).max(minTextWidth);

        // y anchors
        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // ---- Chain A (left) ----
        chainAPanel.bounds     = Rect(paddingX, panelY, halfW, topRowHeight);
        chainAMeterView.bounds = Rect(paddingX + 4, panelY + 8, meterW, topRowHeight - 16); // left edge (outer)
        // A text area (inside panel, to the right of meter) ‚Äî if you later want chain text, add a StaticText here.

        // ---- Chain B (right) ----
        chainBPanel.bounds     = Rect(paddingX + halfW + columnGap, panelY, halfW, topRowHeight);
        chainBMeterView.bounds = Rect(paddingX + halfW + columnGap + halfW - 4 - meterW, panelY
===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd
// v0.5.1
// MD 2025-09-25 17:56 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: Chain A (left) and Chain B (right). The ACTIVE one is highlighted (soft green).
  ‚Ä¢ Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width yellow status row with "system ready".
- Bottom-left: Choices pane (safe; reads from ~system.commandManager.builder if present).
- Bottom-right: Messages / Next pane (safe; last A/B values and optional canonical next).
- Non-intrusive: reads /md/levels A=2001 B=2002 (fallback mirrors test=1001 when A/B quiet).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

var chainAPanel, chainBPanel;
var meterViewBetweenA, meterViewBetweenB; // A's meters (at A right edge), B's meters (at B left edge)
var statusLabel;
var choicesTitleLabel, choicesTextView, messagesTitleLabel, messagesTextView;

var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

var makePanelView, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB;
var setPanelActiveColor, setPanelNeutralColor;

var readLevelsAndUpdate, refreshChoicesPane, refreshMessagesPane;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;

var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;               // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (kept steady vertically for predictability on iPad)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight    = 124;       // Chain A/B row height
statusRowHeight = 26;        // "system ready" row
bottomRowHeight = 168;       // bottom panes row height

minPanelTextWidth = 220;     // minimal inner text area width per chain panel
meterStripWidth   = 18;      // width of each slim vertical meter (2 bars drawn inside)
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, rect;
    var panelView;
    panelView = UserView(parent, rect);
    panelView.background_(Color(0.94, 0.94, 0.94)); // neutral; will be greener when active
    panelView.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    panelView
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    statusLabel.string = "system ready";
};

// bottom-left: Choices (safe; optional)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = "Choices:\n" ++ textLines.join($\n);
        } {
            s = "Choices:\n(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// bottom-right: Messages / Next (safe; optional)
refreshMessagesPane = {
    var sysObj, cm, nextPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ", R=" ++ chainALevelRight.round(0.01) ++ "]   " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ", R=" ++ chainBLevelRight.round(0.01) ++ "]";
    sysObj = ~system;
    cm = sysObj.tryPerform(\commandManager);
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        nextPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesTextView.string = base ++ "\nNext: " ++ nextPath.asString;
    } {
        messagesTextView.string = base;
    };
};

// --- layout (always fit; meters between chains) ------------------------------
computeAndApplyLayout = {
    var winBounds, contentW, contentH;
    var halfW, panelY, statusY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;

    winBounds = windowRef.bounds;
    if(winBounds.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (winBounds.width - (paddingX * 2)).max(520);
        contentH = (winBounds.height - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + (rowGap*3));

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // panel bounds
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // meters BETWEEN chains
        meterY = panelY + 8;
        meterH = topRowHeight - 16;

        // A meters at RIGHT edge (inside A panel)
        meterAX = aX + aW - 8 - meterStripWidth;
        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);

        // B meters at LEFT edge (inside B panel)
        meterBX = bX + 8;
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // status row
        statusLabel.bounds = Rect(paddingX, statusY, contentW, statusRowHeight);
        statusLabel.background = Color(1.0, 0.95, 0.6); // yellow

        // bottom panes
        choicesTitleLabel.bounds  = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds    = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        messagesTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        messagesTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates ~5 Hz
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshMessagesPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- bring-up + construct ----------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// start with proportions that fit on first open
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 40,
    paddingY + topRowHeight + rowGap + statusRowHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.1)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// status row
statusLabel = StaticText(windowRef, Rect(0,0,10,10));
statusLabel.stringColor = Color.black;
statusLabel.align = \left;

// bottom row
choicesTitleLabel   = StaticText(windowRef, Rect(0,0,10,10)); choicesTitleLabel.string = "Choices"; choicesTitleLabel.stringColor = Color.black;
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));  choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

messagesTitleLabel  = StaticText(windowRef, Rect(0,0,10,10)); messagesTitleLabel.string = "Messages / Next"; messagesTitleLabel.stringColor = Color.black;
messagesTextView    = TextView(windowRef, Rect(0,0,10,10));  messagesTextView.editable = false; messagesTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd
// v0.5.2
// MD 2025-09-25 18:12 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ...").
- Top row: Chain A (left) and Chain B (right), EACH with a title. The ACTIVE chain is highlighted (soft green).
  ‚Ä¢ Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width "System State" section (title + triple-height yellow panel, text "system ready").
- Bottom-left: "Choices" section (title + text).
- Bottom-right: "Processors" section (title + text; safe placeholder until you point me to the API).
- Non-intrusive: reads /md/levels (A=2001, B=2002); if A/B quiet, mirrors test=1001 for visual continuity.

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + layout metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowTitleHeight, statusRowBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;

// ids + levels + render shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB; // A‚Äôs meters (right edge), B‚Äôs meters (left edge)

// status row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// state values
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitledLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// data + UI refresh
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;

// layout + ticker
var computeAndApplyLayout, lastWidth, lastHeight, startTicker, stopTicker, tickerFlag;

// identity banner
var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;  // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;              // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (steady verticals for iPad mirroring)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight          = 140; // Chain A/B panels
statusRowTitleHeight  = 18;  // "System State" title
statusRowBodyHeight   = 78;  // triple-height yellow body (‚âà3√ó a standard line)
bottomRowHeight       = 180; // Choices + Processors row

minPanelTextWidth = 220;     // min inner width per chain panel
meterStripWidth   = 18;      // slim vertical meter strip
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var titleString;
        titleString = w.tryPerform(\name);
        titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94)); // neutral; turn soft green when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitledLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data + UI refresh -------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback for demo continuity
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // visual active state (CURRENT)
    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // "System State" text (yellow panel)
    systemStateTextView.string = "system ready";
};

// "Choices" (safe placeholder; reads from ~system if present)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// "Processors" (safe placeholder; wire up when you point me to the API)
refreshProcessorsPane = {
    var s;
    // TODO: replace with your chain processor query (e.g., ~system.listProcessors() or similar)
    s = "Processors:\n(A) ‚Ä¶\n(B) ‚Ä¶\n(Provide the method to query each chain‚Äôs processor list and I‚Äôll wire it.)";
    processorsTextView.string = s;
};

// --- layout (titles added; meters between chains; System State 3√ó height) ---
computeAndApplyLayout = {
    var wb, contentW, contentH;
    var halfW, panelY, statusTitleY, statusBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleHeight;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        contentH = (wb.height - (paddingY * 2)).max(
            topRowHeight + rowGap +
            statusRowTitleHeight + statusRowBodyHeight + rowGap +
            bottomRowHeight
        );

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        // y anchors
        panelY       = paddingY;
        statusTitleY = panelY + topRowHeight + rowGap;
        statusBodyY  = statusTitleY + statusRowTitleHeight + 4;
        bottomY      = statusBodyY + statusRowBodyHeight + rowGap;

        // panels A/B
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // titles inside panels (top-left)
        titleHeight = 16;
        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleHeight);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleHeight);

        // meter strips BETWEEN chains (inside panels near center gap)
        meterY = panelY + 8 + titleHeight + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;

        meterAX = aX + aW - 8 - meterStripWidth;          // right edge of A panel
        meterBX = bX + 8;                                  // left edge of B panel

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State section
        systemStateTitleLabel.bounds = Rect(paddingX, statusTitleY, contentW, statusRowTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, statusBodyY, contentW, statusRowBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6); // yellow

        // Bottom panes: Choices (L) and Processors (R)
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates at ~5 Hz for text panes
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshProcessorsPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + statusRowTitleHeight + statusRowBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.2)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel   = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel= makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView  = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd
// v0.5.3
// MD 2025-09-25 18:45 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: "Chain A" (left) and "Chain B" (right). ACTIVE chain highlighted (soft green).
  ‚Ä¢ Vertical meters BETWEEN the chains (right of A, left of B).
- Second row: "System State" title + triple-height yellow panel with "system ready".
- Bottom-left: "Choices" (title + text).
- Bottom-right: "Processors" (title + text placeholder‚Äîwire once you provide API).
- Non-intrusive: reads /md/levels A=2001 B=2002; if A/B quiet, mirrors test=1001 to keep visuals moving.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC/Qt calls only. Final expression returns -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;

// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;

// system row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;

// identity banner
var identityBanner;

// === console identity (var-first ensured) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

fallbackThreshold = 0.003;  // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0;              // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight      = 140;  // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight  = 78;   // ~triple height
bottomRowHeight   = 180;  // Choices + Processors

minPanelTextWidth = 220;
meterStripWidth   = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView; panelView.background = Color(0.86, 0.97, 0.86) };
setPanelNeutralColor = { arg panelView; panelView.background = Color(0.94, 0.94, 0.94) };

// --- data + UI refresh -------------------------------------------------------
/*readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    systemStateTextView.string = "system ready";
};*/

readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // Keep demo visual continuity: mirror test if A/B effectively zero but test alive.
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // ACTIVE tint based on displayed energy (robust when both Ndefs are "playing")
    sumAEnergy = (displayALevelLeft + displayALevelRight);
    sumBEnergy = (displayBLevelLeft + displayBLevelRight);
    epsilon    = 0.001;

    isAActive = (sumAEnergy > sumBEnergy + epsilon);
    isBActive = (sumBEnergy > sumAEnergy + epsilon);

    if(chainAPanel.notNil) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
    };
    if(chainBPanel.notNil) {
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // System State text + last /md/levels age (requires ~md_lastMsgStamp from bring-up)
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string = "system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)";
};


refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

refreshProcessorsPane = {
    var s;
    s = "Processors:\n(A) ‚Ä¶\n(B) ‚Ä¶\n(Provide the method to query each chain‚Äôs processor list; I‚Äôll wire it.)";
    processorsTextView.string = s;
};

// --- layout (GUARDED; never writes nil Rect) ---------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY       = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY      = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        titleH = 16;

        // Panels
        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleH);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleH);

        // Meters between panels
        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth;        // A: right edge
        meterBX = bX + 8;                                // B: left edge

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State
        systemStateTitleLabel.bounds = Rect(paddingX, systemTitleY, contentW, systemTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, systemBodyY, contentW, systemBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6);

        // Bottom row
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ---------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    // Do a first layout AFTER all views exist and the window has bounds.
    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    // Start the periodic step slightly AFTER initial layout to avoid any race.
    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;

            // Re-layout only if size changed AND layout initialized
            if(layoutInitialized) {
                w = windowRef.bounds.width; h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };

            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;

            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = {
    tickerFlag = nil;
};

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.3)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel     = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView       = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView    = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4 copy.scd.txt =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd
// v0.5.4
// MD 2025-09-25 19:15 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: "Chain A" (left) and "Chain B" (right). ACTIVE chain highlighted (soft green).
  ‚Ä¢ Vertical meters BETWEEN the chains (right of A, left of B).
- Second row: "System State" title + triple-height yellow panel with "system ready" + last /md/levels age.
- Bottom-left: "Choices" (title + text).
- Bottom-right: "Processors" (title + text via user hook ~md_cmdTextProvider).
- Non-intrusive: reads /md/levels A=2001 B=2002; if A/B quiet, mirrors test=1001 to keep visuals moving.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC/Qt calls only. Final expression returns -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;

// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;

// system row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;

// identity banner
var identityBanner;

// === console identity (var-first ensured) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

fallbackThreshold = 0.003;  // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0;              // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight      = 140;  // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight  = 78;   // ~triple height
bottomRowHeight   = 180;  // Choices + Processors

minPanelTextWidth = 220;
meterStripWidth   = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background_(Color(0.86, 0.97, 0.86));
};

setPanelNeutralColor = { arg panelView;
    panelView.background_(Color(0.94, 0.94, 0.94));
};

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    // Safe fetch helper: returns [0.0, 0.0] unless we have a proper 2-element number array
    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
            .if({ arr }, { [0.0, 0.0] })
    };

    // Ensure levelsDict is a dictionary
    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    // Pull raw pairs safely
    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    // Assign channel values
    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    // Demo-safe fallback: mirror test if A/B effectively zero but test alive
    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // Defensive numeric coercion for energy sums
    sumAEnergy = (
        (displayALevelLeft.isNumber  .if({ displayALevelLeft  }, { 0.0 })) +
        (displayALevelRight.isNumber .if({ displayALevelRight }, { 0.0 }))
    );
    sumBEnergy = (
        (displayBLevelLeft.isNumber  .if({ displayBLevelLeft  }, { 0.0 })) +
        (displayBLevelRight.isNumber .if({ displayBLevelRight }, { 0.0 }))
    );

    epsilon = 0.001;

    // ACTIVE tint (only one side green unless equal within epsilon)
    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
    };
    if(chainBPanel.notNil) {
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // System State with last /md/levels age (requires ~md_lastMsgStamp from bring-up)
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

// "Choices" (safe pull from ~system if present)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

// "Processors" (malleable via user hook ~md_cmdTextProvider)
refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });

    if(providerFunc.notNil) {
        s = providerFunc.value;
    } {
        s = "Processors / Queue:\n"
          ++ "(no provider)\n"
          ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
          ++ "Example (temporary):\n"
          ++ "~md_cmdTextProvider = {\n"
          ++ "  var cm, next;\n"
          ++ "  cm = (~system.tryPerform(\\commandManager));\n"
          ++ "  next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
          ++ "      .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
          ++ "  \"Next: \" ++ next.asString\n"
          ++ "};";
    };

    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ---------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY       = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY      = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        titleH = 16;

        // Panels
        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));

        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        // Meters between panels
        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth;        // A: right edge
        meterBX = bX + 8;                                // B: left edge

        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        // System State
        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));
        systemStateTextView.background_(Color(1.0, 0.95, 0.6));

        // Bottom row
        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));

        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ---------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    // Do a first layout AFTER all views exist and the window has bounds.
    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    // Start the periodic step slightly AFTER initial layout to avoid any race.
    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;

            // Re-layout only if size changed AND layout initialized
            if(layoutInitialized) {
                w = windowRef.bounds.width; h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };

            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;

            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = {
    tickerFlag = nil;
};

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
systemStateTextView.background_(Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel     = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView       = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
choicesTextView.background_(Color(0.97,0.97,0.97));

processorsTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView    = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
processorsTextView.background_(Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd  / v0.5.4-p1 (safe background) / MD 2025-09-28
//
// Purpose
// - Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
// - Same layout and features as v0.5.4, but with SAFE deferred background color
//   assignment for TextView widgets to avoid 'base_' on nil during early layout.
//
// Style
// - var-first in every block/closure; AppClock-only; no server.sync; known-good SC/Qt calls.
// - Final expression returns -> a Window.

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;
// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;
// system row views
var systemStateTitleLabel, systemStateTextView;
// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;
// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;
var safeSetBackground; // NEW: safe, deferred TextView background setter
// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;
// identity banner
var identityBanner;

// === console identity =========================================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ----------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003; // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0; // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap = 8;
columnGap= 12;
topRowHeight = 140;       // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight = 78;    // ~triple height
bottomRowHeight = 180;    // Choices + Processors
minPanelTextWidth = 220;
meterStripWidth = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0; testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;
isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ----------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

// NEW: safe, deferred setter for TextView backgrounds (prevents 'base_' on nil)
safeSetBackground = { |view, color, delay=0.03|
    AppClock.sched(delay, {
        if(view.notNil and: { view.isClosed.not }) {
            view.background_(color);
        };
        nil
    });
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersA.value(uv) };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersB.value(uv) };
    v
};

setPanelActiveColor  = { arg panelView;  panelView.background_(Color(0.86, 0.97, 0.86)) };
setPanelNeutralColor = { arg panelView;  panelView.background_(Color(0.94, 0.94, 0.94)) };

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
        .if({ arr }, { [0.0, 0.0] })
    };

    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    chainALevelLeft = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft   = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    }{
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    sumAEnergy = ((displayALevelLeft.isNumber.if({ displayALevelLeft }, { 0.0 })) +
                  (displayALevelRight.isNumber.if({ displayALevelRight }, { 0.0 })));
    sumBEnergy = ((displayBLevelLeft.isNumber.if({ displayBLevelLeft }, { 0.0 })) +
                  (displayBLevelRight.isNumber.if({ displayBLevelRight }, { 0.0 })));
    epsilon = 0.001;

    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // System State with last /md/levels age
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    }{
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        }{
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });
    if(providerFunc.notNil) {
        s = providerFunc.value;
    }{
        s = "Processors / Queue:\n"
        ++ "(no provider)\n"
        ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
        ++ "Example (temporary):\n"
        ++ "~md_cmdTextProvider = {\n"
        ++ " var cm, next;\n"
        ++ " cm = (~system.tryPerform(\\commandManager));\n"
        ++ " next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
        ++ " .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
        ++ " \"Next: \" ++ next.asString\n"
        ++ "};";
    };
    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ----------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    }{
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW    = (((contentW - columnGap) / 2)).max(minPanelTextWidth + meterStripWidth + 16);
        panelY = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX; aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;
        titleH = 16;

        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));
        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth; // A: right edge
        meterBX = bX + 8; // B: left edge
        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));

        // SAFE: defer TextView background (prevents 'base_' on nil)
        safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));

        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));
        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ----------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;
            if(layoutInitialized) {
                w = windowRef.bounds.width;  h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };
            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;
            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ----------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Initial size (fits on first open)
windowRect = Rect(
  70, 70,
  paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
  paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// Resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
// SAFE: defer initial background too
safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel   = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
safeSetBackground.(choicesTextView,    Color(0.97,0.97,0.97));

processorsTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView   = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
safeSetBackground.(processorsTextView, Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.2.scd =====
// MagicDisplayGUI_New_Window_v0.3.2.scd
// v0.3.2
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call ~md_startTestSource / ~md_stopTestSource.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.5.scd =====
// MagicDisplayGUI_New_Window_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call robust API (~md_startTestSource / ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.5)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;  // auto-heals routing if server rebooted
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_QuickPeek_Levels.scd =====
// MagicDisplayGUI_NewPath_QuickPeek_Levels.scd
// v0.1.0
// MD timestamp: 2025-09-25

/* Purpose
   - Print ~levels a few times to verify updates.
   - No top-level 'var'; local vars are inside the Routine function.

   Style
   - var-first inside the Routine; no non-local returns (^).
*/

~md_levelsPeek = Routine({
    var i;
    i = 0;
    12.do {
        ("~levels now: " ++ ~levels.asString).postln;
        0.25.wait;
    };
}).play(AppClock);

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd =====
// MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd
// v0.2.2
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall the /reply receiver for level updates with explicit recvPort.
   - Keep updating ~levels and record a heartbeat time (~md_lastLevelAt) for GUI status.
   - Non-invasive: does not touch groups/synths/busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; known-good SC syntax.
*/

(
var reinstallReceiver;

reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var tag, count, i, outArray;

            tag = msg[2];
            count = 0;
            i = 0;
            outArray = nil;

            if (tag == "/md/levels") {
                count = msg.size - 3;
                outArray = Array.newClear(count);
                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };
                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/reply',
        recvPort: NetAddr.langPort  // explicit
    );

    true;
};

"Reinstalling /reply receiver...".postln;
reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd =====
// MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd
// v0.2.4
// MD timestamp: 2025-09-25

/* Purpose
   - Bind OSC receiver to '/md/levels' (matches SendReply in the probe SynthDef).
   - Parse values at indices 3..end and update ~levels and ~md_lastLevelAt.
   - No top-level 'var' declarations to avoid parse errors.

   Style
   - var-first inside function bodies; no non-local returns (^).
   - descriptive lowercase variable names; known-good SC syntax.
*/

(
// remove any previous receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = Main.elapsedTime;

// Expected message from SendReply:
// [ '/md/levels', nodeID, replyID, val1, val2, ... ]
OSCdef(
    \md_levels,
    { |msg, time, addr, recvPort|
        var nodeId, replyId, count, i, outArray;

        nodeId = 0;
        replyId = 0;
        count = 0;
        i = 0;
        outArray = nil;

        if (msg.size >= 3) {
            nodeId = msg[1].asInteger;
            replyId = msg[2].asInteger;

            count = msg.size - 3;
            outArray = Array.newClear(count);

            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };

            ~levels = outArray;
            ~md_lastLevelAt = Main.elapsedTime;
        };
    },
    '/md/levels',
    recvPort: NetAddr.langPort
);
"Patch C installed: listening on /md/levels".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd =====
// MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd
// v0.2.1
// MD timestamp: 2025-09-25
/* Purpose
   - Cleanly (re)initialize the audio server tree, build a generated-only test signal path,
     and install a level probe that reports channel levels via /reply.
   - Publish public tilde helpers (~md_startTestSource, ~md_stopTestSource, ~md_cleanup) for GUI use.
   - Use compile-time channel counts (2ch) in SynthDefs.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; no server.sync; server ops wrapped in s.bind where relevant.
   - generated audio only; probe reads a private bus.
*/

(
var prepareServerAndDefs, setupRouting, installOscReceiver, definePublicAPI, startStartupSequence;

prepareServerAndDefs = {
    var ok;
    ok = true;

    s.waitForBoot({
        var def_testSource, def_toHardware2, def_levelProbe2;

        s.initTree;
        s.defaultGroup.freeAll;

        ~levels = [0.0, 0.0];

        // Test source: stereo beeps
        def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.20|
            var trig, freqSeq, sig, env, stereo;
            trig = Impulse.kr(2);
            freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
            env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
            sig = SinOsc.ar(freqSeq) * env;
            stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
            Out.ar(outBus, stereo * amp);
        }).add;

        // Relay to hardware (fixed 2ch)
        def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
            var sig;
            sig = In.ar(inBus, 2);
            Out.ar(0, sig);
        }).add;

        // Level probe (fixed 2ch) ‚Üí /reply
        def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, sendID = 1001|
            var sig, amps, ticker;
            sig = In.ar(inBus, 2);
            amps = Amplitude.kr(sig, 0.01, 0.30);
            ticker = Impulse.kr(20);
            SendReply.kr(ticker, "/md/levels", amps, sendID);
        }).add;
    });

    ok;
};

setupRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        ~md_mixBus = Bus.audio(s, 2);

        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \sendID, 1001]);

        ~md_testSynth = nil;
    });

    ok;
};

installOscReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];

    OSCdef(\md_levels, { |msg, time, addr, recvPort|
        var tag, count, i, outArray;

        tag = msg[2];
        count = 0;
        i = 0;
        outArray = nil;

        if (tag == "/md/levels") {
            count = msg.size - 3;
            outArray = Array.newClear(count);
            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };
            ~levels = outArray;
        };
    }, '/reply');

    true;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_startTestSource = {
        var ok2;
        ok2 = true;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.20]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        if (~md_probe.notNil) {
            ~md_probe.free;
            ~md_probe = nil;
        };

        if (~md_toHardware.notNil) {
            ~md_toHardware.free;
            ~md_toHardware = nil;
        };

        if (~md_outGroup.notNil) {
            ~md_outGroup.free;
            ~md_outGroup = nil;
        };
        if (~md_meterGroup.notNil) {
            ~md_meterGroup.free;
            ~md_meterGroup = nil;
        };
        if (~md_srcGroup.notNil) {
            ~md_srcGroup.free;
            ~md_srcGroup = nil;
        };

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        s.defaultGroup.freeAll;

        ok2;
    };

    ok;
};

startStartupSequence = {
    var ok;

    ok = true;

    "Step 1: preparing server + defs...".postln;
    prepareServerAndDefs.value;

    "Step 1: setting up routing (bus, groups, probe)...".postln;
    setupRouting.value;

    "Step 1: installing OSC receiver...".postln;
    installOscReceiver.value;

    // ‚úÖ Publish the API so Step 2 can call it
    "Step 1: defining public API...".postln;
    definePublicAPI.value;

    "Step 1: ready. Use ~md_startTestSource.value to begin audio.".postln;

    ok;
};

// ---------- run ----------
startStartupSequence.value;

// Tips:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd =====
// MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd
// v0.2.3
// MD timestamp: 2025-09-25

/* Purpose
   - Add a status label showing seconds since last level message ('rx age').
   - Helps confirm receiver is live.

   Style
   - var-first inside function bodies; no non-local returns (^).
*/

(
if (~mdGui_window.notNil) {
    var content, statusLabel;

    content = ~mdGui_window.view;

    statusLabel = StaticText(content, Rect(200, 120, 180, 18));
    statusLabel.string = "rx age: ‚Äî";
    statusLabel.stringColor = Color.gray(0.85);
    statusLabel.background = Color.clear;
    statusLabel.align = \left;

    ~mdGui_status = statusLabel;

    // start an AppClock updater (store it so we can stop later)
    ~mdGui_statusTicker = Routine({
        var running, age, lastAt;

        running = true;
        while { running } {
            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_status.notNil) {
                ~mdGui_status.string = "rx age: " ++ age.asString ++ " s";
            };

            0.2.yield;
            running = (~mdGui_window.notNil);
        };
    }).play(AppClock);

    "Status label installed.".postln;
} {
    "Open the MagicDisplayGUI window first, then run this patch.".postln;
};
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd =====
// MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd
// v0.2.0
// MD timestamp: 2025-09-25
/* Purpose
   - Build a robust single-window GUI that follows the window patterns you used in MagicPedalboard-WindowDisplayExamples:
     * one window whose name starts with "MagicDisplayGUI"
     * no FlowLayout
     * AppClock-only refresh loop
     * LevelIndicators for meters
   - Buttons call the public Step 1 tilde helpers (~md_startTestSource, ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; LevelIndicator values in [0..1].
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString, levelLeft, levelRight, labelLeft, labelRight, labelTitle, buttonRowY, startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Path (Step 2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // title
    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    // level bars
    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    // db readouts
    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    // control buttons (call Step 1 helpers if present)
    buttonRowY = 44;

    startButton = Button(content, Rect(200, buttonRowY, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, buttonRowY + 36, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    // store references for the ticker
    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30; // ~30 Hz

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) {
                ~mdGui_levelLeft.value = leftVal;
            };
            if (~mdGui_levelRight.notNil) {
                ~mdGui_levelRight.value = rightVal;
            };
            if (~mdGui_labelLeft.notNil) {
                ~mdGui_labelLeft.string = leftDb;
            };
            if (~mdGui_labelRight.notNil) {
                ~mdGui_labelRight.string = rightDb;
            };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) {
        ~mdGui_window.close;
        ~mdGui_window = nil;
    };
    ok;
};

// ---------- run ----------
mdGuiOpen.value;

// Later: mdGuiClose.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd =====
// MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Trace /md/levels briefly and then print active replyIDs with current values.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^).
*/

(
var postStatus;

"=== RUN MagicDisplayGUI_OSC_TraceAndReport_v0.3.11 ===".postln;

postStatus = {
    var keys, msg;
    keys = if (~md_levelsById.notNil) { ~md_levelsById.keys.asArray.sort } { [] };
    msg = "Active replyIDs: " ++ keys.asString;
    msg.postln;
    if (~md_levelsById.notNil) {
        if (~md_levelsById[2001].notNil) { ("A (2001): " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B (2002): " ++ ~md_levelsById[2002].asString).postln; };
        if (~md_levelsById[1001].notNil) { ("Test (1001): " ++ ~md_levelsById[1001].asString).postln; };
    };
};

OSCFunc.trace(true);
AppClock.sched(1.0, {
    var ok;
    ok = true;
    OSCFunc.trace(false);
    postStatus.value;
    ok;
});
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd =====
// MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Replace ~md_ensureRouting with a NON-DESTRUCTIVE version:
     * does NOT call s.defaultGroup.freeAll
     * only creates/repairs OUR groups/bus/probes if missing or not playing
   - Keeps your Ndefs and any other nodes intact.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var safeEnsure;

("MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd").postln;

safeEnsure = {
    var ok, needBus, needGroups, needRelay, needProbe, defaultGroup;

    ok = true;

    if (s.serverRunning.not) {
        s.boot;
        s.waitForBoot({
            var ok2;
            ok2 = true;
            s.initTree;
            ok2;
        });
    };

    defaultGroup = s.defaultGroup;

    // bus
    needBus = (~md_mixBus.isNil);

    // groups
    needGroups = (
        ~md_srcGroup.isNil or: { ~md_meterGroup.isNil } or: { ~md_outGroup.isNil } or: {
            (~md_srcGroup.notNil and: { ~md_srcGroup.isPlaying.not })
            or: (~md_meterGroup.notNil and: { ~md_meterGroup.isPlaying.not })
            or: (~md_outGroup.notNil and: { ~md_outGroup.isPlaying.not })
        }
    );

    // relay + default probe
    needRelay = (~md_toHardware.isNil or: { ~md_toHardware.isPlaying.not });
    needProbe = (~md_probe.isNil or: { ~md_probe.isPlaying.not });

    s.bind({
        // bus
        if (needBus) {
            if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };
            ~md_mixBus = Bus.audio(s, 2);
        };

        // groups in strict order
        if (needGroups) {
            if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
            if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
            if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

            ~md_srcGroup = Group.head(defaultGroup);
            ~md_meterGroup = Group.after(~md_srcGroup);
            ~md_outGroup = Group.after(~md_meterGroup);

            // force re-create relay/probe after new groups
            needRelay = true;
            needProbe = true;
        };

        if (needRelay) {
            if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };
            ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        };

        if (needProbe) {
            if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
            ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);
        };
    });

    ok;
};

// replace the old ensure with the safe one
~md_ensureRouting = {
    var ok;
    ok = true;
    safeEnsure.value;
    ok;
};

"Patched ~md_ensureRouting to be non-destructive.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd =====
// MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd
// v0.3.12
// MD timestamp: 2025-09-25

/* Purpose
   - Install .filter meters *inside* Ndef(\chainA) and Ndef(\chainB):
       * compute Amplitude.kr on the proxy signal
       * SendReply.kr directly to '/md/levels' with replyIDs 2001/2002
       * return the input signal unchanged (no audio change)
   - Neutralize any previous tap filters (bus mirroring) by overwriting them to identity.
   - Free any old external probe synths/busses used for taps; they are no longer needed.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables; known-good SC syntax.
*/

(
var hasA, hasB, attackTime, releaseTime, updateRateHz,
    installMeterFor, neutralizeTap, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_FilterMeters_v0.3.12 ===".postln;

hasA = (Ndef(\chainA).notNil);
hasB = (Ndef(\chainB).notNil);

attackTime = 0.01;
releaseTime = 0.30;
updateRateHz = 20;

// overwrite old bus-mirror taps to identity (safe if they don't exist)
neutralizeTap = { |name, key|
    var proxy, canFilter;
    proxy = Ndef(name);
    canFilter = false;
    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|  // identity pass-through
                var outSig;
                outSig = inputSig;
                outSig
            });
        };
    };
};

// install the actual meter filter (no bus, direct SendReply)
installMeterFor = { |name, replyID, key|
    var proxy, canFilter, ok;
    proxy = Ndef(name);
    canFilter = false;
    ok = true;

    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|
                var amps, ticker, outSig;
                amps = Amplitude.kr(inputSig, attackTime, releaseTime);
                ticker = Impulse.kr(updateRateHz);
                SendReply.kr(ticker, "/md/levels", amps, replyID);
                outSig = inputSig; // no audio change
                outSig
            });
            (("Installed meter on " ++ name.asString) ++ " (replyID " ++ replyID.asString ++ ").").postln;
        } {
            (name.asString ++ ": .filter not supported; skipped.").postln;
        };
    } {
        (name.asString ++ " not found; skipped.").postln;
    };

    ok;
};

// neutralize any prior tap keys used before (safe no-ops if absent)
neutralizeTap.value(\chainA, \mdProbeTapA);
neutralizeTap.value(\chainB, \mdProbeTapB);

// install in-proxy meters (distinct keys so they are idempotent)
if (hasA) { installMeterFor.value(\chainA, 2001, \mdMeterA); };
if (hasB) { installMeterFor.value(\chainB, 2002, \mdMeterB); };

// free old external probe synths/busses (from the tap approach)
freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

freeIfPlaying.value(~md_probeA);  ~md_probeA = nil;
freeIfPlaying.value(~md_probeB);  ~md_probeB = nil;

if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

"Installed in-proxy meters; removed external probes/tap busses.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.10.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Make A/B meters move reliably by reinstating .filter taps on Ndef(\chainA/\chainB).
   - Mirror audio to private stereo busses, then attach A(2001)/B(2002) probes to those busses.
   - Non-destructive: does not modify chain sound; taps return 'in'.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, haveA, haveB, tapBusA, tapBusB;

("MagicDisplayGUI_Reenable_Taps_v0.3.10.scd").postln;

ok = true;
haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

// (re)allocate private tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// install/overwrite taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes to tap busses (free stale ones first)
s.bind({
    if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
    if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
    };
});

("A probe -> inBus " ++ tapBusA.asString).postln;
("B probe -> inBus " ++ tapBusB.asString).postln;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.11.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall .filter taps on Ndef(\chainA/\chainB) to mirror audio to private 2ch busses.
   - Attach probes A(2001) and B(2002) to those busses.
   - Quiet stale frees; print nodeIDs of created probes.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables.
*/

(
var haveA, haveB, tapBusA, tapBusB, newProbeA, newProbeB, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_Taps_v0.3.11 ===".postln;

haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

// fresh tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// (re)install taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes (free stale ones only if playing)
s.bind({
    freeIfPlaying.value(~md_probeA);
    ~md_probeA = nil;

    freeIfPlaying.value(~md_probeB);
    ~md_probeB = nil;

    newProbeA = nil;
    newProbeB = nil;

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
        newProbeA = ~md_probeA;
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
        newProbeB = ~md_probeB;
    };
});

if (newProbeA.notNil) { ("A probe nodeID: " ++ newProbeA.nodeID.asString).postln; } { "A probe not created.".postln; };
if (newProbeB.notNil) { ("B probe nodeID: " ++ newProbeB.nodeID.asString).postln; } { "B probe not created.".postln; };

"Re-enable taps: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_ResetReceiver_v0.3.11.scd =====
// MagicDisplayGUI_ResetReceiver_v0.3.11.scd
// v0.3.11
// MD 2025-09-25 15:10 BST

/*
Purpose
- Reinstall the /md/levels receiver on NetAddr.langPort (idempotent).
- Posts identity banner so logs show exact order of actions.
Style
- var-first; no server.sync; returns -> true.
*/

(
// === RUN ===
var ok, dict;
dict = (~md_levelsById ? IdentityDictionary.new);
~md_levelsById = dict;
ok = ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } ? false;
("Receiver reset: " ++ ok).postln;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd
// v0.3.8
// MD timestamp: 2025-09-25
/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if playing).
   - Attach A (replyID 2001) and B (replyID 2002) probes directly to those busses.
   - Remove previously-installed .filter taps and free their private busses (if present).
   - Non-invasive: does not change your chain sound.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var detectBusIndex, aIdx, bIdx, ok, hadBringUp;

ok = true;
hadBringUp = (~md_attachProbesAB.notNil);

if (hadBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid if the proxy has produced output (ideally playing)
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // attach probes directly to A/B buses (even if one is -1, the helper skips it)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // remove taps if they exist (safe if none present)
    if (Ndef(\chainA).notNil) { Ndef(\chainA).removeFilter(\mdProbeTapA); };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).removeFilter(\mdProbeTapB); };

    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps removed (if present).".postln;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd
// v0.3.9
// MD timestamp: 2025-09-25

/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if present).
   - Ensure routing (bus/groups) exists even after a server reboot.
   - Attach A (2001) and B (2002) probes directly to those busses.
   - Neutralize any prior .filter taps (identity pass-through) and free their private busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, haveBringUp, detectBusIndex, aIdx, bIdx, neutralizeTap;

ok = true;
haveBringUp = (~md_attachProbesAB.notNil);

if (haveBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure routing exists (rebuilds groups/bus/probe if server rebooted)
    ~md_ensureRouting.value;

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus;   // valid when the proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    neutralizeTap = { |name, key|
        var proxy, canFilter;
        proxy = Ndef(name);
        canFilter = false;
        if (proxy.notNil) {
            canFilter = proxy.respondsTo(\filter);
            if (canFilter) {
                // Overwrite any existing tap with identity to stop extra Out.ar
                proxy.filter(key, { |in| in });
            };
        };
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // Attach probes directly (skips -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // Neutralize taps (works in all versions; no removeFilter needed)
    neutralizeTap.value(\chainA, \mdProbeTapA);
    neutralizeTap.value(\chainB, \mdProbeTapB);

    // Free the private tap busses if they exist
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps neutralized and tap busses freed.".postln;
};

ok;
)

===== MagicPedalboard/utils_mpb_force_reconnect.scd =====
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)

===== MagicPedalboard/WindowDisplayExamples/examplesSlidersButtons.scd =====
// examplesSlidersButtons.scd
// taken from Eli Fieldsteel book examples for chatper 8.

(
Window("Layout Management", Rect(100, 100, 250, 500)).front
.layout_(
	VLayout(
		HLayout(Knob(), Knob(), Knob(), Knob()),
		HLayout(Slider(), Slider(), Slider(), Slider()),
		Slider2D(),
		Button()
	)
);
)
===== MagicPedalboard/WindowDisplayExamples/SC_GUI_Meters_Summary_v1_0.sc =====
/*
SuperCollider GUI + Meters: Working Pattern & Pitfalls
v1.0
MD 2025-09-25 10:27

============================================================

‚úÖ WHAT MAKES THIS WORK

1) Separate GUI from Audio Boot
   - Build the window and layout first so something is visible immediately.
   - Use s.waitForBoot Ellipsis or a Routine for audio bring‚Äëup; never block the AppClock.
   - Avoid server.sync in GUI paths to prevent freezes and blank windows.

2) Use Layout Managers for Predictability
   - Prefer GridLayout or VLayout/HLayout so panes resize reliably.
   - Avoid manual Rect math unless you need pixel‚Äëperfect control.

3) Draw Borders with UserView.drawFunc
   - CompositeView does not implement drawFunc_.
   - Create a UserView inside the pane to draw colored borders/fills.

4) Var‚Äëfirst and Descriptive Names
   - Declare all locals at the top of every block (functions, drawFunc, actions).
   - No single‚Äëletter variables; use paneView, meterColumnView, amplitudeBusA, etc.
   - This prevents parser errors like ‚Äúunexpected VAR‚Äù.

5) Atomic Server Operations
   - If you rewire NodeProxies, wrap changes in Server.default.bind Ellipsis.
   - Keep GUI responsive by avoiding synchronous waits.

6) Smooth, Click‚Äëfree Level Changes
   - Apply Lag.kr to amplitude controls before multiplying the audio signal.
   - Update LevelIndicator values on AppClock and defer GUI writes with Ellipsis.defer.

7) Clean Meter Updates
   - Use control buses for metering (Out.kr), and read them with .get on AppClock.
   - Always .defer updates to the actual GUI widgets.

8) Deterministic Cleanup
   - In window.onClose_, stop routines, free buses, and stop+clear Ndefs.
   - Also close any previous MagicDisplayGUI windows on start.

------------------------------------------------------------

‚ö†Ô∏è COMMON PITFALLS

‚Ä¢ drawFunc_ on CompositeView has no effect ‚Üí use UserView.
‚Ä¢ Multiple assignment to array elements (e.g., #array[i], ‚Ä¶ = ...) is invalid ‚Üí assign to locals first, then store.
‚Ä¢ server.sync in GUI code blocks the AppClock ‚Üí freezes or blank windows.
‚Ä¢ Non‚Äëvar‚Äëfirst blocks ‚Üí ‚Äúunexpected VAR, expecting ‚Ä¶‚Äù parse errors.
‚Ä¢ Updating widgets directly from audio/server callbacks ‚Üí must .defer GUI writes.
‚Ä¢ Leaving old Ndefs and buses running ‚Üí audio chaos and resource leaks on re‚Äërun.
‚Ä¢ Hard‚Äëcoded sizes on HiDPI/Sidecar ‚Üí panes appear tiny; layouts fix scaling.

------------------------------------------------------------

üîç EASY‚ÄëTO‚ÄëOVERLOOK DETAILS

‚Ä¢ Close prior MagicDisplayGUI windows before building a new one.
‚Ä¢ Free control buses used for meters in onClose_.
‚Ä¢ Convert dB ‚Üí linear with .dbamp and clamp to [0, 1] for LevelIndicator.
‚Ä¢ Give LevelIndicator a minSize_ (e.g., Size(20, 180)) so layouts don‚Äôt collapse it.
‚Ä¢ Add small spacers (UserView().minWidth_/minHeight_) in H/V layouts for readable gaps.
‚Ä¢ If GUI must appear even when audio fails, build the window first, then boot server.

------------------------------------------------------------

‚û°Ô∏è UPGRADE PATH / NEXT STEPS

1) Keep the proven GUI skeleton (GridLayout or V/HLayout) and slot in top‚Äërow meters.
2) Add one audible Ndef test source; meter its amplitude via a control bus.
3) Layer routing gradually:
   - one source ‚Üí one effect ‚Üí one sink;
   - then two sinks with A/B selection (use Lag/XFade2 to avoid clicks);
   - finally expand to 3 sources, 3 effects, 2 sinks, preserving the GUI contract.
4) Only after routing is stable, attach real meters to each chain point as needed.

------------------------------------------------------------

CHEAT SHEET (DO / AVOID)

DO
- window first; audio later (non‚Äëblocking).
- UserView.drawFunc for borders and custom visuals.
- var‚Äëfirst, descriptive names everywhere.
- AppClock for GUI updates, with .defer inside callbacks.
- Lag.kr for level changes; XFade2 + Lag for A/B.
- onClose_: stop routines, free buses, clear Ndefs.

AVOID
- server.sync in any GUI path.
- drawFunc_ on CompositeView.
- Multiple assignment to array elements.
- Single‚Äëletter variable names; hidden locals mid‚Äëblock.
- Direct GUI writes from non‚ÄëGUI threads.

============================================================
*/
===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes in GridLayout (3x2); top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, p;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

p = Array.newClear(6);

// ---------- factories ----------
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView();
    textColumn.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    pane
};

// ---------- build six panes (index 0 gets the meter) ----------
p[0] = makePaneWithMeter.(paneTitles[0], paneColors[0]); // top-left with meter
p[1] = makePane.(paneTitles[1], paneColors[1]);
p[2] = makePane.(paneTitles[2], paneColors[2]);
p[3] = makePane.(paneTitles[3], paneColors[3]);
p[4] = makePane.(paneTitles[4], paneColors[4]);
p[5] = makePane.(paneTitles[5], paneColors[5]);

// ---------- install grid 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with GridLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, paneArray;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build six panes ----------
paneArray = Array.newClear(6);
paneArray[0] = makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A); // top-left with meter A
paneArray[1] = makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B); // top-right with meter B
paneArray[2] = makeTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = makeTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = makeTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = makeTextPane.(paneTitles[5], paneBorderColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with two meters in the top row.
// - Meter A (top-left) is real (Ndef test source -> control bus); Meter B (top-right) is simulated.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterRoutine, serverBootRoutine;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI Grid + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build 3x2 grid: top row has meters ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"); // top-left real
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B"); // top-right simulated
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with 2 meters in the top row.
// - Audible test source (Ndef) plays; its amplitude steps in 10 dB increments every second.
// - Meters A and B both follow the same stepped level.
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0];
stepIntervalSeconds = 1.0;

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- assemble grid (top row has meters) ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A");
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B");
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- AUDIO bring-up (audible Ndef + stepped amplitude) ----------
serverBringUpRoutine = Routine({
    s.waitForBoot({
        var defaultNumChannels, leftFrequency, rightFrequency;
        defaultNumChannels = 2;
        s.initTree; s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\stepToneA, {
            var stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20, 20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30, 30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // smooth the steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            monoSignal    = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP meters + audible amplitude ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);

        { if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
          if(meterViewB.notNil, { meterViewB.value_(currentLinear) }); }.defer;

        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters.scd
// v0.3.1
// MD 2025-09-25 14:20
//
// Purpose / Style:
// - GUI-only: 6 panes in a GridLayout (3x2).
// - Top-left and top-right contain simulated meters (no audio).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makeTextPane, makeMeterPane, p;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

// returns [pane, meterView]
makeMeterPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    [pane, meterView]
};

// ---------- build six panes ----------
p = Array.newClear(6);
var pane, m;

#pane, m = makeMeterPane.(paneTitles[0], paneColors[0]); p[0] = pane; meterViewA = m; // top-left
#pane, m = makeMeterPane.(paneTitles[1], paneColors[1]); p[1] = pane; meterViewB = m; // top-right
p[2] = makeTextPane.(paneTitles[2], paneColors[2]);
p[3] = makeTextPane.(paneTitles[3], paneColors[3]);
p[4] = makeTextPane.(paneTitles[4], paneColors[4]);
p[5] = makeTextPane.(paneTitles[5], paneColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valA) });
            if(meterViewB.notNil, { meterViewB.value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_Grid.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_Grid.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: six colored panes arranged with GridLayout (3 rows x 2 columns).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles, makePane;
var p = Array.newClear(6);

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes GridLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

// ---------- styles ----------
titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView().background_(paneFill).minSize_(Size(500, 230));
    border = UserView(pane).resize_(1).drawFunc_({ |v|
        var rect; rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11,0.11,0.12); Pen.strokeColor = borderColor; Pen.width = 2;
        Pen.fillRect(rect); Pen.strokeRect(rect);
    });
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    pane.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane
};

// ---------- build array of six panes ----------
6.do({ |i| p[i] = makePane.(paneTitles[i], paneColors[i]) });

// ---------- grid layout: 3 rows √ó 2 columns ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));

window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_VH.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_VH.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: draw 6 "pane" rectangles (colored borders) arranged with VLayout/HLayout.
// - No audio, no Ndefs, no server. Pure Qt layout.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, row1, row2, row3, rootLayout;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes VHLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill  = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

// six distinct colors and titles
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory: a container with colored border and two text lines ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView()  // no parent yet; layout will parent it
        .background_(paneFill)
        .minSize_(Size(500, 230)); // give layout something decent to work with

    border = UserView(pane)
        .resize_(1)
        .drawFunc_({ |v|
            var rect;
            rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
            Pen.fillColor = Color(0.11, 0.11, 0.12);
            Pen.strokeColor = borderColor;
            Pen.width = 2;
            Pen.fillRect(rect);
            Pen.strokeRect(rect);
        });

    titleText = StaticText()
        .string_(titleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyText = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    // inner stack inside each pane (title above body)
    pane.layout_(VLayout(
        // top margin shim
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        // bottom stretch
        nil
    ));

    pane
};

// ---------- build six panes ----------
row1 = HLayout(
    makePane.(paneTitles[0], paneColors[0]),
    UserView().minWidth_(cellPadding), // spacer
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout: 3 rows stacked, with vertical spacers ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding), // top margin
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)  // bottom margin
);

// install the layout on the window
window.layout_(rootLayout);
window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter on the right side
makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left uses the meter) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0]), // top-left with meter
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        // simple sine-driven value with a hint of noise, clipped to [0,1]
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, rowTop, rowMiddle, rowBottom, rootLayout;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B (decides which global meterView to write)
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A), // top-left
    UserView().minWidth_(cellPadding),
    makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B)  // top-right
);

rowMiddle = HLayout(
    makeTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    makeTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with two meters in the top row.
// - Meter A (top-left) shows a real level from a tiny Ndef test source.
// - Meter B (top-right) is simulated (sine + noise) to verify GUI update path.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterRoutine;           // GUI meter widgets + updater
var serverBootRoutine;                               // guard: keep GUI responsive
var amplitudeBusA;                                   // control bus for real meter A
var meterLabelFont;                                  // tiny label above meters

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VH + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    paneView.layout_(VLayout(
        UserView().minHeight_(6),
        textColumnView,
        nil
    ));

    paneView
};

// Pane with meter and label (labelTextString = "A" or "B")
// Returns: the pane view; assigns meterViewA/meterViewB internally
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    meterLabelView = StaticText()
        .string_(labelTextString)
        .font_(meterLabelFont)
        .stringColor_(Color.white)
        .align_(\center);

    localMeterView = LevelIndicator()
        .warning_(0.7)
        .critical_(0.95)
        .minSize_(Size(20, 180));

    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });

    meterColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(4),
        meterLabelView,
        UserView().minHeight_(4),
        localMeterView,
        nil
    ));

    paneView.layout_(HLayout(
        UserView().minWidth_(6),
        textColumnView,
        UserView().minWidth_(10),
        meterColumnView,
        UserView().minWidth_(6)
    ));

    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"), // top-left: meter A (real)
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")  // top-right: meter B (simulated)
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);

window.layout_(rootLayout);
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    // 1) Boot + minimal server prep
    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        // 2) Control bus for meter A
        amplitudeBusA = Bus.control(s, 1);

        // 3) Tiny test source -> real meter A (no OutputProxy indexing; no server.sync)
        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue;
            var meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);   // language sets this before/around play
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        // set meter bus, then play quietly to out
        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    // 4) Update both meters on AppClock (A from control bus, B simulated)
    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            // real meter A (read from control bus written by Ndef)
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            // simulated meter B (sine + noise)
            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with 2 meters in the top row.
// - Audible test source (Ndef) plays a soft stereo tone whose amplitude
//   steps through dB values once per second (default: [-60,-50,...,0] dB).
// - Meters A and B show the same stepped level (so you hear the same step).
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0]; // edit as you like
stepIntervalSeconds = 1.0;                                // 1 second per step

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Pane with labeled meter ("A" or "B"); assigns to meterViewA / meterViewB
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top has two meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"),
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- AUDIO bring-up (small audible Ndef + AMP stepping) ----------
serverBringUpRoutine = Routine({
    var defaultNumChannels;
    s.waitForBoot({
        defaultNumChannels = 2;
        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        // Test source with controlled amplitude (stepped)
        Ndef(\stepToneA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            // slow-moving, gentle timbre
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // prevent clicks on level steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            // drive a meter bus so GUI can also poll (optional)
            monoSignal   = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP both meters + audible level every 1s ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);     // e.g. -60 .. 0 dB
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);     // convert to 0..1

        // update meters
        {
            if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
            if(meterViewB.notNil, { meterViewB.value_(currentLinear) });
        }.defer;

        // update audible amplitude
        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters.scd
// v0.3.0
// MD 2025-09-25 14:08
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right contain simulated meters.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterViews, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// store two meter views [A, B]
meterViews = Array.newClear(2);

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter; meterIndex: 0 for top-left (A), 1 for top-right (B)
makePaneWithMeter = { |titleString, borderColor, meterIndex|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterViews.put(meterIndex, meterView);

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left & top-right use meters) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0], 0), // top-left meter A
    UserView().minWidth_(cellPadding),
    makePaneWithMeter.(paneTitles[1], paneColors[1], 1)  // top-right meter B
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single AppClock routine for both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 1.2; // offset so A and B differ
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViews[0].notNil, { meterViews[0].value_(valA) });
            if(meterViews[1].notNil, { meterViews[1].value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MDMiniLogger/MDMiniLogger.sc =====
// MDMiniLogger.sc
// v0.3.3
// MD 20250919-13:51

// access with MDMiniLogger.get (which creates the instance if there isn't one)
// verbosity levels: 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=TRACE

MDMiniLogger : Object {
	classvar < logger;
	classvar verbosityNames;
	var < verbosity;
	var < enabled;

	// 3.1 fix
	*initClass {
		verbosityNames = ["ERROR", "WARN", "INFO", "DEBUG", "TRACE"];
		logger = nil; // discard any stale instance after class library recompile
	}

	init {
		verbosity = 2;
		enabled = true;
	}
	*get {
		// return existing, otherwise create one
		^logger ?? { logger = MDMiniLogger.new };
	}

	shouldLog { |msgVerbosity|
		var messageLevel, thresholdLevel, isOn;

		messageLevel   = (msgVerbosity ? 0).clip(0, 4);  // if nil default to 0
		thresholdLevel = (verbosity ? 0).clip(0, 4);     // the logger's current threshold
		isOn = (enabled ? true);
		// Print when:
		//  - logging is enabled, AND
		//  - the message is at least as important as the threshold (lower number = more important)
/*		^(isOn and: { messageLevel <= thresholdLevel });*/

// fix 0.3.2
^((enabled == true) and: { messageLevel <= thresholdLevel });

	}

	setverbosity { |newverbosity| verbosity = (newverbosity ? 0).clip(0, 4); ^verbosity }

	enable  { enabled = true;  ^enabled }

	disable { enabled = false; ^enabled }

	format {|argVerbosity, argLabel, argMessage |
		var line, logVerbosity, logLabel, logMessage;

		// check we have a verbosity
		logVerbosity = (argVerbosity ? 0).clip(0,4); // 0 if nil

		// check we have a label
		logLabel = argLabel ? "GENERIC";

		// check we have a message:
		logMessage = argMessage ? "";

		line = "[" ++ Date.getDate.stamp
		++ " | " ++ verbosityNames.at(logVerbosity)
		++ " | " ++ logLabel ++ "] "
		++ logMessage;
		^line;
	}

	log { |msgVerbosity, label, message|
		if (this.shouldLog(msgVerbosity)) {
			this.format(msgVerbosity, label, message).postln;
		};
		^this
	}

	// helpers

	error { |label, message| ^this.log(0, label, message) }  // ERROR
	warn  { |label, message| ^this.log(1, label, message) }  // WARN
	info  { |label, message| ^this.log(2, label, message) }  // INFO
	debug { |label, message| ^this.log(3, label, message) }  // DEBUG
	trace { |label, message| ^this.log(4, label, message) }  // TRACE

}
===== MDMiniLogger/test_MDMiniLogger.scd =====
// test_MDMiniLogger.scd

m = MDMiniLogger.get;

m.setverbosity(0);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(1);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(2);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");


===== notes/LPDisplay Layout Test (Windo.textClipping =====
bplist00“[OSType-DataXUTI-Data—POhttps://m365.cloud.microsoft‘	
_public.utf16-plain-text[public.html_$com.apple.traditional-mac-plain-text_public.utf8-plain-textOpL P D i s p l a y   L a y o u t   T e s t   ( W i n d o w )                  ≤%                 %    ( p a n e s   +   m e t e r s   v i a   S e n d P e a k R M S ;   n o   P e r f H U D )                  % L i v e P e d a l b o a r d S y s t e m   ( h e a d l e s s   U I   t o d a y )      % %  b r i n g U p P e d a l b o a r d   í!  M a g i c P e d a l b o a r d N e w      % %  b r i n g U p C o m m a n d S y s t e m   í!  C o m m a n d M a n a g e r   +   C o m m a n d T r e e   +   M I D I      % %  i n s t a l l A d a p t e r B r i d g e   í!  r o u t e s   c a n o n i c a l   p a t h s   í!  M P B O¨<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"><pre node="[object Object]" style="border-radius: 4px; border-width: 1px; border-style: solid; border-color: rgb(209, 209, 209); padding: 23px 24px; margin: 17px 0px 23px; font-size: 15px; overflow-x: auto; white-space: pre-wrap; overflow-wrap: break-word; color: rgb(66, 66, 66); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(250, 250, 250); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;">LPDisplay Layout Test (Window)
        ‚ñ≤
        ‚îÇ  (panes + meters via SendPeakRMS; no PerfHUD)
        ‚îÇ
LivePedalboardSystem (headless UI today)
  ‚îú‚îÄ bringUpPedalboard ‚Üí MagicPedalboardNew
  ‚îú‚îÄ bringUpCommandSystem ‚Üí CommandManager + CommandTree + MIDI
  ‚îî‚îÄ installAdapterBridge ‚Üí routes canonical paths ‚Üí MPB</code></pre>O'LPDisplay Layout Test (Window)        o8 L P D i s p l a y   L a y o u t   T e s t   ( W i n d o w ) 
                %≤ 
                %     ( p a n e s   +   m e t e r s   v i a   S e n d P e a k R M S ;   n o   P e r f H U D ) 
                % 
 L i v e P e d a l b o a r d S y s t e m   ( h e a d l e s s   U I   t o d a y ) 
    %%    b r i n g U p P e d a l b o a r d  !í   M a g i c P e d a l b o a r d N e w 
    %%    b r i n g U p C o m m a n d S y s t e m  !í   C o m m a n d M a n a g e r   +   C o m m a n d T r e e   +   M I D I 
    %%    i n s t a l l A d a p t e r B r i d g e  !í   r o u t e s   c a n o n i c a l   p a t h s  !í   M P B    " % & E N h t õ ¥(ÿ                           
v
===== README.md =====
# LivePedalboardSuite

## Overview

LivePedalboardSuite is a modular, scriptable, and extensible live audio processing environment for SuperCollider. It is designed for rapid prototyping, testing, and demonstration of pedalboard-style audio effect chains, with or without hardware integration.

---

## Project Structure

- **Scripts/** ‚Äî Demo scripts, playbooks, and acceptance tests (e.g., `Demo_Today_Playbook_FallbackOnly.scd`)
- **LivePedalboardSystem/** ‚Äî Core system classes, adapters, and utilities
- **MagicPedalboardNew.scd** ‚Äî Main pedalboard engine (chain management, switching, bypass, etc.)
- **Adapters/** ‚Äî Bridges for hardware or OSC-based control (e.g., CommandTree adapter)
- **Processors/** ‚Äî Effect definitions (delay, chorus, drive, etc.)
- **GUI/** ‚Äî MagicDisplayGUI and related visual components
- **Utilities/** ‚Äî Helper scripts, test utilities, and fallback routines

---

## Main Components

- **LivePedalboardSystem**: Top-level system manager. Handles bring-up, shutdown, and coordination of pedalboard, GUI, and adapters.
- **MagicPedalboardNew**: The core pedalboard class. Manages two chains (CURRENT and NEXT), supports adding/removing/bypassing effects, switching with crossfade, and enforcing Option A (exclusive audio path).
- **Adapters**: Optional bridges (e.g., `~ct_applyOSCPathToMPB`) that translate high-level commands (like `/add/delay`) to pedalboard actions, supporting both hardware and software control.
- **Processors**: Individual effect modules (delay, chorus, reverb, etc.), defined as SynthDefs or Ndefs, and added to chains by symbolic name.
- **GUI**: MagicDisplayGUI provides a visual overview of chain state, effect status, and demo progress. Level meters and HUDs may be included.

---

## How It Works

- **Bring-up**: `Start_LivePedalboardSystem.scd` initializes the system, pedalboard, GUI, and (optionally) adapters.
- **Demo Scripts**: Scripts like `Demo_Today_Playbook_FallbackOnly.scd` apply a sequence of canonical commands (e.g., `/add/delay`, `/switch`) to demonstrate effect switching, bypass, and chain management.
- **Audio Sources**: Uses generated sources (e.g., `Ndef(\testmelody)`) for hardware-independent testing. Option A ensures only one chain is audible at a time.
- **Adapters**: If present, adapters handle OSC or hardware commands; otherwise, scripts call pedalboard methods directly.
- **GUI**: The GUI updates in response to commands, showing current/next chain, effect status, and demo progress.

---

## Customization & Extensibility

- Add new effects by defining new SynthDefs/Ndefs and registering them as processors.
- Extend adapters for new hardware or OSC protocols.
- Write new demo scripts/playbooks for custom test scenarios.

---

## Troubleshooting & Support

- See `StartHere.md` for step-by-step instructions and troubleshooting tips.
- Check the SuperCollider console for errors and warnings.
- For advanced debugging, inspect `~system`, `~system.pedalboard`, and GUI state.
- For help, open an issue on the project repository or contact the maintainer.

---

---

Happy patching!
===== README.txt =====

README.txt ‚Äî LivePedalboardSuite Overview
========================================

LivePedalboardSuite is a modular, scriptable, and extensible live audio processing environment for SuperCollider. It is designed for rapid prototyping, testing, and demonstration of pedalboard-style audio effect chains, with or without hardware integration.

Project Structure
-----------------
- **Scripts/** ‚Äî Demo scripts, playbooks, and acceptance tests (e.g., Demo_Today_Playbook_FallbackOnly.scd)
- **LivePedalboardSystem/** ‚Äî Core system classes, adapters, and utilities
- **MagicPedalboardNew.scd** ‚Äî Main pedalboard engine (chain management, switching, bypass, etc.)
- **Adapters/** ‚Äî Bridges for hardware or OSC-based control (e.g., CommandTree adapter)
- **Processors/** ‚Äî Effect definitions (delay, chorus, drive, etc.)
- **GUI/** ‚Äî MagicDisplayGUI and related visual components
- **Utilities/** ‚Äî Helper scripts, test utilities, and fallback routines

Main Components
---------------
- **LivePedalboardSystem**: Top-level system manager. Handles bring-up, shutdown, and coordination of pedalboard, GUI, and adapters.
- **MagicPedalboardNew**: The core pedalboard class. Manages two chains (CURRENT and NEXT), supports adding/removing/bypassing effects, switching with crossfade, and enforcing Option A (exclusive audio path).
- **Adapters**: Optional bridges (e.g., ~ct_applyOSCPathToMPB) that translate high-level commands (like /add/delay) to pedalboard actions, supporting both hardware and software control.
- **Processors**: Individual effect modules (delay, chorus, reverb, etc.), defined as SynthDefs or Ndefs, and added to chains by symbolic name.
- **GUI**: MagicDisplayGUI provides a visual overview of chain state, effect status, and demo progress. Level meters and HUDs may be included.

How It Works
------------
- **Bring-up**: Start_LivePedalboardSystem.scd initializes the system, pedalboard, GUI, and (optionally) adapters.
- **Demo Scripts**: Scripts like Demo_Today_Playbook_FallbackOnly.scd apply a sequence of canonical commands (e.g., /add/delay, /switch) to demonstrate effect switching, bypass, and chain management.
- **Audio Sources**: Uses generated sources (e.g., Ndef(\testmelody)) for hardware-independent testing. Option A ensures only one chain is audible at a time.
- **Adapters**: If present, adapters handle OSC or hardware commands; otherwise, scripts call pedalboard methods directly.
- **GUI**: The GUI updates in response to commands, showing current/next chain, effect status, and demo progress.

Customization & Extensibility
-----------------------------
- Add new effects by defining new SynthDefs/Ndefs and registering them as processors.
- Extend adapters for new hardware or OSC protocols.
- Write new demo scripts/playbooks for custom test scenarios.

Troubleshooting & Support
-------------------------
- See StartHere.txt for step-by-step instructions and troubleshooting tips.
- Check the SuperCollider console for errors and warnings.
- For advanced debugging, inspect ~system, ~system.pedalboard, and GUI state.


Happy patching!

===== RulesForChatGPT-Copilot.scd =====
// RulesForChatGPT-Copilot.scd

/*
STYLE, SYNTAX & CODING RULES (STRICT)
- SuperCollider ONLY known‚Äëgood syntax. Do NOT invent methods or pseudo‚Äëslots.
- Variable style: descriptive lowercase names; **var-first in EVERY block and closure** (do a second pass each time).
- No non‚Äëlocal returns; no `try` or `protect` (not supported).
- No `server.sync`. Use `Server.default.bind` for server ops. `s.waitForBoot` is allowed in bring‚Äëup only.
- GUI: AppClock ONLY; NO FlowLayout; fixed vertical metrics; top‚Äëleft anchored; resizable width with safe layout; single titled window (‚ÄúMagicDisplayGUI ‚Ä¶‚Äù).
- Windows MUST return **‚Üí a Window** as final expression.
- Titles/headers: Every SC file starts with my standard header:
  - Line 1: `<file name>`
  - Line 2: `// vX.Y.Z`
  - Line 3: `// MD <YYYY-MM-DD HH:MM TZ>`
  - Blank line
  - `/* Purpose / Style */`
  - Then code.
- Do not use any ‚Äúv6‚Äù labels (legacy).
- JITLib connect operator: **`Ndef(left) <<> Ndef(right)`** ONLY (never `<>` or `<<>>`).
- Sinks/processors read from `\in.ar(defaultNumChannels)`.
- Acceptance tests: generated audio only; NO SoundIn.

- ALWAYS do a second pass to check for variables after statements before showing me code.
*/
===== RunBook_20251002.scd =====
// RunBook.scd
// MD
// 20251002-1157

/*
--- > RUN BLOCK BY BLOCK! <--
*/

//////////////////////////////
// 0) Clean up (safe preflight)

(
// Close LPDisplay / MagicDisplay windows
Window.allWindows
 .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        or: { w.tryPerform(\name) == "Layout Test" } })
 .do(_.close);

// Free OSCdefs used by the LPDisplay demo (if present)
[ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ].do { |k|
    var d = OSCdef(k); if(d.notNil) { d.free };
};

// Stop the LPDisplay demo Ndefs if they exist
[ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ].do { |sym|
    var nd = Ndef(sym); if(nd.notNil) { nd.stop };
};
"Cleanup done.".postln;
)


//////////////////////////////
// 1) Open LPDisplay window (silence its internal demo sources)
(
// Controller (instance with setSourceA/B) and GUI window
~inst = LPDisplayLayoutTestWindow.new(nil);  // pass a HUD object if you prefer; nil = raw meters
~win  = ~inst.open;                          // -> a Window titled "Layout Test"

// Silence the LPDisplay demo sources so the meters don't show its noise/tone
~inst.setSourceA(\srcZ);
~inst.setSourceB(\srcZ);

// If you added the console gate previously:
try { ~inst.setConsoleLevelsOn(false) } { };  // optional: keep console quiet

// Ready check
[ ~inst.notNil, ~win.notNil, ~win.class ].postln;
)

//////////////////////////////
// 2) Bring up LivePedalboardSystem (headless UI)
(
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;      // MagicPedalboardNew
~system.bringUpCommandSystem;   // CommandManager + MIDI
~system.installAdapterBridge;   // routes '/add/delay', '/switch', etc. to MPB
"OK: LPS up (headless UI).".postln;

// Sanity
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;
)

//////////////////////////////
// 3) Confirm core objects and callback exist
(
~cm = ~system.commandManager;
~mm = ~cm.midiManager;
[ ~system.notNil, ~cm.notNil, ~mm.notNil, (~cm.queueExportCallback.notNil) ].postln;
)


//////////////////////////////
//4) Load the emulator helpers (block [1] in the emulator file)

/*
Open Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd and evaluate the parenthesized block under [1] Emulation helpers.
That block defines: ~fc, ~toProg, ~toQueue, ~toSend, ~gm, ~nav, ~showNav, etc.
*/
//verify helps exist:
[ ~toProg.isKindOf(Function), ~nav.isKindOf(Function), ~toQueue.isKindOf(Function), ~toSend.isKindOf(Function) ].postln;
// Expect: [ true, true, true, true ]


//////////////////////////////
//5) Scenario A ‚Äî Add Delay (navigate ‚Üí queue ‚Üí send)
(
~toProg.();           // enter navigation mode
~nav.(6, 1);          // "audio"
~nav.(5, 5);          // "timebased"
~nav.(4, 3);          // "delay"
~showNav.();          // optional: prints long/canonical path
~toQueue.();          // queue canonical (e.g. "/add/delay")
~toSend.();           // send via adapter -> MagicPedalboardNew
)

//////////////////////////////
//6) Scenario B ‚Äî Switch chains
(
~toProg.();
~nav.(6, 5);          // "switch"
~showNav.();
~toQueue.();
~toSend.();
)


//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//
===== Sim_MIDI_FootAndGuitar_Demo_v0.1.scd =====
// Sim_MIDI_FootAndGuitar_Demo_v0.1.scd
// v0.1.2
// MD 2025-09-26 10:45 BST

/* Purpose / Style
   Simulate foot controller + hex guitar without hardware:
   - FOOT (noteOn): 36‚Üí\idle, 38‚Üí\prog, 40‚Üí\queue, 41‚Üí\send
   - GUITAR (channels 0..5 ‚Üí strings 6..1) bases [40,45,50,55,59,64]
   - Drives MIDIInputManager handlers + CommandManager + adapter bridge if present.

   Style
   - var-first everywhere; descriptive lowercase variable names; AppClock-only; no server.sync.
   - Generated audio only; exclusivity Option A remains enforced by bring-up (no SoundIn).
*/

(
var ensureSystem, basePitches, ensureReady, footToIdle, footToProg, footToQueue, footToSend;
var guitarNote, navFret, showCanonical, refreshChoices;
var runScenarioAddDelay, runScenarioSwitch, runScenarioBypassOn, runAllScenarios, logger;

logger = { arg message; ("[SIM] " ++ message).postln };

ensureSystem = {
    var systemInstance;
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    systemInstance = LivePedalboardSystem.new(nil);  // nil -> class path resolver
    ~system = systemInstance;
    ~system.bringUpAll;
    if(~system.respondsTo(\installAdapterBridge)) { ~system.installAdapterBridge };
    logger.("system is up (GUI + MPB + CommandTree)");
};

ensureReady = {
    var ok;
    ok = ~system.notNil
        and: { ~system.commandManager.notNil }
        and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run ensureSystem.() first".warn };
    ok
};

basePitches = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

footToIdle  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 36) } };
footToProg  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 38) } };
footToQueue = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 40) } };
footToSend  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 41) } };

guitarNote = { arg stringNumber, fretNumber;
    var midiManager, channelIndex, baseNote, midiPitch;
    if(ensureReady.().not) { ^nil };
    midiManager = ~system.commandManager.midiManager;
    channelIndex = (6 - stringNumber.asInteger).clip(0, 5);
    baseNote = basePitches[channelIndex];
    if(baseNote.isNil) { "‚ö†Ô∏è Invalid string number".warn; ^nil };
    midiPitch = (baseNote + fretNumber.asInteger).asInteger;
    midiManager.guitarHandler.handleMessage(channelIndex, \noteOn, midiPitch);
};
navFret = { arg stringNumber, fretNumber; guitarNote.(stringNumber, fretNumber) };

showCanonical = {
    var cmRef, builderRef, longPath, shortPath;
    if(ensureReady.().not) { ^nil };
    cmRef = ~system.commandManager; builderRef = cmRef.builder;
    builderRef.printPathToRoot;
    longPath  = cmRef.buildLongPathFromBuilder(builderRef);
    shortPath = cmRef.canonicalPathFromBuilder(builderRef);
    ("‚Ä¢ long=" ++ longPath ++ "  canonical=" ++ shortPath).postln;
};
refreshChoices = { if(~system.notNil) { ~system.commandManager.updateDisplay } };

runScenarioAddDelay = {
    footToProg.(); refreshChoices.();
    navFret.(6, 1); navFret.(5, 5); navFret.(4, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario A complete (add delay)");
};

runScenarioSwitch = {
    footToProg.();
    navFret.(6, 5);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario B complete (switch)");
};

runScenarioBypassOn = {
    footToProg.();
    navFret.(6, 3); navFret.(5, 9); navFret.(4, 3); navFret.(3, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario C complete (bypass delay on)");
};

runAllScenarios = {
    var stepIndex;
    stepIndex = 0;
    AppClock.sched(0.0, {
        switch(stepIndex,
            0, { ensureSystem.(); stepIndex = 1; AppClock.sched(0.40, { runAllScenarios.(); nil }) },
            1, { runScenarioAddDelay.(); stepIndex = 2; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            2, { runScenarioSwitch.();   stepIndex = 3; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            3, { runScenarioBypassOn.(); nil },
            { nil }
        );
        nil
    });
    "[SIM] queued runAllScenarios".postln;
};

~sim_runAll = { runAllScenarios.() };
logger.("Evaluate:  ensureSystem.();  then  ~sim_runAll.();");
)

===== StartHere_LivePedalboardSuite.scd =====
// StartHere_LivePedalboardSuite.scd
// v0.6.1
// MD 20250928-1824
//
// Purpose
// - Canonical bring-up for LivePedalboardSuite using ONE GUI with WORKING METERS.
// - Avoid duplicate GUI/taps: rely on LivePedalboardSystem.bringUpAll to open GUI,
//   then install the adapter bridge and auto-meters once.
//
// Style / Guard Rails
// - single () block; var-first; lowercase names; no server.sync; no non-local '^'.
// - UI via AppClock; server ops inside Server.default.bind when needed.
// - Returns -> a Window (MagicDisplayGUI‚Ä¶).

(
var meterRate, postSwitchDelay, systemRef, windowRef;
var findMagicDisplayWindow, closeExistingMagicDisplayWindows, frontWindow, afterBringUp;

// ---- tunables ----
meterRate = 24;
postSwitchDelay = 0.35;

// ---- helpers ----
closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows; i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }) {
            w.close;
        };
        i = i + 1;
    };
};

findMagicDisplayWindow = {
    var win;
    win = Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    win
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    // Adapter: route short canonical commands to MagicPedalboard (+HUD toggle on /switch)
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    // Meters: assert one set of taps + GUI re-arm (idempotent)
    if(lps.respondsTo(\enableAutoMeters)) { lps.enableAutoMeters(meterRate, postSwitchDelay) };
    // detect and front the GUI window
    frontWindow.(findMagicDisplayWindow.());
};

// ---- run ----

// 0) keep one GUI window only
closeExistingMagicDisplayWindows.();

// 1) shutdown existing system cleanly (if present)
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };

// 2) construct and bring up everything (this will open the GUI once)
systemRef = LivePedalboardSystem.new(nil);
systemRef.bringUpAll;

// 3) post-steps: adapter bridge + meters + front window
windowRef = afterBringUp.(systemRef);

// 4) publish handles
~system = systemRef;
~mpb = systemRef.pedalboard;
~gui = systemRef.statusDisplay;

// 5) return the GUI window
windowRef
)

===== StartHere.md =====

StartHere.txt ‚Äî Quick Start for LivePedalboardSuite Demo
======================================================

\1. Prerequisites
----------------
- SuperCollider 3.11 or newer installed and working
- Clone or download the LivePedalboardSuite repository to your computer
- (Optional) Audio interface or headphones for best sound

\2. Launch SuperCollider
-----------------------
- Open SuperCollider (scide)
- Open the file: Start_LivePedalboardSystem.scd (usually in the root or a Scripts/ folder)

\3. Bring Up the System
----------------------
- Evaluate the following block (select and press Cmd+Return or Ctrl+Return):

(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
    ~system.installAdapterBridge;
}.defer;
)

- Wait for the GUI window to appear and for console logs to confirm bring-up.

\4. Run the Demo
---------------
- Open the file: Demo_Today_Playbook_FallbackOnly.scd (or similarly named demo script)
- Evaluate the entire file (select all, Cmd+Return/Ctrl+Return)
- You should see console output like:
    [FALLBACK] entered
    [FALLBACK] apply ‚Üí /add/delay
    ...
    [FALLBACK] done.
- The GUI window should update with each step.
- You should hear a pleasant melody and effect changes.

\5. Troubleshooting
------------------
- **No sound?**
    - Make sure your audio interface is selected in SuperCollider (check ServerOptions)
    - Check your system volume and headphones/speakers
    - Confirm that the Ndef(\testmelody) is playing (see code in ensureGeneratedSources)
    - Try re-evaluating Start_LivePedalboardSystem.scd and then the demo script
- **No GUI window?**
    - Make sure you ran the bring-up block in step 3
    - Check for errors in the SuperCollider console
    - Try closing all SuperCollider windows and re-running from step 3
- **No effect changes?**
    - Confirm the demo script is running (look for [FALLBACK] logs)
    - Check that ~system.pedalboard is not nil (type ~system.pedalboard; in the console)
    - Try restarting SuperCollider and repeating steps 3 and 4
- **Still stuck?**
    - Paste any error messages into an issue on the project repo or ask your team lead

\6. Stopping the Demo
--------------------
- To stop all sound, evaluate:
    s.meter; // open meters
    s.quit;  // stop audio server
    // or close SuperCollider

Enjoy exploring LivePedalboardSuite!
===== SystemSpecification_ModularGuitarPedalboard.md =====

# System Specification: Modular Guitar-Controlled Audio Pedalboard with Hierarchical Command Navigation

## 1. System Overview

This system is a modular, software-based audio pedalboard designed for live performance and experimentation. It is controlled by a hexaphonic (six-string) guitar, where each string is mapped to a separate MIDI channel. The performer navigates a hierarchical command tree by playing specific frets on each string, allowing for rapid, hands-free selection and execution of audio processing commands. The system is designed for flexibility, robust state management, and clear feedback to the performer.

## 2. Core Concepts

### 2.1. Audio Pedalboard Engine

- **Signal Chains:**
  The audio engine maintains two parallel signal chains (A and B), each consisting of a sequence of audio processors (effects) and a source. These chains are dynamically reconfigurable.
- **Processors:**
  Each processor is a modular audio effect (e.g., delay, chorus, reverb, drive) that can be inserted, bypassed, or removed from a chain. All processors are designed to operate on a configurable number of channels (typically stereo).
- **Chain Switching:**
  The performer can crossfade between the two chains, ensuring smooth transitions. Only one chain is audible at a time, except during deliberate crossfades.
- **Exclusivity:**
  The system enforces that only the ‚Äúcurrent‚Äù chain is audible, muting the ‚Äúnext‚Äù chain at its source except during crossfades.

### 2.2. Hierarchical Command Navigation

- **Command Tree:**
  All available commands (such as adding effects, switching chains, or changing sources) are organized in a hierarchical tree structure. Each node represents a command or a category of commands.
- **Navigation by Guitar:**
  The performer navigates the tree by playing specific frets on each string. Each string corresponds to a level in the tree; the fret number selects a branch at that level.
- **Command Queue:**
  As the performer navigates, the selected path is recorded as a sequence of tokens (e.g., `/audio/time-based/delay`). When navigation is complete (either at a leaf node or by explicit user action), the resulting command path is queued for execution.

### 2.3. Execution and Feedback

- **Command Execution:**
  When the performer triggers execution (e.g., by pressing a footswitch or reaching a leaf node), the queued command is sent to the audio engine for processing.
- **Partial Commands:**
  The system allows for both complete (leaf node) and partial (intermediate node) command paths to be executed, enabling both generic and specific actions.
- **User Feedback:**
  The system provides real-time feedback on the current navigation state, available choices, queued commands, and execution status via a display (console or GUI).

## 3. System Architecture

### 3.1. Audio Engine

- Maintains two independent signal chains (A/B), each as an ordered list of processors and a source.
- Supports dynamic mutation of chains: add, remove, swap, bypass processors; set sources.
- Enforces channel count and audio-rate consistency throughout the chain.
- Provides robust methods for resetting, rebuilding, and crossfading chains.

### 3.2. Command Navigation and Queue

- Maintains a hierarchical tree of commands, each node with a name, identifier, fret mapping, and optional payload.
- Navigation is performed by mapping incoming MIDI notes (from each guitar string/channel) to tree branches.
- Tracks the current navigation path and supports resetting or restarting navigation at any time.
- Maintains a queue of commands to be executed, supporting enqueue, dequeue, clear, and export operations.

### 3.3. MIDI and Device Management

- Detects and manages multiple MIDI input devices (guitar, foot controller, launchpad, etc.).
- Binds specific handlers to each device, mapping incoming MIDI messages to navigation, mode switching, or command execution.
- Supports flexible mode switching (e.g., navigation, queueing, sending, play, record) via foot controller or other devices.

### 3.4. Display and Feedback

- Provides a user interface (console or GUI) that displays:
  - Current navigation mode and state
  - Available choices at each navigation step
  - Current command queue
  - Last executed command
  - Status messages and errors
- Updates the display in real time as navigation and execution progress.

## 3.5 Command Tree Path Resolution (Runtime)

When no explicit path is provided to `LivePedalboardSystem.new(path)`, the JSON path is resolved with this precedence:

1. `Platform.userExtensionDir/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json`
2. `Platform.userExtensionDir/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json` _(repo default)_
3. _(Legacy, deprecated; warning emitted)_ `Platform.userExtensionDir/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json`

If none exist, the repo default path is returned and the import warns.

### 3.6 Acceptance & Demo Constraints
- **Audio**: generated sources only (no `SoundIn`).
- **Exclusivity (Option A)**: NEXT is silenced at source except during crossfades.
- **A/B XOR**: at any time exactly one sink (A or B) is audible; demos verify this.
- **GUI**: single MagicDisplayGUI window; UI updates via `AppClock` only.


## 4. Operational Workflow

1. **System Initialization**
   - Audio engine initializes both signal chains with default processors and sources.
   - Command tree is loaded from a configuration file or built programmatically.
   - MIDI devices are detected and handlers are bound.

2. **Navigation**
   - Performer enters navigation mode (e.g., via foot controller).
   - Each string/fret played advances one level in the command tree.
   - At each step, available choices are displayed.
   - Navigation can be completed by reaching a leaf node or by explicit user action.

3. **Queueing and Execution**
   - Upon completion, the selected command path is added to the command queue.
   - Performer can review, modify, or clear the queue.
   - When ready, the performer triggers execution (e.g., via foot controller).
   - The queued command is sent to the audio engine for processing.

4. **Audio Processing**
   - The audio engine interprets the command path and mutates the signal chain(s) accordingly.
   - If a chain switch is requested, a crossfade is performed.
   - Exclusivity is enforced: only the current chain is audible.

5. **Feedback**
   - The display updates to reflect the new state, available commands, and any errors or status changes.

## 5. Design Principles

- **Modularity:**
  All components (audio processors, command nodes, device handlers) are modular and extensible.
- **Robustness:**
  The system is designed to recover gracefully from errors, with clear state management and reset capabilities.
- **Real-Time Safety:**
  All time-sensitive operations (audio, MIDI) are handled in a thread-safe manner, with UI updates deferred as needed.
- **User-Centric Feedback:**
  The performer receives immediate, clear feedback at every step, supporting both novice and expert workflows.
- **Testability:**
  The system supports headless (non-GUI) operation and automated acceptance tests using generated audio only.

## 6. Extensibility and Future Directions

- **Additional Processors:**
  New audio effects can be added by registering new processor modules.
- **Custom Command Trees:**
  The command hierarchy can be reconfigured or extended to support new workflows.
- **Advanced Displays:**
  The user interface can be enhanced with richer visualizations, touch support, or remote control.
- **Integration with Other Instruments:**
  The navigation and command system can be adapted for other MIDI controllers or input devices.

## 7. Example Use Case

1. Performer powers on the system; both audio chains are initialized with default settings.
2. Performer enters navigation mode and plays a sequence of frets on the guitar, selecting a path such as ‚Äúaudio ‚Üí time-based ‚Üí delay‚Äù.
3. The system displays available sub-commands (e.g., ‚Äúmulti-tap‚Äù, ‚Äúping-pong‚Äù) or allows execution of the generic delay command.
4. Performer confirms the selection; the command is queued.
5. Performer triggers execution; the delay effect is added to the next chain, and a crossfade is performed to make it active.
6. The display updates to show the new chain configuration and confirms successful execution.

## 8. Summary

This system enables expressive, hands-free control of a modular audio pedalboard using a guitar as a navigation device. Its hierarchical command structure, robust audio engine, and real-time feedback make it suitable for live performance, experimentation, and further extension.

v0.9
===== test 31tp8ve.scd =====
// test 31tp8ve.scd
//

(
var baseFreq = 220.0; // A3
var stepsPerOctave = 31;
var numSteps = 62; // two octaves
var dur = 0.2;
var gap = 0.05;

Routine({
    numSteps.do { |step|
        var freq = baseFreq * (2 ** (step / stepsPerOctave));
        Synth(\play31tone, [\freq, freq]);
        dur.wait;
        gap.wait;
    };
}).play;

SynthDef(\play31tone, { |freq=220|
    var env = EnvGen.kr(Env.perc(0.01, 0.19), doneAction:2);
    var sig = SinOsc.ar(freq) * 0.2 * env;
    Out.ar(0, sig!2);
}).add;
)
===== Test_MagicDisplayGUI_BootAndScenarios.scd =====
// Test_MagicDisplayGUI_BootAndScenarios.scd
// v0.1.6
// MD 2025-09-26 11:58 BST

/* Purpose / Style
   One-click system bring-up using the PerfHUD v0.5.4 integration:
   - LivePedalboardSystem.new(nil).bringUpAll() -> your PerfHUD window (v0.5.4).
   - Install queue->MPB adapter bridge (if present) and inline AutoMeters taps.
   - AppClock-only; var-first in EVERY block; no server.sync; generated audio only.
   - Final expression returns -> a Window.
*/

(
var systemRef, pickedWindow, wins;

// Fresh system
systemRef = LivePedalboardSystem.new(nil);
~system = systemRef;  // convenience handle at top level (allowed per your style)
systemRef.bringUpAll;

// Optional: adapter and inline meter taps
if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
if(systemRef.respondsTo(\enableAutoMeters))     { systemRef.enableAutoMeters(18, 0.35) };

// Find MagicDisplay window produced by PerfHUD v0.5.4
wins = Window.allWindows;
pickedWindow = wins.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

// Final expression -> a Window
pickedWindow ? { wins.last }
)

===== Tests/Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd =====
// Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd
// v0.1.1
// MD 2025-09-26 16:35 BST

/* Purpose / Style
   Purpose: One-file, sectioned run-sheet for the 5pm demo. Brings up the system, ensures a single
            ‚ÄúMagicDisplayGUI ‚Ä¶‚Äù window, installs the adapter bridge and robust meter taps, and provides
            simulated footcontroller + hex guitar. Applies canonical commands via the adapter to avoid
            the known queue/display crash path today.
   Style:   SC only; known-good syntax; var-first everywhere; no non-local returns; no try/protect;
            no server.sync; GUI on AppClock; the bring-up section returns ‚Üí a Window.
*/

// [0] BRING-UP (build once; returns ‚Üí a Window)
(
var needNew, winList, pickedWindow;

needNew = ~system.isNil;
if(needNew) {
    var treePath;  // nil ‚Üí LivePedalboardSuite resolver precedence
    treePath = nil;
    ~system = LivePedalboardSystem.new(treePath);                     // resolver inside class
    ~system.bringUpAll;                                               // GUI+MPB+CommandManager+meters staged
} {
    // Refresh GUI only (avoid double full bring-up)
    ~system.closeExistingMagicDisplayWindows;
    ~system.bringUpMagicDisplayGUI;                                   // sets statusDisplay and re-binds if commandManager exists
};

// Return the single MagicDisplayGUI window and front it
winList = Window.allWindows;
pickedWindow = winList.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});
if(pickedWindow.notNil) { pickedWindow.front };
pickedWindow
)

// [1] ADAPTER BRIDGE + STABLE TAPS + INLINE OVERLAY METERS (self-contained)
/* Reason:
   - Your GUI shows the /md/levels OSC listener is installed, but the overlay meters weren't attached in your run.
   - We install stable taps (A=2001, B=2002) and a minimal overlay here so you see movement immediately.  */
(
var ensureBridge, ensureStableTaps, installLevelsListener, attachOverlay;

ensureBridge = {
    ~system.installAdapterBridge;  // routes canonical queue strings through adapter; also toggles active-chain HUD
    nil
};

ensureStableTaps = {
    // Sanitised + smoothed visual taps to /md/levels with IDs 2001 (A) / 2002 (B)
    ~system.installStableMeters;
    nil
};

installLevelsListener = {
    // Minimal HUD-side listener (independent of any external file)
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    if(OSCdef.all.at(\md_levels_inline).notNil) { OSCdef.all.at(\md_levels_inline).free };
    OSCdef(\md_levels_inline, { arg msg;
        var id, l, r, L, R;
        if(msg.size >= 5) {
            id = msg[2];
            l  = msg[3].asFloat; r = msg[4].asFloat;
            L  = l.isFinite.if({ l.clip(0,1) }, { 0.0 });
            R  = r.isFinite.if({ r.clip(0,1) }, { 0.0 });
            ~md_levelsById.put(id, [L, R]);
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    nil
};

attachOverlay = {
    var hudWindow, overlayView, pad, w, h, tick;
    hudWindow = Window.allWindows.detect({ arg ww;
        var n = ww.tryPerform(\name);
        n.notNil and: { n.asString.beginsWith("MagicDisplayGUI") }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI window yet; run [0] first.".warn; ^nil };

    pad = 8; w = 22; h = 86;
    overlayView = UserView(hudWindow, Rect(pad, pad, w, h));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var pairA, pairB, aL, aR, bL, bR, halfH, halfW;
        pairA = ~md_levelsById.at(2001) ? [0, 0];       // A (replyID 2001)
        pairB = ~md_levelsById.at(2002) ? [0, 0];       // B (replyID 2002)
        aL = pairA[0]; aR = pairA[1];
        bL = pairB[0]; bR = pairB[1];
        halfH = v.bounds.height/2; halfW = v.bounds.width/2;

        // A (bottom half): left=green, right=blue
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, halfH - (halfH * aL), halfW, (halfH * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, halfH - (halfH * aR), halfW, (halfH * aR))); Pen.fill;

        // B (top half): lighter tint
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, v.bounds.height - (halfH * bL), halfW, (halfH * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, v.bounds.height - (halfH * bR), halfW, (halfH * bR))); Pen.fill;
    });

    // Refresh loop (AppClock only)
    tick = Routine({
        var keep;
        keep = true;
        while({ keep and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "‚úÖ Inline overlay meters attached (top-left)".postln;
    overlayView
};

// Apply fixes
ensureBridge.();
ensureStableTaps.();
installLevelsListener.();
attachOverlay.();
nil
)

// [2] SIMULATED CONTROLLERS (foot + hex guitar ‚Üí nav); AVOID queue/send crash today
(
var ensure, bases;

// Guard
ensure = {
    var ok;
    ok = ~system.notNil
      and: { ~system.commandManager.notNil }
      and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run section [0] first.".warn };
    ok
};

// Channel‚Üístring base pitches (E A D G B E) as per GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

// FOOT: emulate a foot button press (note number)
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);  // 36 idle, 38 prog, 40 queue, 41 send
};

// Shortcuts
~toIdle  = { var n; n = 36; ~fc.(n) };
~toProg  = { var n; n = 38; ~fc.(n) };

// GUITAR: emulate ‚Äústring s @ fret f‚Äù
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "‚ö†Ô∏è Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Helper: print current and canonical path
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);         // "/add/delay", "/switch", etc.
    ("‚Ä¢ long=" ++ long ++ "  canonical=" ++ short).postln;
    short
};
nil
)

// [3] DEMO SCENARIOS (canonical applied via adapter to avoid queue/display crash path)

// Scenario A ‚Äî Add delay to NEXT via guitar nav, then apply canonical via adapter (no queue/send today)
(
var path;
~toProg.();      // enter navigation mode
~gm.(6, 1);      // "audio"    (string 6 fret 1)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(5, 5);      // "timebased"(string 5 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(4, 3);      // "delay"    (string 4 fret 3)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // should be "/add/delay"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // apply via adapter
} {
    "‚ö†Ô∏è Adapter not loaded.".warn;
};
"‚úÖ Scenario A applied (add delay to NEXT).".postln;
nil
)

// Scenario B ‚Äî Navigate to top-level ‚Äúswitch‚Äù and apply canonical via adapter
(
var path;
~toProg.();
~gm.(6, 5);      // "switch" (string 6 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // "/switch"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // guarded crossfade + post-audit
} {
    "‚ö†Ô∏è Adapter not loaded.".warn;
};
"‚úÖ Scenario B applied (switch).".postln;
nil
)

===== troubleshooting/00_Reset_KnownClean_State.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)

===== troubleshooting/00A_HUD_Sanity_Check.scd =====
//////////////////////////////////////////////////////////////
// 00A_HUD_Sanity_Check.scd
// v0.1.0
// MD 20250929-13:02

/* Purpose
   - Print which window(s) are open and what ~gui is.
Style
   - var-first; no server.sync; safe .tryPerform.
*/
(
var windowNames, guiClass, isWindow;

windowNames = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
guiClass = ~gui.tryPerform(\class);
isWindow = ~gui.notNil and: { ~gui.isKindOf(Window) };

"‚Äî HUD Sanity ‚Äî".postln;
("Windows: " ++ windowNames).postln;
("~gui: " ++ (~gui ? "nil").asString).postln;
("~gui.class: " ++ (guiClass ? "nil").asString).postln;
("~gui is a Window? " ++ isWindow.asString).postln;
if(~gui.notNil) {
    ("GridDemo methods: highlight=" ++ ~gui.respondsTo(\highlightCurrentColumn)
      ++ " setOps=" ++ ~gui.respondsTo(\setOperations)).postln;
};
)

===== troubleshooting/00B_HUD_Force_GridDemo_Now.scd =====
//////////////////////////////////////////////////////////////
// 00B_HUD_Force_GridDemo_Now.scd
// v0.1.0
// MD 20250929-13:02
/* Purpose
   - Close PerfHUD/GridDemo windows and bring up GridDemo (non-pulsing).
   - Assign ~gui to the GridDemo controller and bring it to front.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/
(
var closeWindows, bringGrid, front;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller, not a Window
};

front = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (static A/B; no pulse)", 0);
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { front.value; nil }); nil });
)

===== troubleshooting/01_StartHere_LivePedalboardSuite.scd =====
// 01_StartHere_LivePedalboardSuite.scd
// v0.6.2
// MD 20250928-1935

(
// Purpose
// - Bring up LivePedalboardSuite from a clean state (server reboot, GUI, MPB, CommandTree).
// - Enable GUI taps for overlay; HUD meters will be driven by ‚Äú02_ForceMeters_FromBuses.scd‚Äù.
// Style
// - var-first; no server.sync; use s.waitForBoot; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var rebootServer, ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

rebootServer = {
    if(s.serverRunning) { s.reboot } { s.boot };
    s.waitForBoot({
        s.initTree;
        Server.default.bind({ s.defaultGroup.freeAll });
        "üîÅ Server booted & tree initialized.".postln;
    });
};

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };  // GUI taps for overlay
    frontWindow.(findMagicDisplayWindow.());
};

rebootServer.value;
ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_1_HUD_Adapter.scd =====
// 01b_1_HUD_Adapter.scd
// v0.1.0
// MD 2025-09-29 13:05

/* Purpose
   - Provide a stable HUD API regardless of which GUI is up:
        ~hud_highlightCurrent.(\chainA | \chainB)
        ~hud_showExpectation.("text", seconds=0)
        ~hud_setOperations.(["line1", "line2", ...])
   - If GridDemo is up, forward to its native methods.
   - If PerfHUD is up (meters!), create lightweight overlays on top of the window:
       ‚Ä¢ a solid A/B highlight (masks the pulsing)
       ‚Ä¢ a small text panel for status + choices
Style
   - var-first; AppClock for UI; no server.sync; nil-safe; idempotent.
*/

(
var findHudWindow, isGridDemo, adoptGridDemo, adoptPerfHUD, ensureOverlayBag;
var mkOrGetView, setSolidHighlight, setStatusText, setChoicesText;

findHudWindow = {
    Window.allWindows.detect { |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    }
};

isGridDemo = {
    // If ~gui is a GridDemo controller, prefer it
    (~gui.notNil)
    and: { ~gui.class.asString == "MagicDisplayGUI_GridDemo" }
    and: { ~gui.respondsTo(\highlightCurrentColumn) }
};

// ---- GridDemo path: forwarders to class methods -----------------------------
adoptGridDemo = {
    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            ~gui.highlightCurrentColumn(which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation(text, secs ? 0) };
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\setOperations)) { ~gui.setOperations(lines ? []) };
            nil
        })
    };
    "HUD adapter: GridDemo forwarders installed.".postln;
};

// ---- PerfHUD path: overlays on top of the window ----------------------------
ensureOverlayBag = { |win|
    var dict;
    dict = Library.at(\HUD_Overlay, win.identityHash);
    if(dict.isNil) {
        dict = IdentityDictionary.new;
        Library.put(\HUD_Overlay, win.identityHash, dict);
    };
    dict
};

mkOrGetView = { |win, key, makeFunc|
    var bag, v;
    bag = ensureOverlayBag.(win);
    v = bag[key];
    if(v.isNil or: { v.wasRemoved ? false }) {
        v = makeFunc.value(win.view);
        bag[key] = v;
    };
    v
};

setSolidHighlight = { |win, which|
    var host, w, h, half, rect, color, key;
    host = win.view;
    w = host.bounds.width; h = host.bounds.height;
    half = (w * 0.5).round(1);
    rect = (which == \chainA)
        .if({ Rect(0, 0, half, h) }, { Rect(half, 0, w - half, h) });
    color = Color(0.85, 1.0, 0.85, 0.90);   // same tint as GridDemo "active"
    key = \highlightView;

    mkOrGetView.(win, key, { |parent|
        var v = CompositeView(parent);
        v.background = color;
        v
    }).bounds = rect;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).background = color;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).front;
};

setStatusText = { |win, string|
    var host, rect, key;
    host = win.view;
    rect = Rect(8, 6, (host.bounds.width - 16).max(120), 22);
    key = \statusText;

    mkOrGetView.(win, key, { |parent|
        var tv = StaticText(parent);
        tv.stringColor = Color.black;
        tv.background = Color(1, 1, 0.6, 0.8);
        tv.align = \left;
        tv
    }).bounds = rect;

    mkOrGetView.(win, key, { |parent| StaticText(parent) }).string = string.asString;
    mkOrGetView.(win, key, { |parent| StaticText(parent) }).front;
};

setChoicesText = { |win, lines|
    var host, x, y, w, h, key, text;
    host = win.view;
    x = (host.bounds.width - 360).clip(8, host.bounds.width - 120);
    y = 40;
    w = 352;
    h = 220;
    text = (lines ? []).collect(_.asString).join("\n");
    key = \choicesText;

    mkOrGetView.(win, key, { |parent|
        var box = TextView(parent);
        box.string = text.size > 0.if({ text }, { "‚Äî" });
        box.background = Color(0.95, 0.98, 1.0, 0.85);
        box.editable = false;
        box.hasVerticalScroller = true;
        box
    }).bounds = Rect(x, y, w, h);

    mkOrGetView.(win, key, { |parent| TextView(parent) }).string = text.size > 0.if({ text }, { "‚Äî" });
    mkOrGetView.(win, key, { |parent| TextView(parent) }).front;
};

adoptPerfHUD = {
    var win;
    win = findHudWindow.();
    if(win.isNil) {
        "HUD adapter: no MagicDisplayGUI window found (PerfHUD expected).".warn;
        ^nil
    };

    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            setSolidHighlight.(win, which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            setStatusText.(win, text.asString);
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            setChoicesText.(win, lines ? []);
            nil
        })
    };
    "HUD adapter: PerfHUD overlays installed (solid A/B, status, choices).".postln;
};

// ---- Install adapter ---------------------------------------------------------
AppClock.sched(0.00, {
    var win;
    win = findHudWindow.();

    // Prefer GridDemo if controller is present and methods exist
    if(isGridDemo.()) {
        adoptGridDemo.();
    }{
        // Otherwise, adopt PerfHUD (overlays) if its window exists
        if(win.notNil) {
            adoptPerfHUD.();
        }{
            "HUD adapter: no GUI found yet; will try again shortly.".warn;
            AppClock.sched(0.10, {
                var win2 = findHudWindow.();
                if(isGridDemo.()) { adoptGridDemo.() } { if(win2.notNil) { adoptPerfHUD.() } };
                nil
            });
        };
    };
    nil
});
)

===== troubleshooting/01b_StartHere_NoReboot copy.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.2
// MD 20250929-0918

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

//new
~gui = Window.allWindows.detect { |w| w.name.asString.beginsWith("MagicDisplayGUI") };

ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_StartHere_NoReboot.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)

===== troubleshooting/01b_StartHere_NoRebootBROKEN.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-11:46

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoid reboot races; opens the single GUI window; enables GUI taps.
// - Force GridDemo for these tests (PerfHUD pulses and lacks setOperations).
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef, pedalboardRef, guiRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, closeMagicDisplayWindows;
var installGridDemo, bindDisplay, afterBringUp;

// ---------- helpers ----------

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0).source.isNil)    { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, { // neutral; 02D will replace with centered pulses
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, 0.0)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

closeMagicDisplayWindows = {
    var wins = Window.allWindows.select({ |w|
        var nm = w.tryPerform(\name) ? "";
        nm.asString.beginsWith("MagicDisplayGUI")
    });
    AppClock.sched(0.00, { wins.do(_.close); nil });
};

installGridDemo = {
    // Create GridDemo and publish it
    AppClock.sched(0.05, {
        guiRef = MagicDisplayGUI_GridDemo.new;        // <- concrete GUI
        ~gui   = guiRef;                               // publish for step scripts
        // if LPS carries the variable, update it too (it‚Äôs a <> ivar, settable)
        if(systemRef.notNil and: { systemRef.respondsTo(\statusDisplay_) }) {
            systemRef.statusDisplay_(guiRef);
        };
        // bind display to pedalboard if possible
        bindDisplay.value;
        // meters off->on to ensure responders
        if(guiRef.respondsTo(\enableMeters)) { guiRef.enableMeters(false); guiRef.enableMeters(true) };
        guiRef.showExpectation("System ready.", 0);
        guiRef.window.front.alwaysOnTop_(true);
        nil
    });
};

bindDisplay = {
    pedalboardRef = systemRef.pedalboard;
    if(pedalboardRef.notNil and: { pedalboardRef.respondsTo(\setDisplay) } and: { guiRef.notNil }) {
        pedalboardRef.setDisplay(guiRef);
    };
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll;            // this may load PerfHUD if present
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    // Note: when PerfHUD is used, statusDisplay stays nil; we‚Äôll force GridDemo next.
};

afterBringUp = { |lps|
    // Route short canonicals via adapter + post-switch meter re-arm
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };

    // If PerfHUD window was created, close it and switch to GridDemo
    AppClock.sched(0.05, {
        var win = findMagicDisplayWindow.();
        // If bringUpAll used PerfHUD, LivePedalboardSystem.statusDisplay is nil.
        if(lps.statusDisplay.isNil) {
            // Close the PerfHUD window (title contains "Performance HUD")
            if(win.notNil and: { win.name.asString.contains("Performance HUD") }) { win.close };
            installGridDemo.value; // create GridDemo, publish ~gui, bind to pedalboard
        } {
            // We already have a GUI object (GridDemo path)
            guiRef = lps.statusDisplay; ~gui = guiRef; bindDisplay.value;
            guiRef.window.front.alwaysOnTop_(true);
        };
        nil
    });
};

// ---------- run ----------

ensureAudioProxies.value;
startSystem.value;       // creates LPS + MPB; may open PerfHUD
closeMagicDisplayWindows.value;  // ensure only one window survives (we‚Äôll reinstall)
afterBringUp.(systemRef);
)

===== troubleshooting/01b.1_HUD_Ensure_GridDemo.scd =====
// 01b.1_HUD_Ensure_GridDemo.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Close any existing MagicDisplayGUI windows (including PerfHUD) and bring up GridDemo
   so highlighting is NON-PULSING.
 - Set ~gui to the GridDemo controller and front the window.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeWindows, bringGrid, frontIt;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller object (not a Window)
};

frontIt = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA); // make it obvious we‚Äôre on A
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo_v0.1.0.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemoREJECTED.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01c_PerfHUD_CompatAdapter.scd =====
//////////////////////////////////////////////////////////////
// 01c_PerfHUD_CompatAdapter.scd
// v0.9.0  MD 2025-09-29 12:35
//
// Purpose
// - Add a minimal, GridDemo-compatible layer on top of the existing
//   PerfHUD window (meters/layout unchanged).
// - Provide these helpers for test scripts:
//     ~hud_highlightCurrentColumn.(\chainA | \chainB)  // solid, no pulse
//     ~hud_showExpectation.("text", secs?)             // top status line
//     ~hud_updateTextField.(\state, "text")            // compat alias
//     ~hud_setOperations.([ "fret 3 ‚Üí add", "fret 5 ‚Üí ‚Ä¶" ])
//
// Style
// - var-first; descriptive names; AppClock-only for UI; no server.sync.
// - Nil-safe: aborts cleanly if no PerfHUD window is found.
// - Does NOT modify PerfHUD's own ticker; simply draws opaque overlays.
//
(
var win, host, hasWindow, ensureOverlays, relayoutOverlays;
var overlayLeft, overlayRight, statusLabel, choicesText;
var drawSolidA, drawSolidB, setStatus, setChoices, attachResize;

////////////////////////////////////////////////////////////
// 0) Find the PerfHUD window synchronously
win = ~gui;   // you already set this in 01b; it prints as a Window
hasWindow = win.notNil and: { win.isKindOf(Window) };
if(hasWindow.not) {
    "PerfHUD_CompatAdapter: ~gui is not a Window; aborting adapter.".warn;
    ^nil;
};

// Root view of the window
host = win.tryPerform(\view);
if(host.isNil) {
    "PerfHUD_CompatAdapter: window has no .view; aborting adapter.".warn;
    ^nil;
};

////////////////////////////////////////////////////////////
// 1) Create overlays (idempotent)
ensureOverlays = {
    var b, halfW, pad, topY, colH, rightX, rightW;
    b = host.bounds;  // Rect in UI coords (origin at top-left in View)
    pad = 8;
    halfW = (b.width / 2).asInteger;

    // reserve a small top bar for status
    topY = pad;
    // columns height = full minus top/status area and a small bottom pad
    colH = (b.height - (pad*3) - 180).max(40);

    // LEFT column overlay (Chain A)
    overlayLeft = overlayLeft ?? { CompositeView(host) };
    overlayLeft.bounds = Rect(pad, topY + 28, halfW - (pad*1.5), colH);
    overlayLeft.background = Color(0.85, 1.0, 0.85, 1.0);  // ACTIVE-green
    overlayLeft.visible = false; // default off; we turn it on in highlight
    overlayLeft.front;

    // RIGHT column overlay (Chain B)
    rightX = halfW + (pad * 0.5);
    rightW = b.width - rightX - pad;
    overlayRight = overlayRight ?? { CompositeView(host) };
    overlayRight.bounds = Rect(rightX, topY + 28, rightW, colH);
    overlayRight.background = Color(0.85, 1.0, 0.85, 1.0);
    overlayRight.visible = false;
    overlayRight.front;

    // STATUS label at very top (compatible with showExpectation / updateTextField(\state))
    statusLabel = statusLabel ?? { StaticText(host) };
    statusLabel.bounds = Rect(pad, pad, b.width - (pad*2), 22);
    statusLabel.align = \center;
    statusLabel.stringColor = Color.black;
    statusLabel.string = "Ready";
    statusLabel.front;

    // CHOICES text (right side, under the status bar)
    choicesText = choicesText ?? { TextView(host) };
    choicesText.bounds = Rect(halfW + (pad * 0.5), overlayRight.bounds.top - 22, rightW, 160);
    choicesText.editable = false;
    choicesText.hasVerticalScroller = true;
    choicesText.background = Color(0.97, 0.97, 0.97);
    choicesText.string = ""; // empty until setOperations call
    choicesText.front;
};

relayoutOverlays = {
    AppClock.sched(0.0, { ensureOverlays.value; nil });
};

////////////////////////////////////////////////////////////
// 2) Small helpers used by the tests (GridDemo-compatible)

drawSolidA = { // solid ACTIVE on A
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = true;
        overlayRight.visible = false;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

drawSolidB = { // solid ACTIVE on B
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = false;
        overlayRight.visible = true;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

setStatus = { |textString = "Ready", seconds = 0|
    AppClock.sched(0.0, {
        ensureOverlays.value;
        statusLabel.string = textString.asString;
        nil
    });
};

setChoices = { |itemsArray|
    var s;
    s = (itemsArray ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        ensureOverlays.value;
        choicesText.string = (s.size > 0).if({ s }, { "‚Äî" });
        choicesText.scrollToTop;
        nil
    });
};

////////////////////////////////////////////////////////////
// 3) Public tilde helpers (what your 02B / 02F will call if ~gui lacks methods)

~hud_highlightCurrentColumn = { |which|
    var w = (which ? \chainA).asSymbol;
    if(w == \chainA) { drawSolidA.value } { drawSolidB.value };
};

~hud_showExpectation = { |text, secs = 0| setStatus.value(text, secs) };

~hud_updateTextField = { |keySym, valueText|
    var k = keySym.asSymbol;
    if(k == \state) { setStatus.value(valueText.asString, 0) }
    { /* ignore other keys for now; extend later if needed */ };
};

~hud_setOperations = { |itemsArray| setChoices.value(itemsArray) };

////////////////////////////////////////////////////////////
// 4) Keep overlays in place on window resize
attachResize = {
    var resizeFunc;
    resizeFunc = {
        relayoutOverlays.value;
        nil
    };
    win.onResize = { resizeFunc.value };
};

////////////////////////////////////////////////////////////
// 5) Go
ensureOverlays.value;
attachResize.value;
"PerfHUD_CompatAdapter installed: uses ~hud_* helpers (solid A/B + status + choices).".postln;
)

===== troubleshooting/01c_PerfHUD_CompatAdapter.scd_v0.1.1 =====
//////////////////////////////////////////////////////////////
// 01c_PerfHUD_CompatAdapter.scd  (patch: resize + layout guard)
// v0.1.1  MD 2025-09-29

(
var win, host, ensureOverlays, relayoutOverlays;

// 1) Find the PerfHUD window by its title prefix (unchanged)
win = Window.allWindows.detect({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
});

if (win.isNil) {
    "01c: PerfHUD window not found; compat overlay skipped.".warn;
    ^nil;
};

// 2) Always work off the TopView, not the Window
host = win.view;

// 3) Your existing overlay builders go here (unchanged)
ensureOverlays = {
    // create or fetch CompositeView/TextView/StaticText children under `host`
    // ‚Ä¶ your current code ‚Ä¶
};

// 4) Relayout uses host.bounds (view coords)
relayoutOverlays = {
    var b = host.bounds, w = b.width, h = b.height;
    ensureOverlays.value;
    // recompute bounds for your overlay views using w/h
    // ‚Ä¶ your current code ‚Ä¶
};

// 5) Do an initial layout on AppClock
AppClock.sched(0.00, { relayoutOverlays.value; nil });

// 6) Hook resize on the **view**, not the window
if (host.respondsTo(\onResize_)) {
    host.onResize_{ relayoutOverlays.value };
};
)

===== troubleshooting/02_ForceMeters_FromBuses.scd =====
// 02_ForceMeters_FromBuses.scd
// v0.1.1
// MD 20250928-1935

(
// Purpose
// - Bypass older meter paths. Tap Ndef buses directly and send on "/md/levels_bus".
// - Correct parsing: SendReply => msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R.
// Style
// - var-first; no server.sync; server ops in Server.default.bind.

var makeTapDefOnce, installBusTaps, installHudReceiver, aBus, bBus, tBus;

makeTapDefOnce = {
    SynthDef(\md_busTap2, { |inBus=0, rate=24, replyID=2001|
        var sig, aL, aR;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).clip(0, 1);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [aL, aR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap2 installed.".postln;
};

installBusTaps = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, aBus, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, bBus, \rate, 24, \replyID, 2002]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, tBus, \rate, 24, \replyID, 1001]);
        "üì° Bus taps active (A=2001 / B=2002 / Test=1001).".postln;
    });
};

installHudReceiver = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        var id, l, r;
        if(msg.size < 5) { nil } {
            id = msg[2].asInteger;         // 2001 / 2002 / 1001
            l  = msg[3].asFloat.clip(0,1); // left
            r  = msg[4].asFloat.clip(0,1); // right
            ~md_levelsById.put(id, [l, r]);
            ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] listening /md/levels_bus (key=md_levels_hud; ids 2001/2002/1001)".postln;
};

makeTapDefOnce.value;
installBusTaps.value;
installHudReceiver.value;
"‚úÖ Forced bus meters installed; HUD bridged to dict.".postln;
)

===== troubleshooting/02A_Sanity_Wire_ChainA.scd =====
// 02A_Sanity_Wire_ChainA.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Ensure a real, steady signal reaches Chain A‚Äôs bus; keep Chain B silent.
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainA) <<> Ndef(\testmelody);  // Chain A <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainA).play;   // run A
        Ndef(\chainB).stop;   // keep B off for clarity
    });
    "üîó Wired: testmelody -> chainA; chainA is playing (B is stopped).".postln;
};

link.value;
start.value;
)

===== troubleshooting/02A_Sanity_Wire_ChainB.scd =====
// 02A_Sanity_Wire_ChainB.scd
// v0.1.0
// MD 20250929-1010

(
// Purpose
// - Route the same centered pulse source to chainB and play B (A can remain on).
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainB) <<> Ndef(\testmelody);   // Chain B <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainB).play;                // run B
        // (leave A as-is; you can stop it if you want: Ndef(\chainA).stop)
    });
    "üîó Wired: testmelody -> chainB; chainB is playing.".postln;
};

link.value;
start.value;
)

===== troubleshooting/02B_ForceMeters_FromBuses_dB.scd =====
// 02B_ForceMeters_FromBuses_dB.scd
// v0.1.2
// MD 20250929-0838

(
// Purpose
// - Replace bus taps with server-side dB-mapped meters (‚àí60 dB -> 0.0, 0 dB -> 1.0).
// - Keep using the existing /md/levels_bus receiver (ids: 2001=A, 2002=B, 1001=test).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, replaceBusTaps_dB, aBus, bBus, tBus;

minDB = -60;  // raise to -48 or -42 if you want hotter bars

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);  // avoid -inf
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046;                           // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);                            // clamp to floor
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);              // map -60..0 -> 0..1
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);           // gentle smoothing
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

replaceBusTaps_dB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, tBus, \rate, 24, \replyID, 1001, \floorDB, minDB]);
    });
    ("üì° Bus taps replaced with dB mapping (floor = " ++ minDB.asString ++ " dB).").postln;
};

makeTapDefOnce.value;
replaceBusTaps_dB.value;
"‚úÖ 02B dB taps active; HUD continues on /md/levels_bus (md_levels_hud).".postln;
)

===== troubleshooting/02B_HUD_AB_StrictAOnly copy.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.3
// MD 20250929-1153

(
var gui, applySolidA;

gui = ~gui;

applySolidA = {
    // Prefer GridDemo API if present
    if(gui.notNil and: { gui.respondsTo(\highlightCurrentColumn) }) {
        gui.highlightCurrentColumn(\chainA);
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_highlightCurrentColumn.notNil) {
            ~hud_highlightCurrentColumn.(\chainA);
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0);
            };
        } {
            "02B: No HUD adapter (~hud_*) and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid highlight.
 - Optional: stop demo overlays/meters if those extensions are loaded.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, setSolidA;

gui = ~gui; // provided earlier in your run (01b_StartHere_NoReboot / HUD bring-up)

// do nothing if HUD missing
if(gui.isNil) { "02B_HUD_AB_StrictAOnly: ~gui is nil (skipping).".warn; ^nil; };

setSolidA = {
    // 1) Solid highlight on Chain A (GridDemo API)
    if(gui.respondsTo(\highlightCurrentColumn)) {
        gui.highlightCurrentColumn(\chainA);
    };

    // 2) Optional: stop demo visual drivers if present (extensions)
    if(gui.respondsTo(\testMeter_stop)) { gui.testMeter_stop };
    if(gui.respondsTo(\testMarker_clear)) { gui.testMarker_clear };

    // 3) Small confirmation in the status line
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
    };
};

// Schedule on AppClock to be safe for UI operations
AppClock.sched(0.0, { setSolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd =====
//02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd
//v0.2.0
//MD 20250929-13:05

/* Purpose
   - Show Chain A as ACTIVE with a solid highlight in the current HUD.
   - Works with either GridDemo controller (~gui respondsTo \highlightCurrentColumn)
     or the PerfHUD window (~gui is a Window) by drawing an overlay.
Style
   - var-first; AppClock-only UI; no server.sync; idempotent; single-window policy.
*/

(
var ensureGui, useGridDemo, usePerfHUD, makeOverlay, drawSolidA, win;

ensureGui = {
    if(~gui.isNil) {
        // Grab whichever MagicDisplayGUI window exists (likely PerfHUD)
        ~gui = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
    };
    if(~gui.isNil) { "02B: No MagicDisplayGUI window found.".warn; };
    win = if(~gui.isKindOf(Window)) { ~gui } { ~gui.tryPerform(\window) };
    if(win.notNil) { AppClock.sched(0.00, { win.front.alwaysOnTop_(true); nil }) };
};

useGridDemo = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
        if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };   // stop any demo meter overlay if present
        if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
        if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        ^true
    };
    ^false
};

// Draws/updates a translucent overlay on left or right half of the window.
makeOverlay = { |w|
    var root, ov, aTint, bTint;
    root = w.tryPerform(\view);
    if(root.isNil) { ^nil };

    ov = w.getProperty(\md_overlay);
    if(ov.isNil) {
        ov = CompositeView(root);
        ov.name_("MD_OVERLAY");
        ov.resize = 5; // eLeft + eTop + eRight + eBottom
        w.setProperty(\md_overlay, ov);
    };

    // two half-width child views: left = A, right = B
    aTint = w.getProperty(\md_overlay_A);
    if(aTint.isNil) {
        aTint = CompositeView(ov); aTint.name_("MD_OVERLAY_A");
        w.setProperty(\md_overlay_A, aTint);
    };
    bTint = w.getProperty(\md_overlay_B);
    if(bTint.isNil) {
        bTint = CompositeView(ov); bTint.name_("MD_OVERLAY_B");
        w.setProperty(\md_overlay_B, bTint);
    };

    // lay out halves
    ov.bounds = root.bounds;
    aTint.bounds = Rect(0, 0, ov.bounds.width/2, ov.bounds.height);
    bTint.bounds = Rect(ov.bounds.width/2, 0, ov.bounds.width/2, ov.bounds.height);

    // gentle green & neutral tints
    aTint.background = Color(0.85, 1.0, 0.85, 0.50);
    bTint.background = Color(0.92, 0.92, 0.92, 0.00); // start hidden
    ov.front;

    // keep overlay aligned on resize
    if(w.onResize.isNil) {
        w.onResize = {
            var rb = root.bounds;
            ov.bounds = rb;
            aTint.bounds = Rect(0, 0, rb.width/2, rb.height);
            bTint.bounds = Rect(rb.width/2, 0, rb.width/2, rb.height);
        };
    };
    ^w
};

drawSolidA = { |w|
    var ov, aTint, bTint;
    ov = w.getProperty(\md_overlay);
    if(ov.isNil) { makeOverlay.(w) };
    aTint = w.getProperty(\md_overlay_A);
    bTint = w.getProperty(\md_overlay_B);
    if(aTint.notNil) { aTint.background = Color(0.85, 1.0, 0.85, 0.50) };
    if(bTint.notNil) { bTint.background = Color(0.92, 0.92, 0.92, 0.00) };
};

AppClock.sched(0.00, {
    ensureGui.value;
    if(~gui.isNil) { ^nil };
    if(useGridDemo.value.not) {
        // PerfHUD path
        if(win.notNil) {
            makeOverlay.(win);
            drawSolidA.(win);
        };
    };
    nil
});
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_v0.1.4.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:05

/* Purpose
   - Force Chain A to display as ACTIVE with a solid, non-pulsing highlight.
   - Uses the HUD adapter if available (~hud_highlightCurrent), else tries GridDemo.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/

(
var apply;

apply = {
    if(~hud_highlightCurrent.notNil) {
        ~hud_highlightCurrent.(\chainA);
        if(~hud_showExpectation.notNil) { ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0) };
    }{
        // Fallback for raw GridDemo controller if adapter missing
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        }{
            "02B: No HUD adapter and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { apply.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid (non‚Äëpulsing) highlight.
 - If ~gui is nil, bring up GridDemo and set ~gui first (single window).
Style
 - var-first; AppClock UI; no server.sync; nil-safe responders; idempotent.
*/

(
var ensureGui, applySolidA;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

applySolidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
    };
    // Shut off any optional demo overlays if present (nil-safe)
    if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };
    if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
};

AppClock.sched(0.00, { ensureGui.value; applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_Receiver_dB_Map.scd =====
// 02B_HUD_Receiver_dB_Map.scd
// v0.1.1
// MD 20250928-2050

(
// Purpose
// - Reinstall the HUD OSCdef to read the *linear* bus taps from "/md/levels_bus"
//   and convert them to a log/decibel-like visual scale on the *language* side.
// - No UGens here; only language methods (known-good): .ampdb, .max, arithmetic.
// - Mapping: floor = -60 dB -> 0.0, 0 dB -> 1.0 (adjust floor as needed).
// Style
// - var-first; no server.sync; UI/OSC on language side; no non-local returns.

var key, minDB, mapToMeter;

// ---- settings ----
key   = \md_levels_hud;  // the same key PerfHUD expects
minDB = -60.0;           // raise to -48 or -42 if you want hotter-looking bars

// ---- mapping function (language side) ----
mapToMeter = { |amp|
    var db, v;
    // guard tiny values to avoid -inf
    db = amp.max(1e-9).ampdb;    // amp -> dB (language method)
    db = db.max(minDB);          // clamp floor
    // map -60..0 dB -> 0..1
    v = (db - minDB) / (0 - minDB);
    v.clip(0, 1)
};

// ---- reinstall the OSCdef safely ----
if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
~md_lastMsgStamp = SystemClock.seconds.asFloat;

OSCdef(key, { |msg|
    // SendReply -> msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R
    var id, lAmp, rAmp, l, r;
    if(msg.size >= 5) {
        id   = msg[2].asInteger;
        lAmp = msg[3].asFloat;
        rAmp = msg[4].asFloat;
        l = mapToMeter.(lAmp);
        r = mapToMeter.(rAmp);
        ~md_levelsById.put(id, [l, r]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);

("[HUD] md_levels_hud reinstalled (dB map; floor = " ++ minDB.asString ++ " dB)").postln;
)

===== troubleshooting/02B_Taps_dB_NoTest_and_HUD.scd =====
// 02B_Taps_dB_NoTest_and_HUD.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose
// - Install server-side dB-mapped taps for Chain A and Chain B only (no "test").
// - Reinstall the HUD receiver to read "/md/levels_bus" and update dict keys:
//   2001 (A) and 2002 (B).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, installBusTaps_dB_AB, installHudReceiver_AB, aBus, bBus;
minDB = -60;  // try -48 for hotter visuals

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046; // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

installBusTaps_dB_AB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        "üì° Bus taps (dB) active for A/B only (floor=" ++ minDB.asString ++ " dB).".postln;
    });
};

installHudReceiver_AB = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        // SendReply => [ path, nodeID, replyID, L, R ]
        var id, l, r;
        if(msg.size >= 5) {
            id = msg[2].asInteger;          // 2001 or 2002
            if((id == 2001) or: { id == 2002 }) {
                l = msg[3].asFloat.clip(0,1);
                r = msg[4].asFloat.clip(0,1);
                ~md_levelsById.put(id, [l, r]);
                ~md_lastMsgStamp = SystemClock.seconds.asFloat;
            };
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] md_levels_hud listening on /md/levels_bus (A/B only).".postln;
};

makeTapDefOnce.value;
installBusTaps_dB_AB.value;
installHudReceiver_AB.value;
"‚úÖ dB taps installed and HUD receiver set (A=2001, B=2002).".postln;
)

===== troubleshooting/02C_Testmelody_Level_Boost.scd =====
// 02C_Testmelody_Level_Boost.scd
// v0.1.0
// MD 20250928-2015
(
// Purpose: temporarily raise testmelody output so meters are clearly visible.
// Style: var-first; server ops in Server.default.bind.

var boost;
boost = {
    Server.default.bind({
        // Reinstall the same testmelody with a slightly higher amp (0.22 -> 0.40)
        Ndef(\testmelody, {
            var trig = Impulse.kr(2.4);
            var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
            var scale = [60, 62, 64, 67, 69];
            var f = Select.kr(sel, scale).midicps;
            var env = Decay2.kr(trig, 0.01, 0.35);
            var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
            Pan2.ar(SinOsc.ar(f) * env * 0.40, pan)  // <-- boosted
        });
    });
    "‚¨ÜÔ∏è testmelody amp boosted (0.40).".postln;
};
boost.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02E_Meter_Floor_Adjust.scd =====
// 02E_Meter_Floor_Adjust.scd
// v0.1.0
// MD 20250929-0912

(
// Purpose
// - Adjust the dB floor used by the md_busTap_db Synths on the fly.
// - Example sets floor to -48 dB (hotter visuals). Re-run with -60 to restore.
// Style
// - var-first; server ops in Server.default.bind.

var setFloorDB;

setFloorDB = { |floorDB = -48|
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.set(\floorDB, floorDB) };
        if(~md_busTapB.notNil) { ~md_busTapB.set(\floorDB, floorDB) };
        if(~md_busTapT.notNil) { ~md_busTapT.set(\floorDB, floorDB) };
    });
    ("üìè Meter floor set to " ++ floorDB.asString ++ " dB").postln;
};

// Try -48 for a start, or -42 if you want it hotter:
setFloorDB.(-48);
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming copy.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.0
// MD 20250929-1121

/* Purpose
   - Write demo "system state", "choices", and "incoming" text into the existing HUD window.
   - Use the GUI's public API if available:
       showExpectation(String, Int)
       updateTextField(\state | \choices | \lastCommand, String)
   - No server changes; AppClock-only for UI.
   - var-first; lowercase; no server.sync.
*/

(
var g, have, pushStatus, pushChoices, pushIncoming;

g = ~system.notNil.if({ ~system.statusDisplay }, { nil }); // prefer your system GUI if present
have = { |selector| g.notNil and: { g.respondsTo(selector) } };

pushStatus = {
    var text;
    text = "State: serverRunning=true, activeChain=A (demo)\nGroups=(true,true)";
    if(have.(\updateTextField)) { g.updateTextField(\state, text) };
    if(have.(\showExpectation)) { g.showExpectation("System ready ‚Äî demo text injected", 0) };
};

pushChoices = {
    var txt;
    txt = "Choices:\nFret 7: delay\nFret 9: chorus\nFret 11: reverb\nFret 13: drive";
    if(have.(\updateTextField)) { g.updateTextField(\choices, txt) };
};

pushIncoming = {
    var txt;
    txt = "Incoming: key:a ‚Ä¢ key:b ‚Ä¢ key:r (rebuild)";
    if(have.(\updateTextField)) { g.updateTextField(\lastCommand, txt) };
};

// Defer UI calls to AppClock
{
    pushStatus.();
    pushChoices.();
    pushIncoming.();
}.defer;

"[*] 02F: demo HUD text pushed (state/choices/incoming)".postln;
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Write demo text to the HUD (state / choices / incoming).
 - Uses the public GridDemo API: showExpectation/updateTextField/setOperations.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, pushStateAndChoices;

gui = ~gui; // should be set by your earlier HUD bring-up step

if(gui.isNil) { "02F_HUD: ~gui is nil (skipping).".warn; ^nil; };

pushStateAndChoices = {
    // 0) (Optional) ensure the Choices panel exists (extension is nil-safe)
    if(gui.respondsTo(\ensureChoicesPanel)) { gui.ensureChoicesPanel };

    // 1) Top status / state line
    if(gui.respondsTo(\updateTextField)) {
        gui.updateTextField(\state, "Mode: treeNav ¬∑ A=ACTIVE");
    } {
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("Mode: treeNav ¬∑ A=ACTIVE", 0);
        };
    };

    // 2) Choices list (each line = ‚Äúfret ‚Üí name‚Äù)
    if(gui.respondsTo(\setOperations)) {
        gui.setOperations([
            "fret 3 ‚Üí add",      // example entries; replace with your actual current node‚Äôs options
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ]);
    };

    // 3) ‚ÄúIncoming‚Äù (GridDemo doesn‚Äôt have a dedicated box; use status line)
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("Incoming: demo-key:a ¬∑ demo-key:r", 0);
    };
};

// Defer to AppClock for UI safety
AppClock.sched(0.0, { pushStateAndChoices.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.3.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.3
// MD 2025-09-29 12:35

(
var gui, pushHUD;

gui = ~gui;

pushHUD = {
    var choicesLines;
    choicesLines = [
        "fret 3 ‚Üí add",
        "fret 5 ‚Üí timebased",
        "fret 7 ‚Üí modulation",
        "fret 9 ‚Üí filter"
    ];

    // Prefer GridDemo API
    if(gui.notNil and: { gui.respondsTo(\updateTextField) or: { gui.respondsTo(\showExpectation) } }) {
        if(gui.respondsTo(\updateTextField)) {
            gui.updateTextField(\state, "Mode: treeNav ¬∑ A=ACTIVE");
        } {
            gui.showExpectation("Mode: treeNav ¬∑ A=ACTIVE", 0);
        };
        if(gui.respondsTo(\setOperations)) {
            gui.setOperations(choicesLines);
        } {
            // fallback to status if no choices panel in that class
            gui.showExpectation("Choices:\n" ++ choicesLines.join("\n"), 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_updateTextField.notNil) {
            ~hud_updateTextField.(\state, "Mode: treeNav ¬∑ A=ACTIVE");
        } { if(~hud_showExpectation.notNil) { ~hud_showExpectation.("Mode: treeNav ¬∑ A=ACTIVE", 0) } };
        if(~hud_setOperations.notNil) {
            ~hud_setOperations.(choicesLines);
        } {
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("Choices:\n" ++ choicesLines.join("\n"), 0);
            };
        };
    };
};

AppClock.sched(0.0, { pushHUD.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.4.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Write demo text to the HUD via the overlay helpers created by 02H:
   ‚Ä¢ STATE line
   ‚Ä¢ CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
 - Assumes 02H_GridDemo_MinHUD_Overlay.scd has already run in this session.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    // If overlay is missing for any reason, create it on the fly:
    if(~gui.isNil or: { ~gui.tryPerform(\window).isNil }) {
        // fall back to GridDemo and create overlay
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    // If helper funcs don‚Äôt exist yet, synthesize the minimal overlay now:
    if(~hud_setState.isNil or: { ~hud_setChoices.isNil }) {
        // create a tiny overlay inline (same as 02H but shorter)
        var host, r, panel, stateBox, choicesBox, pad = 8, width = 360, height = 220, titleH = 18;

        host = ~gui.tryPerform(\window).tryPerform(\view);
        r = host.bounds;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.30);
        panel.bounds = Rect(r.width - (width + 12), 12, width, height);

        StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
            .stringColor_(Color(1,1,1,0.8))
            .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color.white)
            .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
            .font_(Font("Monaco", 11))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color(0.95,0.95,0.95))
            .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ‚Äî‚Äî‚Äî Actual demo content push ‚Äî‚Äî‚Äî
    ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE");
    ~hud_setChoices.([
        "fret 3 ‚Üí add",
        "fret 5 ‚Üí timebased",
        "fret 7 ‚Üí modulation",
        "fret 9 ‚Üí filter"
    ]);
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.5
// MD 2025-09-29 13:28 BST

/* Purpose
 - Write demo text to the HUD via overlay helpers created by 02H/02M:
   ‚Ä¢ STATE line
   ‚Ä¢ CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    var host, overlay;

    // Ensure ~gui and overlay exist
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });

    if(overlay.isNil) {
        // run 02H inline if needed (minimal version)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;
        r = host.bounds; width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ‚Äî‚Äî‚Äî Actual content push ‚Äî‚Äî‚Äî
    (~hud_setState !? { ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 ‚Üí add",
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ])
    });
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.0.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.0
// MD 20250929-1310

/* Purpose
   - Add a small overlay HUD panel (STATE + CHOICES) on top of GridDemo,
     without using GridDemo's internal ivars/methods (which are erroring in your build).
   - Export two helpers: ~hud_setState.(textString), ~hud_setChoices.([lines]).
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

// 1) Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

// 2) Remove any previous overlay if re-running
killOld = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

// 3) Create a small overlay panel at top-right
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds; // Rect
    width  = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30); // transparent dark
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    // 3a) Export helpers
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

// 4) Front and banner
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.1.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Add a small overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs ivars or buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.2.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs private ivars or its buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

/* Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller */
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

/* Remove any previous overlay if re-running */
killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

/* Create overlay at top-right (compact; draws above other widgets) */
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox;
    var pad, width, height, titleH, stateH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 320;          // narrower to avoid covering A/B headers
    height = 170;         // shorter; room for 5‚Äì7 lines
    pad = 8;
    titleH = 16;
    stateH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.28);         // translucent dark
    panel.decorator = FlowLayout(panel.bounds, 0@0, 0@0); // keeps children stable
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front; // ensure on top
    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.82))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 10))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.93,0.93,0.93))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + pad)
        ));

    // Export helpers:
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };

    positionTopRight = { arg margin = 10;
        var rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

/* Re-anchor overlay on window resize */
hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = {
            (~hud_moveTopRight !? { ~hud_moveTopRight.(10) });
        };
    };
};

/* Bring to front and seed banner */
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.3
// MD 2025-09-29 13:42 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs privates. Uses StaticText for guaranteed visibility.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

mkOverlay = {
    var host, r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360;                       // room for multi-line CHOICES
    height = 190;                      // compact but readable
    pad = 8;
    titleH = 16;
    stateH = 18;
    lineH = 14;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front;

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateLabel = StaticText(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.95))
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesLabel = StaticText(panel)
        .string_("CHOICES:")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH));

    choicesBox = StaticText(panel)
        .string_("(choices)")
        .align_(\topLeft)
        .font_(Font("Monaco", 10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6 + lineH + 2,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
        ));

    // ‚Äî‚Äî‚Äî Helpers (exported) ‚Äî‚Äî‚Äî
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, {
            stateLabel.string = textString.asString;
            nil
        });
    };

    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, {
            choicesBox.string = s.size > 0 ? s : "‚Äî";
            nil
        });
    };

    positionTopRight = { arg margin = 10;
        var rb;
        rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = { (~hud_moveTopRight !? { ~hud_moveTopRight.(10) }) };
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
    (~hud_setChoices !? { ~hud_setChoices.(["(no choices yet)"]) });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar_v0.1.0.scd =====
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.0
// MD 20250929-1258

/* Purpose
   - Attach tiny A/B bus meters to your existing taps (A=2001, B=2002)
     so GridDemo can display a moving meter bar via its TestMeter extension.
   - Then show a small horizontal "debug meter" inside the right panel, driven by /ampA.
Style
   - var-first; AppClock UI; Server.default.bind for server ops; no server.sync; idempotent.
*/

(
var aBus, bBus, mkMeters, showBar, killOld, ensureGui;

aBus = 2001;  // from your tap step (see console)
bBus = 2002;  // from your tap step (see console)

/* 0) Ensure we have a GridDemo GUI controller (non-pulsing)
      If you prefer PerfHUD for this run, skip this ensure block.
*/
ensureGui = {
    if(~gui.isNil) {
        // keep only one MagicDisplayGUI window
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

/* 1) Clean previous meter synths if we re-run */
killOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

/* 2) Create meter synths that publish /ampA and /ampB
      MagicDisplay already defines SynthDefs \busMeterA / \busMeterB (class init).
      We just need to instantiate them on our tap busses.
*/
mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // ‚Üí sends /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // ‚Üí sends /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

/* 3) Show a small moving meter bar in GridDemo (right panel, near 'eff:')
      Uses GridDemo‚Äôs TestMeter extension (if present). Safe if absent.
*/
showBar = {
    if(~gui.notNil and: { ~gui.respondsTo(\testMeter_attach) }) {
        // show chain A level; change to \B to view next chain
        ~gui.testMeter_attach(\A);
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensureGui.value;
killOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar.scd =====
//////////////////////////////////////////////////////////////
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.1
// MD 20250929-13:02
/* Purpose
   - Attach meter Synths to tap busses (A=2001, B=2002), emitting /ampA,/ampB.
//  - Display a small moving bar inside GridDemo (right panel) via TestMeter ext.
Style
   - var-first; Server.default.bind for synths; AppClock for UI; no server.sync.
*/

(
var aBus, bBus, mkMeters, stopOld, showBar, ensure;

aBus = 2001;  bBus = 2002;

ensure = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

stopOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // ‚Üí /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // ‚Üí /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

showBar = {
    if(~gui.respondsTo(\testMeter_attach)) {
        ~gui.testMeter_attach(\A);   // or \B to view NEXT
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensure.value;
stopOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.0.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.0
// MD 20250929-13:10

/* Purpose
   - Show a simple horizontal meter bar driven by your existing taps (A=2001, B=2002).
   - Avoid GridDemo TestMeter extension (which warns and OOC-returns in your build).
   - Instantiates \busMeterA / \busMeterB Synths if needed and listens to /ampA or /ampB.
Style
   - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, ensureSynths, killOld, mkBar, ampKey, oscKey;

aBus = 2001;  bBus = 2002;
whichChain = \A; // change to \B if you want to view NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        if(host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).not) {
            // bring up overlay if missing
            "02M: Overlay missing; creating‚Ä¶".postln;
            thisProcess.interpreter.executeFile(
                Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd"
            )
        };
    };
};

killOld = {
    // free previous synths + OSCdefs + view if re-running
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        // Define/instantiate lightweight bus meters (MagicDisplay provides the SynthDefs)
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };

    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    // OSC driver (choose /ampA or /ampB)
    ampKey = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey = ("mdg_simple_" ++ ampKey.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampKey);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.1.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Display a simple horizontal meter bar in the overlay, driven by your existing taps.
 - Uses MagicDisplay‚Äôs \busMeterA/\busMeterB SynthDefs (SendReply ‚Üí /ampA,/ampB).
 - Avoids GridDemo‚Äôs TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, ampPath, oscKey;

aBus = 2001;  // your tap buses (confirmed by console)
bBus = 2002;
whichChain = \A; // change to \B if you prefer watching NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, hasOverlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    hasOverlay = host.notNil and: { host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }) };
    if(hasOverlay.not) {
        // create overlay on the spot
        (
            var r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
            r = host.bounds; width = 360; height = 220; pad = 8; titleH = 18;
            panel = CompositeView(host).name_("MDG_MINHUD");
            panel.background = Color(0,0,0,0.30);
            panel.bounds = Rect(r.width - (width + 12), 12, width, height);
            title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
                   .stringColor_(Color(1,1,1,0.8)).bounds_(Rect(pad, pad, width - 2*pad, titleH));
            stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
                       .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                       .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));
            choicesBox = TextView(panel).string_("(choices)").editable_(false)
                         .font_(Font("Monaco", 11)).background_(Color(0,0,0,0.10))
                         .stringColor_(Color(0.95,0.95,0.95))
                         .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));
            ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
            ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                                AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        );
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Display a simple horizontal meter bar in the MIN-HUD overlay, driven by your taps.
 - Uses MagicDisplay‚Äôs \busMeterA/\busMeterB SynthDefs (SendReply ‚Üí /ampA,/ampB).
 - Avoids GridDemo‚Äôs TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain;
var ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, startOsc;

aBus = 2001;            // confirmed by your taps step
bBus = 2002;
whichChain = \A;        // set to \B to watch NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        // Create overlay quickly (same geometry as 02H)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;

        r = host.bounds;
        width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        ~hud_moveTopRight = { arg margin = 10;
            AppClock.sched(0.0, { panel.bounds = Rect(r.width - (width + margin), margin, width, height); panel.front; nil })
        };
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

startOsc = {
    var ampPath, oscKey;
    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; startOsc.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleMeters_FromOSC.scd =====
// 02M_GridDemo_SimpleMeters_FromOSC.scd
// v0.2.0
// MD 2025-09-29 13:42 BST

/* Purpose
 - Show a simple horizontal meter bar in the MIN-HUD overlay, driven directly by existing OSC taps.
 - Listens to any of these (whichever arrives first will drive the bar): /md/levels_gui, /md/levels, /ampA, /ampB.
 - Defaults to CURRENT (A). Set whichChain = \B to monitor NEXT instead.
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var whichChain, ensureGui, ensureOverlay, killOld, mkBar, startListeners, parseMsg, pickVal;

whichChain = \A;   // change to \B if you want NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        "02M: creating overlay (02H inline)".postln;
        thisProcess.interpreter.executeFile(Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd");
    };
};

killOld = {
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free; ~mdg_meterOSC_A = nil };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free; ~mdg_meterOSC_B = nil };
    if(~mdg_meterView.notNil)  { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 16;  // thicker bar

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

// Extract a normalized 0..1 value from a variety of message shapes
pickVal = { arg msg, wantB = false;
    var floats, vL, vR, v;
    // Common shapes:
    //  - ['/ampA', node, l, r] or ['/ampB', node, l, r]
    //  - ['/md/levels_gui', ..., lA, rA, lB, rB] (varies by sender)
    //  - ['/md/levels', ..., numbers...]         (varies by sender)
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        // Heuristic: last 4 floats are usually [lA, rA, lB, rB] (sanitised)
        if(floats.size >= 4) {
            if(wantB.not) {
                vL = floats.at(floats.size - 4);
                vR = floats.at(floats.size - 3);
            }{
                vL = floats.at(floats.size - 2);
                vR = floats.at(floats.size - 1);
            };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            // Fallback: mean of all floats
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startListeners = {
    var wantB, pathA1, pathA2, pathB1, pathB2, chainLabel;
    wantB = (whichChain == \B);
    chainLabel = (wantB.not).if({ "A" }, { "B" });

    pathA1 = (wantB.not).if({ '/ampA' }, { '/ampB' });
    pathA2 = (wantB.not).if({ '/md/levels_gui' }, { '/md/levels_gui' }); // we filter in pickVal
    pathB1 = (wantB.not).if({ '/ampA' }, { '/ampB' });  // both defs update same var
    pathB2 = (wantB.not).if({ '/md/levels' }, { '/md/levels' });

    // Free any previous listeners
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free };

    // Listener 1: /ampA or /ampB
    ~mdg_meterOSC_A = OSCdef(("mdg_meter_" ++ pathA1.asString).asSymbol, { |msg|
        var raw, sm;
        raw = pickVal.(msg, wantB);
        sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        ~mdg_meterVal = sm;
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, pathA1);

    // Listener 2: /md/levels_gui and /md/levels
    ~mdg_meterOSC_B = OSCdef(("mdg_meter_mix").asSymbol, { |msg|
        var raw, sm;
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            raw = pickVal.(msg, wantB);
            sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            ~mdg_meterVal = sm;
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // nil path: catch-all, we'll filter inside
    // Note: if the catch-all is too broad, change to two OSCdef with explicit paths.
    ("02M: meter listening for chain " ++ chainLabel ++ " on /ampA/B + /md/levels(_gui)").postln;
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    mkBar.value;
    startListeners.value;
    nil
});
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd =====
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap.scd =====
// 02S_AssertStereo_ChainAB_and_Retap.scd
// v0.1.0
// MD 20250929-0948

(
// Purpose
// - Force chainA/chainB to allocate *stereo* busses, then rewire A and reattach dB taps.
// - Clears stale 1001 (‚Äútest‚Äù) dict entry so HUD only shows A/B.
// Style
// - var-first; server ops in Server.default.bind.

var makeStereoBusses, rewireA, restartTaps, clearOldTestDict;

makeStereoBusses = {
    Server.default.bind({
        // Force stereo allocation by setting explicit stereo sources first
        Ndef(\chainA, { Silent.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { Silent.ar(2) }); Ndef(\chainB).ar(2);
        // Materialize bus width
        Ndef(\chainA).play;
        Ndef(\chainB).stop;
    });
    "üõ†Ô∏è Stereo busses asserted for chainA/chainB.".postln;
};

rewireA = {
    // Keep your exact operator
    Ndef(\chainA) <<> Ndef(\testmelody);
    "üîó Rewired: testmelody -> chainA.".postln;
};

restartTaps = {
    // Reinstall dB taps using existing SynthDef \md_busTap_db
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainA).bus.index, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainB).bus.index, \rate, 24, \replyID, 2002]);
    });
    "üì° dB taps restarted on asserted stereo busses (A/B).".postln;
};

clearOldTestDict = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_levelsById.removeAt(1001);  // remove ‚Äútest‚Äù so HUD can‚Äôt mirror it
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
};

makeStereoBusses.value;
rewireA.value;
restartTaps.value;
clearOldTestDict.value;

"‚úÖ Stereo confirmed, taps reattached. Expect both A bars moving, B near zero.".postln;
)

===== troubleshooting/03_Sanity_Beep.scd =====
// 03_Sanity_Beep.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose: Prove server + audio device are OK (audible 1-second beep).
// Style: var-first; no server.sync.

var playBeep;

playBeep = {
    if(s.serverRunning.not) { s.boot; s.waitForBoot({ "üîÅ Server booted for beep.".postln; }) };
    {
        var env = Env.perc(0.005, 0.9).ar(doneAction:2);
        var sig = SinOsc.ar(880) * 0.1 * env;
        Out.ar(0, sig.dup);
    }.play;
    "üîä Beep should be audible for ~1s.".postln;
};

playBeep.();
)

===== troubleshooting/04_Probes.scd =====
// 04_Probes.scd
// v0.1.0
// MD 20250928-1948

(
// A ‚Äî Dict snapshot used by the HUD (expect values < 1.0, changing)
var d = ~md_levelsById ? IdentityDictionary.new;
[1001, 2001, 2002].collect({ |k| [k, d[k]] }).postln;
)

(
// B ‚Äî Log a few /md/levels_bus messages (expect id, then two floats < 1.0)
~probeCount = 0;
if(OSCdef.all.at(\probe_levels_bus).notNil) { OSCdef(\probe_levels_bus).free };
OSCdef(\probe_levels_bus, { |msg|
    var id=msg[2], l=msg[3].asFloat, r=msg[4].asFloat;
    ("[bus] id=" ++ id.asString ++ " l=" ++ l.round(0.003) ++ " r=" ++ r.round(0.003)).postln;
    ~probeCount = (~probeCount ? 0) + 1;
    if(~probeCount >= 12) { OSCdef(\probe_levels_bus).free; "~probe done".postln; };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);
"probe armed /md/levels_bus".postln;
)

===== troubleshooting/98_PerfHUD_Triage_UIOnly.scd =====
// 98_PerfHUD_Triage_UIOnly.scd
// v0.1.0
// MD 2025-09-29 15:30 BST

/* Purpose
 - ZERO-OSC triage: prove we can paint + animate inside the PerfHUD window.
 - Draws a top RED banner, two wide bars near bottom; animates bars via AppClock.
 - Helpers:
     ~ui_wiggle_start.(\A or \B)   // start animation, tint active half
     ~ui_wiggle_stop.()            // stop + remove our overlays
Style
 - var-first; AppClock-only; idempotent; no server.sync; known-good SC API only.
*/

(
var findHudWin, findHost, debugPrintWindows, removeOverlays, makeBanner, makeBars, makeTint, startAnim, stopAnim;

// 0) enumerate windows for sanity
debugPrintWindows = {
    var names;
    names = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
    ("[triage] Windows: " ++ names).postln;
};

// 1) find the MagicDisplayGUI window and its host view
findHudWin = {
    var win;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    win
};

findHost = {
    var win, host, r;
    win = findHudWin.();
    if(win.isNil) { "[triage] MagicDisplayGUI window not found.".warn; ^nil };
    host = win.tryPerform(\view);
    r = host.tryPerform(\bounds);
    ("[triage] Host bounds: " ++ (r ? "<nil>")).postln;
    host
};

// 2) remove our overlays if present
removeOverlays = {
    var host;
    host = findHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["TRI_BANNER","TRI_BAR_A","TRI_BAR_B","TRI_TINT_A","TRI_TINT_B"].includes(n)
        }).do(_.remove);
    };
    if(~tri_task.notNil) { ~tri_task.stop; ~tri_task = nil };
    ~tri_valA = 0.0;
    ~tri_valB = 0.0;
};

// 3) big red banner at top (instant visual proof)
makeBanner = {
    var host, r, banner;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds;
    banner = UserView(host);
    banner.name = "TRI_BANNER";
    banner.bounds = Rect(0, 0, r.width, 18);
    banner.background = Color(1.0, 0.2, 0.2, 0.75); // red translucent
    banner.front;
    host.window.onResize = {
        var r2 = host.bounds;
        banner.bounds = Rect(0, 0, r2.width, 18);
        banner.refresh;
    };
    "[triage] Banner shown (top).".postln;
};

// 4) two wide bars near bottom (A green, B blue)
makeBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 12; h = 16; gap = 10;
    w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(30);
    yA = (yB - h - gap).max(10);

    barA = UserView(host);
    barA.name = "TRI_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.12);
    barA.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    barB = UserView(host);
    barB.name = "TRI_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.12);
    barB.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    host.window.onResize = {
        var r2, w2, yA2, yB2;
        r2 = host.bounds;
        w2 = (r2.width - (2*pad)).max(50);
        yB2 = (r2.height - pad - h).max(30);
        yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
    "[triage] Bars created (bottom).".postln;
};

// 5) translucent tint on left or right half to mark ACTIVE
makeTint = { arg which = \A;
    var host, r, midX, tintA, tintB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old
    host.children.select({ |v|
        var n = v.tryPerform(\name) ? "";
        ["TRI_TINT_A","TRI_TINT_B"].includes(n)
    }).do(_.remove);

    tintA = UserView(host);
    tintA.name = "TRI_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18);

    tintB = UserView(host);
    tintB.name = "TRI_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    host.window.onResize = {
        var r2 = host.bounds, mx = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx, r2.height);
        tintB.bounds = Rect(mx, 0, r2.width - mx, r2.height);
        tintA.refresh; tintB.refresh;
    };
    ("[triage] Active tint ‚Üí " ++ which.asString).postln;
};

// 6) animation (triangle wave) ‚Äî no OSC, UI-only
startAnim = { arg which = \A;
    var host, dt, t;
    host = findHost.(); if(host.isNil) { ^nil };

    removeOverlays.();
    makeBanner.();
    makeBars.();
    makeTint.(which);

    dt = 1/30; t = 0.0;
    ~tri_task = Task({
        loop {
            var a = (t % 1.0);   // 0..1 triangle
            var b = 1.0 - a;
            ~tri_valA = a;
            ~tri_valB = b;
            // refresh our bars only
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if((n == "TRI_BAR_A") or: { n == "TRI_BAR_B" }) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.6);
        }
    }).play(AppClock);

    "[triage] UI-only animation started.".postln;
};

stopAnim = {
    removeOverlays.();
    "[triage] UI-only animation stopped.".postln;
};

// Export helpers
~ui_wiggle_start = { arg which = \A; AppClock.sched(0.0, { debugPrintWindows.value; startAnim.(which); nil }) };
~ui_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };

"[triage] Ready: use ~ui_wiggle_start.(\\A) / ~ui_wiggle_stop.()".postln;
)

===== troubleshooting/99_HUD_GridDemo_OneShot.scd =====
// 99_HUD_GridDemo_OneShot.scd
// v0.1.1
// MD 2025-09-29 14:05 BST

/* Purpose
 - One-shot HUD bring-up for GridDemo (non-pulsing), replacing multiple files:
   ‚Ä¢ close old MagicDisplayGUI windows, bring up GridDemo, set ~gui
   ‚Ä¢ solid A highlight
   ‚Ä¢ overlay at top-right with STATE + CHOICES (StaticText only; guaranteed visible)
   ‚Ä¢ thicker moving meter bar driven by OSC taps (/ampA, /ampB, /md/levels_gui, /md/levels)
   ‚Ä¢ push demo STATE/CHOICES text
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns in closures.
Run
 - Run after audio/tap steps (e.g., after 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd).
 - To monitor NEXT (B) instead of CURRENT (A), set wantB = true below.
*/

(
var wantB;
var closeWindows, makeGridDemo, ensureReady, solidA, buildOverlay, pushDemoText;
var addMeterBar, startOscDefs, stopOldOscDefs, parseVal, retry;

// ===== CONFIG =====
wantB = false;  // false = monitor CURRENT (A); true = monitor NEXT (B)

// ===== HELPERS =====

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

makeGridDemo = {
    ~gui = MagicDisplayGUI_GridDemo.new;         // controller (not a Window)
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
};

ensureReady = { arg triesLeft = 20, thenDo = { } ;
    // Wait until ~gui.window.view is non-nil and has a Rect bounds
    AppClock.sched(0.03, {
        var win, host, ok;
        win = ~gui.tryPerform(\window);
        host = win.tryPerform(\view);
        ok = host.notNil and: { host.bounds.notNil };
        if(ok) { thenDo.value(host); nil } {
            if(triesLeft <= 0) { "99: window/view not ready; giving up.".warn; nil } {
                ensureReady.value(triesLeft - 1, thenDo);
            }
        }
    });
};

solidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) { ~gui.highlightCurrentColumn(\chainA) };
};

buildOverlay = { arg host;
    var r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    // Kill any old overlay
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);

    // Layout numbers (kept simple & safe)
    r = host.bounds;
    width = 360; height = 190;
    pad = 8; titleH = 16; stateH = 18; lineH = 14;

    panel = CompositeView(host);
    panel.name = "MDG_MINHUD";
    panel.background = Color(0,0,0,0.30);
    // no .border or decorators (avoids internal draw quirks)
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.front;

    title = StaticText(panel);
    title.string = "MIN-HUD";
    title.font   = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.85);
    title.bounds = Rect(pad, pad, width - 2*pad, titleH);

    stateLabel = StaticText(panel);
    stateLabel.string = "(state)";
    stateLabel.font   = Font("Monaco", 11);
    stateLabel.stringColor = Color(1,1,1,0.95);
    stateLabel.bounds = Rect(pad, pad + titleH + 4, width - 2*pad, stateH);

    choicesLabel = StaticText(panel);
    choicesLabel.string = "CHOICES:";
    choicesLabel.font   = Font("Monaco", 11);
    choicesLabel.stringColor = Color(1,1,1,0.85);
    choicesLabel.bounds = Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH);

    choicesBox = StaticText(panel);
    choicesBox.string = "(choices)";
    choicesBox.font   = Font("Monaco", 10);
    choicesBox.stringColor = Color(0.95,0.95,0.95);
    choicesBox.bounds = Rect(
        pad,
        pad + titleH + 4 + stateH + 6 + lineH + 2,
        width - 2*pad,
        height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
    );

    // Export helpers
    ~hud_setState = { arg s;
        AppClock.sched(0.0, { stateLabel.string = s.asString; nil });
    };
    ~hud_setChoices = { arg lines;
        var txt;
        txt = (lines ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = (txt.size > 0).if({ txt }, { "‚Äî" }); nil });
    };

    // Re-anchor after any resize
    if(~gui.respondsTo(\window)) {
        ~gui.window.onResize = {
            var rb = host.bounds;
            panel.bounds = Rect(rb.width - (width + 12), 10, width, height);
            panel.front;
        };
    };

    // Create thicker meter bar at bottom of the overlay
    addMeterBar.value(panel);
};

addMeterBar = { arg overlay;
    var bnds, pad, h, bar;

    bnds = overlay.bounds; pad = 8; h = 16;

    // Remove any previous bar if re-running
    overlay.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_SIMPLE_METER" }).do(_.remove);

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
    ~mdg_meterVal  = 0.0;
};

stopOldOscDefs = {
    if(~mdg_meterOSC_amp.notNil) { ~mdg_meterOSC_amp.free; ~mdg_meterOSC_amp = nil };
    if(~mdg_meterOSC_lvl.notNil) { ~mdg_meterOSC_lvl.free; ~mdg_meterOSC_lvl = nil };
};

parseVal = { arg msg, wantNext;
    var floats, vL, vR, v;
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        if(floats.size >= 4) {
            if(wantNext.not) { vL = floats.at(floats.size - 4); vR = floats.at(floats.size - 3) }
            { vL = floats.at(floats.size - 2); vR = floats.at(floats.size - 1) };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startOscDefs = {
    var wantNext, ampPath;
    wantNext = wantB;

    stopOldOscDefs.value;

    // 1) Prefer /ampA or /ampB if present (bus meters)
    ampPath = (wantNext.not).if({ '/ampA' }, { '/ampB' });
    ~mdg_meterOSC_amp = OSCdef(("mdg_meter_" ++ ampPath.asString).asSymbol, { |msg|
        var raw = parseVal.(msg, wantNext);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);

    // 2) Also listen to /md/levels_gui and /md/levels explicitly
    ~mdg_meterOSC_lvl = OSCdef(\mdg_meter_levels_mux, { |msg|
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            var raw = parseVal.(msg, wantNext);
            ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // catch all; we filter inside
    ("99: meter listening for chain " ++ (wantNext.if({ "B" }, { "A" })) ++ " on /ampA/B + /md/levels(_gui)").postln;
};

pushDemoText = {
    (~hud_setState !? { ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 ‚Üí add",
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ])
    });
};

// ===== RUN (guarded sequence) =====

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.08, {
    makeGridDemo.value;
    solidA.value;
    ensureReady.value(20, { arg host;
        buildOverlay.value(host);
        // Give layout a breath, then meters + text
        AppClock.sched(0.06, {
            addMeterBar.value(host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }));
            startOscDefs.value;
            pushDemoText.value;
            nil
        });
        nil
    });
    nil
});
)

===== troubleshooting/99_PerfHUD_BringUp_OneShot.scd =====
// 99_PerfHUD_BringUp_OneShot.scd
// v0.1.0
// MD 2025-09-29 14:25 BST

/* Purpose
 - Bring up (or focus) the PerfHUD window reliably with minimal moving parts.
 - Verify that meter data is arriving via OSC for a couple of seconds.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
   (so taps are armed and /md/levels(_gui)/ampA/ampB are flowing).
*/

(
var perfHudPath, ensurePerfHUD, waitForWindow, startProbe, stopProbe;

// Path as seen in your logs
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// 1) Ensure PerfHUD is loaded; DO NOT close existing windows (avoid flicker/races)
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD‚Ä¶".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing‚Ä¶".postln;
    };
};

// 2) Wait for the MagicDisplayGUI window, bring to front + always-on-top
waitForWindow = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        if(win.notNil) {
            win.front.alwaysOnTop_(true);
            ~perfHUDWin = win; // publish for convenience
            thenDo.value(win);
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not found; giving up.".warn; nil }{
                waitForWindow.value(triesLeft - 1, thenDo);
            }
        }
    });
};

// 3) Brief OSC probe: confirm meter messages are arriving; auto-stops
startProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\perfHUD_probe, { |msg|
        var path = msg[0];
        if(
            path == '/md/levels'
            or: { path == '/md/levels_gui' }
            or: { path == '/ampA' }
            or: { path == '/ampB' }
        ) {
            ("[levels] " ++ path ++ " ¬∑ size=" ++ msg.size).postln;
        };
    }, nil);
    "99: Probing /md/levels(_gui) & /ampA/B for 2 seconds‚Ä¶".postln;
    AppClock.sched(2.0, { stopProbe.value; nil });
};

stopProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: Probe stopped.".postln;
};

// ‚Äî‚Äî RUN ‚Äî‚Äî //
AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, { waitForWindow.value(40, { startProbe.value }); nil });
)

===== troubleshooting/99_PerfHUD_FixAndVerify_OneShot.scd =====
// 99_PerfHUD_FixAndVerify_OneShot.scd
// v0.2.0
// MD 2025-09-29 14:32 BST

/* Purpose
 - One-shot: make the existing PerfHUD window show MOVING METERS, highlight ACTIVE chain,
   and prove pane text updates, without closing windows or touching audio routing.
 - Bridges /md/levels ‚Üí also emit /md/levels_gui + /ampA + /ampB on the language port,
   so PerfHUD will update regardless of which path it is listening to internally.
 - Writes demo text via common GUI hooks (if exposed by PerfHUD‚Äôs compat shim).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd (taps armed).
Flip
 - Set wantB=true to highlight NEXT (B) instead of CURRENT (A).
*/

(
var wantB;
var perfHudPath, ensurePerfHUD, waitForGui, setHighlight, pushDemoText;
var installBridges, freeBridges, bridgeLevelsToGuiAndAmp, mkLocalSender, probeStart, probeStop;

// ===== CONFIG =====
wantB = false; // false = highlight A; true = highlight B

// ===== PATH to PerfHUD script (from your logs) =====
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// ===== HELPERS =====

mkLocalSender = {
    var addr;
    addr = NetAddr("127.0.0.1", NetAddr.langPort);
    ^addr
};

// 1) Ensure PerfHUD exists; DO NOT close existing GUI (avoid flicker/race).
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD‚Ä¶".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing‚Ä¶".postln;
        existing.front.alwaysOnTop_(true);
    };
};

// 2) Wait until a GUI handle is usable.
//    PerfHUD usually installs a ~gui compat shim; if not, we still proceed with window only.
waitForGui = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win, ok;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        // Accept either ~gui controller (preferable) or at least the window
        ok = (win.notNil) and: { (~gui.notNil) or: { true } };
        if(ok) {
            if(~gui.isNil) {
                // Try to capture a compat controller if PerfHUD exposed one (harmless if not)
                ~gui = ~gui ?? { nil };
            };
            win.front.alwaysOnTop_(true);
            thenDo.value;
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not ready; giving up.".warn; nil }
            { waitForGui.value(triesLeft - 1, thenDo) }
        }
    });
};

// 3) Highlight ACTIVE chain (default A). If compat shim exposes highlightCurrentColumn, use it.
setHighlight = {
    var targetSym;
    targetSym = (wantB.not).if({ \chainA }, { \chainB });
    if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
        ~gui.highlightCurrentColumn(targetSym);
        ("99: highlight set via GUI method ‚Üí " ++ targetSym.asString).postln;
    }{
        // fallback: post only; we avoid direct view hacking in PerfHUD for safety
        ("99: highlight method not found (GUI compat shim missing?) ‚Äî expected " ++ targetSym.asString).warn;
    };
};

// 4) Push DEMO TEXT: try showExpectation ‚Üí updateTextField ‚Üí setOperations (if present).
pushDemoText = {
    var stateText, lines;
    stateText = (wantB.not).if({ "Mode: test ¬∑ ACTIVE=A" }, { "Mode: test ¬∑ ACTIVE=B" });
    lines = ["fret 3 ‚Üí add", "fret 5 ‚Üí timebased", "fret 7 ‚Üí modulation", "fret 9 ‚Üí filter"];

    if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
        ~gui.showExpectation(stateText, 0);
        "99: showExpectation OK".postln;
    }{
        if(~gui.notNil and: { ~gui.respondsTo(\updateTextField) }) {
            ~gui.updateTextField(\state, stateText);
            "99: updateTextField(:state) OK".postln;
        }{
            "99: No text API found on GUI (skipping)".warn;
        };
    };
    if(~gui.notNil and: { ~gui.respondsTo(\setOperations) }) {
        ~gui.setOperations(lines);
        "99: setOperations OK".postln;
    }{
        "99: setOperations not available (skipping choices text)".postln;
    };
};

// 5) Bridge /md/levels ‚Üí also emit /md/levels_gui and /ampA/B so PerfHUD meters move.
freeBridges = {
    if(~osc_bridge_levels.notNil) { ~osc_bridge_levels.free; ~osc_bridge_levels = nil };
    if(~osc_bridge_gui.notNil)    { ~osc_bridge_gui.free; ~osc_bridge_gui    = nil };
};
bridgeLevelsToGuiAndAmp = {
    var out, lastPrint;
    var routeA, routeB;

    out = mkLocalSender.value;
    lastPrint = 0.0;

    // Helper to emit ampA/ampB from 4 floats [lA, rA, lB, rB]
    routeA = { arg lA = 0.0, rA = 0.0; out.sendMsg('/ampA', 0, lA, rA) };
    routeB = { arg lB = 0.0, rB = 0.0; out.sendMsg('/ampB', 0, lB, rB) };

    // Bridge from /md/levels ‚Üí duplicate as /md/levels_gui and /ampA/B
    ~osc_bridge_levels = OSCdef(\md_bridge_levels, { |msg, time, addr, recvPort|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // Emit a straight pass-through for GUI path (same payload except the path)
        out.sendMsg('/md/levels_gui', *floats);

        // Try to extract last 4 floats as [lA, rA, lB, rB]; fallback to mean pairs if shorter
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };
        routeA.value(lA.clip(0,1), rA.clip(0,1));
        routeB.value(lB.clip(0,1), rB.clip(0,1));

        // Throttled console confirmation
        if((SystemClock.seconds - lastPrint) > 0.50) {
            ("99: bridged levels ‚Üí GUI + ampA/B   A=(" ++ lA.round(0.01) ++ "," ++ rA.round(0.01)
              ++ ")  B=(" ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")").postln;
            lastPrint = SystemClock.seconds;
        };
    }, '/md/levels');

    // Also, if someone else sends /md/levels_gui only, mirror to ampA/B as well.
    ~osc_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            routeA.value(lA.clip(0,1), rA.clip(0,1));
            routeB.value(lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: bridges installed (levels ‚Üí gui + ampA/B)".postln;
};

// 6) Short probe: print any arriving meter messages for visibility (auto-stop)
probeStart = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\md_probe_any, { |msg|
        var p = msg[0];
        if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/ampA' } or: { p == '/ampB' }) {
            ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
        };
    }, nil);
    "99: probe: watching /md/levels(_gui) & /ampA/B for 2s‚Ä¶".postln;
    AppClock.sched(2.0, { probeStop.value; nil });
};
probeStop = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: probe stopped.".postln;
};

// 7) Uninstall bridges if you need to revert
~hud_fix_stop = {
    freeBridges.value;
    probeStop.value;
    "99: bridges and probe removed.".postln;
};

// ===== RUN (guarded) =====

AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, {
    waitForGui.value(40, {
        setHighlight.value;
        pushDemoText.value;
        freeBridges.value;
        installBridges.value;  // forward-declare call ‚Äî see below
        probeStart.value;
        nil
    });
    nil
});

// We bind the bridge installer late to avoid forward-ref warnings in some editors
installBridges = { bridgeLevelsToGuiAndAmp.value };
)

===== troubleshooting/99_PerfHUD_MetersFromBusses_v0.1.0.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.0
// MD 2025-09-29 15:18 BST

(
var aBus, bBus;
var mkDefs, startMeters, uiNudge;

aBus = 2001;  // your tap buses
bBus = 2002;

mkDefs = {
    Server.default.bind({
        SynthDef(\md_levels4_from_busses, { arg inA=2001, inB=2002, rate=24;
            var a, b, la, ra, lb, rb, t;
            a  = In.ar(inA, 2);
            b  = In.ar(inB, 2);
            la = Amplitude.ar(a[0], 0.01, 0.20).clip(0, 1);
            ra = Amplitude.ar(a[1], 0.01, 0.20).clip(0, 1);
            lb = Amplitude.ar(b[0], 0.01, 0.20).clip(0, 1);
            rb = Amplitude.ar(b[1], 0.01, 0.20).clip(0, 1);
            t  = Impulse.kr(rate);
            SendReply.kr(t, '/md/levels_gui', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/md/levels_bus', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/ampA', A2K.kr([la, ra]));
            SendReply.kr(t, '/ampB', A2K.kr([lb, rb]));
        }).add;
    });
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeters = {
    if(~md_levelsSynth.notNil) { ~md_levelsSynth.free; ~md_levelsSynth = nil };
    Server.default.bind({
        ~md_levelsSynth = Synth(\md_levels4_from_busses, [\inA, aBus, \inB, bBus, \rate, 24]);
    });
    ("99: Started md_levels4_from_busses on A=" ++ aBus ++ "  B=" ++ bBus).postln;
};

uiNudge = {
    AppClock.sched(0.10, {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B taps", 0);
        };
        nil
    });
};

mkDefs.value;
AppClock.sched(0.05, { startMeters.value; uiNudge.value; nil });
)

===== troubleshooting/99_PerfHUD_MetersFromBusses.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.1
// MD 2025-09-29 15:22 BST
(
/* Purpose
   - Bridge two 2-ch AUDIO buses (A and B) into the PerfHUD UI via OSC:
       ‚Ä¢ '/md/levels_gui'  ‚Üí linear amplitudes (0..1)  [A L, A R, B L, B R]
       ‚Ä¢ '/md/levels_db'   ‚Üí dBFS values (‚âà -inf..0)   [A L, A R, B L, B R]
       ‚Ä¢ '/ampA', '/ampB'  ‚Üí linear pairs for legacy listeners
   - Provide optional test pattern (fixed values) to prove the UI is controllable.
   - Optionally print a few lines of dB to the console to validate input sanity.

Style
   - var-first everywhere; descriptive lowercase names; no single-letter locals.
   - Server.default.bind for server ops; AppClock for UI; no server.sync; no non-local returns.
*/

var busIndexA, busIndexB;
var attackSeconds, releaseSeconds, updateRateHz;
var useTestPattern, testValueAL, testValueAR, testValueBL, testValueBR;
var printDbLinesCount;

var installSynthDefinitions, startMeterBridge, nudgeHudOnce, installDbConsolePrinter;

// --- Configuration (edit these if needed) ------------------------------------
busIndexA        = 2001;        // your A-tap bus index (2 channels expected)
busIndexB        = 2002;        // your B-tap bus index (2 channels expected)
attackSeconds    = 0.01;        // Amplitude.kr attack time
releaseSeconds   = 0.20;        // Amplitude.kr release time
updateRateHz     = 24;          // OSC update rate for GUI

useTestPattern   = false;       // set true to drive meters with fixed values
testValueAL      = 0.25;        // A left (linear 0..1)
testValueAR      = 0.50;        // A right
testValueBL      = 0.75;        // B left
testValueBR      = 0.50;        // B right

printDbLinesCount = 6;          // number of dB lines to print to console (0 disables)

// --- Definitions --------------------------------------------------------------
installSynthDefinitions = {
    var synthAdder;

    synthAdder = {
        // Two-bus (stereo+stereo) ‚Üí linear + dB, with optional test pattern
        SynthDef(\md_levels4_from_busses, {
            arg inBusA = 2001, inBusB = 2002, updatesPerSecond = 24,
                ampAttack = 0.01, ampRelease = 0.20,
                enableTestPattern = 0,
                patternAL = 0.25, patternAR = 0.50, patternBL = 0.75, patternBR = 0.50;

            var inputStereoA, inputStereoB;
            var ampLinearAL, ampLinearAR, ampLinearBL, ampLinearBR;
            var linearAL, linearAR, linearBL, linearBR;
            var dbAL, dbAR, dbBL, dbBR;
            var updateTrigger;
            var minLinearFloor;

            // Read 2 channels from each bus
            inputStereoA = In.ar(inBusA, 2);
            inputStereoB = In.ar(inBusB, 2);

            // Measure linear amplitude at control rate
            ampLinearAL = Amplitude.kr(inputStereoA[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearAR = Amplitude.kr(inputStereoA[1], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBL = Amplitude.kr(inputStereoB[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBR = Amplitude.kr(inputStereoB[1], ampAttack, ampRelease).clip(0.0, 1.0);

            // Select measured vs. test pattern
            linearAL = Select.kr(enableTestPattern, [ampLinearAL, patternAL]);
            linearAR = Select.kr(enableTestPattern, [ampLinearAR, patternAR]);
            linearBL = Select.kr(enableTestPattern, [ampLinearBL, patternBL]);
            linearBR = Select.kr(enableTestPattern, [ampLinearBR, patternBR]);

            // Convert to dB (guard the floor to avoid -inf)
            minLinearFloor = 1e-7;
            dbAL = (max(linearAL, minLinearFloor)).log10 * 20.0;
            dbAR = (max(linearAR, minLinearFloor)).log10 * 20.0;
            dbBL = (max(linearBL, minLinearFloor)).log10 * 20.0;
            dbBR = (max(linearBR, minLinearFloor)).log10 * 20.0;

            // Tick and send
            updateTrigger = Impulse.kr(updatesPerSecond);

            // Linear for GUI
            SendReply.kr(updateTrigger, '/md/levels_gui', [linearAL, linearAR, linearBL, linearBR]);

            // dB for console or dB-aware GUIs
            SendReply.kr(updateTrigger, '/md/levels_db',  [dbAL, dbAR, dbBL, dbBR]);

            // Legacy: per-chain linear pairs
            SendReply.kr(updateTrigger, '/ampA', [linearAL, linearAR]);
            SendReply.kr(updateTrigger, '/ampB', [linearBL, linearBR]);
        }).add;
    };

    Server.default.bind(synthAdder);
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeterBridge = {
    var freeOld, startNew;

    freeOld = {
        if(~md_levelsSynth.notNil) {
            ~md_levelsSynth.free;
            ~md_levelsSynth = nil;
        };
    };

    startNew = {
        Server.default.bind({
            ~md_levelsSynth = Synth(
                \md_levels4_from_busses,
                [
                    \inBusA,          busIndexA,
                    \inBusB,          busIndexB,
                    \updatesPerSecond, updateRateHz,
                    \ampAttack,        attackSeconds,
                    \ampRelease,       releaseSeconds,
                    \enableTestPattern, (useTestPattern.if({ 1 }, { 0 })),
                    \patternAL,        testValueAL,
                    \patternAR,        testValueAR,
                    \patternBL,        testValueBL,
                    \patternBR,        testValueBR
                ]
            );
        });
        ("99: Started md_levels4_from_busses on A=" ++ busIndexA
            ++ "  B=" ++ busIndexB
            ++ "  testPattern=" ++ useTestPattern).postln;
    };

    freeOld.();
    startNew.();
};

nudgeHudOnce = {
    var doIt;

    doIt = {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B buses", 0);
        };
        nil
    };

    AppClock.sched(0.10, doIt);
};

installDbConsolePrinter = {
    var oscKeyName, linesRemaining;

    oscKeyName     = \md_levels_db_console_printer;
    linesRemaining = printDbLinesCount.max(0).asInteger;

    // Optional: print a few dB lines then auto-stop
    if(linesRemaining > 0) {
        OSCdef(oscKeyName, { arg message;
            var dbLeftA, dbRightA, dbLeftB, dbRightB, lineText;

            if(message.size >= 5) {
                // ['/md/levels_db', nodeID, replyID, dB_AL, dB_AR, dB_BL, dB_BR] (nodeID/replyID vary by build)
                dbLeftA   = message[3].round(0.1);
                dbRightA  = message[4].round(0.1);
                dbLeftB   = message[5].round(0.1);
                dbRightB  = message[6].round(0.1);

                lineText = "[dB]  A: L=" ++ dbLeftA  ++ " dB  R=" ++ dbRightA
                         ++ "   |   B: L=" ++ dbLeftB ++ " dB  R=" ++ dbRightB;
                lineText.postln;

                linesRemaining = linesRemaining - 1;
                if(linesRemaining <= 0) {
                    OSCdef(oscKeyName).free;
                    "[dB] console printer finished.".postln;
                };
            };
        }, '/md/levels_db');
    };
};

// --- Run sequence -------------------------------------------------------------
installSynthDefinitions.();
installDbConsolePrinter.();               // prints a few lines if printDbLinesCount > 0
AppClock.sched(0.05, {
    startMeterBridge.();
    nudgeHudOnce.();
    nil
});
)

===== troubleshooting/99_PerfHUD_MetersNow_v2.scd =====
// 99_PerfHUD_MetersNow_v2.scd
// v0.2.1
// MD 2025-09-29 14:55 BST

/* Purpose
 - Make PerfHUD meters MOVE by bridging your real level messages to the paths PerfHUD reads,
   after SANITIZING payloads (strip bus IDs / counters; normalize to 0..1).
 - Listens on: /md/levels AND /md/levels_gui
 - Emits to : /md/levels_bus  (and mirrors to /ampA, /ampB)
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe; verbose console for verification.
*/

(
var out, freeAll, startBridge, stopBridge, extract4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean previous bridges
freeAll = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
};

// 2) dB ‚Üí 0..1 using a floor (default -48 dB mapped to 0)
normDb = { arg dbVal, floorDb = -48.0;
    var x = dbVal ? floorDb;
    x = x.clip(floorDb, 0.0);
    ^((x - floorDb) / (0.0 - floorDb))  // 0..1
};

// 3) Extract the last 4 meaningful floats [lA,rA,lB,rB] from a float list.
//    - Prefer values already in 0..1
//    - Else accept dB-ish (-120..+6) and convert via normDb
//    - Ignore obvious bus IDs / counters (>= 2.0 and not dB-range)
extract4 = { arg floatsIn;
    var f, tail4, useDb, vA1, vA2, vB1, vB2, floats01, floatsDbRange;

    f = (floatsIn ? []).collect(_.asFloat);

    // 3a) Try to find a **last** window of 4 floats already within 0..1
    floats01 = f.select({ |x| x.isNumber and: { (x >= 0.0) and: (x <= 1.0) } });
    if(floats01.size >= 4) {
        tail4 = floats01.keepLast(4);
        ^tail4; // already 0..1
    };

    // 3b) Else try dB-like values (e.g., -48..0 or up to +6)
    floatsDbRange = f.select({ |x| x.isNumber and: { (x >= -120.0) and: (x <= 6.0) } });
    if(floatsDbRange.size >= 4) {
        tail4 = floatsDbRange.keepLast(4);
        vA1 = normDb.(tail4[0]); vA2 = normDb.(tail4[1]);
        vB1 = normDb.(tail4[2]); vB2 = normDb.(tail4[3]);
        ^[vA1, vA2, vB1, vB2];
    };

    // 3c) Last resort: take **any** floats, drop obviously huge values (>= 2.0),
    //     then if still not enough, pad with zeros.
    tail4 = f.reject({ |x| x >= 2.0 }).keepLast(4);
    tail4 = (tail4 ++ Array.fill((4 - tail4.size).max(0), { 0.0 })).keepLast(4);
    // clip to 0..1 to be safe
    ^tail4.collect({ |x| x.clip(0.0, 1.0) });
};

// 4) Start the sanitizing bridge
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v2 = OSCdef(\md_bridge_levels_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);  // [lA,rA,lB,rB] normalized 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        // Emit to PerfHUD-friendly paths
        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui_v2 = OSCdef(\md_bridge_gui_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels_gui ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels_gui');

    "99v2: BRIDGE active (sanitized ‚Üí levels_bus + ampA/B)".postln;
};

stopBridge = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
    "99v2: BRIDGE stopped.".postln;
};

// Run
freeAll.value;
startBridge.value;
)

===== troubleshooting/99_PerfHUD_MetersNow_v3.scd =====
// 99_PerfHUD_MetersNow_v3.scd
// v0.3.0
// MD 2025-09-29 15:05 BST

/* Purpose
 - Make PerfHUD meters move by sanitizing level messages before forwarding:
   ‚Ä¢ Listen:  /md/levels   and  /md/levels_gui
   ‚Ä¢ Emit  :  /md/levels_bus   (and mirror to /ampA, /ampB)
 - Sanitizer rules (known-good SC only, no non-existent methods):
   1) Prefer the last 4 floats in 0..1
   2) Else prefer the last 4 floats in dB-ish range [-120..+6], map to 0..1 (floor = -48 dB)
   3) Else drop floats >= 2.0 (IDs/counters), take last 4, clip to 0..1
Style
 - var-first; AppClock-only scheduling; no server.sync; idempotent; nil-safe; conservative logging.
*/

(
var out, freeBridges, startBridges, stopBridges, sanitize4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean any previous bridges
freeBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
};

// 2) dB ‚Üí 0..1 with floor
normDb = { arg dbVal, floorDb = -48.0;
    var x;
    x = (dbVal ? floorDb);
    x = x.clip(floorDb, 0.0);
    // linear from floorDb..0 dB ‚Üí 0..1
    ((x - floorDb) / (0.0 - floorDb))
};

// 3) Get the **last** 4 usable floats
sanitize4 = { arg floatsIn;
    var f, i, count, res, v, dbCand, last4FromDb, raw, startIndex, endIndex;

    // Defensive copy of floats
    f = (floatsIn ? []).collect(_.asFloat);

    // (A) Prefer the last 4 in 0..1
    res = Array.new;
    i = f.size - 1;
    while({ i >= 0 and: { res.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= 0.0) and: (v <= 1.0) }) {
            res = res.add(v);
        };
        i = i - 1;
    });
    if(res.size >= 4) {
        res = res.reverse; // we collected backwards
        ^res;
    };

    // (B) Else, try last 4 in dB-ish range [-120..+6] ‚Üí map to 0..1
    dbCand = Array.new; i = f.size - 1;
    while({ i >= 0 and: { dbCand.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= -120.0) and: (v <= 6.0) }) {
            dbCand = dbCand.add(v);
        };
        i = i - 1;
    });
    if(dbCand.size >= 4) {
        dbCand = dbCand.reverse;
        last4FromDb = dbCand.collect({ arg x; normDb.(x) });
        ^last4FromDb;
    };

    // (C) Last resort: drop obvious IDs/counters (>= 2.0), take last 4, clip 0..1
    raw = f.select({ arg x; x.isNumber and: { x < 2.0 } });
    if(raw.size >= 4) {
        startIndex = (raw.size - 4).max(0);
        endIndex   = raw.size - 1;
        res = raw.copyRange(startIndex, endIndex).collect({ arg x; x.clip(0.0, 1.0) });
        ^res;
    }{
        // Not enough candidates: pad with zeros
        res = raw.collect({ arg x; x.clip(0.0, 1.0) });
        while({ res.size < 4 }, { res = res.add(0.0) });
        ^res;
    };
};

// 4) Bridges: listen ‚Üí sanitize ‚Üí forward
startBridges = {
    var throttle;

    throttle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.60) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v3 = OSCdef(\md_bridge_levels_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);

        // for visibility, show the numeric tail we saw (up to last 6 floats)
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats); // [lA,rA,lB,rB] in 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels tail=" ++ rawTail
            ++ "  ‚Üí bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels');

    ~md_bridge_gui_v3 = OSCdef(\md_bridge_gui_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels_gui tail=" ++ rawTail
            ++ "  ‚Üí bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels_gui');

    "99v3: BRIDGE active (sanitized ‚Üí /md/levels_bus + /ampA/B)".postln;
};

stopBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
    "99v3: BRIDGE stopped.".postln;
};

// Run
freeBridges.value;
startBridges.value;
)

===== troubleshooting/99_PerfHUD_MetersNow.scd =====
// 99_PerfHUD_MetersNow.scd
// v0.1.0
// MD 2025-09-29 14:40 BST

/* Purpose
 - Make PerfHUD meters MOVE immediately without touching the GUI or audio routing.
 - Step 1 (2s): emit a visible ramp to /md/levels_bus and /ampA/B (proof meters react).
 - Step 2 (continuous): bridge your real /md/levels & /md/levels_gui to /md/levels_bus (+ /ampA/B).
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe.
*/

(
var out, freeAll, startProof, stopProof, startBridge, stopBridge, lastPost;

// 0) local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean up any previous helpers
freeAll = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    if(~md_probe_perf.notNil)    { ~md_probe_perf.free;    ~md_probe_perf    = nil };
    if(~md_proof_task.notNil)    { ~md_proof_task.stop;    ~md_proof_task    = nil };
};

// 2) SHORT PROOF: drive a ramp so you SEE the meters move now
startProof = {
    var t = 0.0, dt = 1/24, secs = 2.0, steps = (secs / dt).round(1);
    var stepCount = 0, ramp;
    ramp = {
        // 0..1 triangle for A, inverse for B (obvious visual motion)
        var a = ( (stepCount % 24) / 24 );
        var b = 1.0 - a;
        out.sendMsg('/md/levels_bus', a, a, b, b);  // [lA, rA, lB, rB]
        out.sendMsg('/ampA', 0, a, a);
        out.sendMsg('/ampB', 0, b, b);
        stepCount = stepCount + 1;
    };
    ~md_proof_task = Task({
        steps.do({
            ramp.value;
            dt.wait;
        });
    }).play(AppClock);
    "99: PROOF running for 2s ‚Üí watch meters MOVE now‚Ä¶".postln;
};

stopProof = {
    if(~md_proof_task.notNil) { ~md_proof_task.stop; ~md_proof_task = nil };
    "99: PROOF stopped.".postln;
};

// 3) BRIDGE real levels ‚Üí /md/levels_bus (+ mirror to /ampA/B)
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels = OSCdef(\md_bridge_levels, { |msg|
        var floats, lA, rA, lB, rB;

        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // heuristics: last 4 floats are [lA,rA,lB,rB]; fallback if fewer
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };

        // forward to paths PerfHUD commonly consumes
        out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
        out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
        out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));

        postThrottle.value("99: bridged ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
            out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
            out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: BRIDGE active (levels ‚Üí levels_bus + ampA/B).".postln;
};

stopBridge = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    "99: BRIDGE stopped.".postln;
};

// 4) Optional: tiny probe (prints any level/amp paths for 2s)
~md_probe_perf = OSCdef(\md_probe_perf, { |msg|
    var p = msg[0];
    if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/md/levels_bus' } or: { p == '/ampA' } or: { p == '/ampB' }) {
        ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
    };
}, nil);

// RUN
freeAll.value;
startProof.value;
AppClock.sched(2.05, { stopProof.value; startBridge.value; nil });
)

===== troubleshooting/99_PerfHUD_UIOnly_Wiggle_Toggle.scd =====
// 99_PerfHUD_UIOnly_Wiggle_Toggle.scd
// v0.1.0
// MD 2025-09-29 15:22 BST

/* Purpose
 - Pure GUI-side diagnostic: animate two meter bars (A/B) inside the PerfHUD window
   WITHOUT OSC, to prove the window can update; also tint ACTIVE column and show test text.
 - Provides helpers:
     ~hud_wiggle_start.(\A or \B)   // start animation, choose active column
     ~hud_wiggle_stop.()            // stop & remove overlays
     ~hud_text.("state text", ["choice1", "choice2"])  // show sample texts
Style
 - var-first; AppClock-only; idempotent; nil-safe; no server.sync; no caret-returns in closures.
*/

(
var findHudHost, removeOverlays, mkBars, mkTint, mkText, startAnim, stopAnim;

// --- find the MagicDisplayGUI host view (PerfHUD window) ---
findHudHost = {
    var win, host;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    host = win.tryPerform(\view);
    ^host
};

// --- remove our overlays if present (safe to call anytime) ---
removeOverlays = {
    var host = findHudHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["WGL_BAR_A", "WGL_BAR_B", "WGL_TINT_A", "WGL_TINT_B", "WGL_TEXT"].includes(n)
        }).do(_.remove);
    };
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
};

// --- create two bars near the bottom of the window ---
mkBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD host not found.".warn; ^nil };
    r = host.bounds; pad = 12; h = 14; gap = 8; w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(10);
    yA = (yB - h - gap).max(10);

    // A
    barA = UserView(host);
    barA.name = "WGL_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.10);
    barA.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    // B
    barB = UserView(host);
    barB.name = "WGL_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.10);
    barB.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    // keep re-anchored on resize
    host.window.onResize = {
        var r2 = host.bounds;
        var w2 = (r2.width - (2*pad)).max(50);
        var yB2 = (r2.height - pad - h).max(10);
        var yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
};

// --- tint ACTIVE column (large translucent rect on left or right half) ---
mkTint = { arg which = \A;
    var host, r, leftRect, rightRect, tintA, tintB, midX;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old tints
    host.children.select({ |v| ["WGL_TINT_A","WGL_TINT_B"].includes(v.tryPerform(\name) ? "") }).do(_.remove);

    tintA = UserView(host); tintA.name = "WGL_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18); // soft green

    tintB = UserView(host); tintB.name = "WGL_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    // show only the chosen one
    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    // keep on resize
    host.window.onResize = {
        var r2 = host.bounds, mx2 = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx2, r2.height);
        tintB.bounds = Rect(mx2, 0, r2.width - mx2, r2.height);
        tintA.refresh; tintB.refresh;
    };
};

// --- small text block (state + choices) in top-right as a demo ---
mkText = { arg stateStr = "HUD UI-test", choices = #["choice A","choice B"];
    var host, r, pad, w, h, title, body, panel, s;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 8; w = 280; h = 120;

    // clear previous
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "WGL_TEXT" }).do(_.remove);

    panel = CompositeView(host).name_("WGL_TEXT");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (w + 12), 12, w, h);
    panel.front;

    title = StaticText(panel);
    title.string = stateStr.asString;
    title.font = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.9);
    title.bounds = Rect(pad, pad, w - 2*pad, 18);

    s = choices.collect(_.asString).join("\n");
    body = StaticText(panel);
    body.string = (s.size > 0).if({ s }, { "‚Äî" });
    body.font = Font("Monaco", 10);
    body.stringColor = Color(0.95,0.95,0.95);
    body.align = \topLeft;
    body.bounds = Rect(pad, pad + 22, w - 2*pad, h - (pad + 22 + pad));

    // keep anchored
    host.window.onResize = {
        var r2 = host.bounds;
        panel.bounds = Rect(r2.width - (w + 12), 12, w, h);
        panel.front;
    };
};

// --- animation task (no OSC; just wiggle locally) ---
startAnim = { arg active = \A;
    var host, barA, barB, t = 0.0, dt = 1/30;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD not found".warn; ^nil };

    // build overlays
    mkBars.();
    mkTint.(active);

    // drive values
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
    ~wgl_task = Task({
        loop {
            // simple triangle ‚Üí obvious motion
            var a = (t % 1.0);
            var b = 1.0 - a;
            ~wgl_valA = a;
            ~wgl_valB = b;
            // refresh our bars
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if(["WGL_BAR_A","WGL_BAR_B"].includes(n)) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.5); // slow-ish
        }
    }).play(AppClock);
};

stopAnim = {
    removeOverlays.();
};

// export helpers
~hud_wiggle_start = { arg which = \A; AppClock.sched(0.0, { startAnim.(which); nil }) };
~hud_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };
~hud_text = { arg state="HUD UI-test", choices = #[]; AppClock.sched(0.0, { mkText.(state, choices); nil }) };

"PerfHUD UI-only wiggle helpers ready: ~hud_wiggle_start.(\\A or \\B), ~hud_wiggle_stop.(), ~hud_text.(state, choices)".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck_GUI.scd =====
// Accept_Meters_QuickCheck_GUI.scd
// v0.1.0  MD 2025-09-26 16:10 BST

(
var key, counts, lastGA, lastGB, lastGT;
counts = IdentityDictionary[ 32001 -> 0, 32002 -> 0, 31001 -> 0 ];
lastGA = [0.0, 0.0]; lastGB = [0.0, 0.0]; lastGT = [0.0, 0.0];

key = \md_levels_gui_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };

OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 32001) { counts.put(32001, counts[32001] + 1); lastGA = [l, r] };
    if(id == 32002) { counts.put(32002, counts[32002] + 1); lastGB = [l, r] };
    if(id == 31001) { counts.put(31001, counts[31001] + 1); lastGT = [l, r] };
    nil
}, "/md/levels_gui", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), line;
    if(d.notNil) { d.free };
    line = "[ACCEPT_GUI] GA=" ++ counts[32001].asString ++ " " ++ lastGA.asString
        ++ "  GB=" ++ counts[32002].asString ++ " " ++ lastGB.asString
        ++ "  GT=" ++ counts[31001].asString ++ " " ++ lastGT.asString;
    line.postln;
    nil
});

"[ACCEPT_GUI] counting /md/levels_gui for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck.scd =====
// Accept_Meters_QuickCheck.scd
// v0.1.0  MD 2025-09-26 15:58 BST

/* Purpose
   Lightweight acceptance: count /md/levels for 0.5 s and print one line.
*/

(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), okLine;
    if(d.notNil) { d.free };
    okLine = "[ACCEPT] A=" ++ counts[2001].asString ++ " " ++ lastA.asString
           ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
           ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString;
    okLine.postln;
    nil
});
"[ACCEPT] counting /md/levels for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Bridge_mdlevels_to_ampAB.scd =====
// Bridge_mdlevels_to_ampAB.scd
// v0.1.0
// MD 2025-09-26 12:43 BST

/* Purpose
   Bridge /md/levels to /ampA and /ampB so the HUD meters animate regardless of
   which responder is currently active in the window code.
   - replyID 2001 -> /ampA
   - replyID 2002 -> /ampB
*/

(
var senderAddr, installBridge;

senderAddr = NetAddr("127.0.0.1", NetAddr.langPort);

installBridge = {
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };  // idempotent

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };  // guard

        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // Relay to whichever responders the HUD already has
        if(replyId == 2001) { senderAddr.sendMsg("/ampA", 0, -1, leftVal, rightVal) };
        if(replyId == 2002) { senderAddr.sendMsg("/ampB", 0, -1, leftVal, rightVal) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installBridge.();
"[/md/levels] -> [/ampA,/ampB] bridge installed.".postln;
)

===== troubleshooting/Bridge_Meters_Universal.scd =====
// Bridge_Meters_Universal.scd
// v0.1.0
// MD 2025-09-26 12:58 BST

/* Purpose / Style
   Make HUD meters move regardless of whether it listens to /md/levels or /ampA,/ampB.
   - Auto-discovers receiver ports for /ampA,/ampB responders and relays /md/levels to them.
   - Also updates the language-side model (~md_levelsById) from /ampA,/ampB (reverse path).
   - Idempotent: re-running replaces previous bridge.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
var allDefs, ampPorts, collectAmpPorts, installMdToAmp, installAmpToModel, postSummary;

allDefs = OSCdef.all;

collectAmpPorts = {
    var ports;
    ports = IdentitySet.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == "/ampA" or: { pathValue == "/ampB" }) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            ports.add(portValue);
        };
    });
    // Always include langPort as a fallback
    ports.add(NetAddr.langPort);
    ports.asArray
};

installMdToAmp = { arg portArray;
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        var sendAddrs;

        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // multicast to every port the HUD is listening on
        sendAddrs = portArray.collect({ arg portNum; NetAddr("127.0.0.1", portNum) });

        if(replyId == 2001) { sendAddrs.do({ arg na; na.sendMsg("/ampA", 0, -1, leftVal, rightVal) }) };
        if(replyId == 2002) { sendAddrs.do({ arg na; na.sendMsg("/ampB", 0, -1, leftVal, rightVal) }) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installAmpToModel = {
    var ensureDict;
    ensureDict = { ~md_levelsById = ~md_levelsById ? IdentityDictionary.new };

    // /ampA -> model[2001]
    if(OSCdef.all.at(\ampA_to_model).notNil) { OSCdef.all.at(\ampA_to_model).free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1); // guard
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    if(OSCdef.all.at(\ampB_to_model).notNil) { OSCdef.all.at(\ampB_to_model).free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        nil
    }, "/ampB", recvPort: NetAddr.langPort);
};

postSummary = { arg portsArray;
    var msg;
    msg = "Universal meter bridge active. ampA/ampB multicast ports: " ++ portsArray.asString;
    msg.postln;
};

// Main
ampPorts = collectAmpPorts.();
installMdToAmp.(ampPorts);
installAmpToModel.();
postSummary.(ampPorts);
)

===== troubleshooting/Diag_0G_ALT_CreateGridGuiAndBind.scd =====
// Diag_0G_ALT_CreateGridGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:25 BST
/* Purpose / Style
   Purpose: Avoid the PerfHUD 'base_' crash by bringing up the GridDemo GUI instead.
            Bind CommandManager.display to the created GUI object and return ‚Üí a Window.
   Style:   var-first; descriptive lowercase variable names; no server.sync; single MagicDisplayGUI window.
*/

(
var system_ref, cmd_mgr, gui_obj, window_list, gui_window;

system_ref = ~system;
if(system_ref.isNil) {
    // Construct LivePedalboardSystem with default path resolver (nil) and do the standard bring-up
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;  // server + pedalboard + command system (GUI may still be nil if PerfHUD crashed earlier)
};

// Close any existing MagicDisplayGUI windows to avoid duplicates
~system.closeExistingMagicDisplayWindows;

// Explicitly create the safe GridDemo GUI (bypass PerfHUD file loading)
gui_obj = MagicDisplayGUI_GridDemo.new;  // known-good fallback window class in your codebase

// Bind CommandManager.display if needed
cmd_mgr = ~system.commandManager;
if(cmd_mgr.notNil and: { cmd_mgr.display.isNil }) {
    cmd_mgr.display = gui_obj;
    "MD0G_ALT: bound CommandManager.display to GridDemo".postln;
};

// Bring the MagicDisplayGUI window to front and RETURN it
window_list = Window.allWindows;
gui_window = window_list.detect({ arg w;
    var title_string;
    title_string = w.tryPerform(\name);
    title_string.notNil and: { title_string.asString.beginsWith("MagicDisplayGUI") }
});
if(gui_window.notNil) { gui_window.front };
gui_window  // ‚Üí a Window (final expression)
)

===== troubleshooting/Diag_0G_CreateGuiAndBind.scd =====
// Diag_0G_CreateGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:05 BST

/* Purpose / Style
   Purpose: Ensure a single MagicDisplayGUI window exists, bind it to CommandManager.display,
            and return ‚Üí a Window (final expression).
   Style:   var-first; descriptive lowercase variable names (‚â•3 chars); no server.sync; AppClock implied.
*/

(
var systemRef, guiWindow, cmdMgr;

systemRef = ~system;
if(systemRef.isNil) {
    // If system doesn‚Äôt exist yet, construct with default path resolver.
    ~system = LivePedalboardSystem.new(nil);         // uses your resolveTreePath  (known-good)
    ~system.bringUpAll;
};

// Bring up (or refresh) the single GUI window
~system.closeExistingMagicDisplayWindows;
guiWindow = ~system.bringUpMagicDisplayGUI;          // sets statusDisplay inside LivePedalboardSystem

// Bind CommandManager.display to the GUI object if needed
cmdMgr = ~system.commandManager;
if(cmdMgr.notNil and: { cmdMgr.display.isNil } and: { ~system.statusDisplay.notNil }) {
    cmdMgr.display = ~system.statusDisplay;
    "MD0G: bound CommandManager.display to statusDisplay".postln;
};

// Final expression ‚Üí a Window (per your rule)
guiWindow
)

===== troubleshooting/Diag_1_CheckDisplayBinding.scd =====
// Diag_1_CheckDisplayBinding.scd
// v0.1.0
// MD 2025-09-26 16:55 BST
/* Purpose / Style
   Purpose: Check that CommandManager.display points to the current MagicDisplayGUI object.
            If not, bind it safely (no GUI calls are made here).
   Style:   var-first; descriptive lowercase variable names (>=3 chars); no server.sync.
*/

(
var systemRef, cmdMgr, guiRef, displayBefore, didBind;

systemRef = ~system;
if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; run your bring-up first.".warn; ^nil };

cmdMgr = systemRef.commandManager;
guiRef = systemRef.statusDisplay;

displayBefore = if(cmdMgr.notNil) { cmdMgr.display } { nil };
"MDSTEP1: before ‚Üí display.isNil=%  gui.isNil=%".format(displayBefore.isNil, guiRef.isNil).postln;

// Bind only if we have both objects and display is nil
didBind = false;
if(cmdMgr.notNil and: { guiRef.notNil } and: { displayBefore.isNil }) {
    cmdMgr.display = guiRef;
    didBind = true;
    "MDSTEP1: bound CommandManager.display to system.statusDisplay".postln;
};

"MDSTEP1: after  ‚Üí display.isNil=%  didBind=%".format(cmdMgr.display.isNil, didBind).postln;
nil
)

===== troubleshooting/Diag_2_LevelsSniffer.scd =====
// Diag_2_LevelsSniffer_FIXED.scd
// v0.1.2
// MD 2025-09-26 17:25 BST

/* Purpose / Style
   Purpose: Confirm that /md/levels messages arrive from stable taps (A=2001, B=2002).
            Prints compact values every second.
   Style:   var-first; descriptive lowercase names; AppClock; no server.sync; no single-letter variable names.
*/

(
var ensure_stable_taps, install_listener, start_reporter;
var values_by_id, last_stamp_seconds, reporter_routine;

// Share dictionary with any overlays; create if missing
values_by_id = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = values_by_id;
last_stamp_seconds = SystemClock.seconds.asFloat;

// Reinstall sanitised/smoothed taps to /md/levels with IDs 2001/2002
ensure_stable_taps = {
    if(~system.notNil) {
        ~system.installStableMeters;   // known-good installer in your codebase
        "MD2: stable taps reinstalled (IDs 2001/2002).".postln;
    } {
        "MD2: ~system is nil; cannot reinstall taps.".warn;
    };
};

// Listener updating ~md_levelsById (guard NaN and non-numbers; clip to [0,1])
install_listener = {
    var osc_key;
    osc_key = \md_levels_sniffer_fixed;
    if(OSCdef.all.at(osc_key).notNil) { OSCdef.all.at(osc_key).free };
    OSCdef(osc_key, { arg osc_message;
        var reply_id, left_value, right_value, safe_left, safe_right, now_seconds;
        var left_is_bad, right_is_bad;

        if(osc_message.size >= 5) {
            reply_id   = osc_message[2];
            left_value  = osc_message[3];
            right_value = osc_message[4];

            left_is_bad  = (left_value.isNumber.not)  or: { left_value.isNaN };
            right_is_bad = (right_value.isNumber.not) or: { right_value.isNaN };

            safe_left  = left_is_bad.if({ 0.0 }, { left_value.clip(0, 1) });
            safe_right = right_is_bad.if({ 0.0 }, { right_value.clip(0, 1) });

            values_by_id.put(reply_id, [safe_left, safe_right]);
            now_seconds = SystemClock.seconds.asFloat;
            last_stamp_seconds = now_seconds;
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "MD2: /md/levels sniffer installed.".postln;
};

// 1 Hz reporter
start_reporter = {
    if(reporter_routine.notNil) { reporter_routine.stop };
    reporter_routine = Routine({
        var keep_running;
        keep_running = true;
        while({ keep_running }, {
            var pair_a, pair_b, text_a, text_b;
            pair_a = values_by_id.at(2001) ? [0, 0];
            pair_b = values_by_id.at(2002) ? [0, 0];
            text_a = "A(L,R)=(" ++ pair_a[0].round(0.01) ++ "," ++ pair_a[1].round(0.01) ++ ")";
            text_b = "B(L,R)=(" ++ pair_b[0].round(0.01) ++ "," ++ pair_b[1].round(0.01) ++ ")";
            ("MD2: " ++ text_a ++ "  " ++ text_b).postln;
            1.0.wait;
        });
    }).play(AppClock);
};

ensure_stable_taps.();
install_listener.();
start_reporter.();
nil
)

===== troubleshooting/Diag_3_AttachInlineOverlay.scd =====
// Diag_3_AttachInlineOverlay.scd
// v0.1.0
// MD 2025-09-26 16:55 BST

/* Purpose / Style
   Purpose: Attach a small overlay view inside the existing MagicDisplayGUI window that visualises
            /md/levels (A=2001 bottom half; B=2002 top half). Uses the sniffer‚Äôs dictionary.
   Style:   var-first; descriptive lowercase variable names; AppClock; no server.sync.
*/

(
var hudWindow, overlayView, leftPadPixels, viewWidthPixels, viewHeightPixels, refreshRoutine;

hudWindow = Window.allWindows.detect({ arg winRef;
    var titleString;
    titleString = winRef.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

if(hudWindow.isNil) { "‚ö†Ô∏è MDSTEP3: No MagicDisplayGUI window; run your bring-up.".warn; ^nil };

leftPadPixels    = 8;
viewWidthPixels  = 22;
viewHeightPixels = 86;

overlayView = UserView(hudWindow, Rect(leftPadPixels, leftPadPixels, viewWidthPixels, viewHeightPixels));
overlayView.background_(Color.clear);

overlayView.drawFunc_({ arg viewRef;
    var valuesA, valuesB, aLeft, aRight, bLeft, bRight, halfHeight, halfWidth;
    valuesA = ~md_levelsById.at(2001) ? [0, 0];
    valuesB = ~md_levelsById.at(2002) ? [0, 0];

    aLeft  = valuesA[0]; aRight = valuesA[1];
    bLeft  = valuesB[0]; bRight = valuesB[1];

    halfHeight = viewRef.bounds.height / 2;
    halfWidth  = viewRef.bounds.width  / 2;

    // A (bottom half) ‚Äî green left, blue right
    Pen.fillColor = Color(0.35, 0.9, 0.35);
    Pen.addRect(Rect(0,        halfHeight - (halfHeight * aLeft),  halfWidth, halfHeight * aLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95);
    Pen.addRect(Rect(halfWidth, halfHeight - (halfHeight * aRight), halfWidth, halfHeight * aRight)); Pen.fill;

    // B (top half) ‚Äî subtle tint
    Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
    Pen.addRect(Rect(0,        viewRef.bounds.height - (halfHeight * bLeft),  halfWidth, halfHeight * bLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
    Pen.addRect(Rect(halfWidth, viewRef.bounds.height - (halfHeight * bRight), halfWidth, halfHeight * bRight)); Pen.fill;
});

// refresh on AppClock
refreshRoutine = Routine({
    var keepRunning;
    keepRunning = true;
    while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
        overlayView.refresh;
        0.15.wait;
    });
}).play(AppClock);

"MDSTEP3: inline overlay attached (top-left)".postln;
overlayView
)

===== troubleshooting/Diag_B_DebugTaps_AmplitudeVsVisual.scd =====
// Diag_B_DebugTaps_AmplitudeVsVisual.scd
// v0.1.0
// MD 2025-09-26 17:45 BST

/* Purpose / Style
   Purpose: Add debug taps (non-intrusive) on chainA/chainB that SendReply both the raw amplitude and
            the mapped visual value to /md/levels_dbg with reply IDs 42001 (A) and 42002 (B).
            Then print one line/second with (ampLeft, ampRight) and (visLeft, visRight), so we can
            see if unity (1.0) appears at the Amplitude stage or in the mapping/transport.
   Style:   var-first; descriptive lowercase variable names (>=3 chars); Server.default.bind; no server.sync.
*/

(
// ---- 1) Install debug taps (server side, pass-through audio intact)
var install_debug_taps;

install_debug_taps = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // chainA ‚Üí replyID 42001
        Ndef(\chainA).filter(\mdDebugTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // DO NOT overwrite vis_left/vis_right with CheckBadValues result;
            // we only call it for side-effect logging.
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            // Send both raw amplitude and final visual as 4 floats
            // payload: [ampLeft, ampRight, visLeft, visRight]
            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42001);

            in_sig
        });

        // chainB ‚Üí replyID 42002
        Ndef(\chainB).filter(\mdDebugTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42002);

            in_sig
        });
    });
    "MDDBG: debug taps installed (/md/levels_dbg; A=42001, B=42002).".postln;
};

install_debug_taps.();
nil
)

// ---- 2) Install compact, 1 Hz debug listener (language side; prints one line per second)
(
// Shared dictionary so we can read and format values
var dbg_values_by_id, dbg_listener_key, dbg_reporter_routine;

dbg_values_by_id = ~md_levels_dbg ? IdentityDictionary.new;
~md_levels_dbg = dbg_values_by_id;

// Listener
dbg_listener_key = \md_levels_dbg_sniffer;
if(OSCdef.all.at(dbg_listener_key).notNil) { OSCdef.all.at(dbg_listener_key).free };
OSCdef(dbg_listener_key, { arg osc_message;
    var reply_id, amp_left, amp_right, vis_left, vis_right;
    var valid_payload;

    valid_payload = (osc_message.size >= 7); // addr, timeTag, id, v0, v1, v2, v3 ‚Üí size >= 7
    if(valid_payload) {
        reply_id  = osc_message[2];
        amp_left  = osc_message[3];
        amp_right = osc_message[4];
        vis_left  = osc_message[5];
        vis_right = osc_message[6];

        // Minimal guards
        amp_left  = (amp_left.isNumber  and: { amp_left .isNaN.not })  .if({ amp_left  .clip(0,1) }, { 0.0 });
        amp_right = (amp_right.isNumber and: { amp_right.isNaN.not })  .if({ amp_right .clip(0,1) }, { 0.0 });
        vis_left  = (vis_left.isNumber  and: { vis_left .isNaN.not })  .if({ vis_left  .clip(0,1) }, { 0.0 });
        vis_right = (vis_right.isNumber and: { vis_right.isNaN.not })  .if({ vis_right .clip(0,1) }, { 0.0 });

        dbg_values_by_id.put(reply_id, [amp_left, amp_right, vis_left, vis_right]);
    };
    nil
}, "/md/levels_dbg", recvPort: NetAddr.langPort);
"MDDBG: /md/levels_dbg sniffer installed.".postln;

// Reporter
if(~md_levels_dbg_reporter.notNil) { ~md_levels_dbg_reporter.stop };
~md_levels_dbg_reporter = Routine({
    var keep_running;
    keep_running = true;
    while({ keep_running }, {
        var a_vals, b_vals, text_a, text_b;
        a_vals = dbg_values_by_id.at(42001) ? [0,0,0,0];
        b_vals = dbg_values_by_id.at(42002) ? [0,0,0,0];

        text_a = "A amp=("
            ++ a_vals[0].round(0.01) ++ "," ++ a_vals[1].round(0.01)
            ++ ") vis=("
            ++ a_vals[2].round(0.01) ++ "," ++ a_vals[3].round(0.01) ++ ")";

        text_b = "B amp=("
            ++ b_vals[0].round(0.01) ++ "," ++ b_vals[1].round(0.01)
            ++ ") vis=("
            ++ b_vals[2].round(0.01) ++ "," ++ b_vals[3].round(0.01) ++ ")";

        ("MDDBG: " ++ text_a ++ "   " ++ text_b).postln;
        1.0.wait;
    });
}).play(AppClock);

nil
)

===== troubleshooting/Diag_Meters_BringUp_And_Verify.scd =====
// Diag_Meters_BringUp_And_Verify.scd
// v0.1.2
// MD 2025-09-26 14:31 BST

/* Purpose / Style
   Re-install inline taps (A/B + testmelody), then verify /md/levels traffic
   with a short counter. Prints a concise PASS/FAIL line with counts + last values.
   - var-first, descriptive lowercase, AppClock-only, no server.sync.
   - Pass-through taps (return 'in'); generated audio only.
*/

(
var ensureSources, installTapsOnce, installTapsRobust, verifyTraffic, postSummary;
var packetCounts, lastAPair, lastBPair, lastTPair, verifySeconds;

verifySeconds = 0.6;

packetCounts = IdentityDictionary[
    2001 -> 0,   // A
    2002 -> 0,   // B
    1001 -> 0    // testmelody probe
];

lastAPair = [0.0, 0.0];
lastBPair = [0.0, 0.0];
lastTPair = [0.0, 0.0];

ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // keep sinks alive
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
    });
};

installTapsOnce = { arg rateHz = 18;
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A
        Ndef(\chainA).filter(\mdTapA, nil);
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B
        Ndef(\chainB).filter(\mdTapB, nil);
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (always present for diagnostics)
        Ndef(\testmelody).filter(\mdTapT, nil);
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
};

installTapsRobust = {
    var passIndex, passCount;
    passIndex = 0; passCount = 3;
    AppClock.sched(0.0, {
        installTapsOnce.(18);
        passIndex = passIndex + 1;
        if(passIndex < passCount) { 0.20 } { nil }  // re-run every 200ms, 3 passes
    });
    "[Diag] Inline taps installed (A=2001, B=2002, T=1001) with 3-pass rearm.".postln;
};

verifyTraffic = {
    var defKey;
    defKey = \md_levels_diag_count;

    if(OSCdef.all.at(defKey).notNil) { OSCdef.all.at(defKey).free };

    OSCdef(defKey, { arg msg;
        var replyId, leftVal, rightVal, currentCount;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat;
        rightVal = msg[4].asFloat;

        if(replyId == 2001) {
            currentCount = packetCounts[2001] ? 0;
            packetCounts.put(2001, currentCount + 1);
            lastAPair = [leftVal, rightVal];
        };
        if(replyId == 2002) {
            currentCount = packetCounts[2002] ? 0;
            packetCounts.put(2002, currentCount + 1);
            lastBPair = [leftVal, rightVal];
        };
        if(replyId == 1001) {
            currentCount = packetCounts[1001] ? 0;
            packetCounts.put(1001, currentCount + 1);
            lastTPair = [leftVal, rightVal];
        };

        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    AppClock.sched(verifySeconds, {
        var defObj;
        defObj = OSCdef.all.at(defKey);
        if(defObj.notNil) { defObj.free };
        postSummary.();
        nil
    });

    ("[Diag] Counting /md/levels for " ++ verifySeconds.asString ++ " s‚Ä¶").postln;
};

postSummary = {
    var aCount, bCount, tCount, message;
    aCount = packetCounts[2001] ? 0;
    bCount = packetCounts[2002] ? 0;
    tCount = packetCounts[1001] ? 0;

    message = "RESULT /md/levels  A=" ++ aCount.asString
        ++ "  B=" ++ bCount.asString
        ++ "  T=" ++ tCount.asString
        ++ "  lastA=" ++ lastAPair.asString
        ++ "  lastB=" ++ lastBPair.asString
        ++ "  lastT=" ++ lastTPair.asString;

    message.postln;
};

// run
ensureSources.();
installTapsRobust.();
verifyTraffic.();
)

===== troubleshooting/Diag_Meters_QuickProbe_A_B_T.scd =====
// Diag_Meters_QuickProbe_A_B_T.scd
// v0.1.0  MD 2025-09-26
(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_probe_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key);
    if(d.notNil) { d.free };
    ("RESULT A=" ++ counts[2001].asString ++ " " ++ lastA.asString
     ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
     ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString).postln;
    nil
});
"[Probe] counting /md/levels for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Diag_MeterWiring_Inspector.scd =====
// Diag_MeterWiring_Inspector.scd
(
var wantedPaths, allDefs, summary, listForPath, printEntry;
wantedPaths = ["/md/levels", "/ampA", "/ampB"];
allDefs = OSCdef.all;
listForPath = { arg pathString;
    var matches;
    matches = List.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == pathString) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            matches.add([keySym, portValue])
        };
    });
    matches
};
printEntry = { arg pathString, entries;
    (pathString ++ ": " ++ entries.size.asString ++ " listener(s)").postln;
    entries.do({ arg one;
        var keySym, portValue;
        keySym = one[0]; portValue = one[1];
        ("  key=" ++ keySym.asString ++ " port=" ++ portValue.asString).postln;
    });
};
"=== Meter Wiring Inspector ===".postln;
summary = wantedPaths.collect({ arg p; [p, listForPath.(p)] });
summary.do({ arg pair;
    var pathString, entries;
    pathString = pair[0]; entries = pair[1];
    printEntry.(pathString, entries);
});
)

===== troubleshooting/Feed_ChainA_TestTone_PlayChainA.scd =====
// Feed_ChainA_TestTone_PlayChainA.scd
// v0.1.0
// MD timestamp: 2025-09-26 19:40 GMT+1

/*
Purpose
- Generate a gentle test tone and feed it into Ndef(\chainA) using <<>.
- Also calls Ndef(\chainA).play so you can hear it through the default output.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var freq, amp, msg;

freq = 220;      // adjust if you prefer
amp  = 0.10;     // safe level

Server.default.bind({
    // signal generator
    Ndef(\testmelody, { var sig;
        sig = SinOsc.ar(freq ! 2) * amp;
        sig
    });

    // connect strictly per your rule (left <<> right)
    Ndef(\chainA) <<> Ndef(\testmelody);

    // make it audible (optional but useful for sanity)
    Ndef(\chainA).play;
});

msg = "[FEED] Ndef(\\chainA) <<> Ndef(\\testmelody), playing @ " ++ freq ++ " Hz, amp=" ++ amp;
msg.postln;
msg
)

===== troubleshooting/Fix_Meters_KnownGood.scd =====
// Fix_Meters_KnownGood.scd
// v0.1.0
// MD 2025-09-26 14:45 BST

/* Purpose / Style
   Minimal, known‚Äëgood meter bring‚Äëup:
   1) Install a /md/levels receiver (-> ~md_levelsById, ~md_lastMsgStamp).
   2) Re-arm inline taps on chainA (2001), chainB (2002), testmelody (1001) via Ndef.filter.
   3) Heartbeat prints "last /md/levels: X s" every ~2s so we know it's alive.
   - var-first; descriptive lowercase names; AppClock-only; no server.sync; no '?:'.
   - Pass-through taps (return 'in'); *generated audio only*.
*/

(
var installReceiver, ensureSources, installTaps, startHeartbeat;
var rateHz, receiverKey, heartbeatRoutine;

rateHz = 18;
receiverKey = \md_levels_hud;

// ---------- 1) /md/levels receiver ----------
installReceiver = {
    var existing;
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;

    existing = OSCdef.all.at(receiverKey);
    if(existing.notNil) { existing.free };

    OSCdef(receiverKey, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    ("[HUD] /md/levels listener installed (key=" ++ receiverKey.asString ++ ")").postln;
};

// ---------- 2) Sources / sinks kept alive (no server.sync) ----------
ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks "awake" at audio rate (no audible change)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    "[Meters] sources/sinks ensured.".postln;
};

// ---------- 3) Inline taps via known-good Ndef.filter ----------
installTaps = {
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A (replyID 2001)
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B (replyID 2002)
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (replyID 1001)
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
    "[Meters] inline taps armed (A=2001, B=2002, T=1001).".postln;
};

// ---------- 4) Heartbeat (light) ----------
startHeartbeat = {
    var beatInterval, routine;
    beatInterval = 2.0;
    routine = Routine({
        var keepRunning, now, lastAge;
        keepRunning = true;
        while({ keepRunning }, {
            now = SystemClock.seconds.asFloat;
            lastAge = (now - (~md_lastMsgStamp ? now)).round(0.01);
            ("[Meters] last /md/levels: " ++ lastAge.asString ++ " s").postln;
            beatInterval.wait;
        });
    }).play(AppClock);
    routine
};

// Run steps
installReceiver.();
ensureSources.();
installTaps.();

// (Optional) start/refresh overlay drawing here if you added one earlier.

// Heartbeat so we know packets are arriving
heartbeatRoutine = startHeartbeat.();
)

===== troubleshooting/Fix_Taps_CheckBadValues_SideEffect.scd =====
// Fix_Taps_CheckBadValues_SideEffect.scd
// v0.1.0
// MD 2025-09-26 17:35 BST

/* Purpose / Style
   Purpose: Reinstall /md/levels taps for A/B so that CheckBadValues.kr is side-effect only
            (do not overwrite the visual signals). This should remove the constant 1.0 issue.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync.
*/

(
var reinstallOnce;

reinstallOnce = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // ---- CHAIN A ‚Üí replyID 2001
        Ndef(\chainA).filter(\mdVisTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            // Log-like visual map then gentle smoothing; keep 0..1
            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // Side-effect diagnostics only (do NOT assign result)
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2001);
            in_sig  // pass-through audio
        });

        // ---- CHAIN B ‚Üí replyID 2002
        Ndef(\chainB).filter(\mdVisTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2002);
            in_sig
        });
    });
    "MDTAPS: reinstalled /md/levels taps (A=2001, B=2002) with side-effect checks only.".postln;
};

reinstallOnce.();
nil
)

===== troubleshooting/INSTALL_AmpA_AmpB_Responders_Min.scd =====
// INSTALL_AmpA_AmpB_Responders_Min.scd
// v0.1.0
// MD 2025-09-29

(
var ensureModelReady, installAmpResponders, updatesToLog, logKeyA, logKeyB;

updatesToLog = 6;
logKeyA = \ampA_to_model_log_once;
logKeyB = \ampB_to_model_log_once;

ensureModelReady = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installAmpResponders = {
    var existingA, existingB;

    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };

    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };

    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear, logText;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;

        if(updatesToLog > 0) {
            logText = "[ampA_to_model] A: L=" ++ leftLinear.round(0.01)
                ++ "  R=" ++ rightLinear.round(0.01);
            logText.postln;
            updatesToLog = updatesToLog - 1;
            if(updatesToLog <= 0) { "ampA/B model logging done.".postln };
        };
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
};

ensureModelReady.();
installAmpResponders.();
)

===== troubleshooting/justMartin/MD_Test_OneDrive_RoundTrip.scd =====
// MD_Test_OneDrive_RoundTrip.scd
// v0.1.1
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose: Detect a OneDrive root, create a test folder, write a file, read it back, and print results.
            Works with ~/Library/CloudStorage/OneDrive-* and legacy ~/OneDrive* names.
   Style:   Single () block; VAR-FIRST in every closure; descriptive lowercase names; no server.sync; finite print.
*/

(
var postBanner, expandPath, listFolders, findOneDriveRoot, writeThenRead;
var cloudRoot, homeRoot, foundRoot, testFolderPath, testFilePath, timeStampText, resultPath;

// Header
postBanner = {
    var headerText;
    headerText = "=== MD_TEST_ONEDRIVE_ROUND_TRIP ===";
    headerText.postln;
};

// Expand helper
expandPath = { arg pathString;
    var pn;
    pn = PathName(pathString.standardizePath);
    pn.fullPath
};

// Folder list helper
listFolders = { arg directoryPath;
    var pn, entries, indexCount, indexLimit, outList, item;
    pn = PathName(directoryPath);
    if(pn.isFolder.not) { [] } {
        entries = pn.entries;
        indexCount = 0; indexLimit = entries.size; outList = [];
        while({ indexCount < indexLimit }, {
            item = entries[indexCount];
            if(item.isFolder) { outList = outList.add(item.fullPath) };
            indexCount = indexCount + 1;
        });
        outList
    }
};

// Root finder
findOneDriveRoot = {
    var roots, candidates, indexCount, indexLimit, pathItem, baseOk;
    roots = [];

    cloudRoot = expandPath.("~/Library/CloudStorage");
    candidates = listFolders.(cloudRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    homeRoot = expandPath.("~");
    candidates = listFolders.(homeRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    if(roots.size > 0) { roots[0] } { nil }
};

// Writer/reader
writeThenRead = { arg folderPath;
    var okFolder, outFileName, outPath, readBackText;

    okFolder = PathName(folderPath).isFolder;
    if(okFolder.not) { File.mkdir(folderPath) };

    timeStampText = Date.getDate.stamp;
    outFileName = "sc_roundtrip_" ++ timeStampText ++ ".txt";
    outPath = folderPath ++ "/" ++ outFileName;

    File.use(outPath, "w", { arg fileRef; fileRef.write("Hello from SuperCollider at " ++ timeStampText) });
    readBackText = "";
    File.use(outPath, "r", { arg fileRef; readBackText = fileRef.readAllString });

    ("ODTEST: wrote " ++ outPath).postln;
    ("ODTEST: read  " ++ readBackText).postln;
    outPath
};

// ‚Äî‚Äî run ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner.();

foundRoot = findOneDriveRoot.();
if(foundRoot.isNil) {
    "‚ö†Ô∏è ODTEST: OneDrive root not found. Edit script to supply your OneDrive path explicitly.".warn;
    "   Example: set foundRoot = \"/Users/yourname/Library/CloudStorage/OneDrive-YourOrg\";".postln;
    resultPath = nil;
} {
    ("ODTEST: root = " ++ foundRoot).postln;
    testFolderPath = foundRoot ++ "/SC_MPB_Test";
    ("ODTEST: folder = " ++ testFolderPath).postln;
    resultPath = writeThenRead.(testFolderPath);
    "ODTEST: done.".postln;
};

// Final expression (so the block returns a value but uses no ^)
resultPath
)

===== troubleshooting/MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd =====
// MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd
// v0.1.0
// MD 2025-09-26 19:12 BST

/* Purpose / Style
   Purpose:
     ‚Ä¢ Loud console headers; clean-boot bring-up.
     ‚Ä¢ Single MagicDisplayGUI GridDemo window; bind CommandManager.display if present.
     ‚Ä¢ Generated-audio test source Ndef(\testmelody) at modest level.
     ‚Ä¢ Feed chain A from testmelody using Ndef(left) <<> Ndef(right).
     ‚Ä¢ Raw amplitude taps on A/B ‚Üí /md/levels (A=2001, B=2002).
     ‚Ä¢ Finite sniffer: print 6 lines (1 Hz) AND append to OneDrive log; auto-free listener.
     ‚Ä¢ Tiny overlay meters on the existing GUI (top-left) for ~4.5 s; auto-stop.
     ‚Ä¢ Final expression returns ‚Üí a Window.
   Style:
     ‚Ä¢ Single () block; VAR-FIRST in EVERY block/closure; ‚â•3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock for GUI; known-good SC syntax only.
*/

(
var postBanner, findWindowByPrefix, ensureGridDemoWindow, freeOscIfPresent, stopRoutineIfPresent;
var serverRef, guiWindow, systemRef, commandManagerRef;
var oneDriveRoot, sessionFolderPath, logFilePath, timeStampText;
var oscKeyLevels, linesRemaining, overlayView, overlayTicksRemaining, overlayRoutine;
var valuesById;

// ‚Äî‚Äî‚Äî loud header ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner = {
    var headerText;
    headerText = "=== MD_BRINGUP_GRIDDEMO_FEEDA_SAVEMETERS_ONEDRIVE ===";
    headerText.postln;
};

// ‚Äî‚Äî‚Äî helpers (VAR-FIRST in closures) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, nameString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        nameString = windowRef.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var priorWin, guiObj, newWin;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)‚Ä¶".postln;
    priorWin = findWindowByPrefix.("MagicDisplayGUI");
    if(priorWin.notNil) {
        priorWin.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };
    guiObj = MagicDisplayGUI_GridDemo.new;
    systemRef = ~system;
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };
    newWin = findWindowByPrefix.("Magic
===== troubleshooting/MD_Check_Suite_Symlink.scd =====
// MD_Check_Suite_Symlink.scd
// v0.1.0
// MD 2025-09-26 19:55 BST

/* Purpose / Style
   Purpose: Report whether Extensions/LivePedalboardSuite is a symlink and, if so, where it points.
            This block is read-only (no filesystem changes).
   Style:   Single () block; VAR-FIRST in every closure; ‚â•3-char lowercase descriptive names;
            no single-letter locals; no server.sync; finite output; no non-local ^ in .scd.
*/

(
var postBanner, quotePath, extensionsDir, suiteExtPath, testCmd, isLinkExit, isSymlinkFlag;
var readCmd, pipeRef, linkTargetPath, expectedTargetPrefix, looksCorrectFlag;

postBanner = {
    var headerText;
    headerText = "=== MD_CHECK_SUITE_SYMLINK ===";
    headerText.postln;
};

quotePath = { arg rawPathString;
    var q;
    q = "\"" ++ rawPathString.asString ++ "\"";
    q
};

postBanner.();

// 1) Paths
extensionsDir = Platform.userExtensionDir.standardizePath;
suiteExtPath  = extensionsDir +/+ "LivePedalboardSuite";
("EXT: suite path = " ++ suiteExtPath).postln;

// 2) Is it a symlink? (exit=0 means yes)
testCmd = "[ -L " ++ quotePath.(suiteExtPath) ++ " ]";
isLinkExit = testCmd.unixCmd;
isSymlinkFlag = (isLinkExit == 0);
("EXT: is symlink? " ++ isSymlinkFlag.asString).postln;

// 3) If a symlink, read its target
linkTargetPath = "(not a symlink)";
if(isSymlinkFlag) {
    readCmd = "readlink " ++ quotePath.(suiteExtPath);
    pipeRef = Pipe.new(readCmd, "r");
    linkTargetPath = if(pipeRef.notNil) { pipeRef.getLine } { "(unavailable)" };
    if(pipeRef.notNil) { pipeRef.close };
};
("EXT: link target = " ++ linkTargetPath).postln;

// 4) Does the link target appear to live under OneDrive?
expectedTargetPrefix = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
looksCorrectFlag = isSymlinkFlag and: { linkTargetPath.asString.beginsWith(expectedTargetPrefix) };
("OD : target under OneDrive? " ++ looksCorrectFlag.asString).postln;

// Final note
if(isSymlinkFlag.not) {
    "NOTE: Extensions/LivePedalboardSuite is a real folder, not a link. We can convert it to a symlink safely.".postln;
} {
    "NOTE: Good ‚Äî Extensions/LivePedalboardSuite is a symlink.".postln;
};

nil
)

===== troubleshooting/MD_MeterDiagnostics_Proof_Min.scd =====
// MD_MeterDiagnostics_Proof_Min.scd
// v0.1.1 (var-first everywhere; correct /md/levels format)
// MD timestamp: 2025-09-27 19:52 GMT+1

/*
Purpose (first principles)
- \const: set A to exact values (no audio), prove GUI path.
- \ramp: animate A deterministically (no audio), prove timing.
- \audio: feed a sine into chainA, compute expected RMS, print measured levels,
  send live values to /md/levels (A=2001, B=2002) and correlate with what you hear.

Style / Guard Rails
- Single () block; VAR-FIRST in all blocks/closures; no non-local returns; no server.sync.
- AppClock only for finite drivers; loud banners.
*/

(
var phase, server, sendToLang, banner, postLine, hz, secs, startWhen, endWhen, tickTask;
var constAL, constAR;
var testFreq, testAmp, expectedRMS;
var ensureProxy, attachTap, makeTaps;
var sendPair;

// ===== PHASE SELECTOR =====
phase = \const;  // change to \ramp or \audio and re-run the SAME block

// ===== COMMON UTILS (statements OK after var decls) =====
server     = Server.default;
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);
banner     = { arg text; ("[MDPROOF] " ++ text).postln; };
postLine   = { arg text; text.postln; };
hz         = 12;
secs       = 4.0;
startWhen  = thisThread.seconds;
endWhen    = startWhen + secs;

// We send messages matching your GUI/meter path:
// ['/md/levels', nodeID, replyID, L, R]  (replyIDs: A=2001, B=2002)
sendPair = { arg aLR, bLR;
    var aL, aR, bL, bR;
    aL = aLR[0]; aR = aLR[1]; bL = bLR[0]; bR = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

// ===== PHASE A params =====
constAL = 0.25;  // set any values 0..1 to prove exactness
constAR = 0.75;

// ===== PHASE C params =====
testFreq    = 220;
testAmp     = 0.20;                       // gentle
expectedRMS = (testAmp / (2.sqrt));       // RMS(sin) = A/‚àö2

// ===== TAPS for PHASE C (server-side; var-first in closures) =====
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);

        // Correct: replyID is 4th arg; values are ONLY [L, R]
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// ===== DRIVER =====
(phase == \const).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE A: set A=(" ++ constAL ++ "," ++ constAR ++ "), B=(0,0) for " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now;
        now = thisThread.seconds;
        (now < taskEnd).if({
            sendPair.([constAL, constAR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE A done.");
            nil
        });
    });
});

(phase == \ramp).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE B: ramp A L:0‚Üí0.9, R:0.9‚Üí0 over " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < taskEnd).if({
            t  = (now - taskStart) / secs;         // 0..1
            aL = (0.9 * t).clip(0.0, 0.9);         // rise
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);   // fall
            sendPair.([aL, aR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE B done.");
            nil
        });
    });
});

(phase == \audio).if({
    var spyStopAt;
    banner.("PHASE C: audio freq=" ++ testFreq ++ " Hz, amp=" ++ testAmp
        ++ "  (expected RMS‚âà" ++ expectedRMS.round(0.0001) ++ ")");

    Server.default.bind({
        var sig;
        sig = SinOsc.ar(testFreq ! 2) * testAmp;
        Ndef(\testmelody, { sig });
        Ndef(\chainA) <<> Ndef(\testmelody);
        Ndef(\chainA).play;
    });

    makeTaps.();

    spyStopAt = thisThread.seconds + 5.0;
    OSCdef(\mdSpyA, { arg msg, time, addr, port;
        var isA, l, r, line;
        isA = (msg.size >= 5) and: { msg[2] == 2001 };
        isA.if({
            l = msg[3].asFloat; r = msg[4].asFloat;
            line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
                ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.001);
            line.postln;
        });
    }, '/md/levels');

    AppClock.sched(5.0, {
        OSCdef(\mdSpyA).free;
        banner.("PHASE C done. Use Cleanup_ChainA_Unfeed later to stop audio.");
        nil
    });
});

"-> MD_MeterDiagnostics_Proof_Min scheduled.".postln;
)

===== troubleshooting/MD_Meters_D1_SpyAndRamp.scd =====
// MD_Meters_D1_SpyAndRamp.scd
// v0.1.0
// MD timestamp: 2025-09-28 09:55 GMT+1

/*
Purpose
- First principles: prove the sclang process receives /md/levels.
- Spy counts A (2001) and B (2002) messages for 3 s while we send a ramp.
- If counts > 0, OSC is fine and PerfHUD isn't listening to /md/levels.
- If counts == 0, messages aren't arriving (wrong port/shape).

Style / Guard Rails
- Single () block; VAR-FIRST everywhere; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendRamp, aCount, bCount, total, spy, startAt, endAt, banner;

hz         = 12;
secs       = 3.0;
aCount     = 0;
bCount     = 0;
total      = 0;
banner     = { arg text; ("[MD_D1] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// ---- Spy: capture ANY /md/levels messages and count A/B by replyID position ----
OSCdef(\md_levels_spy).free;
spy = OSCdef(\md_levels_spy, { arg msg, time, addr, port;
    var isA, isB;
    // Expect S1 standard: ['/md/levels', nodeID, replyID, L, R]
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isB = (msg.size >= 5) and: { msg[2] == 2002 };
    isA.if({ aCount = aCount + 1; });
    isB.if({ bCount = bCount + 1; });
    total = total + 1;
}, '/md/levels');

// ---- Known-good sender: S1 standard shape [0, replyID, L, R] ----
sendRamp = {
    var t, aL, aR, now, endSend;
    now = thisThread.seconds;
    endSend = now + secs;
    AppClock.sched(0.0, {
        var cur;
        cur = thisThread.seconds;
        (cur < endSend).if({
            t  = (cur - now) / secs;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
            sendToLang.sendMsg('/md/levels', 0, 2002, 0.0, 0.0); // B held at 0
            (1.0 / hz)
        }, {
            nil
        });
    });
};

banner.("Starting spy + ramp for " ++ secs ++ " s‚Ä¶");
startAt = thisThread.seconds;
endAt   = startAt + secs;

sendRamp.();

AppClock.sched(secs + 0.1, {
    OSCdef(\md_levels_spy).free;
    banner.("Spy summary: total=" ++ total
        ++ "  A(2001)=" ++ aCount
        ++ "  B(2002)=" ++ bCount);
    "-> MD_Meters_D1_SpyAndRamp done.".postln;
    nil
});
"-> MD_Meters_D1_SpyAndRamp scheduled."
)

===== troubleshooting/MD_Meters_D2_ListOSCdefs_ByPath.scd =====
// MD_Meters_D2_ListOSCdefs_ByPath.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:05 GMT+1

/*
Purpose
- Print all OSCdef listeners whose path mentions md/levels/meter.
- Confirms whether the PerfHUD window registered a listener and how it matches.
*/

(
var items, printOne;

items = List.new;

printOne = { arg keySym, def;
    var p, t, ps;
    p  = def.path;
    t  = def.argTemplate;
    ps = p ? "";
    ((ps.contains("md") or: { ps.contains("levels") or: { ps.contains("meter") } })).if({
        ("OSCdef " ++ keySym.asString
            ++ " : path=" ++ ps
            ++ "  template=" ++ (t ? nil).asString).postln;
        items.add(keySym);
    });
};

OSCdef.all.keysValuesDo { arg k, d; printOne.(k, d) };

("Found " ++ items.size ++ " OSCdef(s) matching 'md|levels|meter'").postln;
)

===== troubleshooting/MD_Meters_PhaseB_CompatProbe.scd =====
// MD_Meters_PhaseB_CompatProbe.scd
// v0.1.0
// MD timestamp: 2025-09-27 20:12 GMT+1

/*
Purpose
- Determine which /md/levels message shape your PerfHUD v0.5.4 consumes.
- Sends the same ramp in three 2s segments:
  A) S1 standard: ['/md/levels', nodeID=0, replyID=2001/2002, L, R]
  B) S0 legacy:  ['/md/levels', replyID=2001/2002, L, R]            // first arg after path is replyID
  C) S2 variant: ['/md/levels', nodeID=0, 0, replyID, L, R]         // mimics old SendReply misuse

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var hz, secsEach, sendToLang, banner, sendS1, sendS0, sendS2, startAt, segmentDur, schedSeg;

// Params
hz       = 12;      // updates per second
secsEach = 2.0;     // duration per segment (A/B/C)

// Utils
banner     = { arg text; ("[MD_COMPAT] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// --- Three message shapes ---
sendS1 = { arg aL, aR, bL, bR;
    // S1 standard: ['/md/levels', 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

sendS0 = { arg aL, aR, bL, bR;
    // S0 legacy: ['/md/levels', 2001, L, R]
    sendToLang.sendMsg('/md/levels', 2001, aL, aR);     // A
    sendToLang.sendMsg('/md/levels', 2002, bL, bR);     // B
};

sendS2 = { arg aL, aR, bL, bR;
    // S2 variant: ['/md/levels', 0, 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 0, 2002, bL, bR);  // B
};

// --- Scheduler for one segment with the given sender ---
schedSeg = { arg label, senderFunc;
    var segStart, segEnd;
    segStart = thisThread.seconds;
    segEnd   = segStart + secsEach;
    banner.("SEG " ++ label ++ " ‚Äî ramp A: L 0‚Üí0.9, R 0.9‚Üí0 (" ++ secsEach ++ " s)");
    AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < segEnd).if({
            t  = (now - segStart) / secsEach;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            senderFunc.value(aL, aR, 0.0, 0.0);  // B kept at 0
            (1.0 / hz)
        }, {
            banner.("SEG " ++ label ++ " done.");
            nil
        });
    });
};

// --- Run the three segments back-to-back ---
AppClock.sched(0.0, { schedSeg.("A (S1 standard: [0,replyID,L,R])", sendS1); secsEach });
AppClock.sched(secsEach, { schedSeg.("B (S0 legacy: [replyID,L,R])",   sendS0); secsEach });
AppClock.sched(secsEach*2, { schedSeg.("C (S2 variant: [0,0,replyID,L,R])", sendS2); nil });

"-> MD_Meters_PhaseB_CompatProbe scheduled (6 s total).".postln;
)

===== troubleshooting/MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd =====
// MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:27 GMT+1

/*
Purpose
- Audio proof with the tap attached to Ndef(\testmelody) (the generator),
  so measured levels are guaranteed non-zero and derived from the actual test signal.
- Sends /md/levels A=2001 from the tap; B stays untouched.

Style / Guard Rails
- Single () block; VAR-FIRST throughout; no non-local returns; no server.sync.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTapOnTest;

// params
hz = 12;
testFreq = 220;
testAmp  = 0.20;                       // gentle, audible
expectedRMS = (testAmp / (2.sqrt));    // ‚âà 0.1414

banner = { arg text; ("[MD_A_AUDIO_FIX] " ++ text).postln; };

// ensure Ndefs exist (not strictly needed for \testmelody, kept for consistency)
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

// attach tap directly on \testmelody (NOT \chainA)
attachTapOnTest = { arg replyID;
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID); // replyID=2001
        inSig
    });
};

// generate tone, feed chainA, and play (so you hear it)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    ensureProxy.(\chainA, 2);
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

attachTapOnTest.(2001);

// finite console monitor for correlation (5 s)
OSCdef(\mdSpyA_fix).free;
OSCdef(\mdSpyA_fix, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
        ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA_fix).free;
    banner.("done (audio keeps playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS‚âà" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio_FIX_TapOnTest scheduled."
)

===== troubleshooting/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd =====
// MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd
// v0.1.2
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose:
     ‚Ä¢ Loud console header + step banners so you can see it ran.
     ‚Ä¢ Clean-boot bring-up: server, single MagicDisplayGUI GridDemo window, modest-level test source.
     ‚Ä¢ Feed chain A from testmelody using your operator: Ndef(left) <<> Ndef(right).
     ‚Ä¢ Install simple raw Amplitude taps to /md/levels (A=2001, B=2002).
     ‚Ä¢ Print exactly 6 lines (1 Hz) and auto-stop; no console spam.
     ‚Ä¢ Final expression returns ‚Üí a Window.
   Style:
     ‚Ä¢ Single () block; VAR-FIRST in every block/closure; ‚â•3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock-only for GUI; known-good SC syntax.
*/

(
var postBanner, freeOscIfPresent, stopRoutineIfPresent, findWindowByPrefix, ensureGridDemoWindow;
var serverRef, oscKeyLevels, reporterRoutine, linesRemaining, guiWindow, systemRef, commandManagerRef;

// ‚Äî‚Äî header ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner = {
    var headerText;
    headerText = "=== MD_MIN_BRINGUP_FEEDA_SIMPLEMETERS_GRIDDEMO ===";
    headerText.postln;
};

// ‚Äî‚Äî helpers (VAR-FIRST inside closures) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MD: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineRef, labelString;
    var canStopRoutine;
    canStopRoutine = routineRef.notNil and: { routineRef.respondsTo(\stop) };
    if(canStopRoutine) { routineRef.stop; (labelString ++ ": stopped").postln };
};

findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, titleString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        titleString = windowRef.tryPerform(\name);
        if(titleString.notNil and: { titleString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            // do not use ^ ; just set foundWindow and let the closure return last expression
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var oldWindow, guiObj, newWindow;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)‚Ä¶".postln;

    oldWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(oldWindow.notNil) {
        oldWindow.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };

    guiObj = MagicDisplayGUI_GridDemo.new; // safe fallback GUI

    systemRef = ~system; // if user has a system object, bind display
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };

    newWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(newWindow.isNil) { "‚ö†Ô∏è GUI: no MagicDisplayGUI window found after creation".warn };
    newWindow
};

// ‚Äî‚Äî run ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner.();

// Server bring-up (allowed here)
serverRef = Server.default;
"STEP S: booting server‚Ä¶".postln;
serverRef.waitForBoot;
"STEP S: server booted".postln;

// GUI
guiWindow = ensureGridDemoWindow.();

// Source: testmelody (modest level; generated audio only)
"STEP SRC: defining Ndef(\\testmelody)‚Ä¶".postln;
Server.default.bind({
    Ndef(\testmelody, {
        var triggerCtl, freqCtl, envCtl, panCtl, midiScale, indexCtl, pairSig;
        triggerCtl = Impulse.kr(2.0);
        midiScale  = [60, 62, 64, 67, 69];
        indexCtl   = Demand.kr(triggerCtl, 0, Dwhite(0, midiScale.size, inf));
        freqCtl    = Select.kr(indexCtl, midiScale).midicps;
        envCtl     = Decay2.kr(triggerCtl, 0.01, 0.40);
        panCtl     = LFNoise1.kr(0.25).range(-0.6, 0.6);
        pairSig    = Pan2.ar(SinOsc.ar(freqCtl) * envCtl * 0.18, panCtl); // modest level
        pairSig
    });
    Ndef(\testmelody).ar(2);
});

// Feed chain A from testmelody (your operator)
"STEP FEED: using Ndef(left) <<> Ndef(right): A <<> testmelody".postln;
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
    Ndef(\chainA) <<> Ndef(\testmelody);
});

// Simple raw amplitude taps to /md/levels
"STEP TAPS: install raw amplitude taps (/md/levels A=2001, B=2002)‚Ä¶".postln;
oscKeyLevels = \md_levels_sniffer_finite;
freeOscIfPresent.(oscKeyLevels);

Server.default.bind({
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
        inSig
    });

    Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
        inSig
    });
});

// Finite 6-line sniffer (auto-free)
"STEP MTR: printing 6 lines (1 Hz) then auto-stop‚Ä¶".postln;
linesRemaining = 6;
OSCdef(oscKeyLevels, { arg oscMessage;
    var replyId, leftVal, rightVal, meterLabel, linesDone;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        meterLabel = if(replyId == 2001) { "A" } { if(replyId == 2002) { "B" } { replyId.asString } };
        ("MDMTR: " ++ meterLabel ++ " (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")").postln;

        linesRemaining = linesRemaining - 1;
        linesDone = linesRemaining <= 0;
        if(linesDone) {
            var oscRef2;
            oscRef2 = OSCdef.all.at(oscKeyLevels);
            if(oscRef2.notNil) { oscRef2.free; "MDMTR: listener freed.".postln };
        };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Bring GUI front and return ‚Üí a Window
if(guiWindow.notNil) { guiWindow.front };
guiWindow  // ‚Üí a Window
)

===== troubleshooting/MD_PerfHUD_LevelSubscriber.scd =====
// MD_PerfHUD_LevelSubscriber.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:15 GMT+1

/*
Purpose
- Populate ~md_levelsById (IdentityDictionary) from /md/levels messages so
  MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd can render meters.
- Also updates ~md_lastMsgStamp for the "last /md/levels age" display.

Message shapes handled
- Standard: ['/md/levels', nodeID, replyID, L, R]   (preferred)
- Legacy:   ['/md/levels', replyID, L, R]           (fallback)

Reply IDs used by the GUI (per file comments):
- A = 2001, B = 2002, test = 1001
*/

(
var ensureDict, putPair, banner, oscAny;

banner = { arg text; ("[MD_SUB] " ++ text).postln; };

// Ensure the shared dictionary exists (the GUI reads this)
ensureDict = {
    (~md_levelsById.isKindOf(IdentityDictionary)).if({
        // already OK
    }, {
        ~md_levelsById = IdentityDictionary.new;
        banner.("created ~md_levelsById");
    });
    ~md_lastMsgStamp = ~md_lastMsgStamp ? thisThread.seconds;
};

putPair = { arg id, l, r;
    var pair;
    pair = [ (l ? 0.0).asFloat, (r ? 0.0).asFloat ];
    ~md_levelsById[id] = pair;
    ~md_lastMsgStamp = thisThread.seconds;
};

// Clean prior instance (idempotent)
OSCdef(\md_levels_any).free;

ensureDict.();

// One listener that accepts both shapes and writes into ~md_levelsById
oscAny = OSCdef(\md_levels_any, { arg msg, time, addr, port;
    var id, l, r, sz;
    sz = msg.size;
    // Standard
    (sz >= 5).if({
        id = msg[2];
        l  = msg[3];
        r  = msg[4];
        putPair.(id, l, r);
    }, {
        // Legacy
        (sz == 4).if({
            id = msg[1];
            l  = msg[2];
            r  = msg[3];
            putPair.(id, l, r);
        }, {
            // ignore
        });
    });
}, '/md/levels');

banner.("listening on /md/levels ‚Üí ~md_levelsById (A=2001, B=2002, test=1001)");
"-> MD_PerfHUD_LevelSubscriber ready"
)

===== troubleshooting/MD_PhaseC_Smoke_PlayTest_TapTest.scd =====
// MD_PhaseC_Smoke_PlayTest_TapTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:58 GMT+1

/*
Purpose
1) Force Ndef(\testmelody) to run by playing it directly.
2) Prove the tap executes by sending a constant 0.5 for 2s (meters must move).
3) Switch the tap to real Amplitude.kr for 3s and print measured vs expected RMS.
All updates go to /md/levels A=2001 (B untouched).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync; finite.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, now,
    installConstantTap, installAmplitudeTap, removeTap, spy, stopSpyAt;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ‚âà0.1414

banner = { arg text; ("[MD_SMOKE] " ++ text).postln; };

// 0) Ensure a fresh, running generator (play directly so the proxy surely runs)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\testmelody).play; // <-- force run; independent of \chainA
});
banner.("testmelody playing @ " ++ testFreq ++ " Hz, amp=" ++ testAmp);

// helper: remove our tap cleanly
removeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig; inSig });
};

// 1) Tap variant A: constant 0.5 for 2s (meters must move)
installConstantTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var trig, l, r;
        trig = Impulse.kr(hz);
        l = 0.5; r = 0.5;
        SendReply.kr(trig, '/md/levels', [l, r], 2001);
        inSig
    });
    banner.("tap A: CONSTANT 0.5 for 2s (A should show ~0.5)");
};

// 2) Tap variant B: real amplitude for 3s (print measured vs expected)
installAmplitudeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], 2001);
        inSig
    });
    banner.("tap B: Amplitude.kr for 3s (console prints A_meas vs expected RMS)");
};

// Spy: show arriving values for A=2001 only
OSCdef(\mdSmokeSpy).free;
spy = OSCdef(\mdSmokeSpy, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
            ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

// Schedule: 0..2s constant 0.5, 2..5s amplitude, stop spy
now = thisThread.seconds;

AppClock.sched(0.0, { installConstantTap.(); 2.0 });
AppClock.sched(2.0, { installAmplitudeTap.(); 3.0 });
stopSpyAt = now + 5.0;
AppClock.sched(5.0, {
    removeTap.();
    OSCdef(\mdSmokeSpy).free;
    banner.("done (testmelody still playing; stop with MD_Cleanup_ChainA_Unfeed if needed).");
    nil
});

"-> MD_PhaseC_Smoke_PlayTest_TapTest scheduled."
)

===== troubleshooting/MD_Probe_Sources_Chain_RawAmp_AutoStop.scd =====
// MD_Probe_Sources_Chain_RawAmp_AutoStop.scd
// v0.1.0
// MD 2025-09-26 18:22 BST

/* Purpose / Style
   Purpose: Measure raw amplitudes directly at the source Ndef(\testmelody) and at the sink Ndef(\chainA)
            by creating two temporary probe Ndefs that read those proxies and SendReply their raw
            Amplitude.kr values to "/md/probe". A finite OSCdef prints exactly 6 lines and then removes
            itself and frees the probes. No GUI changes, no server.sync, single block.
   Style:   single () block; var-first in every closure; descriptive lowercase variable names (>=3 chars);
            AppClock-safe; returns nil.
*/

(
var ensureProbes, installSpy, startReporterAndCleanup;
var probeKeySource, probeKeyChain, spyKey, reporterRoutine, printCountRemaining;

// ---- configuration
printCountRemaining = 6;
probeKeySource = \md_probe_tm;    // probe for testmelody
probeKeyChain  = \md_probe_chain; // probe for chainA
spyKey         = \md_probe_spy;   // OSCdef key

// ---- 1) Create probes (server-side) that read from existing Ndefs and SendReply raw amplitudes
ensureProbes = {
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Server.default.bind({
        // Probe source: reads Ndef(\testmelody).ar(2)
        Ndef(probeKeySource, {
            var srcSig, ampLeft, ampRight;
            srcSig   = Ndef(\testmelody).ar(2);  // read directly from the source proxy
            ampLeft  = Amplitude.kr(srcSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(srcSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51001);
            Silent.ar(2) // silent synth (no audio output)
        }).play;  // ensure it runs on the server

        // Probe chainA: reads Ndef(\chainA).ar(2)
        Ndef(probeKeyChain, {
            var chainSig, ampLeft, ampRight;
            chainSig = Ndef(\chainA).ar(2);  // read directly from the sink proxy
            ampLeft  = Amplitude.kr(chainSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(chainSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51002);
            Silent.ar(2)
        }).play;
    });

    "MDPROBE: probes created (tm=51001, chainA=51002) ‚Üí /md/probe".postln;
};

// ---- 2) Spy listener (finite) that prints exactly 6 lines then frees itself and the probes
installSpy = {
    if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

    OSCdef(spyKey, { arg oscMessage;
        var msgSize, replyId, leftVal, rightVal, lineText;

        msgSize = oscMessage.size;
        if(msgSize >= 5) {
            replyId = oscMessage[2];
            leftVal  = oscMessage[3];
            rightVal = oscMessage[4];

            // guard + clip to [0,1]
            leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
            rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

            lineText = case
            { replyId == 51001 } { "SRC \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { replyId == 51002 } { "A   \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { "ID " ++ replyId.asString ++ " \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" };

            ("MDPROBE: " ++ lineText).postln;

            printCountRemaining = printCountRemaining - 1;
            if(printCountRemaining <= 0) {
                var spyObj;
                spyObj = OSCdef.all.at(spyKey);
                if(spyObj.notNil) { spyObj.free; "MDPROBE: spy freed".postln };

                // free probes (server-side)
                Server.default.bind({
                    if(Ndef(probeKeySource).isPlaying) { Ndef(probeKeySource).free };
                    if(Ndef(probeKeyChain ).isPlaying) { Ndef(probeKeyChain ).free };
                });
                "MDPROBE: probes freed".postln;
            };
        };
        nil
    }, "/md/probe", recvPort: NetAddr.langPort);
    "MDPROBE: spy armed (6 lines)‚Ä¶".postln;
};

// ---- 3) Go
ensureProbes.();
installSpy.();
nil
)

===== troubleshooting/MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd =====
// MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd
// v0.1.0
// MD 2025-09-26 17:55 BST

/* Purpose / Style
   Purpose: Replace current /md/levels taps with a *simple* version that sends raw Amplitude.kr values
            (no LinExp, no LagUD) for A/B sinks. Then install a finite sniffer that prints exactly
            6 lines (one per second) and auto-stops.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync; AppClock.
*/

(
// ---- reinstall simple taps (server-side), replyIDs: A=2001, B=2002
var reinstallSimpleTaps;

reinstallSimpleTaps = {
    Server.default.bind({
        var rateHertz, attackSec, releaseSec, floorAmp;

        rateHertz  = 24;
        attackSec  = 0.01;
        releaseSec = 0.20;
        floorAmp   = 1e-5;

        // CHAIN A
        Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            // Send raw amplitudes (0..1)
            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
            inSig
        });

        // CHAIN B
        Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
            inSig
        });
    });
    "MDSIMPLE: raw amplitude taps installed (/md/levels; A=2001 B=2002).".postln;
};

reinstallSimpleTaps.();
nil
);

// ---- finite sniffer: prints exactly 6 lines and auto-stops
(
var valuesById, oscKey, remainingLines, reporterRoutine;

// Shared store
valuesById = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = valuesById;

// Finite cycles to print
remainingLines = 6;

// Clean previous finite sniffer (if any)
oscKey = \md_levels_sniffer_fixed;
if(OSCdef.all.at(oscKey).notNil) { OSCdef.all.at(oscKey).free };

// Listener: only update the dict; no console spam here
OSCdef(oscKey, { arg oscMessage;
    var replyId, leftVal, rightVal;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        // Guards + clip 0..1
        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        valuesById.put(replyId, [leftVal, rightVal]);
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Reporter: 1 Hz; prints 6 lines then stops and frees listener
reporterRoutine = Routine({
    var keepRunning;
    keepRunning = true;

    while({ keepRunning and: { remainingLines > 0 } }, {
        var pairA, pairB, textA, textB;

        pairA = valuesById.at(2001) ? [0, 0];
        pairB = valuesById.at(2002) ? [0, 0];

        textA = "A(L,R)=(" ++ pairA[0].round(0.01) ++ "," ++ pairA[1].round(0.01) ++ ")";
        textB = "B(L,R)=(" ++ pairB[0].round(0.01) ++ "," ++ pairB[1].round(0.01) ++ ")";

        ("MDSIMPLE: " ++ textA ++ "  " ++ textB).postln;

        remainingLines = remainingLines - 1;
        1.0.wait;
    });

    // Auto-clean: free listener and stop routine
    var oscObj;
    oscObj = OSCdef.all.at(oscKey);
    if(oscObj.notNil) { oscObj.free; "MDSIMPLE: listener freed.".postln };

    "MDSIMPLE: reporter finished.".postln;
}).play(AppClock);

nil
)

===== troubleshooting/MD_Spy_md_levels_RawAutoStop.scd =====
// MD_Spy_md_levels_RawAutoStop.scd
// v0.1.0
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Print the next 4 OSC messages received on "/md/levels" verbatim (with indices),
            then auto-free the listener so the console stays clean.
   Style:   single () block; var-first everywhere; descriptive lowercase names; no server.sync; returns nil.
*/

(
var spyKey, remainingCount, printOneMessage;

spyKey = \md_levels_spy_once;
remainingCount = 4;

// ensure previous spy is gone
if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

// print helper (var-first inside closure)
printOneMessage = { arg messageArray;
    var sizeCount, indexPos, indexLimit, lineText;
    sizeCount = messageArray.size;
    ("MDSPY: size=" ++ sizeCount.asString).postln;
    indexPos = 0; indexLimit = sizeCount;
    while({ indexPos < indexLimit }, {
        lineText = ("  [" ++ indexPos.asString ++ "] = " ++ messageArray[indexPos].asString);
        lineText.postln;
        indexPos = indexPos + 1;
    });
};

OSCdef(spyKey, { arg oscMessage;
    var localCount, doneNow;
    localCount = remainingCount;
    printOneMessage.(oscMessage);
    remainingCount = remainingCount - 1;
    doneNow = remainingCount <= 0;
    if(doneNow) {
        var spyObj;
        spyObj = OSCdef.all.at(spyKey);
        if(spyObj.notNil) { spyObj.free; "MDSPY: freed".postln };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

"MDSPY: armed for 4 messages‚Ä¶".postln;
nil
)

===== troubleshooting/MD_Taps_Clear_All_FIXED.scd =====
// MD_Taps_Clear_All_FIXED.scd
// v0.1.1 (clear proxies instead of filter(..., nil))
// MD timestamp: 2025-09-28 10:52 GMT+1

/*
Purpose
- Remove all taps/filters by clearing proxies and recreating chainA as a 2‚Äëch audio proxy.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var msg;

Server.default.bind({
    // stop and clear any existing sources/filters/taps
    Ndef(\chainA).stop; Ndef(\chainA).clear; Ndef(\chainA).ar(2);
    Ndef(\chainB).stop; Ndef(\chainB).clear; Ndef(\chainB).ar(2);
    Ndef(\testmelody).stop; Ndef(\testmelody).clear;
});

msg = "[TAPS] cleared: chainA, chainB, testmelody ‚Äî chainA re-created as 2ch.";
msg.postln;
msg
)

===== troubleshooting/MD_Taps_Clear_All.scd =====
// MD_Taps_Clear_All.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:45 GMT+1

/*
Purpose
- Remove any previously attached /md/levels taps on chainA/chainB/testmelody
  so only one producer drives A=2001 / B=2002.

Style
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var cleared;

Server.default.bind({
    // Remove known tap filter keys if present
    Ndef(\chainA).filter(\eodTapA, nil);
    Ndef(\chainB).filter(\eodTapB, nil);
    Ndef(\testmelody).filter(\proofTap, nil);
});

cleared = "[TAPS] cleared filters: chainA(\\eodTapA), chainB(\\eodTapB), testmelody(\\proofTap)";
cleared.postln;
cleared
)

===== troubleshooting/MODEL_Print_Amp_Model_Values.scd =====
// MODEL_Print_Amp_Model_Values.scd
// v0.1.1
// MD 2025-09-29

(
var linesRemaining, printOnce;

linesRemaining = 6;

printOnce = {
    var levelsA, levelsB, reportText;
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });
    reportText = "model A=" ++ levelsA ++ "   B=" ++ levelsB;
    reportText.postln;

    linesRemaining = linesRemaining - 1;
    if(linesRemaining > 0) {
        AppClock.sched(0.5, { printOnce.(); nil });
    }{
        nil
    };
};

AppClock.sched(0.0, { printOnce.(); nil });
)

===== troubleshooting/Notes_Meters_2025-09-26.txt =====
Notes_Meters_2025-09-26
MD 2025-09-26

Summary
- NEW HUD (PerfHUD v0.5.4) is the correct window.
- Root cause of ‚Äúmeters not moving‚Äù: no OSC responders active in HUD (0 listeners for /md/levels, /ampA, /ampB).
- Secondary nuisance: occasional Window.flipY(nil) ‚Äì not from PerfHUD file; handled during dev by a guard.

What works now
1) /md/levels receiver (language-side) installed with key md_levels_hud:
   - Updates ~md_levelsById, ~md_lastMsgStamp.
   - Known-good: OSCdef(\md_levels_hud, { ... }, "/md/levels", recvPort: NetAddr.langPort).

2) Inline taps (pass-through) armed on server via Ndef.filter(name, func):
   - A ‚Üí replyID 2001, B ‚Üí 2002, testmelody probe ‚Üí 1001.
   - No 'removeFilter'; use filter(\name, nil) only if needed (we avoid it).

3) Heartbeat shows last /md/levels age ~0‚Äì1 s during normal operation.

4) LPS bring-up now performs, in order:
   - Close existing MagicDisplay windows.
   - Load PerfHUD v0.5.4.
   - Re-enable FilterMeters / Attach Probes / Reset Receiver (troubleshooting scripts).
   - Install /md/levels HUD listener (md_levels_hud).
   - Arm inline taps at ~18 Hz (A/B/testmelody).

Why meters looked "quiet"
- Taps were sending linear amplitude 0..1 (Amplitude.kr).
- GUI was drawing linearly, so normal musical levels looked small.
- Fix: map to dB in GUI (amp ‚Üí dB ‚Üí normalized 0..1). No DSP change.

Active highlight rule
- Previously: energy-based heuristic (pulsed).
- Now: chain flag ~md_currentChain = \A|\B ‚Äì stays green while active.
- Setter: ~md_setCurrentChain.(\A) or .(\B). To be called from switch path.

Dev guards
- A temporary Window.flipY guard extension prevented nil-rect crashes during bring-up.
- Repo search shows no flipY or Window.bounds in our sources; final call-site TBD.

Keep it working (policy)
- LPS bring-up installs HUD listener and taps every time.
- Taps use only Ndef.filter ‚Äì known-good API.
- No 'removeFilter', no '++' on Associations, no '? :' ternary.

===== troubleshooting/obsolete/turnintooneplease copy.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/PerfHUD_Adhoc_MeterFix_Overlay.scd =====
// PerfHUD_Adhoc_MeterFix_Overlay.scd
// v0.1.0
// MD 2025-09-26 13:42 BST

/* Purpose / Style
   - Install a /md/levels listener (HUD-side) so meters have data.
   - Add a small overlay meter (top-left) to prove live updates right now.
   - var-first; descriptive lowercase vars; AppClock-only; no server.sync.
*/

(
var ensureModel, installHudResponder, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installHudResponder = {
    var existing;
    existing = OSCdef.all.at(\md_levels_hud);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_hud, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[HUD] /md/levels listener installed (key=md_levels_hud)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 84;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half, slightly lighter)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15; lastBeatTime = SystemClock.seconds.asFloat;
    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[HUD] meters tick; last /md/levels "
                    ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            0.15.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installHudResponder.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) { attachOverlay.(hudWindow); startRefresh.() } {
    "‚ö†Ô∏è No MagicDisplayGUI window found; bring up PerfHUD first.".warn;
};
)

===== troubleshooting/PERFHUD_Bus_Indices_Inspect.scd =====
// PERFHUD_Bus_Indices_Inspect.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, summaryText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

summaryText =
    "[bus indices] A=" ++ (hasBusA.if({ ~busA.index }, { "nil" })) ++
    "  B=" ++ (hasBusB.if({ ~busB.index }, { "nil" }));

summaryText.postln;
)

===== troubleshooting/PerfHUD_Diag_OverlayMeters.scd =====
// PerfHUD_Diag_OverlayMeters.scd
// v0.1.0
// MD 2025-09-26 13:12 BST

/* Purpose
   - Prove the meter data path & UI repaint with a non-intrusive overlay.
   - Installs a /md/levels receiver -> ~md_levelsById.
   - Adds a tiny overlay UserView that animates A/B bars (top-left).
   - Very light diagnostics: heartbeat every ~2 seconds.
*/

(
var ensureModel, installReceiver, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installReceiver = {
    var existing;
    existing = OSCdef.all.at(\md_levels_diag);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_diag, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[Diag] /md/levels receiver installed (key=md_levels_diag)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 80;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        var aEnergy, bEnergy, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;

        // A on bottom half, B on top half (thin overlay)
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[Diag] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15;
    lastBeatTime = SystemClock.seconds.asFloat;

    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[Diag] meters tick; last /md/levels " ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            beatInterval.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installReceiver.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) {
    attachOverlay.(hudWindow);
    startRefresh.();
} {
    "‚ö†Ô∏è No MagicDisplayGUI window found; run the HUD first.".warn;
};
)

===== troubleshooting/PERFHUD_InlineTaps_On_ChainAB.scd =====
// PERFHUD_InlineTaps_On_ChainAB.scd
// v0.1.0
// MD 2025-09-29 15:26 BST

(
/* Purpose
   - Replace bus-based bridge (silent because no buses exist) with inline taps on Ndef(\chainA/\chainB).
   - Send linear amplitudes for PerfHUD via '/ampA' and '/ampB' (2 values each, L/R).
   - Also send dB readings via '/md/levels_db' with replyIDs A=2001, B=2002 for console sanity.
Style
   - var-first; descriptive lowercase variable names; Server.default.bind for server ops; AppClock for UI only.
   - No server.sync; no non-local returns; idempotent (re-running replaces the taps).
*/

var freeBusBridgeIfPresent, installInlineTaps, installDbSniffer, printLinesRemaining;
var attackSeconds, releaseSeconds, updateRateHz, minLinearFloor;
var oscKeyDb;

attackSeconds   = 0.01;
releaseSeconds  = 0.20;
updateRateHz    = 24;
minLinearFloor  = 1e-7;
printLinesRemaining = 6;
oscKeyDb = \perfHud_db_sniff;

// 1) Free the bus-bridge synth (if any), to avoid double feeds
freeBusBridgeIfPresent = {
    if(~md_levelsSynth.notNil) {
        ~md_levelsSynth.free;
        ~md_levelsSynth = nil;
        "99: Freed md_levels4_from_busses (bus bridge) ‚Äî switching to inline taps.".postln;
    };
};

// 2) Install inline taps on chainA and chainB
installInlineTaps = {
    Server.default.bind({
        // chainA ‚Üí '/ampA' (linear pair) and '/md/levels_db' (dB; replyID=2001)
        Ndef(\chainA).filter(\perfHudTapA, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            // normalize to a stereo pair (duplicate if mono)
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampA', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2001);

            // return audio unchanged
            localSignal
        });

        // chainB ‚Üí '/ampB' (linear pair) and '/md/levels_db' (dB; replyID=2002)
        Ndef(\chainB).filter(\perfHudTapB, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampB', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2002);

            // return audio unchanged
            localSignal
        });
    });

    "99: Inline taps installed on chainA/chainB ‚Üí '/ampA' & '/ampB' (+ dB on '/md/levels_db').".postln;
};

// 3) Short-lived dB console sniffer (6 lines total), then auto-free
installDbSniffer = {
    // clean any previous instance
    if(OSCdef(oscKeyDb).notNil) { OSCdef(oscKeyDb).free };

    OSCdef(oscKeyDb, { arg message;
        var replyId, dbLeft, dbRight, labelText;
        if(message.size >= 5) {
            replyId = message[2];
            dbLeft  = message[3].round(0.1);
            dbRight = message[4].round(0.1);
            labelText = "[dB inline " ++ replyId.asString ++ "] L=" ++ dbLeft ++ " dB  R=" ++ dbRight ++ " dB";
            labelText.postln;

            printLinesRemaining = printLinesRemaining - 1;
            if(printLinesRemaining <= 0) {
                OSCdef(oscKeyDb).free;
                "[dB inline] sniff done.".postln;
            };
        };
    }, '/md/levels_db');
};

// Execute
freeBusBridgeIfPresent.();
installInlineTaps.();
installDbSniffer.();
)

===== troubleshooting/PERFHUD_Repoint_MeterSynth_To_Buses.scd =====
// PERFHUD_Repoint_MeterSynth_To_Buses.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, repointedText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

if(~md_levelsSynth.notNil) {
    if(hasBusA) { ~md_levelsSynth.set(\inBusA, ~busA.index) };
    if(hasBusB) { ~md_levelsSynth.set(\inBusB, ~busB.index) };
    repointedText = "99: md_levels4_from_busses repointed to inBusA=" ++
        (hasBusA.if({ ~busA.index }, { "unchanged" })) ++
        "  inBusB=" ++ (hasBusB.if({ ~busB.index }, { "unchanged" }));
    repointedText.postln;
}{
    "‚ö†Ô∏è  md_levelsSynth not running; run 99_PerfHUD_MetersFromBusses.scd first.".warn;
}
)

===== troubleshooting/RMS_IsolatedHUD_BringUp.scd =====
// RMS_IsolatedHUD_BringUp.scd
//_v0.1.2
// MD 2025-09-29 19:10 BST

/* Purpose
   Show RMS (dB) at the *ends* of chainA and chainB in a NEW isolated window.
   - Reads Ndef(\chainA/\chainB) output busses directly: In.ar(bus, 2)
   - RMS per channel via RMS.ar(sig, 500)   // your spec
   - Convert to dBFS and map dB‚Üí0..1 for bar height (adjustable floor/top)
   - No shared OSC paths; no writes into existing HUD => zero interference

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops;
     no server.sync; no non-local returns. Returns '-> a Window'.
*/

(
var // calibration (live‚Äëtweakable via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra headroom)
updateRateHz   =  15;

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no VLayout/HLayout pitfalls) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aL, aR, bL, bR;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aL = sigA[0];
            aR = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bL = sigB[0];
            bR = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (your spec)
            rmsAL = RMS.ar(aL, 500);
            rmsAR = RMS.ar(aR, 500);
            rmsBL = RMS.ar(bL, 500);
            rmsBR = RMS.ar(bR, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);
            // Private OSC: 4 dB values [A_L, A_R, B_L, B_R]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busA, busB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busA, \inBusB, busB, \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busA ++ "  B=" ++ busB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait briefly until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START**
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this block.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window
rmsWindow;
)

===== troubleshooting/RMS_IsolatedHUD.scd =====
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/Run_All_PerfHUD_RMS_Isolated.scd =====
// Run_All_PerfHUD_RMS_Isolated.scd
// v0.1.0
// MD 2025-09-29 19:40 BST

/* Purpose
   One-shot bring-up from a clean SC restart:
     1) 00_Reset_KnownClean_State.scd
     2) 01b_StartHere_NoReboot.scd
     3) 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
     4) 02D_TestSource_CenteredStereo_Pulsed.scd
     5) RMS_IsolatedHUD (new window): reads ends of chainA/chainB, RMS.ar(sig,500) ‚Üí dB ‚Üí meters

Style
   - var-first; descriptive lowercase names; AppClock for sequencing/GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. Returns '-> a Window' (the RMS window) at the end.
*/

(
var // config (paths and small timings)
    baseDir, fReset, fStartHere, fAssertStereo, fTestSource,
    smallPause, mediumPause, longPause,

    // helpers
    ensureBaseDir, executeFileOnce, scheduleSequence,

    // rms window block (self-contained)
    buildRmsIsolatedHud, // returns a Window
    finalWindow;

// --- configuration (adjust only if your file names differ) -------------------
smallPause  = 0.25;   // seconds between immediate steps
mediumPause = 0.60;   // seconds to allow bring-up to tick
longPause   = 1.00;   // seconds for heavier steps

// Derive the troubleshooting/ folder by default (assumes this file is saved there)
ensureBaseDir = {
    // If this script is saved as a file, we can use nowExecutingPath; otherwise ask user to set.
    var fromFile = thisProcess.nowExecutingPath;
    if(fromFile.notNil) {
        baseDir = PathName(fromFile).parentPath;  // should end with '/'
    }{
        // Fallback: try to guess a 'troubleshooting' folder relative to current documents dir.
        // If this fails on your setup, please SAVE this file in the 'troubleshooting/' folder
        // and re-run so nowExecutingPath is available.
        baseDir = PathName(thisProcess.platform.userAppSupportDir).parentPath ++ "troubleshooting";
        "[RunAll] Warning: nowExecutingPath is nil; guessing baseDir: ".post; baseDir.postln;
    };

    // File names expected to be in baseDir
    fReset       = baseDir ++ "00_Reset_KnownClean_State.scd";
    fStartHere   = baseDir ++ "01b_StartHere_NoReboot.scd";
    fAssertStereo= baseDir ++ "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd";
    fTestSource  = baseDir ++ "02D_TestSource_CenteredStereo_Pulsed.scd";
};

// Execute a file if it exists; prints a readable status line
executeFileOnce = { arg absolutePathString, labelString;
    var pathOk;
    pathOk = File.exists(absolutePathString);
    if(pathOk.not) {
        ("[RunAll] ‚ö†Ô∏è Missing file: " ++ absolutePathString).warn;
    }{
        ("[RunAll] === " ++ labelString ++ " ===").postln;
        thisProcess.interpreter.executeFile(absolutePathString);
    };
    pathOk
};

// Self-contained RMS window that reads ends of chainA/chainB, computes RMS.dB, displays 4 meters
buildRmsIsolatedHud = {
    var defaultFloorDb, defaultTopDb, updateRateHz;
    var rmsWindow, labelTitle, labelDbA, labelDbB;
    var meterAL, meterAR, meterBL, meterBR, updateRoutine;
    var currentDbAL, currentDbAR, currentDbBL, currentDbBR;
    var installSynthDef, startRmsSynthAtTail, stopRmsSynth;
    var oscKeyName, installRmsListener;
    var discoverBussesAndStart, getProxyBusInfo;
    var chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

    defaultFloorDb = -72.0;
    defaultTopDb   =   0.0;   // set to +3.0 for extra visual headroom at full scale
    updateRateHz   =  15;

    // allow live tuning (optional)
    ~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
    ~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

    rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

    labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
        .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
        .font_(Font("Helvetica", 13));

    meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

    StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
    StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
    StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
    StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

    labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
    labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

    currentDbAL = -140.0; currentDbAR = -140.0;
    currentDbBL = -140.0; currentDbBR = -140.0;

    installSynthDef = {
        Server.default.bind({
            SynthDef(\md_rms_isolated_from_busses, {
                arg inBusA = 0, inBusB = 0, fps = 15;
                var sigA, sigB, aLeft, aRight, bLeft, bRight;
                var rmsAL, rmsAR, rmsBL, rmsBR;
                var dbAL, dbAR, dbBL, dbBR;
                var tick, minLinear;

                sigA = In.ar(inBusA, 2);
                sigB = In.ar(inBusB, 2);

                aLeft  = sigA[0];
                aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
                bLeft  = sigB[0];
                bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

                // RMS per channel with 500 Hz smoothing (requested)
                rmsAL = RMS.ar(aLeft,  500);
                rmsAR = RMS.ar(aRight, 500);
                rmsBL = RMS.ar(bLeft,  500);
                rmsBR = RMS.ar(bRight, 500);

                // dBFS with guard
                minLinear = 1e-9;
                dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
                dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
                dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
                dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

                tick = Impulse.kr(fps);
                SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);  // private path for this window
            }).add;
        });
        "[RunAll/RMS] SynthDef \\md_rms_isolated_from_busses installed.".postln;
    };

    stopRmsSynth = {
        if(~rms_isolated_synth.notNil) {
            ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
            "[RunAll/RMS] previous synth stopped.".postln;
        };
    };

    // IMPORTANT: start at TAIL so we read busses *after* chains write to them
    startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
        AppClock.sched(0.20, {
            Server.default.bind({
                ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                    \inBusA, busIndexForA,
                    \inBusB, busIndexForB,
                    \fps, updateRateHz
                ]);
            });
            ("[RunAll/RMS] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
            nil
        });
    };

    // Listener to receive dB payload and update UI model
    oscKeyName = \md_rms_isolated_listener;
    installRmsListener = {
        var existing;
        existing = OSCdef.all.at(oscKeyName);
        if(existing.notNil) { existing.free };

        OSCdef(oscKeyName, { arg msg;
            if(msg.size >= 7) {
                currentDbAL = msg[3].asFloat;
                currentDbAR = msg[4].asFloat;
                currentDbBL = msg[5].asFloat;
                currentDbBR = msg[6].asFloat;
            };
            nil
        }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

        "[RunAll/RMS] listener installed (/md/rms_isolated_dB)".postln;
    };

    // AppClock ticker: dB ‚Üí 0..1 mapping and UI updates
    updateRoutine = Routine({
        var waitSeconds, mapDbToUi, floorDbLive, topDbLive;
        waitSeconds = 1.0 / updateRateHz;
        mapDbToUi = { arg dbValue, floorDb, topDb; ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0) };

        while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
            floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
            topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

            meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
            meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
            meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
            meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

            labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
            labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

            waitSeconds.yield;
        };
    }).play(AppClock);

    // Discover Ndef(\chainA/\chainB) busses and start synth
    getProxyBusInfo = { arg chainSymbol;
        var proxy, busObject, info;
        proxy = Ndef(chainSymbol);
        busObject = proxy.bus;
        info = (
            symbol: chainSymbol,
            playing: proxy.isPlaying,
            numChannels: proxy.numChannels,
            busIndex: busObject.notNil.if({ busObject.index }, { nil })
        );
        info
    };

    discoverBussesAndStart = {
        triesLeft = 20;
        Routine({
            var resolved;
            resolved = false;
            while({ triesLeft > 0 and: { resolved.not } }) {
                chainAInfo = getProxyBusInfo.(\chainA);
                chainBInfo = getProxyBusInfo.(\chainB);
                busIndexA  = chainAInfo[\busIndex];
                busIndexB  = chainBInfo[\busIndex];

                if(busIndexA.notNil and: { busIndexB.notNil }) {
                    ("[RunAll/RMS] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                        ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                    installRmsListener.();
                    installSynthDef.();
                    stopRmsSynth.();
                    startRmsSynthAtTail.(busIndexA, busIndexB);
                    resolved = true;
                }{
                    if(triesLeft == 20) { "[RunAll/RMS] waiting for chainA/chainB busses...".postln };
                    0.25.wait; triesLeft = triesLeft - 1;
                };
            };

            if(resolved.not) {
                "‚ö†Ô∏è [RunAll/RMS] could not resolve busses (chains not playing?). Start a source and re-run this file.".warn;
            };
        }).play(AppClock);
    };

    // Cleanup when window closes
    rmsWindow.onClose_({
        if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
        if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
        if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
        "[RunAll/RMS] closed and cleaned up.".postln;
    });

    // Kick off discovery and return window
    discoverBussesAndStart.();
    rmsWindow
};

// Master sequence: execute your four scripts in order, then start the RMS window
scheduleSequence = {
    AppClock.sched(0.00, {
        ensureBaseDir.();
        executeFileOnce.(fReset, "00_Reset_KnownClean_State.scd");
        nil
    });

    AppClock.sched(longPause, {
        executeFileOnce.(fStartHere, "01b_StartHere_NoReboot.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause, {
        executeFileOnce.(fAssertStereo, "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause + smallPause, {
        executeFileOnce.(fTestSource, "02D_TestSource_CenteredStereo_Pulsed.scd");
        nil
    });

    // Start the isolated RMS HUD after bring-up + source have had a moment to run
    AppClock.sched(longPause + mediumPause + smallPause + longPause, {
        finalWindow = buildRmsIsolatedHud.();
        // Report and return
        "[RunAll] ‚úÖ RMS_IsolatedHUD started.".postln;
        finalWindow;
    });
};

// Kick off the sequence and return the window when ready
scheduleSequence.();

// Return something immediately; the RMS window will be returned by the scheduled step.
// To see '-> a Window' in the post window after completion, re-select and run only the last line:
// finalWindow;
)

===== troubleshooting/startheres/Finish_WriteStatus_SaveToOneDrive.scd =====
// Finish_WriteStatus_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Write an end-of-session status snapshot to OneDrive and return the file path.

What it records
- Timestamp, SC version, platform, sampleRate, server status, window count,
  suite path (under Extensions), and this file's location if available.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no non-local returns.
*/

(
var server, dirPath, pathName, stamp, filePath, writeLine, f, suitePath, windowCount, scVer, platformInfo;
var herePath;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";
dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
pathName = PathName(dirPath);
stamp = Date.getDate.stamp.replace($:, $_);
filePath = dirPath +/+ ("status_" ++ stamp ++ ".txt");
scVer = Main.scVersionString;
platformInfo = Platform.name.asString ++ " " ++ Platform.architecture.asString;
windowCount = Window.allWindows.size;
herePath = thisProcess.nowExecutingPath ? "<interactive>";

pathName.isFolder.if({ }, { pathName.mkdirAll; });

writeLine = { arg txt; f.write(txt ++ Char.nl); };

f = File(filePath, "w");
writeLine.("=== MPB EOD STATUS SNAPSHOT ===");
writeLine.("timestamp: " ++ stamp);
writeLine.("sc_version: " ++ scVer);
writeLine.("platform: " ++ platformInfo);
writeLine.("server_running: " ++ server.serverRunning);
writeLine.("server_sampleRate: " ++ server.sampleRate);
writeLine.("windows_open: " ++ windowCount);
writeLine.("suite_path: " ++ suitePath);
writeLine.("script_path: " ++ herePath);
f.close;

("[EOD] wrote " ++ filePath).postln;
filePath
)

===== troubleshooting/startheres/MD_Cleanup_ChainA_Unfeed.scd =====
// MD_Cleanup_ChainA_Unfeed.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Stop audio; clear and recreate Ndef(\chainA) so the pedalboard can drive it again.
*/

(
var done;
Server.default.bind({
    Ndef(\chainA).stop;
    Ndef(\chainA).clear;
    Ndef(\chainA).ar(2);
});
done = "Cleaned chainA‚Äîpedalboard can drive it again.";
done.postln;
done
)

===== troubleshooting/startheres/MD_Meters_PhaseA_Const.scd =====
// MD_Meters_PhaseA_Const.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Drive meters to exact values A=(0.25, 0.75), B=(0, 0) for 4s via /md/levels.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendPair, aL, aR, bL, bR, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_CONST] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);  // B
};

aL = 0.25; aR = 0.75; bL = 0.0; bR = 0.0;
startAt = thisThread.seconds; endAt = startAt + secs;

banner.("A=(" ++ aL ++ "," ++ aR ++ "), B=(0,0) for " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now;
    now = thisThread.seconds;
    (now < endAt).if({
        sendPair.([aL, aR], [bL, bR]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseA_Const scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseB_Ramp.scd =====
// MD_Meters_PhaseB_Ramp.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Animate A for 4s: L ramps 0‚Üí0.9, R ramps 0.9‚Üí0. B stays 0.
*/

(
var hz, secs, sendToLang, sendPair, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_RAMP] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);
};

startAt = thisThread.seconds; endAt = startAt + secs;

banner.("Ramp A L:0‚Üí0.9, R:0.9‚Üí0 over " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now, t, aL, aR;
    now = thisThread.seconds;
    (now < endAt).if({
        t = (now - startAt) / secs;          // 0..1
        aL = (0.9 * t).clip(0.0, 0.9);       // rise
        aR = (0.9 * (1 - t)).clip(0.0, 0.9); // fall
        sendPair.([aL, aR], [0.0, 0.0]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseB_Ramp scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseC_Audio.scd =====
// MD_Meters_PhaseC_Audio.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Feed a sine into Ndef(\chainA), attach taps that SendReply /md/levels (A=2001, B=2002).
- Print expected RMS (A/‚àö2) and measured A levels in console for 5s.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTap, makeTaps;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ‚âà0.1414 for 0.2

banner = { arg text; var t; t = text; ("[MD_A_AUDIO] " ++ t).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);  // replyID in 4th arg (correct)
        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// Feed test tone and play
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

makeTaps.();

OSCdef(\mdSpyA).free;  // ensure clean
OSCdef(\mdSpyA, { arg msg;
    var isA, l, r, line;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };  // replyID position
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
            ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.001);
        line.postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA).free;
    banner.("done (audio still playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS‚âà" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio scheduled."
)

===== troubleshooting/startheres/Meters_Sanity_6Lines_SaveToOneDrive.scd =====
// Meters_Sanity_6Lines_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Subscribe to /md/levels taps (A=2001, B=2002), sample 3 times, and print exactly 6 lines:
  "MDMTR: A (L,R)=(x.xx,y.yy)" then "MDMTR: B (L,R)=(x.xx,y.yy)" per sample.
- Save the 6 lines to OneDrive: ~/Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test/md_meters_<stamp>.txt
- Finite; auto-stops; cleans responders.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns.
- AppClock used for timing only; finite duration.
*/

(
var aLevels, bLevels, lines, sampleIndex, maxSamples, appTask, startTime;
var dirPath, pathName, filePath, stamp, makeDir;
var oscA, oscB, formatLine, writeFile, printLine;
var levelsUpdatedA, levelsUpdatedB;

aLevels = [0.0, 0.0];
bLevels = [0.0, 0.0];
levelsUpdatedA = false;
levelsUpdatedB = false;

lines = List.new;
sampleIndex = 0;
maxSamples = 3;
startTime = thisThread.seconds;

dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
stamp = Date.getDate.stamp.replace($:, $_); // safe for file names
pathName = PathName(dirPath);
filePath = dirPath +/+ ("md_meters_" ++ stamp ++ ".txt");

makeDir = {
    pathName.isFolder.if({ }, { pathName.mkdirAll; });
};

formatLine = { arg label, lr;
    var l, r;
    l = (lr[0] ? 0.0).asFloat.max(0.0);
    r = (lr[1] ? 0.0).asFloat.max(0.0);
    ("MDMTR: " ++ label ++ " (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001) ++ ")")
};

printLine = { arg text; text.postln; };

writeFile = {
    var f;
    makeDir.();
    f = File(filePath, "w");
    lines.do { arg ln; f.write(ln ++ Char.nl) };
    f.close;
    ("[MDMTR] wrote " ++ filePath).postln;
    filePath
};

// OSC responders: expect messages like /md/levels, id, ... , L, R.
// We match on reply id and pull the last two floats if present.
oscA = OSCdef(\mdLevelsA, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        aLevels = [l, r];
        levelsUpdatedA = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2001]);

oscB = OSCdef(\mdLevelsB, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        bLevels = [l, r];
        levelsUpdatedB = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2002]);

appTask = AppClock.sched(0.1, {
    var doOne;
    doOne = {
        var lineA, lineB;
        lineA = formatLine.("A", aLevels);
        lineB = formatLine.("B", bLevels);
        printLine.(lineA);
        printLine.(lineB);
        lines.add(lineA);
        lines.add(lineB);
        sampleIndex = sampleIndex + 1;
        levelsUpdatedA = false;
        levelsUpdatedB = false;
    };

    (sampleIndex < maxSamples).if({
        doOne.();
        0.6
    }, {
        OSCdef(\mdLevelsA).free;
        OSCdef(\mdLevelsB).free;
        writeFile.();
        nil
    })
});
"MDMTR: starting 3√ó sampling (A=2001, B=2002)‚Ä¶".postln;
filePath
)

===== troubleshooting/startheres/StartHere_CleanBoot_GridOrPerfHUD.scd =====
// StartHere_CleanBoot_GridOrPerfHUD.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Clean boot pathway that brings up PerfHUD (guarded) and, if it fails, falls back to GridDemo.
- Ensures taps are running via LivePedalboardSystem-Taps_Stable.sc.
- Returns -> a Window (PerfHUD if healthy, otherwise Grid).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock use is inside called files only; this wrapper remains finite.
- Loud console banners; prefer existing files; safe operations via Server.default.bind.
*/

(
var server, suitePath, stopDiagPath, perfhudPath, tapsPath, gridPath, gridMinPath;
var windowResult, banner, runFile, fallbackDone, fallbackWindow;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";

stopDiagPath = suitePath +/+ "utilities/MD_Stop_All_MeterDiagnostics.scd";
perfhudPath  = suitePath +/+ "MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
/*tapsPath     = suitePath +/+ "LivePedalboardSystem/LivePedalboardSystem-Taps_Stable.sc";*/
tapsPath = suitePath +/+ "troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd";

gridPath     = suitePath +/+ "MagicPedalboard/MagicDisplayGUI_GridDemo.sc";
gridMinPath  = suitePath +/+ "utilities/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd";

banner = { arg text; ("[MPB-START] " ++ text).postln; };

runFile = { arg filePath;
    var exists, result;
    exists = File.exists(filePath);
    exists.if({
        ("[RUN] " ++ filePath).postln;
        result = thisProcess.interpreter.executeFile(filePath);
        ("[OK ] " ++ filePath).postln;
    }, {
        ("[MISS] " ++ filePath).warn;
        result = nil;
    });
    result
};

banner.("Clean boot begin ‚Äî ensuring server and quiescent diagnostics‚Ä¶");

server.boot;
server.waitForBoot({
    Server.default.bind({
        server.initTree;
        server.defaultGroup.freeAll;
    });
});

runFile.(stopDiagPath);

banner.("PerfHUD bring-up (guarded) ‚Ä¶");
windowResult = runFile.(perfhudPath);

// Always start taps; if missing, we still continue to Grid fallback.
runFile.(tapsPath);

// If PerfHUD did not return a Window, fall back to Grid.
(windowResult.isKindOf(Window)).if({
    banner.("PerfHUD window active ‚Äî returning PerfHUD.");
    windowResult
}, {
    banner.("PerfHUD did not yield a Window ‚Äî falling back to Grid‚Ä¶");
    fallbackDone = false;
    fallbackWindow = runFile.(gridPath);
    (fallbackWindow.isKindOf(Window)).if({
        fallbackDone = true;
        banner.("GridDemo is active ‚Äî returning Grid window.");
        fallbackWindow
    }, {
        // Try minimal grid bring-up
        fallbackWindow = runFile.(gridMinPath);
        (fallbackWindow.isKindOf(Window)).if({
            fallbackDone = true;
            banner.("Minimal GridDemo is active ‚Äî returning Grid window.");
            fallbackWindow
        }, {
            // As a last resort, create a tiny placeholder window so we still return -> a Window.
            banner.("All bring-up files missing or failed ‚Äî creating placeholder window.");
            Window("MagicDisplayGUI (Placeholder)", Rect(120, 120, 480, 260)).front;
        });
    });
});
)

===== troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd =====

===== troubleshooting/Taps_Stable_Runtime_Shim.scd =====
// Taps_Stable_Runtime_Shim.scd
// v0.1.1 (fix SendReply replyID position)
// MD timestamp: 2025-09-27 19:35 GMT+1

/*
Purpose
- Publish /md/levels with replyID in proper slot (msg[2]) so listeners match A=2001 / B=2002.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var server, rateHz, attachTap, ensureProxy, banner;

server = Server.default;
rateHz = 12;

banner = { arg text; ("[TAPS] " ++ text).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var sig, chans, l, r, ampL, ampR, trig;
        sig = inSig;
        chans = sig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l }); // mono -> duplicate
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(rateHz);

        // *** Correct: replyID is the 4th arg, values exclude replyID
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        sig
    });
};

Server.default.bind({
    ensureProxy.(\chainA, 2);
    ensureProxy.(\chainB, 2);
    attachTap.(\chainA, \eodTapA, 2001);
    attachTap.(\chainB, \eodTapB, 2002);
});

banner.("Taps active (/md/levels) ‚Äî A=2001, B=2002 at " ++ rateHz ++ " Hz.");
"-> Taps_Stable_Runtime_Shim ready".postln;
Window.allWindows.detect({ |w| w.name.asString.beginsWith("MagicDisplayGUI") }) ? nil;
)

===== troubleshooting/turnintooneplease copy.scd.txt =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/turnintooneplease.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/WorkingSequence_20250929-1649.scd =====
// WorkingSequence_20250929-1649.scd

/*
We have proof of principle working with these:

00_Reset_KnownClean_State.scd
03_Sanity_Beep.scd
01b_StartHere_NoReboot.scd
02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
PERFHUD_InlineTaps_On_ChainAB.scd
INSTALL_AmpA_AmpB_Responders_Min.scd <-- key


*/
===== utilities/ControlLogVerbosity.scd =====
// ControlLogVerbosity.sc
// v1
// MD 20250923-0835

// error = 0
// warn = 1
// info = 2
// debug = 3
// trace = 4

MDMiniLogger.get.setverbosity(2);
===== utilities/DEMO20250923_FIXED.scd =====
// DEMO20250923_FIXED.scd
// v0.2.0
// MD 2025-09-23 10:46 BST

/* Purpose
 - Run the 2025-09-23 demo steps while updating MagicDisplayGUI at each step.
 - Uses ~nav_handleFret from the SimNav patch (Fix 1) so the GUI shows choices
   and "Apply ‚Üí ..." on leaf selections.
Style
 - var-first; AppClock-only; no server.sync; one MagicDisplayGUI window.
*/

(
var steps, gap, i, runStep, schedNext;

if(~system.isNil) { "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil };
if(~nav_handleFret.isNil) { "‚ö†Ô∏è Load SimNav_Bridge_ApplyLeafPayload_FIX.scd first".warn; ^nil };

// Your original script, now paced:
steps = [
    // Add delay ‚Üí /add/delay
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 1) }, // add
    { ~nav_handleFret.(4, 1) }, // delay (leaf ‚Üí applies)

    // Switch ‚Üí /switch
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 3) }, // switch (leaf ‚Üí applies)

    // Bypass delay ON
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 2) }, // bypass
    { ~nav_handleFret.(4, 1) }, // delay
    { ~nav_handleFret.(3, 2) }, // on (leaf)

    // Bypass delay OFF
    { ~nav_handleFret.(6,10) },
    { ~nav_handleFret.(5, 2) },
    { ~nav_handleFret.(4, 1) },
    { ~nav_handleFret.(3, 3) }, // off (leaf)

    // Set source testmelody ‚Üí /setSource/testmelody
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 4) }, // setSource
    { ~nav_handleFret.(4, 1) }  // testmelody (leaf)
];

// pacing
gap = 0.55;
i = 0;
runStep = { steps[i].value; i = i + 1; if(i < steps.size) { schedNext.() } };
schedNext = { AppClock.sched(gap, { runStep.(); nil }) };

// kick off and ensure GUI is showing something
~nav_reset.();
AppClock.sched(0.0, { runStep.(); nil });
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay ‚Üí /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf ‚Üí applies)


//Switch ‚Üí /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf ‚Üí applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody ‚Üí /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Editor_AddCommands_Branch_Canonical.scd =====
// Editor_AddCommands_Branch_Canonical.scd
// v0.1.7
// MD 20250923-0956

(
/*
Purpose
- Ensure a minimal 'commands' branch exists in the canonical CommandTree JSON used by LivePedalboardSystem.
- Set each leaf's payload under 'commands' to a canonical path string ("/verb/arg/...").
- Uses only known-good methods; no caret returns; var-first at top-level.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPath, tree, ok, proceed;
var findChildByName, ensureChildUnder, ensurePath;
var commandsNode, printSampleLeaves, showFirstN;
var setCanonicalPayloads, buildPathsDown, buildPathFromSegments, rootCmd, count;

// ‚îÄ‚îÄ entry banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
"Editor_AddCommands_Branch_Canonical: ENTER".postln;

// ‚îÄ‚îÄ canonical JSON path (LivePedalboardSuite) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
jsonPath = Platform.userExtensionDir
  ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
("JSON path ‚Üí " ++ jsonPath).postln;

// ‚îÄ‚îÄ load tree ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPath);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// ‚îÄ‚îÄ helpers (only stable fields/methods) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
findChildByName = { |parentNode, childName|
  var wanted, found;
  wanted = childName.asString;
  found = nil;
  parentNode.children.do({ |c|
    if(c.name.asString == wanted) { found = c };
  });
  found
};

ensureChildUnder = { |parentNode, childName, fretNumber|
  var existing, created, fret;
  fret = fretNumber ? 1;
  existing = findChildByName.(parentNode, childName);
  if(existing.notNil) {
    existing
  }{
    created = tree.addNode(parentNode.id, childName.asString, fret);
    if(created.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
    created
  }
};

ensurePath = { |names, frets|
  var node, i, count, name, fret;
  node = tree.root;
  i = 0; count = names.size;
  while({ i < count }, {
    name = names[i];
    fret = frets[i] ? 1;
    node = ensureChildUnder.(node, name, fret);
    i = i + 1;
  });
  node
};

showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new;
  i = 0;
  while({ i < lim }, {
    out.add(listIn[i]);
    i = i + 1;
  });
  out.asArray
};

// ‚îÄ‚îÄ do the work only if load succeeded ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if(proceed) {
  // 1) ensure 'commands' branch + minimal leaves (idempotent)
  ensurePath.( ["commands"], [10] );
  ensurePath.( ["commands","add","delay"],            [10,1,1] );
  ensurePath.( ["commands","bypass","delay","on"],    [10,2,1,2] );
  ensurePath.( ["commands","bypass","delay","off"],   [10,2,1,3] );
  ensurePath.( ["commands","switch"],                 [10,3] );
  ensurePath.( ["commands","setSource","testmelody"], [10,4,1] );

  // 2) normalize payloads and tag depths
  tree.assignPayloads;     // payload := name where missing
  tree.root.tagByDepth(0);

  // 2b) set canonical path strings for each 'commands' leaf ("/verb/arg/...")
  buildPathFromSegments = { |segs|
    var out, i, lim;
    out = "";
    i = 0; lim = segs.size;
    while({ i < lim }, {
      out = out ++ "/" ++ segs[i];
      i = i + 1;
    });
    out
  };

  setCanonicalPayloads = {
    rootCmd = findChildByName.(tree.root, "commands");
    if(rootCmd.isNil) {
      "‚ö†Ô∏è cannot set payloads: 'commands' missing.".postln;
    }{
      count = 0;
      buildPathsDown = { |node, segs|
        if(node.isLeaf) {
          node.payload = buildPathFromSegments.(segs);
          count = count + 1;
        }{
          node.children.do({ |child|
            var nextSegs;
            nextSegs = segs.copy;
            nextSegs.add(child.name.asString);
            buildPathsDown.(child, nextSegs);
          });
        }
      };
      // seed with immediate children of 'commands'
      rootCmd.children.do({ |child|
        buildPathsDown.(child, [child.name.asString]);
      });
      ("set canonical payloads on " ++ count ++ " leaf/leaves under 'commands'").postln;
    };
  };

  setCanonicalPayloads.();

  // 3) save back to the canonical file
  tree.exportJSONFile(jsonPath);
  ("‚úÖ Updated commands branch in ‚Üí " ++ jsonPath).postln;

  // 4) sample a few payloads under 'commands' (sanity)
  commandsNode = findChildByName.(tree.root, "commands");
  if(commandsNode.isNil) {
    "‚ö†Ô∏è 'commands' node not found after ensure-path (unexpected).".postln;
  }{
    printSampleLeaves = {
      var visit, payloads;
      payloads = List.new;
      visit = { |n|
        if(n.isLeaf) {
          payloads.add((n.payload ?? n.name).asString);
        }{
          n.children.do(visit);
        }
      };
      visit.(commandsNode);
      ("sample payloads: " ++ showFirstN.(payloads, 8).asString).postln;
    };
    printSampleLeaves.();
  };
}{
  ("‚ùå Failed to load " ++ jsonPath ++ " (no changes made)").postln;
};

// ‚îÄ‚îÄ exit banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"Editor_AddCommands_Branch_Canonical: EXIT".postln;
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
)

===== utilities/Fallback_Diag_OneShot.scd =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/Fallback_Diag_OneShot.scd.bak =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/FallbackDemo_ManualSequence.scd =====
// FallbackDemo_ManualSequence
// v0.1.3
// MD 20250923

// Purpose:
// - Apply a fixed sequence of canonical commands to MagicPedalboardNew.
// - Uses AppClock for scheduling; no Routine or Task.
// - Follows Martin's SC style: var-first, descriptive names, no server.sync, AppClock-only GUI ops.

(


var canonicalCommands, commandIndex, commandDelay;
var applyCommand, runNextCommand;
var pedalboardRef, bypassState;

canonicalCommands = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

commandIndex = 0;
commandDelay = 0.6;
pedalboardRef = if(~system.notNil) { ~system.pedalboard } { nil };

applyCommand = { |canonicalPath|
    ("[FallbackDemo] apply ‚Üí " ++ canonicalPath).postln;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, ~system.statusDisplay);
    } {
        if(pedalboardRef.isNil) {
            ("[FallbackDemo] pedalboard is nil; skipping " ++ canonicalPath).warn;
            nil;
        } {
            if(canonicalPath == "/add/delay") {
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(\delay);
                };
            } {
            if(canonicalPath == "/switch") {
                if(pedalboardRef.respondsTo(\switchChain)) {
                    pedalboardRef.switchChain(0.12);
                };
            } {
            if(canonicalPath == "/bypass/delay/on") {
                bypassState = true;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
            if(canonicalPath == "/bypass/delay/off") {
                bypassState = false;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
                ("[FallbackDemo] unhandled command: " ++ canonicalPath).warn;
            }}}};
        };
    };
};

runNextCommand = {
    if(commandIndex >= canonicalCommands.size) {
        ("[FallbackDemo] done.").postln;
        nil;
    } {
        applyCommand.(canonicalCommands[commandIndex]);
        commandIndex = commandIndex + 1;

        AppClock.sched(commandDelay, {
            runNextCommand.();
            nil;
        });
    };
};

runNextCommand.();
)

===== utilities/GUI_QuickFix_Choices_Contrast.scd =====
// GUI_QuickFix_Choices_Contrast.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   Improve legibility of the "Choices" panel immediately (runtime).
   Style: var-first; AppClock-only; no server.sync.
*/

(
var displayRef, choicesPanelView, choicesTitleView, choicesTextView, canDo;

displayRef = ~system ? nil;
if(displayRef.isNil or: { ~system.statusDisplay.isNil }) {
  "‚ö†Ô∏è No status display found; bring-up first.".warn; ^nil;
};
displayRef = ~system.statusDisplay;

displayRef.queueUi({
  choicesPanelView = displayRef.tryPerform(\choicesPanel);
  choicesTitleView = displayRef.tryPerform(\choicesTitle);
  choicesTextView  = displayRef.tryPerform(\choicesText);

  if(choicesPanelView.notNil and: { choicesPanelView.respondsTo(\background_) }) {
    choicesPanelView.background_(Color(0.12, 0.12, 0.12));
  };
  if(choicesTitleView.notNil and: { choicesTitleView.respondsTo(\stringColor_) }) {
    choicesTitleView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  if(choicesTextView.notNil and: { choicesTextView.respondsTo(\stringColor_) }) {
    choicesTextView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  nil
});
)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "‚ùå Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "‚ùå Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Inspect_CommandTree_Under_Chain.scd =====
// Inspect_CommandTree_Under_Chain.scd
// v0.1.0
// MD 20250923--1255

/* Purpose
   Print child names (with frets) under "chain"; also prints under "add" if present.
   Helps confirm the live tree route to "delay".
   Style
   - var-first; descriptive variable names; no server.sync.
*/

(
var environmentReady, commandManager, commandTree, chainNode, addNode;
var listChildren, findChildByName;

environmentReady = (~system.notNil) and: { ~system.commandManager.notNil };
if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn; ^nil };

commandManager = ~system.commandManager;
commandTree    = commandManager.tree;

listChildren = { |nodeRef, labelText|
  var childrenArray, childLines;
  if(nodeRef.isNil) { ("[INSPECT] " ++ labelText ++ ": <nil>").postln; ^nil };
  childrenArray = nodeRef.children ? [];
  if(childrenArray.isEmpty) {
    ("[INSPECT] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[INSPECT] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil
};

findChildByName = { |parentNode, childNameString|
  if(parentNode.isNil) { ^nil };
  ^parentNode.getChildByName(childNameString.asString);
};

// 1) under "chain"
chainNode = commandTree.root.getChildByName("chain");
listChildren.(chainNode, "Children under [chain]");

// 2) under "chain ‚Üí add" (if present)
addNode = findChildByName.(chainNode, "add");
if(addNode.notNil) { listChildren.(addNode, "Children under [chain ‚Üí add]") };
)

===== utilities/Install_LightweightMeterPrinters.scd =====
// Install_LightweightMeterPrinters.scd
// v0.1
// MD 20250923-1556

/* Purpose
   Quiet console printers for '/ampA' and '/ampB' that print only non-zero-ish values.
*/

(
var threshold, freeIfExists;

threshold = 0.02;

freeIfExists = { |defName|
  var existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

freeIfExists.(\_meterA_dbg);
freeIfExists.(\_meterB_dbg);

OSCdef(\_meterA_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterA] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampA');

OSCdef(\_meterB_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterB] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampB');

"‚úÖ Lightweight printers installed (non-zero only).".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd.bak =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QuietProxyMeters_Core.scd =====
// Install_QuietProxyMeters_Core.scd
// v0.1
// MD 20250923-1610

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) using .filter:
   - Low-rate sampling with Impulse.kr.
   - Threshold gate from UGens (no Boolean 'or:').
   - Sends '/ampA' '/ampB' only when above threshold.
   - No console prints by default.

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold;
var ensureProxyAudio, installOrReplaceTap, installForProxy;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyAudio = { |proxyName|
  Server.default.bind({
    Ndef(proxyName).ar(2); // ensure 2ch audio-rate proxy exists
  });
};

installOrReplaceTap = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampLeft, ampRight, ampMax, tick, gate;

      // robust channel fetch
      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0.0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // per-channel level followers
      ampLeft  = Amplitude.kr(leftIn, 0.01, 0.15);
      ampRight = Amplitude.kr(rightIn, 0.01, 0.15);
      ampMax   = ampLeft.max(ampRight);     // <- UGen-safe combine

      // low-rate tick and gate when above threshold (UGen compare)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (ampMax > postThreshold); // 0 or tick

      // emit values only when above threshold
      SendReply.kr(gate, oscPath, [ampLeft, ampRight]);

      // pass-through audio unchanged
      inSig
    });
  });
};

installForProxy = { |proxyName, oscPath|
  ensureProxyAudio.(proxyName);
  installOrReplaceTap.(proxyName, oscPath);
};

installForProxy.(\chainA, '/ampA');
installForProxy.(\chainB, '/ampB');

"‚úÖ Quiet proxy taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"‚úÖ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/MD_EOD_Status_Snapshot_FIXED.scd =====
// MD_EOD_Status_Snapshot_FIXED.scd
// v0.1.1
// MD 2025-09-26 16:56 BST

/* Purpose / Style
   Purpose: Record where SC is loading LivePedalboardSuite from and write a status file to OneDrive.
   Style:   Single () block; var-first in all closures; ‚â•3-char lowercase descriptive names;
            no single-letter locals; no non-local ^; finite output.
*/

(
var postBanner, writeStatus, isSymlink, readLinkTarget;
var extensionsDir, extSuitePath, odRootPath, statusFolderPath, outFilePath, linkTargetText, isLink, exitCode;

// ---- header ----
postBanner = {
    var headerText;
    headerText = "=== MD_EOD_STATUS_SNAPSHOT (FIXED) ===";
    headerText.postln;
};

// ---- helpers (var-first inside closures) ----
isSymlink = { arg pathString;
    var testCmd, code, flag;
    testCmd = "[ -L \"" ++ pathString ++ "\" ]";
    code = testCmd.unixCmd;        // 0 if symlink, non-zero otherwise
    flag = (code == 0);
    flag
};

readLinkTarget = { arg pathString;
    var pipeRef, cmd, line;
    cmd = "readlink \"" ++ pathString ++ "\"";
    pipeRef = Pipe.new(cmd, "r");
    if(pipeRef.isNil) { "(unavailable)" } {
        line = pipeRef.getLine ? "(unavailable)";
        pipeRef.close;
        line
    }
};

writeStatus = { arg folderPath, bodyText;
    var ensureFolderOk, fileName, fullPath;
    ensureFolderOk = PathName(folderPath).isFolder;
    if(ensureFolderOk.not) { File.mkdir(folderPath) };
    fileName = "sc_status_" ++ Date.getDate.stamp ++ ".txt";
    fullPath = folderPath +/+ fileName;
    File.use(fullPath, "w", { arg fileRef; fileRef.write(bodyText) });
    ("EOD: wrote " ++ fullPath).postln;
    fullPath
};

// ---- run ----
postBanner.();

extensionsDir  = Platform.userExtensionDir.standardizePath;
extSuitePath   = extensionsDir +/+ "LivePedalboardSuite";
("EXT: " ++ extSuitePath).postln;

isLink = isSymlink.(extSuitePath);
if(isLink) {
    linkTargetText = readLinkTarget.(extSuitePath);
} {
    linkTargetText = "(not a symlink)";
};
("EXT: target = " ++ linkTargetText).postln;

// OneDrive folder we‚Äôre using today
odRootPath = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
statusFolderPath = odRootPath +/+ "SC_MPB_Test";

outFilePath = writeStatus.(statusFolderPath,
    "EOD snapshot at " ++ Date.getDate.stamp
    ++ "\nExtensions dir         = " ++ extensionsDir
    ++ "\nSuite path             = " ++ extSuitePath
    ++ "\nSuite link target      = " ++ linkTargetText
    ++ "\n"
);

// final expression (implicit return; no ^ in .scd)
outFilePath
)

===== utilities/MD_Stop_All_MeterDiagnostics.scd =====
// MD_Stop_All_MeterDiagnostics.scd
// v0.1.1
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Quiet the console by freeing known OSCdef listeners and stopping any reporter routines
            we may have created during diagnostics. Safe to run multiple times. Auto-stops.
   Style:   single () block; var-first everywhere; descriptive lowercase names; AppClock-only where used;
            no server.sync; no single-letter locals; returns nil.
*/

(
var freeOscIfPresent, stopRoutineIfPresent, freedCount, oscKeys, indexCount, indexLimit;
var reporterStoppedCount, oscObj, routineRef;

// ‚Äî‚Äî helpers (var-first in closures)
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MDSTOP: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineVar, labelString;
    var canStop;
    canStop = routineVar.notNil and: { routineVar.respondsTo(\stop) };
    if(canStop) { routineVar.stop; (labelString ++ ": stopped").postln };
};

// ‚Äî‚Äî free known listeners (only if present)
freedCount = 0;
oscKeys = [
    \md_levels_sniffer_fixed,    // finite/continuous sniffers
    \md_levels_inline,           // overlay listener (if any)
    \md_levels_dbg_sniffer,      // debug taps listener
    \md_levels_gui_listener,     // if we created a GUI-only listener
    \md_levels_hud               // HUD listener (optional ‚Äì remove if you want it kept)
];
indexCount = 0; indexLimit = oscKeys.size;
while({ indexCount < indexLimit }, {
    var keySym, exists;
    keySym = oscKeys[indexCount];
    exists = OSCdef.all.at(keySym).notNil;
    if(exists) { freeOscIfPresent.(keySym); freedCount = freedCount + 1 };
    indexCount = indexCount + 1;
});

// ‚Äî‚Äî stop known reporter routines (only if present)
reporterStoppedCount = 0;
stopRoutineIfPresent.(~md_levels_dbg_reporter, "md_levels_dbg_reporter"); reporterStoppedCount = reporterStoppedCount + 1;
stopRoutineIfPresent.(~md_simple_reporter,     "md_simple_reporter");     reporterStoppedCount = reporterStoppedCount + 1;

// ‚Äî‚Äî clear diagnostic dictionaries (safe)
~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
~md_levels_dbg = ~md_levels_dbg ? IdentityDictionary.new;

("MDSTOP: freed=" ++ freedCount.asString
 ++ " stopped=" ++ reporterStoppedCount.asString).postln;
nil
)

===== utilities/Meters_Diagnostic_Bootstrap_FIX.scd =====
// Meters_Diagnostic_Bootstrap_FIX.scd
// v0.1.1
// MD 20250923-1543

/* Purpose
   - Ensure bus meter SynthDefs exist (defines them via MagicDisplay.ensureMeterDefs(2) if needed).
   - Instantiate meter readers on Ndef(\chainA) and Ndef(\chainB) buses.
   - Install console debug printers for '/ampA' and '/ampB' using correct OSCdef.free pattern.

   Style
   - var-first; Server.default.bind for server ops; AppClock-safe UI; no server.sync.
*/

(
var serverRef, statusDisplayRef, chainABusIndex, chainBBusIndex, metersGroupId;
var ensureMeterDefsExist, installDebugPrinters, freeIfExists;

serverRef        = Server.default;
statusDisplayRef = (~system ? nil).notNil.if({ ~system.statusDisplay }, { nil });

ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ÑπÔ∏è Defining meter synths (busMeterA/busMeterB).".postln;
    MagicDisplay.ensureMeterDefs(2); // should be idempotent in your codebase
  };
};

freeIfExists = { |defName|
  var existingDef;
  existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

installDebugPrinters = {
  // Avoid duplicates by
===== utilities/Meters_QuickCheck_And_Enable.scd =====
// Meters_QuickCheck_And_Enable.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - Ensure meter SynthDefs exist (busMeterA/B).
   - Attach meter readers to Ndef(\chainA/\chainB) buses.
   - Print incoming values to console (quick sanity).
   - Re-enable GUI meters if the display supports it.

   Style
   - var-first; Server.default.bind for server ops; no server.sync.
*/

(
var serverRef, displayRef, chainABusIndex, chainBBusIndex, metersGroup;
var ensureMeterDefsExist, installConsolePrinters;

serverRef  = Server.default;
displayRef = ~system ? nil;

// --- helpers ---
ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ö†Ô∏è Meter SynthDefs missing ‚Äî defining now via MagicDisplay.ensureMeterDefs(2)".postln;
  };
  MagicDisplay.ensureMeterDefs(2); // idempotent
};

installConsolePrinters = {
  // avoid duplicates
  OSCdef.remove(\_meterA_dbg);
  OSCdef.remove(\_meterB_dbg);
  OSCdef(\_meterA_dbg, { |oscMessage| ("[meterA] " ++ oscMessage[3..].asString).postln }, '/ampA');
  OSCdef(\_meterB_dbg, { |oscMessage| ("[meterB] " ++ oscMessage[3..].asString).postln }, '/ampB');
};

// --- server work ---
Server.default.bind({
  ensureMeterDefsExist.value;

  // ensure both chain proxies are realized at audio-rate
  Ndef(\chainA).ar(2);
  Ndef(\chainB).ar(2);
  chainABusIndex = Ndef(\chainA).bus.index;
  chainBBusIndex = Ndef(\chainB).bus.index;

  metersGroup = Group.head(serverRef.defaultGroup);

  // spawn readers (safe to re
===== utilities/MIDI_Input_Tests_20250922.scd =====
// MIDI_Input_Tests_20250922.scd
// Run these step by step

// STEP A ‚Äî canonical bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);   // nil -> class default tree path
    ~system.bringUpAll;
}.defer;
)


// STEP B ‚Äî Refresh and connect MIDI at the SC level (safe anytime)
(
MIDIClient.restart;     // re-scan devices (good after hot-plug)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)



// STEP C ‚Äî Inspect manager + the symbol names you can bind
(
var mi;

mi = ~system.commandManager.midiManager;

"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;   // prints "Symbol: \NAME  ‚Üí UID: 1234..."

"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;         // prints the connected devices it sees
)


// STEP D ‚Äî Bind nanoKEY2 and IAC "to SC" to handlers
(
var mi = ~system.commandManager.midiManager;

// nanoKEY2 -> FootController (so notes 36/38/40/41 switch idle/prog/queue/send)
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);

// IAC "to SC" -> Guitar handler (so notes become frets during PROG mode)
mi.bindDevice(\MD_IAC_to_SC, mi.guitarHandler);

// Show current bindings (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect { |k| mi.deviceUIDs[k] == srcID } ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)


// Option 1
MIDIdef.trace(true);   // start tracing all MIDI events
// Press a nanoKEY2 key (or send a note to IAC "to SC") ‚Äî you should see noteOn/off
// When done:
MIDIdef.trace(false);

// Option 2:
// Install once; re-evaluate if you hot-plug (it rebuilds the map)
(
var buildMap;
~midiLog_srcFilter = nil;  // e.g. set to \nanoKEY2_KEYBOARD to filter (optional)
~midiLog_chanFilter = nil; // e.g. set to 1 to filter (optional)
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name)
            .replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%"
                .format(sym, chan, num, val)).postln;
        };
    };
});

// quick refresh if you hot-plug:
~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

// stop logger if needed:
~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k| MIDIdef(k).free };
    "[MIDI-LOG] stopped".postln;
};

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)


===== utilities/MIDI_Input_Tests2_20250922.scd =====
//MIDI_Input_Tests2_20250922.scd

// 0) Bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
}.defer;
)


// 1) Refresh MIDI in SC and connect all sources
(
MIDIClient.restart;     // re-scan devices (safe after hot-plugging)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)


// 2) See the symbols your app uses and their UIDs
(
var mi = ~system.commandManager.midiManager;
"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;
"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;
)


// 3) Bind nanoKEY2 -> FootController; IAC 'to SC' -> Guitar
(
var mi = ~system.commandManager.midiManager;
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);
mi.bindDevice(\MD_IAC_to_SC,      mi.guitarHandler);

// Print bound table (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect({ |k| mi.deviceUIDs[k] == srcID }) ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)

MIDIdef.trace(true);   // enable global trace
// press keys on nanoKEY2 or send notes to IAC "to SC"
MIDIdef.trace(false);

// 4B) Install raw taps (noteOn/noteOff/cc)
(
var mkLabel, fns;

mkLabel = { |src|
    var ep = MIDIClient.sources.detect({ |e| e.uid == src });
    if(ep.notNil) { (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_") } { "uid:" ++ src }
};

~midiTap_remove.(); // remove any previous tap safely (defined below)

// keep references so we can remove cleanly
~midiTap_fns = IdentityDictionary[
    \noteOn  -> MIDIIn.addFuncTo(\noteOn,  { |src, chan, num, vel| ("[RAW] noteOn  src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \noteOff -> MIDIIn.addFuncTo(\noteOff, { |src, chan, num, vel| ("[RAW] noteOff src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \control -> MIDIIn.addFuncTo(\control, { |src, chan, num, val| ("[RAW] cc     src=%  ch=%  num=%  val=%".format(mkLabel.(src), chan, num, val)).postln; })
];

~midiTap_remove = {
    if(~midiTap_fns.notNil) {
        ~midiTap_fns.keysValuesDo { |k, fn| if(fn.notNil) { MIDIIn.removeFuncFrom(k, fn) } };
        ~midiTap_fns = nil;
        "[RAW] taps removed".postln;
    } {
        // noop
    };
};

"[RAW] taps installed ‚Äî press nanoKEY2 or send to IAC".postln;
)


// 4C) Minimal logger (noteOn/off & CC), with map refresh helper
(
var buildMap;
~midiLog_srcFilter = nil;
~midiLog_chanFilter = nil;
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k|
        var def = MIDIdef(k);
        if(def.notNil) { def.free };
    };
    "[MIDI-LOG] stopped".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%".format(sym, chan, num, val)).postln;
        };
    };
});

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "üîé [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"‚úÖ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "üõë [MIDI-LOG] stopped.".postln;
};
)

===== utilities/MIDI_Log_RefreshAndConnect.scd =====
// MIDI_Log_RefreshAndConnect.scd
// v0.1.0
// MD 20250922-1422

/*
Purpose
- If you plugged devices while SC was running, restart the MIDI client,
  reconnect all inputs, and refresh the logger's source map.
- Also clears any logger filters so you see everything.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

(
var announce;

announce = { |title| ("[MIDI-LOG] " ++ title).postln };

MIDIClient.restart;           // re-scan devices (idempotent & safe)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

~midiLog_srcFilter = nil;     // show all sources
~midiLog_chanFilter = nil;    // show all channels

if(~midiLog_refresh.isKindOf(Function)) {
    ~midiLog_refresh.();      // rebuild the uid->label map used by the logger
    announce.("sources remapped.");
} {
    announce.("note: logger not installed yet; run MIDI_Log_Console.scd first.");
};

// quick device listing
"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };
"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ [MIDI-LOG] refresh complete ‚Äî play/send something to see messages.".postln;
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "üßπ Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("üì• Command added: " ++ canonicalPathString).postln;
("üì¶ Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Quick_SetSource_Testmelody.scd =====
// Quick_SetSource_Testmelody.scd
// v0.1.0  MD 2025-09-26
(
var systemRef, cmRef, cb;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
cmRef = systemRef.commandManager; if(cmRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
cb = cmRef.queueExportCallback;
if(cb.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    cb = cmRef.queueExportCallback;
};
if(cb.isKindOf(Function)) {
    cb.value("/commands/setSource/testmelody");  // from your tree: commands ‚Üí setSource ‚Üí testmelody
    "[SetSource] '/commands/setSource/testmelody' sent.".postln;
} {
    "‚ö†Ô∏è queueExportCallback missing.".warn;
};
)

===== utilities/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "‚ö†Ô∏è queueExportCallback missing.".warn };
)

===== utilities/Rearm_Attach_Probes_AfterBringUp.scd =====
// Rearm_Attach_Probes_AfterBringUp.scd
// v0.1.0  MD 2025-09-26
(
var baseTrouble, runIfExists;
baseTrouble = Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting";
runIfExists = { arg leaf;
    var p = (baseTrouble ++ "/" ++ leaf).standardizePath;
    if(File.exists(p)) { p.load } { ("‚ö†Ô∏è missing " ++ leaf).warn };
};

AppClock.sched(0.10, { runIfExists.("MagicDisplayGUI_Reenable_FilterMeters_V0.3.12.scd"); nil });
AppClock.sched(0.20, { runIfExists.("MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd"); nil });
AppClock.sched(0.30, { runIfExists.("MagicDisplayGUI_ResetReceiver_v0.3.11.scd"); nil });
"[Rearm] bus/probe helpers scheduled.".postln;
)

===== utilities/Report_ChainPlayFlags.scd =====
// Report_ChainPlayFlags.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Print whether Ndef(\chainA) and Ndef(\chainB) are playing.
   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var isChainAPlaying, isChainBPlaying;

isChainAPlaying = Ndef(\chainA).isPlaying;
isChainBPlaying = Ndef(\chainB).isPlaying;

("[PLAY] chainA=" ++ isChainAPlaying ++ "  chainB=" ++ isChainBPlaying).postln;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd.bak =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager‚Äôs builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X ‚Üí Name" lines for the GUI‚Äôs Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI‚Äôs expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager‚Äôs builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply ‚Üí " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready ‚Äî use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd.bak =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long ‚Üí short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long ‚Üí short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain ‚Üí add ‚Üí delay        (preferred if present)
       (b) chain ‚Üí add ‚Üí timebased ‚Üí delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> ‚Üí /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> ‚Üí /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path‚Üí " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) ‚Üí still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

===== utilities/Test_MagicPedalboard_MIDI_Simulation.scd =====
// Test_MagicPedalboard_MIDI_Simulation.scd
// v0.1.1
// MD 20250922-18-15

/*
Purpose
- Simulate MIDI input sequences for MagicPedalboard system testing.
- Each test step is labeled and commented with expected GUI/behavior.
- Allows repeatable, device-free testing and can be bundled with the suite.

Style
- var-first; lowercase; AppClock-only; no server.sync; clear comments.
*/

// --- Device UIDs: update these to match your system ---
var nanoUID = 302172822;    // nanoKEY2_KEYBOARD
var iacUID  = 1339807908;   // MD_IAC_to_SC

// --- Helper: fire a sequence of steps ---
~fireMidiSequence = { |steps|
    Routine({
        steps.do { |step|
            var src, chan, note, vel, dur, comment;
            src = step[0]; chan = step[1]; note = step[2];
            vel = step[3]; dur = step[4]; comment = step[5];
            ("[TEST] " ++ comment).postln;
            MIDIIn.doNoteOnAction(src, chan, note, vel);
            (dur ? 0.5).wait;
            MIDIIn.doNoteOffAction(src, chan, note, 0);
            0.1.wait;
        }
    }).play(AppClock);
};

// --- Test Sequence 1: Add Delay and Send ---
~test_add_delay = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 41, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /add"],
    [iacUID,  1, 45, 100, 0.5, "Step 3: IAC string 5 ‚Üí select /delay"],
    [nanoUID, 0, 40, 100, 0.5, "Step 4: nanoKEY2 E2 ‚Üí queue path"],
    [nanoUID, 0, 41, 100, 0.5, "Step 5: nanoKEY2 F2 ‚Üí send path"]
];

// --- Test Sequence 2: Switch Chain ---
/*~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 48, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"],
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]
];*/
~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"], // enter prog mode
    [iacUID,  0, 43, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"], // pitch 43 = base 40 + fret 3
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],   // queue
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]     // send
];



// --- To run a test sequence ---
~fireMidiSequence.(~test_add_delay);
// ~fireMidiSequence.(~test_switch_chain); // ‚Üê uncomment to run this one

// --- Add more sequences below as needed ---

===== utilities/Verify_Baseline_CurrentAudible_NextSilent.scd =====
// Verify_Baseline_CurrentAudible_NextSilent.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Verify that CURRENT‚Äôs sink is the audible one and NEXT‚Äôs sink is silent (Option A).
   - Posts a clear PASS/FAIL with details.

   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var systemReady, pedalboardRef;
var currentSinkSymbol, nextSinkSymbol;
var isChainAPlaying, isChainBPlaying;
var currentIsAudible, nextIsSilent;
var summaryText;

// guards
systemReady = ~system.notNil;
if(systemReady.not) {
    "‚ö†Ô∏è ~system is nil. Run Start_LivePedalboardSystem.scd (Option B) first.".postln;
};

// proceed only if ready
if(systemReady) {
    pedalboardRef = ~system.pedalboard;

    // sink symbols at the heads of CURRENT/NEXT
    currentSinkSymbol = pedalboardRef.effectiveCurrent[0];  // \chainA or \chainB
    nextSinkSymbol    = pedalboardRef.effectiveNext[0];     // \chainB or \chainA

    // live flags (do not change any routing)
    isChainAPlaying = Ndef(\chainA).isPlaying;
    isChainBPlaying = Ndef(\chainB).isPlaying;

    // interpret flags relative to CURRENT/NEXT
    currentIsAudible =
        ((currentSinkSymbol == \chainA) and: { isChainAPlaying })
        or: { (currentSinkSymbol == \chainB) and: { isChainBPlaying } };

    nextIsSilent =
        ((nextSinkSymbol == \chainA) and: { isChainAPlaying.not })
        or: { (nextSinkSymbol == \chainB) and: { isChainBPlaying.not } };

    if(currentIsAudible and: { nextIsSilent }) {
        "‚úÖ Baseline OK: CURRENT is audible; NEXT is silent.".postln;
    }{
        summaryText =
            "‚ö†Ô∏è Baseline mismatch ‚Äî "
            ++ "CURRENT=" ++ currentSinkSymbol.asString
            ++ " NEXT=" ++ nextSinkSymbol.asString
            ++ " | chainA=" ++ isChainAPlaying
            ++ " chainB=" ++ isChainBPlaying;
        summaryText.postln;
    };
};
)


===== CommandTree/archived/CommandManager_PathPersistence.sc_OBSOLETE =====
// OBSOLETE


// // CommandManager_PathPersistence.sc
// // v1.0 ‚Äî 2025-09-22 MD
// // Purpose: Remember last used tree path across runs.
// // Style: var-first; lowercase; no server.sync.
//
// + CommandManager {
// 	var <lastPathFile;
//
// 	init { |treePath|
// 		var defaultPath;
// 		lastPathFile = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/last_tree_path.txt";
// 		defaultPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//
// 		// Load last path if treePath is nil
// 		if(treePath.isNil) {
// 			treePath = this.readLastPath ?? defaultPath;
// 		};
//
// 		filePath = treePath;
// 		this.writeLastPath(filePath); // persist for next time
//
// 		// existing init logic continues...
// 		this.createNewTree;
// 		this.createBuilder;
// 		this.createCommandQueue;
// 		midiManager = MIDIInputManager.new(builder, nil, nil, nil);
// 		midiManager.parentCommandManager = this;
// 		^this
// 	}
//
// 	writeLastPath { |path|
// 		File.use(lastPathFile, "w", { |f| f.write(path) });
// 	}
//
// 	readLastPath {
// 		var content;
// 		if(File.exists(lastPathFile)) {
// 			File.use(lastPathFile, "r", { |f| content = f.readAllString });
// 		};
// 		^content
// 	}
// }

===== CommandTree/archived/LivePedalboardSystem_MetersDelegate.sc_OBSOLETE =====
// OBSOLETE


// // LivePedalboardSystem_MetersDelegate.sc
// // v0.2.5 ‚Äî 2025-09-21 MD
// // Purpose
// // - Defer meter definitions to MagicDisplay to avoid duplication.
// // Style
// // - var-first; lowercase; no server.sync.
//
// + LivePedalboardSystem {
// 	ensureMeterDefs {
// 		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
// 	}
// }

===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/archived/UserDisplay.sc_OBSOLETE =====
// userFeedbackSystem.sc
// MD 20250806

// Used to display states of the system and such.

UserDisplay {

	var <>window;
	var <>modeText;
	var <>queueText;
	var <>lastCommandText;
	var <>userChoicesText;
	var <>statusText;

	*new{
		^super.new.init
	}

	init{
		"userFeedback created".postln;

		// create window
		window = Window("user display", Rect(10, 400, 800, 600));

		// create the fields:
		modeText = StaticText(window).string_("modeText");
		queueText = StaticText(window).string_("queueText");
		lastCommandText = StaticText(window).string_("lastCommandText");
		userChoicesText = StaticText(window).string_("userChoicesText");
		statusText = StaticText(window).string_(""); // choose appropriate position and size


		// add layouts to the window
		window.layout =
		VLayout(
			modeText,
			queueText,
			lastCommandText,
			userChoicesText,
			statusText
		);

		// bring window to front:
		window.front;
		^this // return instance of UserDisplay
	}

	updateTextField{
		|box, msg|
		switch (box,
			\state, { modeText.string_(msg)},
			\queue, { queueText.string_(msg)},
			\lastCommand, { lastCommandText.string_(msg)},
			\choices, { userChoicesText.string_(msg)}
		);

		postln("box:" + box);
		postln("msg:" + msg);
	}

	updateStatus { |text|
    ("üñ• Status update: " ++ text).postln;
    { this.statusText.string = text; }.defer; // assuming you have a GUI element called statusText
}


} //end of class
===== CommandTree/CircularFileSave_SortByMTime.sc_obsolete =====
// CircularFileSave_SortByMTime.sc
// v1.1 ‚Äî 2025-09-21 MD

// Purpose
// - Ensure latestVersion() is truly latest by sorting entries (mtime desc).
// Style
// - var-first; lowercase; no server.sync.

+ CircularFileSave {
    refreshFileList {
        var pn, entries;
        pn = PathName(folderPath);
        entries = pn.entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
        // sort newest ‚Üí oldest by modification time
        fileList = entries.sortBy({ |f| File.mtime(f.fullPath) }).reverse;
    }

    saveVersion { |content|
        var timestamp, filename, path;
        timestamp = Date.getDate.stamp;
        filename = "%-%".format(prefix, timestamp) ++ ".json";
        path = folderPath +/+ filename;
        File.use(path, "w", { |fh| fh.write(content) });
        this.refreshFileList; // recompute then prune
        if(fileList.size > maxVersions) {
            fileList.copyRange(maxVersions, fileList.size - 1).do(_.delete);
            fileList = fileList.copyRange(0, maxVersions - 1);
        };
        path.postln;
    }
}

===== CommandTree/CircularSaves.sc =====
// circularSaves.sc
// v1.2.1
// MD 20250819

// This allows me to save the last ten trees in a folder, and keep track of the last one. Versions are named after date/time.


CircularFileSave {
	var <>prefix, <>folderPath, <>maxVersions, <fileList;

/*    *new { |prefix = "myTree", folderPath = "~/TreeSaves", maxVersions = 10|
        ^super.new.init(prefix, folderPath, maxVersions);
    }*/

	*new { |prefix = "myTree", folderPath, maxVersions = 10|
		var userStateFolder;

		userStateFolder = (Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/TreeSaves").standardizePath;

		folderPath = (folderPath ? userStateFolder).standardizePath;
		super.new.init(prefix, folderPath, maxVersions)
	}


	init { |prefix, folderPath, maxVersions|
		this.prefix = prefix;
		this.folderPath = folderPath.standardizePath;
		this.maxVersions = maxVersions;
		this.ensureFolderExists;
		this.refreshFileList;
	}

	ensureFolderExists {
		File.mkdir(folderPath);
	}

/*    refreshFileList {
        fileList = PathName(folderPath).entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
    }*/

	// 20250922
/*	refreshFileList {
		var pn, entries;
		pn = PathName(folderPath.standardizePath);
		if (pn.isFolder.not) { File.mkdir(pn.fullPath) };

		entries = pn.entries
		.select(_.isFile)
		.select({ |p| p.fileName.beginsWith(prefix) and: { p.fileName.endsWith(".json") } });

		// robust boolean comparator; no key-function; no .at on PathName
		entries = entries.asArray.sort({ |a, b| a.fileName > b.fileName });

		fileList = entries; // keep PathName objects; callers can use .fullPath / .fileName
		^this
	}*/
// 20250924
	refreshFileList {
    var pathNameRef, entries;

    pathNameRef = PathName(folderPath.standardizePath);
    if (pathNameRef.isFolder.not) { File.mkdir(pathNameRef.fullPath) };

    entries = pathNameRef.entries
        .select({ arg entry; entry.isFile })
        .select({ arg pn; pn.fileName.beginsWith(prefix) and: { pn.fileName.endsWith(".json") } });

    // newest-first assuming timestamped filenames
    entries = entries.asArray.sort({ arg a, b; a.fileName > b.fileName });

    fileList = entries;
    this
}


	saveVersion { |content|
		var timestamp = Date.getDate.stamp;
		var filename = "%-%".format(prefix, timestamp) ++ ".json";
		var path = folderPath +/+ filename;

		File.use(path, "w", { |f| f.write(content) });

		fileList.addFirst(PathName(path));

		if(fileList.size > maxVersions) {
			var toDelete = fileList.copyRange(maxVersions, fileList.size - 1);
			toDelete.do(_.delete);
			fileList = fileList.copyRange(0, maxVersions - 1);
		};

		path.postln;
	}

	listVersions {
		fileList.collect(_.fileName).do(_.postln);
	}

	loadVersion { |index|
		var file, content;

		if(index >= fileList.size or: { index < 0 }) {
			"Invalid index: % (available: 0 to %)".format(index, fileList.size - 1).warn;
			^nil;
		};

		file = fileList[index];
		if(file.isNil) {
			"No file found at index %".format(index).warn;
			^nil;
		};

		File.use(file.fullPath, "r", { |f|
			content = f.readAllString;
		});
		^content;
	}

	latestVersion {
		^this.loadVersion(0);
	}
}


===== CommandTree/CircularSaves.sc.zip =====
PK   ùe[               CircularSaves.scux ˘     UT ∫c§hºc§h∫c§h≠U€n„6}∂øb ¿Ä›8îlÅ6ﬁêv`Å6-êE˚P4∆≈Di  ÈKö∏ﬂﬁ!EK¢b'ﬁ†z±%Œ9úÀ!Oö¬TËÈRr}√W»Ã4Î¶)¸ÚŒFgﬂéæﬂÌ˛ÆÑDè]†g≈5ºøXhÃ≈fHˇÚBf®„vÊﬁÊ|Û;j#
eË5'Ëœ¬ÿI◊CøQ∏ÜGx*¡í˘√gçò°fqüˇMõŸZoR¿xÙ‰	›skñ‘å®ôP¬ˆwô5Ûj†è‹ñ9Dù—APΩõù	√™¸À?ìx5*•~a∆rïqùâ–Ω∑PqÅç∑V*≥‘xÂi⁄Po€îíF3ª™Zﬂ(˜98’=¡ÊgB˜Î¨„vµ∏‡›§)wªÊsl≤P⁄V4Ã†ƒ©oy^7’0G·pÏÔÖ2;√ÑìHNìPœ	€àEïïëâ”0Öl+÷-3Ö∂?<Ùø∞yëâ\Lπ•Ü~s¨´2§Ø–ió‘¥PñR}™în)ö7_PaπEvè÷ˇ˙è†Cs)5ÚÏœÒ(Ç°<C_∆gÔﬁùç+2óµ¢¨ùƒ{ßΩÑ§¢ÁºñlµŸ¿WÏ+öTËE[QpíûTúeúü·“`·%ú¨ÈË¯^Sœ÷ZXÏá
©Q°	áE¥æT¯´Ãb9:z∂(åïj“•6ñ[°y¨gƒ‹¨d¬ù∏àéıv– Ïäv≈zUUHçÛbÖó∂?L¢2îe§0ãı“∂)`I{“´»ßÖt˙$…Ï6`YAØe≠µnd¡≥ÜnÑ pÛz°’·ÚyﬂG¡≈áV
ÌD].æáQ‹à‰ìZq)≤r˝z–Á+.$øì§∂ÿzÉJI>hÿ‚?ÖÒÄ≠πVuSnïê°ñêûÉ4⁄¸ßg˙k≤K›}g¬\%w]î¿ºX™∏UÙ‚Ñ^ﬂΩ“≠ﬂ'_JYﬁ¡âﬁ	∏áÆ∫\ô;xóRﬁ–›¢Ócò—m’}öñS®Û∑tøÌµú/M√«D™÷SÆ†X†fÎoîvÓ
°?¿≠:á+#ËÆÇE!(SëùaµD=¢¿]p∑Ãs‘Â¶nﬂ=∂K_;i:ï‹ØÆΩrx:o3Í ~ªU?wj«◊˘zõv∞Ì.ü£ç⁄o∂ﬂ•Î•£-∫Üº‡œu–>sÆWü]≤QÖ{ΩŸÉsnÕ˚&_ˆ»ŒˇÁ»ûÔe;éj9d ûÁWÆø“qqCπmì«kæ[œËx„}Eù÷Î◊"Ôç˙∂«Ä=‚h˜-ÑÔñÅ-«-«ß‘2‹HìG∏mÃµ◊s£YÔs∞jœ∂]Ï»I°ˇPKà÷›ﬂ    PK   ùe[               __MACOSX/._CircularSaves.scux ˘     UT ∫c§hºc§he§hc`cg`b`MLVVàPÄê'q!É¯ãàé!!AP&H« ÊFS¬àMŒœ’K,(»I’+( /KÕKÃKNe`db›Êø#Û«Ã PKÄ‚V   £   PK   ùe[à÷›ﬂ              §Å    CircularSaves.scux ˘     UT ∫c§hPK   ùe[Ä‚V   £             §Å=  __MACOSX/._CircularSaves.scux ˘     UT ∫c§hPK      ∑   ¸    
===== CommandTree/CommandManager.sc =====
// CommandManager.sc
// v1.6
// MD 20250921-22:40

// Purpose: Central controller; uses injected display (MagicDisplayGUI), does NOT create windows.
// Style: var-first, AppClock.defer for UI, no server.sync. Tree path is configurable in *new/init.

CommandManager {
	var <>currentState;
	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var <>filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver;
	var <>queueExportCallback;

	var launchpadHandlerRef, footHandlerRef, guitarHandlerRef, dawHandlerRef;

	var <>launchpadID, <>footControllerID, <>guitarID;

	*new { arg treePath;
		^super.new.init(treePath);
	}


	init { arg treePath;
		var defaultPath, savedPath, stateDir, stateFile;
		var explicitOk, savedOk;

		currentState = \idle;
		// saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);
		saver = CircularFileSave.new("myTree", nil, 10);
// or simply: saver = CircularFileSave.new("myTree");


		stateDir  = Platform.userExtensionDir ++ "/LivePedalboardSuite/.state";
		stateFile = stateDir ++ "/LastCommandTreePath.txt";

		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		savedPath = this.readLastPath(stateFile); // <- empty/whitespace -> nil

		explicitOk = treePath.isString and: { treePath.size > 0 };
		savedOk    = savedPath.isString and: { savedPath.size > 0 } and: { File.exists(savedPath) };

		filePath = if (explicitOk) { treePath } { if (savedOk) { savedPath } { defaultPath } };

		if (filePath.isString and: { filePath.size > 0 }) {
			this.writeLastPath(stateDir, stateFile, filePath);
		};

		this.createNewTree;        // will harden path again inside
		this.createBuilder;
		this.createCommandQueue;

		// midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager = MIDIInputManager.new(builder, nil, nil, nil, nil);

		midiManager.parentCommandManager = this;


		^this
	}



	// --- Build pieces --------------------------------------------------------

	createNewTree {
		var usePath;
		// final guard before import: ensure a usable String path
		usePath = filePath;
		if (usePath.isString.not or: { usePath.size <= 0 }) {
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};
		if (File.exists(usePath).not) {
			// last resort: keep going with default even if missing (import will warn gracefully)
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};

		tree = MDCommandTree.new("root");
		tree.importJSONFile(usePath);

		if (tree.notNil) {
			"üì• Tree imported from ".post; usePath.postln;
		}{
			"üì• Couldn't create/import tree.".postln;
		};
		^this
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			if (true) { "üîÆ Builder created".postln };
		}{
			"üîÆ Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			if (true) { "üì¶ Queue created".postln };
		}{
			"üì¶ Couldn't create queue".postln;
		}
	}

	// --- Display passthrough -------------------------------------------------

	setStatus { arg text;
		// If a MagicDisplayGUI is injected, use showExpectation (no updateStatus in that class)
		if (display.notNil and: { display.respondsTo(\showExpectation) }) {
			display.showExpectation(text, 0);
		}{
			("Status: " ++ text).postln;
		}
	}

	// Optional hot-reload from a new path
	reloadTreeFromPath { arg path;
		if (path.notNil) { filePath = path; };
		this.createNewTree;
		builder = MDCommandBuilder.new(tree);
		this.setStatus("‚úÖ Tree reloaded from: " ++ filePath);
	}

	// --- tiny helpers (inside the same class) ---

	writeLastPath { arg dirPath, filePath, pathToWrite;
		var okDir;
		// guard: do nothing if not a non-empty String
		if (pathToWrite.isString.not or: { pathToWrite.size <= 0 }) { ^this };

		okDir = PathName(dirPath).isFolder;
		if (okDir.not) { File.mkdir(dirPath) };

		File.use(filePath, "w", { |fh| fh.write(pathToWrite) });
		^this
	}

	readLastPath { arg filePath;
		var content, cleaned, hasNonSpace;
		if (File.exists(filePath)) {
			File.use(filePath, "r", { |fh| content = fh.readAllString });
			// collapse whitespace-only to nil
			cleaned = content ? "";
			hasNonSpace = false;
			cleaned.do { |ch|
				if ((ch != $\ ) and: { ch != $\t } and: { ch != $\n } and: { ch != $\r }) {
					hasNonSpace = true;
				}
			};
			if (hasNonSpace.not) { content = nil };
		};
		^content
	}


/*	updateDisplay {
		var guiRef, modeText, choiceLines;

		guiRef = display;   // may be nil
		if (guiRef.isNil) { ^this };

		modeText = "Mode: " ++ (currentState ? \idle).asString;

		// build "fret X ‚Üí Name" lines from the builder's current node
		choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
			builder.currentNode.children.collect({ |ch|
				("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
			})
		} { [] };

		{
			if (guiRef.respondsTo(\showExpectation)) {
				guiRef.showExpectation(modeText, 0);
			};
			if (guiRef.respondsTo(\updateTextField)) {
				guiRef.updateTextField(\state, modeText);
				guiRef.updateTextField(\choices, choiceLines.join("\n"));
			};
			// NEW: update choices panel in MagicDisplayGUI if present
			if (guiRef.respondsTo(\setOperations)) {
				guiRef.setOperations(choiceLines);
			};
		}.defer;

		^this
	}*/

// updated 20250924-1209
	updateDisplay {
    var guiRef, modeText, choiceLines;
    guiRef = display; // may be nil
    if (guiRef.isNil) { ^this };
    modeText = "Mode: " ++ (currentState ? \idle).asString;

    // build "fret X ‚Üí Name" lines from the builder's current node
    choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
        builder.currentNode.children.collect({ arg ch;
            ("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
        })
    } { [] };

    {
        if (guiRef.respondsTo(\showExpectation)) {
            guiRef.showExpectation(modeText, 0);
        };
        if (guiRef.respondsTo(\updateTextField)) {
            guiRef.updateTextField(\state, modeText);
            guiRef.updateTextField(\choices, choiceLines.join("\n"));
        };
        if (guiRef.respondsTo(\setOperations)) {
            guiRef.setOperations(choiceLines);
        };
    }.defer;
    ^this
}

}

// Back-compat alias
MDCommandMC : CommandManager {}

===== CommandTree/CommandManager.sc_v1.6.txt =====
// CommandManager.sc
// v1.6
// MD 20250921-22:40

// Purpose: Central controller; uses injected display (MagicDisplayGUI), does NOT create windows.
// Style: var-first, AppClock.defer for UI, no server.sync. Tree path is configurable in *new/init.

CommandManager {
	var <>currentState;
	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var <>filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver;
	var <>queueExportCallback;

	var launchpadHandlerRef, footHandlerRef, guitarHandlerRef, dawHandlerRef;

	var <>launchpadID, <>footControllerID, <>guitarID;

	*new { arg treePath;
		^super.new.init(treePath);
	}


	init { arg treePath;
		var defaultPath, savedPath, stateDir, stateFile;
		var explicitOk, savedOk;

		currentState = \idle;
		// saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);
		saver = CircularFileSave.new("myTree", nil, 10);
// or simply: saver = CircularFileSave.new("myTree");


		stateDir  = Platform.userExtensionDir ++ "/LivePedalboardSuite/.state";
		stateFile = stateDir ++ "/LastCommandTreePath.txt";

		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		savedPath = this.readLastPath(stateFile); // <- empty/whitespace -> nil

		explicitOk = treePath.isString and: { treePath.size > 0 };
		savedOk    = savedPath.isString and: { savedPath.size > 0 } and: { File.exists(savedPath) };

		filePath = if (explicitOk) { treePath } { if (savedOk) { savedPath } { defaultPath } };

		if (filePath.isString and: { filePath.size > 0 }) {
			this.writeLastPath(stateDir, stateFile, filePath);
		};

		this.createNewTree;        // will harden path again inside
		this.createBuilder;
		this.createCommandQueue;

		// midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager = MIDIInputManager.new(builder, nil, nil, nil, nil);

		midiManager.parentCommandManager = this;


		^this
	}



	// --- Build pieces --------------------------------------------------------

	createNewTree {
		var usePath;
		// final guard before import: ensure a usable String path
		usePath = filePath;
		if (usePath.isString.not or: { usePath.size <= 0 }) {
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};
		if (File.exists(usePath).not) {
			// last resort: keep going with default even if missing (import will warn gracefully)
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};

		tree = MDCommandTree.new("root");
		tree.importJSONFile(usePath);

		if (tree.notNil) {
			"üì• Tree imported from ".post; usePath.postln;
		}{
			"üì• Couldn't create/import tree.".postln;
		};
		^this
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			if (true) { "üîÆ Builder created".postln };
		}{
			"üîÆ Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			if (true) { "üì¶ Queue created".postln };
		}{
			"üì¶ Couldn't create queue".postln;
		}
	}

	// --- Display passthrough -------------------------------------------------

	setStatus { arg text;
		// If a MagicDisplayGUI is injected, use showExpectation (no updateStatus in that class)
		if (display.notNil and: { display.respondsTo(\showExpectation) }) {
			display.showExpectation(text, 0);
		}{
			("Status: " ++ text).postln;
		}
	}

	// Optional hot-reload from a new path
	reloadTreeFromPath { arg path;
		if (path.notNil) { filePath = path; };
		this.createNewTree;
		builder = MDCommandBuilder.new(tree);
		this.setStatus("‚úÖ Tree reloaded from: " ++ filePath);
	}

	// --- tiny helpers (inside the same class) ---

	writeLastPath { arg dirPath, filePath, pathToWrite;
		var okDir;
		// guard: do nothing if not a non-empty String
		if (pathToWrite.isString.not or: { pathToWrite.size <= 0 }) { ^this };

		okDir = PathName(dirPath).isFolder;
		if (okDir.not) { File.mkdir(dirPath) };

		File.use(filePath, "w", { |fh| fh.write(pathToWrite) });
		^this
	}

	readLastPath { arg filePath;
		var content, cleaned, hasNonSpace;
		if (File.exists(filePath)) {
			File.use(filePath, "r", { |fh| content = fh.readAllString });
			// collapse whitespace-only to nil
			cleaned = content ? "";
			hasNonSpace = false;
			cleaned.do { |ch|
				if ((ch != $\ ) and: { ch != $\t } and: { ch != $\n } and: { ch != $\r }) {
					hasNonSpace = true;
				}
			};
			if (hasNonSpace.not) { content = nil };
		};
		^content
	}


/*	updateDisplay {
		var guiRef, modeText, choiceLines;

		guiRef = display;   // may be nil
		if (guiRef.isNil) { ^this };

		modeText = "Mode: " ++ (currentState ? \idle).asString;

		// build "fret X ‚Üí Name" lines from the builder's current node
		choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
			builder.currentNode.children.collect({ |ch|
				("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
			})
		} { [] };

		{
			if (guiRef.respondsTo(\showExpectation)) {
				guiRef.showExpectation(modeText, 0);
			};
			if (guiRef.respondsTo(\updateTextField)) {
				guiRef.updateTextField(\state, modeText);
				guiRef.updateTextField(\choices, choiceLines.join("\n"));
			};
			// NEW: update choices panel in MagicDisplayGUI if present
			if (guiRef.respondsTo(\setOperations)) {
				guiRef.setOperations(choiceLines);
			};
		}.defer;

		^this
	}*/

// updated 20250924-1209
	updateDisplay {
    var guiRef, modeText, choiceLines;
    guiRef = display; // may be nil
    if (guiRef.isNil) { ^this };
    modeText = "Mode: " ++ (currentState ? \idle).asString;

    // build "fret X ‚Üí Name" lines from the builder's current node
    choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
        builder.currentNode.children.collect({ arg ch;
            ("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
        })
    } { [] };

    {
        if (guiRef.respondsTo(\showExpectation)) {
            guiRef.showExpectation(modeText, 0);
        };
        if (guiRef.respondsTo(\updateTextField)) {
            guiRef.updateTextField(\state, modeText);
            guiRef.updateTextField(\choices, choiceLines.join("\n"));
        };
        if (guiRef.respondsTo(\setOperations)) {
            guiRef.setOperations(choiceLines);
        };
    }.defer;
    ^this
}

}

// Back-compat alias
MDCommandMC : CommandManager {}

===== CommandTree/Logging/CommandManagerLogging.sc_OBSOLETE =====
// CommandManagerLogging
// v1.0.1
// MD 20220923-1222

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ CommandManager {

    logInit { |treePathString|
        this.mdlog(2, "CommandManager", "‚úÖ created; treePath=" ++ treePathString);
        ^this
    }

    setStatus { |text|
        if(display.notNil and: { display.respondsTo(\showExpectation) }) {
            display.showExpectation(text, 0);
        }{
            this.mdlog(2, "CommandManager", "Status: " ++ text);
        };
        ^this
    }

    createNewTree {
        tree = MDCommandTree.new("root");
        tree.importJSONFile(filePath);
        if(tree.notNil) {
            this.mdlog(2, "CommandManager", "üì• tree imported: " ++ filePath);
            this.mdlog(3, "CommandManager", "tree pretty-print follows‚Ä¶");
            tree.printTreePretty;
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create/import tree");
        };
        ^this
    }

    createBuilder {
        builder = MDCommandBuilder.new(tree);
        if(builder.notNil) {
            this.mdlog(2, "CommandManager", "üî≠ builder created");
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create builder");
        };
        ^this
    }

    createCommandQueue {
        queue = MDCommandQueue.new;
        if(queue.notNil) {
            this.mdlog(2, "CommandManager", "üì¶ queue created");
        }{
            this.mdlog(1, "CommandManager", "‚ö† couldn't create queue");
        };
        ^this
    }

    reloadTreeFromPath { |path|
        if(path.notNil) { filePath = path; };
        this.createNewTree;
        builder = MDCommandBuilder.new(tree);
        this.setStatus("‚úÖ tree reloaded from: " ++ filePath);
        this.mdlog(2, "CommandManager", "‚úÖ tree reloaded: " ++ filePath);
        ^this
    }


	// added 20250923

	  // Build a slash path (without "root") from the builder's current node, e.g.
  //  "root -> chain -> add -> audio -> timebased -> delay"
  //   -> "/chain/add/audio/timebased/delay"
  buildLongPathFromBuilder { arg builderRef;
    var names, raw, filtered;
    if(builderRef.isNil or: { builderRef.currentNode.isNil }) { ^"/" };
    names = builderRef.currentNode.getPathToRoot; // List from root..current
    // drop "root", to-lower is not required (your names are already lower)
    filtered = names.copyRange(1, names.size - 1);
    raw = "/" ++ filtered.join("/");
    ^raw;
  }

  // Map long tree paths to short canonical "/verb/..." understood by MPB.
  canonicalizeCommandPath { arg rawPath;
    var parts, first;
    parts = rawPath.asString.split($/).reject({ arg s; s.size == 0 });
    if(parts.size == 0) { ^rawPath.asString };
    first = parts[0].asString;

    // switch family ‚Üí "/switch"
    if(first == "switch") { ^"/switch" };

    // chain/*
    if(first == "chain") {
      if(parts.size >= 3) {
        var second = parts[1].asString;
        // /chain/add/audio/.../<effect> -> /add/<effect>
        if(second == "add" and: { parts[2].asString == "audio" }) {
          ^("/add/" ++ parts.last.asString);
        };
        // /chain/setsource/audio/source/<src> -> /setSource/<src>
        if(second == "setsource"
          and: { parts.size >= 5 }
          and: { parts[2].asString == "audio" }
          and: { parts[3].asString == "source" }) {
          ^("/setSource/" ++ parts.last.asString);
        };
      };
      ^rawPath.asString; // fall through
    };

    // already-canonical short forms
    if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
      ^("/" ++ parts.join("/"));
    };

    ^rawPath.asString;
  }

  // One-shot helper from builder ‚Üí CANONICAL short path.
  canonicalPathFromBuilder { arg builderRef;
    var longPath, shortPath;
    longPath = this.buildLongPathFromBuilder(builderRef);
    shortPath = this.canonicalizeCommandPath(longPath);
    ^shortPath;
  }



}

===== CommandTree/Logging/MDCommandBuilderLogging.sc_OBSOLETE =====
// MDCommandBuilderLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandBuilder {

    printChildren {
        var names;
        if(currentNode.children.notEmpty) {
            currentNode.children.do { |item|
                this.mdlog(3, "CommandBuilder", "üéö fret " ++ item.fret ++ " ‚Üí " ++ item.name);
            };
            names = currentNode.children.collect(_.name);
        }{
            this.mdlog(1, "CommandBuilder", "‚ö† no children");
            names = [];
        };
        ^names
    }

    navigateByFret { |stringLevel, fretNumber|
        var nextNode;
        this.mdlog(2, "CommandBuilder", "üé∏ navigateByFret: " ++ fretNumber);
        nextNode = currentNode.getChildByFret(fretNumber);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        }{
            this.mdlog(1, "CommandBuilder", "‚ö† no child for fret " ++ fretNumber);
        };
        ^currentNode
    }

    navigateByName { |stringLevel, childName|
        var nextNode = currentNode.getChildByName(childName);
        if(nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        }{
            var avail = currentNode.children.collect(_.name).join(", ");
            this.mdlog(1, "CommandBuilder", "‚ö† not found; available: " ++ avail);
        };
        ^currentNode
    }

    printPathToRoot {
        this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
        ^this
    }

    getCurrentName {
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }

    getCurrentPayload {
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }

    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;
        this.mdlog(2, "CommandBuilder", "üîÑ navigation reset");
        ^this
    }

    printfretPath {
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }
}

===== CommandTree/Logging/MDCommandNodeLogging.sc_OBSOLETE =====
// MDCommandNodeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandNode {

    addChild { |child|
        if(child.isKindOf(MDCommandNode)) {
            child.parent = this;
            children.add(child);
            this.mdlog(2, "CommandNode", "‚ûï added child '" ++ child.name ++ "' under '" ++ name ++ "'");
        }{
            this.mdlog(1, "CommandNode", "‚ö† attempted to add non-node child");
        };
        ^this
    }

    createChild { |name, id, fret|
        var child;
        if(name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
            this.mdlog(1, "CommandNode", "‚ùå invalid args for createChild");
            ^nil;
        };
        child = this.getChildByName(name);
        if(child.isNil) {
            child = MDCommandNode.new(name, id, fret);
            this.addChild(child);
            this.mdlog(2, "CommandNode", "‚úÖ created '" ++ name ++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
        }{
            this.mdlog(2, "CommandNode", "‚ÑπÔ∏è child already exists: " ++ name);
        };
        ^child
    }

    removeChildById { |idToRemove|
        var target = children.detect { |c| c.id == idToRemove };
        if(target.notNil) {
            children.remove(target);
            this.mdlog(2, "CommandNode", "üóëÔ∏è removed id " ++ idToRemove);
        }{
            this.mdlog(1, "CommandNode", "‚ö† id not found: " ++ idToRemove);
        };
        ^this
    }

    getNodeByNamePath { |nameList|
        var currentLocal = this;
        nameList.do { |n|
            currentLocal = currentLocal.getChildByName(n);
            if(currentLocal.isNil) {
                this.mdlog(1, "CommandNode", "‚ùå path segment not found: " ++ n);
                ^nil;
            }
        };
        this.mdlog(2, "CommandNode", "‚úÖ found node: " ++ currentLocal.name);
        ^currentLocal
    }

    printPathToRoot {
        this.mdlog(3, "CommandNode", "üìç " ++ this.getPathToRoot.join(" ‚Üí "));
        ^this
    }

    printTreePretty { |level = 0, isLast = true, prefix = ""|
        var sortedChildren, connector, newPrefix, line;
        connector = if(level == 0) { "" } { if(isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
        line = prefix ++ connector ++ this.name
            ++ " (fret:" ++ this.fret
            ++ ", id:" ++ this.id
            ++ ", payload:" ++ this.payload ++ ")";
        this.mdlog(3, "CommandNode", line);

        newPrefix = if(level == 0) { "" } { prefix ++ if(isLast) { "   " } { "‚îÇ  " } };
        sortedChildren = this.children;
        sortedChildren.do { |child, i|
            var last = (i == (sortedChildren.size - 1));
            child.printTreePretty(level + 1, last, newPrefix);
        };
        ^this
    }
}

===== CommandTree/Logging/MDCommandTreeLogging.sc_OBSOLETE =====
// MDCommandTreeLogging
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


+ MDCommandTree {

    printTreePretty {
        this.mdlog(3, "CommandTree", "pretty-print follows‚Ä¶");
        root.printTreePretty;
        ^this
    }

    findNodeByName { |name|
        var found;
        found = nodeMap.values.detect { |node| node.name == name };
        if(found.notNil) {
            this.mdlog(2, "CommandTree", "üîé found '" ++ found.name ++ "' (id " ++ found.id ++ ")");
            ^found
        }{
            this.mdlog(1, "CommandTree", "‚ö† node not found: " ++ name);
            ^nil
        }
    }

    getNodeByNamePath { |nameList|
        var found = root.getNodeByNamePath(nameList);
        if(found.notNil) { ^found }{
            this.mdlog(1, "CommandTree", "‚ö† path not found: " ++ nameList.join(" ‚Üí "));
            ^nil
        }
    }

    exportJSONFile { |path|
        var jsonString, file;
        jsonString = JSONlib.convertToJSON(root.asDictRecursively);
        file = File(path, "w");
        if(file.isOpen) {
            file.write(jsonString);
            file.close;
            this.mdlog(2, "CommandTree", "üì§ exported to " ++ path);
        }{
            this.mdlog(1, "CommandTree", "‚ö† failed to open for write: " ++ path);
        };
        ^this
    }

    importJSONFile { |path|
        var jsonString, dict, newTree;
        if(File.exists(path).not) {
            this.mdlog(0, "CommandTree", "‚ùå file does not exist: " ++ path);
            ^false;
        };
        jsonString = File(path, "r").readAllString;
        if(jsonString.isNil or: { jsonString.isEmpty }) {
            this.mdlog(1, "CommandTree", "‚ö† file is empty/unreadable: " ++ path);
            ^false;
        };
        dict = JSONlib.convertToSC(jsonString);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "‚ùå failed to parse JSON: " ++ path);
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "üì• imported from " ++ path);
        ^true
    }

    saveVersioned {
        var json = JSONlib.convertToJSON(root.asDictRecursively);
        saver.saveVersion(json);
        this.mdlog(2, "CommandTree", "üíæ versioned save complete");
        ^this
    }

    loadLatestVersion {
        var json, dict, newTree;
        json = saver.latestVersion;
        if(json.isNil or: { json.isEmpty }) {
            this.mdlog(1, "CommandTree", "‚ö† no saved version found");
            ^false;
        };
        dict = JSONlib.convertToSC(json);
        if(dict.isNil) {
            this.mdlog(0, "CommandTree", "‚ùå failed to parse saved JSON");
            ^false;
        };
        newTree = MDCommandTree.fromDict(dict);
        this.root = newTree.root;
        this.nodeMap = newTree.nodeMap;
        this.nodeCount = newTree.nodeCount;
        this.mdlog(2, "CommandTree", "üì• loaded latest version");
        ^true
    }

    listSavedVersions {
        this.mdlog(2, "CommandTree", "üóÇ listing saved versions‚Ä¶");
        saver.listVersions; // CircularFileSave may still post; optional: move it to logger later
        ^this
    }

    validateTree {
        var seen = Set.new, valid = true;
        nodeMap.values.do { |node|
            if(seen.includes(node.name)) {
                this.mdlog(1, "CommandTree", "‚ö† duplicate node name: " ++ node.name);
                valid = false;
            };
            seen.add(node.name);
        };
        this.mdlog(valid.if(2,0), "CommandTree", valid.if("‚úÖ validation passed", "‚ùå validation failed"));
        ^valid
    }

    assignPayloads {
        var assignRecursively;
        assignRecursively = { |node|
            node.payload = node.name;
            node.children.do { |child| assignRecursively.(child) };
        };
        assignRecursively.(this.root);
        this.mdlog(2, "CommandTree", "üß† payloads assigned");
        ^this
    }

    printPayloads {
        var printRecursively;
        printRecursively = { |node, level = 0|
            var indent = " " ! level;
            this.mdlog(3, "CommandTree", indent.join ++ node.name ++ " ‚Üí payload: " ++ node.payload);
            node.children.do { |child| printRecursively.(child, level + 1) };
        };
        printRecursively.(this.root);
        ^this
    }
}

===== CommandTree/Logging/MDLogFacade.sc =====
// MDLogFacade
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


// Minimal logging facade so any object can call: this.mdlog(level, label, message)
+ Object {
    mdlog { |level = 2, label = "GENERIC", message = ""|
        var logger = MDMiniLogger.get;
        switch(level,
            0, { logger.error(label, message) },
            1, { logger.warn(label, message) },
            2, { logger.info(label, message) },
            3, { logger.debug(label, message) },
            4, { logger.trace(label, message) }
        );
        ^this
    }
}

===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"üóÇ CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "‚úÖ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("‚úÖ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("üóë Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("‚ö†Ô∏è Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "üíæ Tree saved to versioned file.".postln;
} {
    "‚ö†Ô∏è No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "‚úÖ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "‚ùå Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("‚úÖ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"üíæ Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilder_Compat_Ext.sc_OBSOLETE =====
// MDCommandBuilder_Compat_Ext.sc
// v0.1.0
// MD 20250924-1048

/*
Purpose
- Keep older .scd tests running unchanged by mapping legacy selector names to current API.
Style
- class extension; var-first; lowercase; no server.sync.
*/

+ MDCommandBuilder {

  // Old: listChildren -> New: printChildren (returns names)
  listChildren {
    ^this.printChildren
  }

  // Old: navigateToChild(fret) OR navigateToChild(string, fret)
  navigateToChild { arg legacyArgA, legacyArgB = nil;
    var stringLevel, fretNumber;

    if (legacyArgB.isNil) {
      stringLevel = nil;
      fretNumber  = legacyArgA;
    } {
      stringLevel = legacyArgA;
      fretNumber  = legacyArgB;
    };

    ^this.navigateByFret(stringLevel, fretNumber)
  }

  // Old: printCurrentPath -> New: printPathToRoot
  printCurrentPath {
    ^this.printPathToRoot
  }

  // Old: getCurrentCommand -> New: getCurrentPayload
  getCurrentCommand {
    ^this.getCurrentPayload
  }

  // Old: reset -> New: resetNavigation
  reset {
    ^this.resetNavigation
  }

}

===== CommandTree/MDCommandBuilder.sc =====
// MDCommandBuilder.sc
// v0.2
// MD 20250924-1008

/*
Purpose
- Fold mdlog instrumentation into the base class (Option A).
- Keep existing console messages; add small legacy shims so old tests keep working.
Style
- var-first; descriptive variable names; no single-letter locals; lowercase; no server.sync.
- Minimal changes; preserve your current behavior.
*/

MDCommandBuilder {
    var <>tree, <>currentNode, <>currentCommand, <>fretPath;
    var <>navigationComplete = false;

    *new { arg argTree;  ^super.new.init(argTree); }

    init { arg argTree;
        tree = argTree;
        currentNode = tree.root;
        fretPath = List[0];
        "CommandBuilder initialized".postln;
        ^this
    }

/*    printChildren {
        var childrenNames;

        if (currentNode.children.notEmpty) {
            currentNode.children.do({ arg childItem;
                ("üéöÔ∏è Fret: " ++ childItem.fret ++ " ‚Üí " ++ childItem.name).postln;
            });
            childrenNames = currentNode.children.collect({ arg childItem; childItem.name });
            this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
        } {
            "‚ö†Ô∏è No children".postln;
            this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
        };
        ^childrenNames
    }*/

/*    navigateByFret { arg stringLevel, fretNumber;
        var nextNode;

        this.mdlog(2, "CommandBuilder",
            "üé∏ navigateByFret fret=" ++ fretNumber ++ " stringLevel=" ++ stringLevel);

        ("üé∏ Navigating by fret: " ++ fretNumber).postln;
        nextNode = currentNode.getChildByFret(fretNumber);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        } {
            ("‚ö†Ô∏è No child found for fret: " ++ fretNumber).postln;
            this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
        };
        ^currentNode
    }*/

/*    navigateByName { arg stringLevel, childName;
        var nextNode;

        nextNode = currentNode.getChildByName(childName);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            ("Path: " ++ currentNode.getFullPathString).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        } {
            var availableNames;
            availableNames = currentNode.children.collect({ arg childItem; childItem.name }).join(", ");
            ("‚ö†Ô∏è Available children: " ++ availableNames).postln;
            this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
        };
        ^currentNode
    }*/

/*    printPathToRoot {
        currentNode.getPathToRoot.postln;
        this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
        ^this
    }*/

/*    getCurrentName {
        currentNode.name.postln;
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }*/

/*    getCurrentPayload {
        ("Current payload: " ++ currentNode.payload).postln;
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }*/

    isAtLeaf {
        ^currentNode.children.isEmpty
    }

/*    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;  // important; reset the flag
        "üîÑ Navigation reset".postln;
        this.mdlog(2, "CommandBuilder", "navigation reset");
        ^this
    }*/

//superseded
/*    printfretPath {
        ("Fret path: " ++ fretPath).postln;
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }*/

    // ---- Legacy shims (keep old tests working) ----

    // Old: listChildren -> New: printChildren
    listChildren {
        ^this.printChildren
    }

    // Old: navigateToChild(fret) OR navigateToChild(string, fret)
    navigateToChild { arg legacyArgA, legacyArgB = nil;
        var stringLevel, fretNumber;

        if (legacyArgB.isNil) {
            stringLevel = nil;
            fretNumber  = legacyArgA;
        }{
            stringLevel = legacyArgA;
            fretNumber  = legacyArgB;
        };

        ^this.navigateByFret(stringLevel, fretNumber)
    }

    // Old: printCurrentPath -> New: printPathToRoot
    printCurrentPath {
        ^this.printPathToRoot
    }

    // Old: getCurrentCommand -> New: getCurrentPayload
    getCurrentCommand {
        ^this.getCurrentPayload
    }

    // Old: reset -> New: resetNavigation
    reset {
        ^this.resetNavigation
    }

	// newer 20250924 ------
	printChildren {
    var childrenNames;

    if (currentNode.children.notEmpty) {
      currentNode.children.do({ arg item;
        // existing console output
        ("üéöÔ∏è Fret: " ++ item.fret ++ " ‚Üí " ++ item.name).postln;
      });
      childrenNames = currentNode.children.collect(_.name);
      this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
    } {
      "‚ö†Ô∏è No children".postln;
      this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
    };
    ^childrenNames
  }

  navigateByFret { arg stringLevel, fretNumber;
    var nextNode;

    this.mdlog(2, "CommandBuilder", "üé∏ navigateByFret: " ++ fretNumber
      ++ " (stringLevel=" ++ stringLevel ++ ")");

    nextNode = currentNode.getChildByFret(fretNumber);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
    } {
      ("‚ö†Ô∏è No child found for fret: " ++ fretNumber).postln;
      this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
    };
    ^currentNode
  }

  navigateByName { arg stringLevel, childName;
    var nextNode;

    nextNode = currentNode.getChildByName(childName);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      ("Path: " ++ currentNode.getFullPathString).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
      this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
    } {
      var availableNames;
      availableNames = currentNode.children.collect(_.name).join(", ");
      ("‚ö†Ô∏è Available children: " ++ availableNames).postln;
      this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
    };
    ^currentNode
  }

  printPathToRoot {
    currentNode.getPathToRoot.postln;
    this.mdlog(3, "CommandBuilder", "üìç path=" ++ currentNode.getPathToRoot);
    ^this
  }

  getCurrentName {
    currentNode.name.postln;
    this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
    ^currentNode.name
  }

  getCurrentPayload {
    ("Current payload: " ++ currentNode.payload).postln;
    this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
    ^currentNode.payload
  }

  resetNavigation {
    currentNode = tree.root;
    fretPath = List[0];
    navigationComplete = false;
    "üîÑ Navigation reset".postln;
    this.mdlog(2, "CommandBuilder", "navigation reset");
    ^this
  }

  printfretPath {
    ("Fret path: " ++ fretPath).postln;
    this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
    ^this
  }



}

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandNode test.scd =====
(
// Set a fixed random seed for reproducibility
thisThread.randSeed = 12345;

// Global node counter and limit
~nodeLimit = 50;
~nodeCount = 1;
~fixedChildren = 3;

// Create root node
~root = MDCommandNode.new("root", 0);

// Breadth-first queue
~nodeQueue = List[~root];

// Build tree
while {
    (~nodeQueue.notEmpty and: { ~nodeCount < ~nodeLimit })
} {
    var parent = ~nodeQueue.removeAt(0);
    ("Adding " ++ ~fixedChildren ++ " children to " ++ parent.name).postln;

    ~fixedChildren.do {
        if (~nodeCount < ~nodeLimit) {
            var childName = parent.name ++ "_" ++ ~nodeCount;
            var child = MDCommandNode.new(childName, ~nodeCount);
            parent.addChild(child);
            ~nodeQueue.add(child);
            ("Created node: " ++ child.name ++ " | Total nodes: " ++ ~nodeCount).postln;
            ~nodeCount = ~nodeCount + 1;
        };
    };
};

// Print tree
"Generated Tree Structure:".postln;
~root.printTreePretty("", true);

// Check integrity
"Running integrity check...".postln;
~root.checkIntegrity;

// Count total nodes
~countNodes = { |node|
    var count = 1;
    node.children.do { |c|
        count = count + ~countNodes.(c);
    };
    ^count;
};

("‚úÖ Total nodes in tree: " ++ ~countNodes.(~root)).postln;
"Tree printed.".postln;
"end".postln;
)


b = MDCommandTree("root", 0);

===== CommandTree/MDCommandNode_FixIntegrity+DepthTag.sc =====
// MDCommandNode_FixIntegrity+DepthTag.sc
// v1.0 ‚Äî 2025-09-21 MD

// Purpose
// - Accept SortedList in checkIntegrity.
// - Add tagByDepth(depth) used by MDCommandTree.tagDepths.
// Style
// - var-first; lowercase; no server.sync.

+ MDCommandNode {
    // Accept List OR SortedList
    checkIntegrity {
        var failedChild;
        if( (this.children.isKindOf(List).not) && (this.children.isKindOf(SortedList).not) ) {
            ("‚ùå Integrity check failed at node '" ++ this.name ++ "': children is " ++ children.class).postln;
            ^false;
        };
        failedChild = this.children.detect { |c| c.checkIntegrity.not };
        if(failedChild.notNil) {
            ("‚ùå Integrity failed in child: " ++ failedChild.name).postln;
            ^false;
        };
        ^true
    }

    // annotate nodes with a 'depth' entry in payload (non-destructive)
    tagByDepth { |depth|
        var nextDepth = (depth ? 0).asInteger.max(0);
        // if payload is nil or a String, wrap in a simple Event to attach depth safely
        if(this.payload.isNil or: { this.payload.isKindOf(String) }) {
            this.payload = (name: this.name, depth: nextDepth);
        }{
            // if payload is e.g., an Event/Dict, set depth if slot exists
            this.payload.put(\depth, nextDepth);
        };
        this.children.do { |child| child.tagByDepth(nextDepth + 1) };
        ^this
    }
}

===== CommandTree/MDCommandNode.sc =====
// MDCommandNode.sc
// v1.0.1
// MD 20250924

MDCommandNode {
	var <>name, <>id, <>fret, <>parent, <>children;
	var <> payload; // the "command" that will be inserted in the tree


	*new { |name = "default", id = 1, fret = 1, parent = nil|
		^super.new.init(name, id, fret, parent);
	}

	init { |name, id, fret, parent = nil|
		this.name = name;
		this.id = id;
		this.fret = fret;
		this.parent = parent;
		//this.children = List.new; // updated to following:
		this.children = SortedList.new(nil, { |a, b| a.fret < b.fret });

		//if (children.isKindOf(List).not) updated to following:
		if (this.children.isKindOf(SortedList).not) {
			{
				("‚ö†Ô∏è Children is not a SortedList in node '" ++ name ++ "'! It is: " ++ children.class).postln;
			};

			^this
		}
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/*	removeChildByName { |nameToRemove|
		var index = children.findIndex { |c| c.name == nameToRemove };
		if (index.notNil) { children.removeAt(index); }
	}*/


	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Lookup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/*	getChildByName { |name|
		if (name.isKindOf(String).not) {
			("‚ùå getChildByName error: name must be a String").warn;
			^nil;
		};
		^children.detect { |c| c.name == name }
	}*/

	//getChildById { |id| ^children.detect { |c| c.id == id } }

	// getChildByFret { |fret| ^children.detect { |c| c.fret == fret } }

	childNameExists { |name| ^children.any { |c| c.name == name } }

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	getPathToRoot {
		var path = List.new;
		var current = this;
		while { current.notNil } {
			path.addFirst(current.name);
			current = current.parent;
		};
		^path
	}

	printPathToRoot {
		("üìç Path: " ++ this.getPathToRoot.join(" ‚Üí ")).postln;
	}

/*	getNodeByNamePath { |nameList|
		var current = this;
		nameList.do { |name|
			current = current.getChildByName(name);
			if (current.isNil) {
				("‚ùå Node not found at path segment: " ++ name).postln;
				^nil;
			}
		};
		("‚úÖ Found node: " ++ current.name).postln;
		^current
	}*/

	getDepth {
		^this.parent.notNil.if({ this.parent.getDepth + 1 }, { 0 })
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Analysis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	isLeaf {
		^this.children.size == 0
	}


	hasChild { |node|
		^this.children.any { |c| c === node }
	}
	countDescendants {
		if (this.isLeaf) { ^1 } {
			^this.children.sum { |c| c.countDescendants }
		}
	}

	countLeavesOnly {
		^this.isLeaf.if({ 1 }, {
			this.children.sum { |c| c.countLeavesOnly }
		})
	}

	getFullPathString {
		^this.getPathToRoot.join(" ‚Üí ");
	}

	//newer:
	checkIntegrity {
		var okType, failedChild;
		okType = this.children.isKindOf(List) or: { this.children.isKindOf(SortedList) };
		if(okType.not) {
			("‚ùå Integrity check failed at node '" ++ this.name
				++ "': children is " ++ children.class).postln;
			^false;
		};
		failedChild = this.children.detect { |c| c.checkIntegrity.not };
		if(failedChild.notNil) {
			("‚ùå Integrity failed in child: " ++ failedChild.name).postln;
			^false;
		};
		^true;
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Display ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/*	printTreePretty { |level = 0, isLast = true, prefix = ""|
		var sortedChildren, connector, newPrefix;

		// Print current node
		connector = if (level == 0) { "" } { if (isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
		(prefix ++ connector ++ this.name ++
			" (fret: " ++ this.fret ++
			", id: " ++ this.id ++
			", payload: " ++ this.payload ++ ")").postln;

		// Prepare prefix for children
		newPrefix = if (level == 0) { "" } {
			prefix ++ if (isLast) { "    " } { "‚îÇ   " }
		};

		// Use existing sortedChildren logic
		sortedChildren = this.children;

		// Recursively print children
		sortedChildren.do { |child, i|
			var last = (i == (sortedChildren.size - 1));
			child.printTreePretty(level + 1, last, newPrefix);
		};
	}*/

	printTreePretty { |level = 0, isLast = true, prefix = ""|
    var childList, connector, nextPrefix;

    connector = if (level == 0) { "" } { if (isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
    (prefix ++ connector ++ this.name
        ++ " (fret: " ++ this.fret
        ++ ", id: " ++ this.id
        ++ ", payload: " ++ this.payload ++ ")").postln;

    nextPrefix = if (level == 0) { "" } { prefix ++ if (isLast) { "    " } { "‚îÇ   " } };
    childList = this.children;

    childList.do({ arg child, index;
        var lastFlag;
        lastFlag = (index == (childList.size - 1));
        child.printTreePretty(level + 1, lastFlag, nextPrefix);
    });

    this
}


	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Serialization for exporting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

	asDictRecursively {
		var childrenDicts;

		childrenDicts = this.children.collect({ arg childNode;
			childNode.asDictRecursively
		});

		^(
			id:       this.id,
			name:     this.name,
			fret:     this.fret,
			payload:  this.payload,    // ‚Üê Added: keep payload in exports
			children: childrenDicts
		)
	}

	addChild { arg child;
		if (child.isKindOf(MDCommandNode)) {
			child.parent = this;
			children.add(child);
			this.mdlog(2, "CommandNode", "‚ûï added child '" ++ child.name
				++ "' under '" ++ name ++ "'");
		} {
			"‚ö†Ô∏è Attempted to add a non-node child.".warn;
			this.mdlog(1, "CommandNode", "attempted to add non-node child");
		}
	}

	createChild { arg name, id, fret;
		var child;

		if (name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
			"‚ùå Invalid arguments for createChild".warn;
			this.mdlog(1, "CommandNode", "invalid args for createChild");
			^nil;
		};

		child = this.getChildByName(name);

		if (child.isNil) {
			child = MDCommandNode.new(name, id, fret);
			this.addChild(child);
			("‚úÖ Created new child node: " ++ name
				++ " (ID: " ++ id ++ ", Fret: " ++ fret ++ ")").postln;
			this.mdlog(2, "CommandNode", "created '" ++ name
				++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
		} {
			("‚ÑπÔ∏è Child node already exists: " ++ name).postln;
			this.mdlog(2, "CommandNode", "child already exists: " ++ name);
		};

		^child
	}

	removeChildById { arg idToRemove;
		var childToRemove;

		childToRemove = children.detect({ arg nodeRef; nodeRef.id == idToRemove });

		if (childToRemove.notNil) {
			children.remove(childToRemove);
			"üóë Child removed".postln;
			this.mdlog(2, "CommandNode", "removed id=" ++ idToRemove);
		} {
			"‚ö†Ô∏è ID not found".postln;
			this.mdlog(1, "CommandNode", "id not found: " ++ idToRemove);
		}
	}






	removeChildByName { |nameToRemove|
		var index;

		index = children.findIndex({ arg c; c.name == nameToRemove });
		if (index.notNil) { children.removeAt(index) };
		this
	}

	getChildByName { |name|
		var result;

		if (name.isKindOf(String).not) {
			"‚ùå getChildByName error: name must be a String".warn;
			result = nil;
		} {
			result = children.detect({ arg c; c.name == name });
		};
		result
	}

	getChildById { |id|
		var result;
		result = children.detect({ arg c; c.id == id });
		result
	}

	getChildByFret { |fret|
		var result;
		result = children.detect({ arg c; c.fret == fret });
		result
	}

	getNodeByNamePath { |nameList|
		var current, ok;

		current = this;
		ok = true;

		nameList.do({ arg segmentName;
			var nextNode;
			nextNode = current.getChildByName(segmentName);
			if (nextNode.isNil) {
				"‚ùå Node not found at path segment: ".post; segmentName.postln;
				ok = false;
			} {
				current = nextNode;
			};
		});

		if (ok) {
			("‚úÖ Found node: " ++ current.name).postln;
			current
		} {
			nil
		}
	}
}
===== CommandTree/MDCommandNodeTest20250731.scd =====
(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 3);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 11);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 7);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 5);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 11);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 11);


// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;

)



/////////////////////
/// BUILD A TREE - older version.
/////////////////////

(
// Setup
var tree, root, lvl1A, lvl1B, lvl2A, lvl2B, lvl3A, lvl3B, lvl3C;
var printSummary;

// üå± Initialize tree and root
tree = MDCommandTree.new("root", 0, 1);
root = tree.root;

// üß© Level 1
lvl1A = tree.addNode(root.id, "Branch A", 2);
lvl1B = tree.addNode(root.id, "Branch B", 3);

// üß© Level 2
lvl2A = tree.addNode(lvl1A.id, "SubBranch A1", 4);
lvl2B = tree.addNode(lvl1B.id, "SubBranch B1", 5);

// üß© Level 3
lvl3A = tree.addNode(lvl2A.id, "Twig A1a", 6);
lvl3B = tree.addNode(lvl2A.id, "Twig A1b", 7);
lvl3C = tree.addNode(lvl2B.id, "Twig B1a", 8);

// üè∑Ô∏è Tag depth from root
tree.root.tagByDepth(0);

// üìã Node Summary
printSummary = {
    tree.nodeMap.values.do { |node|
        (node.name ++ " ‚Üí depthTag: " ++ node.depthTag ++ ", getDepth: " ++ node.getDepth).postln;
    };
};

// üñºÔ∏è Print results
printSummary.();
tree.printTreePretty;

tree.getNodeByName("Twig A1b").printPathToRoot;

)

===== CommandTree/MDCommandQueue_Compat_AddAlias.sc =====
// CommandTree/MDCommandQueue_Compat_AddAlias.sc
// v1.0.1
// MD 20250924-1249
/*
Purpose:
- Keep older tests working: addCommand -> enqueueCommand.
*/

+ MDCommandQueue {
    addCommand { |command|
        var result;
        result = this.enqueueCommand(command);
        result
    }
}

===== CommandTree/MDCommandQueue.sc =====
// MDCommandQueue.sc
// Refactored for clarity and consistency
// MD 20250818



MDCommandQueue {
    var <>commandList;

    *new { ^super.new.init(); }

    init {
        commandList = List.new(8);
        Verbosity.postIf(1, "‚úÖ CommandQueue initialized");
        ^this
    }

    enqueueCommand { |command|
        commandList.add(command);
        Verbosity.postIf(1, "üì• Command added: " ++ command);
        Verbosity.postIf(2, "üì¶ Current queue: " ++ commandList);
        ^commandList
    }

    dequeueLastCommand {
        if (commandList.notEmpty) {
            commandList.removeAt(commandList.size - 1);
            Verbosity.postIf(1, "üóë Last command removed");
        } {
            Verbosity.postIf(0, "‚ö† No command to remove");
        };
        ^commandList
    }

    clearQueue {
        commandList.clear;
        Verbosity.postIf(1, "üßπ Queue cleared");
        ^this
    }

    exportAsOSCPath {
        var oscPath;

        oscPath = "/" ++ commandList.collect { |cmd|
            cmd.asString;
        }.join("/");

        ~commandToSend = oscPath;
        Verbosity.postIf(2, "üöÄ Exported OSC path: " ++ oscPath);
        ^oscPath
    }
}

// MDCommandQueue {
// 	var <>commandList;
//
// 	*new { ^super.new.init(); }
//
// 	init {
// 		commandList = List.new(8);
// 		"CommandQueue initialized".postln;
// 		^this
// 	}
//
// 	enqueueCommand { |command|
// 		commandList.add(command);
// 		("Command added: " ++ command).postln;
// 		("Current queue: " ++ commandList).postln;
// 		^commandList
// 	}
//
// 	dequeueLastCommand {
// 		if (commandList.notEmpty) {
// 			commandList.removeAt(commandList.size - 1);
// 			"Last command removed".postln;
// 		} {
// 			"‚ö†No command to remove".postln;
// 		};
// 		^commandList
// 	}
//
// 	clearQueue {
// 		commandList.clear;
// 		"üßπ Queue cleared".postln;
// 		^this
// 	}
//
//
// 	exportAsOSCPath {
// 		var oscPath;
//
// 		oscPath = "/" ++ commandList.collect { |cmd|
// 			cmd.asString;
// 		}.join("/");
//
// 		~commandToSend = oscPath;
// 		("Exported OSC path: " ++ oscPath).postln;
// 		^oscPath
// 	}
// }
===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandTree.sc =====
// MDCommandTree.sc
// v1.0.1
// MD 20250924-1230

MDCommandTree {
	var <>root, <>nodeLimit = 200, <>nodeCount = 0, <>nodeMap;
	var <>saver;

	*new { |rootName = "root", rootId = 0, nodeLimit|
		^super.new.init(rootName, rootId, nodeLimit);
	}


/*	*fromDict { |dict|
		var tree;

		// Use a default node limit, or extract from dict if available
		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ?? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				tree.rebuildTreeFromDict(childDict, tree.root);
			};
		};
		tree.root.payload = dict[\payload];

		^tree;
	}*/

	*fromDict { |dict|
		var tree;

		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do({ arg childDict;
				tree.rebuildTreeFromDict(childDict, tree.root);
			});
		};

		tree.root.payload = dict[\payload];
		tree
	}

	init { |rootName, rootId, limit|
		root = MDCommandNode.new(rootName, rootId);
		nodeLimit = limit;
		nodeCount = 1;

		nodeMap = IdentityDictionary.new(100);
		nodeMap.put(rootId, root);

		saver = CircularFileSave.new("myTree", "~/TreeSaves", 10); // this is what will manage saves

		^this
	}

	rebuildTreeFromDict { |dict, parent|
		var node;

		node = MDCommandNode.new(dict[\name], dict[\id], dict[\fret]);
		parent.addChild(node);

		nodeMap.put(node.id, node);
		nodeCount = node.id.max(nodeCount);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				this.rebuildTreeFromDict(childDict, node);
			};
		};

		node.payload = dict[\payload];

		^node;
	}

/*	printTreePretty {
		root.printTreePretty;
		^this;
	}*/

	tagDepths {
		root.tagByDepth(0);
		^this;
	}

/*	findNodeByName { |name|
		var found;
		found = nodeMap.values.detect { |node| node.name == name };
		if (found.notNil) {
			("üîç Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			^found
		} {
			"‚ö†Ô∏è Node not found".postln;
			^nil
		}
	}*/

/*	getNodeByNamePath { |nameList|
		var found;
		found = root.getNodeByNamePath(nameList);
		if (found.notNil) {
			^found
		} {
			("‚ö†Ô∏è Node not found at path: " ++ nameList.join(" ‚Üí ")).postln;
			^nil
		}
	}*/

	addNode { |parentId, name, fret|
		var newId, parentNode, newNode;

		newId = nodeCount + 1;
		parentNode = nodeMap.at(parentId);

		if (parentNode.notNil) {
			nodeCount = newId;
			newNode = MDCommandNode.new(name, newId, fret);
			newNode.parent = parentNode;
			parentNode.addChild(newNode);
			nodeMap.put(newId, newNode);
			^newNode
		} {
			("‚ö†Ô∏è Invalid parent ID: " ++ parentId).postln;
			^nil
		}
	}

	removeNode { |nodeId|
		var nodeToRemove, parentNode, found;

		nodeToRemove = nodeMap.at(nodeId);
		parentNode = nodeToRemove.parent;

		if (parentNode.notNil) {
			found = parentNode.children.detect { |c| c === nodeToRemove };
			if (found.notNil) {
				parentNode.removeChildById(found.id);
				nodeMap.removeAt(nodeId);
				("üóë Node " ++ nodeId ++ " removed.").postln;
				^nodeToRemove
			} {
				"‚ö†Ô∏è Node not found in parent's children".postln;
				^nil
			}
		} {
			"‚ö†Ô∏è Cannot remove root node".postln;
			^nil
		}
	}

	swapNodes { |nodeId1, nodeId2|
		var node1, node2, parent1, parent2;

		node1 = nodeMap.at(nodeId1);
		node2 = nodeMap.at(nodeId2);
		parent1 = node1.parent;
		parent2 = node2.parent;

		if (parent1.isNil or: { parent2.isNil }) {
			"‚ö†Ô∏è Both nodes must have parents to swap".postln;
			^nil
		};

		node1 = removeNode(nodeId1);
		node2 = removeNode(nodeId2);

		if (node1.isNil or: { node2.isNil }) {
			"‚ö†Ô∏è Failed to remove nodes for swapping".postln;
			^nil
		};

		parent1.addChild(node2);
		parent2.addChild(node1);

		"üîÑ Nodes swapped".postln;
		^nil
	}

/*	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("üì§ Tree exported to " ++ path).postln;
		} {
			"‚ö†Ô∏è Failed to open file for writing.".warn;
		}
	}*/

	// importJSONFile { |path|
	// 	var jsonString, dict, newTree;
	//
	// 	if (File.exists(path).not) {
	// 		"‚ùå File does not exist: %".format(path).postln;
	// 		^false;
	// 	};
	//
	// 	jsonString = File(path, "r").readAllString;
	//
	// 	if (jsonString.isNil or: { jsonString.isEmpty }) {
	// 		"‚ö†Ô∏è File is empty or unreadable.".postln;
	// 		^false;
	// 	};
	//
	// 	dict = JSONlib.convertToSC(jsonString);
	//
	// 	if (dict.isNil) {
	// 		"‚ö†Ô∏è Failed to parse JSON.".postln;
	// 		^false;
	// 	};
	//
	// 	newTree = MDCommandTree.fromDict(dict);
	// 	this.root = newTree.root;
	// 	this.nodeMap = newTree.nodeMap;
	// 	this.nodeCount = newTree.nodeCount;
	//
	// 	("üì• Tree imported from " ++ path).postln;
	// 	^true;
	// }

	// NEW - added to manage circular saves
/*	saveVersioned {
		var json = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(json);
		"Tree saved to versioned file.".postln;
	}*/
	//---

	// NEW - added to manage circular saves
/*	loadLatestVersion {
		var json = saver.latestVersion;
		var dict, newTree;

		if(json.isNil or: { json.isEmpty }) {
			"‚ö†Ô∏è No saved version found.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(json);

		if(dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		"üì• Tree loaded from latest version.".postln;
		^true;
	}*/
	//---

	// NEW - added to manage circular saves
	listSavedVersions {
		saver.listVersions;
	}

	//---







	// THIS IS NEW. This is so that (for now) we can copy the name of the node into the payload instance variable.
	assignPayloads {
		var assignRecursively;

		assignRecursively = { |node|
			node.payload = node.name;
			node.children.do { |child|
				assignRecursively.(child);
			};
		};

		assignRecursively.(this.root);
		"üß† Payloads assigned to all nodes in tree.".postln;
		^this;
	}

	printPayloads {
		var printRecursively;

		printRecursively = { |node, level = 0|
			var indent = "  " ! level;
			(indent.join ++ node.name ++ " ‚Üí Payload: " ++ node.payload).postln;
			node.children.do { |child|
				printRecursively.(child, level + 1);
			};
		};

		printRecursively.(this.root);
		^this;
	}

	printTreePretty {
		root.printTreePretty;
		this.mdlog(3, "CommandTree", "pretty-print finished");
		^this;
	}

	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("üì§ Tree exported to " ++ path).postln;
			this.mdlog(2, "CommandTree", "exported=" ++ path);
		} {
			"‚ö†Ô∏è Failed to open file for writing.".warn;
			this.mdlog(1, "CommandTree", "failed open for write: " ++ path);
		};
		^this
	}

/*	importJSONFile { |path|
		var jsonString, dict, newTree;

		if (File.exists(path).not) {
			("‚ùå File does not exist: %".format(path)).postln;
			this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
			^false;
		};

		jsonString = File(path, "r").readAllString;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"‚ö†Ô∏è File is empty or unreadable.".postln;
			this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		("üì• Tree imported from " ++ path).postln;
		this.mdlog(2, "CommandTree", "imported=" ++ path);
		^true;
	}*/

	importJSONFile { arg path;
    var jsonString, dict;

    // Basic I/O and parsing guards
    if (File.exists(path).not) {
        ("‚ùå File does not exist: %".format(path)).postln;
        this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
        ^false;
    };

    jsonString = File(path, "r").readAllString;

    if (jsonString.isNil or: { jsonString.isEmpty }) {
        "‚ö†Ô∏è File is empty or unreadable.".postln;
        this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
        ^false;
    };

    dict = JSONlib.convertToSC(jsonString);

    if (dict.isNil) {
        "‚ö†Ô∏è Failed to parse JSON.".postln;
        this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
        ^false;
    };

    // ---- Build *this* tree in-place: reset containers first
    {
        var rootName, rootId, children;

        // tolerant root fields (work even if JSON doesn't carry name/id)
        rootName = dict[\name] ? "root";
        rootId   = (dict[\id] ? 0).asInteger;

        // fresh root + maps
        root = MDCommandNode.new(rootName.asString, rootId, 0);
        nodeMap = IdentityDictionary.new(128);
        nodeMap.put(rootId, root);
        nodeCount = rootId.max(1);

        // recursively build from children if present
        children = dict[\children];
        if (children.isKindOf(Array)) {
            children.do({ |childDict| this.rebuildTreeFromDict(childDict, root) });
        };

        // preserve payload at root if present
        root.payload = dict[\payload];

    }.value;

    ("üì• Tree imported from " ++ path).postln;
    this.mdlog(2, "CommandTree", "imported=" ++ path);
    ^true;
}



	saveVersioned {
		var jsonString;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(jsonString);
		"Tree saved to versioned file.".postln;
		this.mdlog(2, "CommandTree", "versioned save complete");
	}

	loadLatestVersion {
		var jsonString, dict, newTree;

		jsonString = saver.latestVersion;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"‚ö†Ô∏è No saved version found.".postln;
			this.mdlog(1, "CommandTree", "no saved version found");
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse saved JSON");
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		"üì• Tree loaded from latest version.".postln;
		this.mdlog(2, "CommandTree", "loaded latest version");
		^true;
	}

/*  validateTree {
    var seenNames, validFlag;

    seenNames = Set.new;
    validFlag = true;

    nodeMap.values.do({ |nodeRef|
      if (seenNames.includes(nodeRef.name)) {
        ("‚ö†Ô∏è Duplicate node name: " ++ nodeRef.name).postln;
        this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
        validFlag = false;
      };
      seenNames.add(nodeRef.name);
    });

    this.mdlog(validFlag.if(2,0), "CommandTree",
      validFlag.if("‚úÖ validation passed", "‚ùå validation failed"));

    ^validFlag;
  }*/

	findNodeByName { |name|
		var found;

		found = nodeMap.values.detect({ arg nodeRef; nodeRef.name == name });
		if (found.notNil) {
			("üîç Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			found
		} {
			"‚ö†Ô∏è Node not found".postln;
			nil
		}
	}

	getNodeByNamePath { |nameList|
		var found;

		found = root.getNodeByNamePath(nameList);
		if (found.notNil) { found } {
			("‚ö†Ô∏è Node not found at path: " ++ nameList.join(" ‚Üí ")).postln;
			nil
		}
	}

	validateTree {
		var seenNames, validFlag;

		seenNames = Set.new;
		validFlag = true;

		nodeMap.values.do({ arg nodeRef;
			if (seenNames.includes(nodeRef.name)) {
				("‚ö†Ô∏è Duplicate node name: " ++ nodeRef.name).postln;
				this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
				validFlag = false;
			};
			seenNames.add(nodeRef.name);
		});

		this.mdlog(validFlag.if(2, 0), "CommandTree",
			validFlag.if("‚úÖ validation passed", "‚ùå validation failed"));

		validFlag
	}
}

===== CommandTree/MIDIHandlers.sc =====
//MIDIHandlers.sc
// MD 20250818
// taken out of MIDIInputManager.sc to make smaller file and cleaner organisation.

MIDIInputHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}

LaunchpadHandler  {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
	}
}

LaunchpadDAWHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		// Intentionally left blank to ignore DAW messages
	}
}

FootControllerHandler {
	var <>inputManager;

	*new { |inputManager|
		if (inputManager.isNil) {
			Error("FootControllerHandler requires a inputManager").throw;
		};
		^super.new.init(inputManager);
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ FootControllerHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, value|
		("üß™ inputManager class is: " ++ inputManager.class).postln;


		if (type === \noteOn) {
			switch (value,
				36, { inputManager.setMode(inputManager.modes[\idle]) },
				38, { inputManager.setMode(inputManager.modes[\prog]) },
				40, { inputManager.setMode(inputManager.modes[\queue]) },
				41, { inputManager.setMode(inputManager.modes[\send]) },
				{ ("‚ö†Ô∏è No action for note: " ++ value).postln }
			);
		}
	}
}

GuitarMIDIHandler {
	var <>inputManager;

	*new { |inputManager|
		var instance = super.new;
		instance.init(inputManager);
		^instance
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ GuitarMIDIHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, pitch|
		var stringBasePitches, basePitch, fret, stringNumber;

		// ‚úÖ Confirm method is being called
		("üì• handleMessage called with channel: " ++ channel ++ ", type: " ++ type ++ ", pitch: " ++ pitch).postln;

		// ‚úÖ Check type
		if (type === \noteOn) {
			"‚úÖ type is noteOn".postln;
		} {
			"‚ùå type is not noteOn".postln;
		};

		// ‚úÖ Check current mode
		if (inputManager.currentMode == inputManager.modes[\prog]) {
			"‚úÖ currentMode is prog".postln;

			stringBasePitches = (
				0: 40, // E string (6th)
				1: 45, // A
				2: 50, // D
				3: 55, // G
				4: 59, // B
				5: 64  // E (1st)
			);

			basePitch = stringBasePitches[channel];
			if (basePitch.notNil) {
				fret = pitch - basePitch;
				stringNumber = 6 - channel;

				("üé∏ Received MIDI note: " ++ pitch ++
					" on channel: " ++ channel ++
					" ‚Üí string: " ++ stringNumber ++
					", base pitch: " ++ basePitch ++
					", calculated fret: " ++ fret).postln;

				// ‚úÖ Navigation logic
				if (inputManager.waitingForString == stringNumber) {
					inputManager.waitingForString = nil;
					inputManager.navigationCallback.value(fret);
				};
			} {
				("‚ö†Ô∏è Unrecognized channel: " ++ channel ++ ". No base pitch defined.").postln;
			}
		} {
			("‚ùå currentMode is: " ++ inputManager.currentMode).postln;
		};

		{ inputManager.parentCommandManager.updateDisplay; }.defer;
	}
}
===== CommandTree/MIDIInputManager.sc =====
// MIDIInputManager.sc
// v1.1.1
// v1.1 added things in send mode for LivePedalboardSystem
// MD 20250817-1926

MIDIInputManager {
	var <>deviceUIDs;         // Dict: symbolic name -> srcID
	var <>deviceHandlers;     // Dict: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <> builder, <>queue;
	var <> parentCommandManager;
	var <> modes;
	var <>waitingForString, <>navigationCallback;
	var <>lastEnqueuedPayload;


	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	/*
	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|

		this.modes = IdentityDictionary[
			\idle -> \idle,
			\prog -> \prog,
			\queue -> \queue,
			\send -> \send,
			\play -> \play,
			\numeric -> \numeric,
			\capture -> \capture,
			\record -> \record
		];

		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		// this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		// this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		//DEBUG:
		("footControllerHandler manager is: " ++ footControllerHandler.inputManager).postln;

		// this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		// this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;


		this.launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this) };
		this.footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
		this.guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this) };
		this.launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this) };


		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getDeviceSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}
*/

	init { arg argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW;
    var defined;

    // -- modes + basics
    this.modes = IdentityDictionary[
        \idle -> \idle, \prog -> \prog, \queue -> \queue, \send -> \send,
        \play -> \play, \numeric -> \numeric, \capture -> \capture, \record -> \record
    ];
    this.builder = argBuilder;
    this.queue   = MDCommandQueue.new;

    // --- 1) CREATE HANDLERS FIRST (safe fallbacks)
    launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this)      };
    footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
    guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this)     };
    launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this)   };

    // --- 2) MIDI client + device scan/bind
    MIDIClient.init;
    MIDIIn.connectAll;

    deviceUIDs     = Dictionary.new;
    deviceHandlers = Dictionary.new;
    this.scanDevices;

    launchpadID      = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
    launchpadDAWID   = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out);
    footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
    guitarID         = this.getDeviceSrcID(\MD_IAC_to_SC);

    // Bind (guarded inside bindDevice)
    this.bindDevice(launchpadID,      launchpadHandler);
    this.bindDevice(footControllerID, footControllerHandler);
    this.bindDevice(guitarID,         guitarHandler);
    this.bindDevice(launchpadDAWID,   launchpadDAWHandler);

    // --- 3) Optional debug (after creation; nil-safe)
    ("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;
    ("footControllerHandler manager is: "
        ++ (footControllerHandler.notNil.if({ footControllerHandler.inputManager }, { "nil" }))
    ).postln;

    // --- 4) Final MIDIdef
    this.setupMIDIDef;

    ^this
}

	setMode { |newMode|
		currentMode = newMode;
		parentCommandManager.currentState = newMode;
		this.handleModeChange(newMode);
		{ parentCommandManager.updateDisplay }.defer;
	}

	handleModeChange { |mode|
		switch(mode,
			modes[\idle], {
				queue.clear;
				builder.resetNavigation;
				"Tree navigation reset.".postln;
			},

			modes[\prog], {
				var root;

				builder.resetNavigation;

				root = builder.tree.root; // get the root
				if (root.notNil) {
					root.children.do { |child| ("‚Ä¢ " ++ child.name).postln };
				};

				this.startNavigationFromString(6);

				"Tree navigation started.".postln;
			},

			//---


			modes[\queue], {
				var queueText, canonicalPath;

				// NEW: derive canonical short path from current CommandTree selection
				canonicalPath = parentCommandManager.canonicalPathFromBuilder(builder);

				if (canonicalPath != lastEnqueuedPayload) { // reuse dedupe guard
					("Current canonical to queue: " ++ canonicalPath).postln;
					queue.enqueueCommand(canonicalPath);
					lastEnqueuedPayload = canonicalPath;

					if (builder.isAtLeaf) {
						parentCommandManager.setStatus("üåø Leaf ‚Üí " ++ canonicalPath);
					} {
						parentCommandManager.setStatus("üì• Queued node: " ++ canonicalPath);
					};

					queueText = queue.commandList.collect({ arg cmd; "- " ++ cmd.asString }).join("\n");
					{
						parentCommandManager.display.updateTextField(\state, "Mode: queue");
						parentCommandManager.display.updateTextField(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.updateTextField(\lastCommand, "Last Added: " ++ canonicalPath);
					}.defer;

				} {
					("‚ö†Ô∏è Duplicate canonical ignored: " ++ canonicalPath).postln;
					parentCommandManager.setStatus("‚ö†Ô∏è Duplicate canonical ignored");
				};

				builder.resetNavigation;
				"Added canonical to queue and restarted navigation.".postln;
				this.setMode(modes[\prog]); // unchanged
			},

			//---

/*			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;

				("Sent queue as OSC: " ++ path).postln;
				queue.clear;
			},*/

			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;
				("Sent queue as OSC: " ++ path).postln;
				if (parentCommandManager.notNil and: { parentCommandManager.queueExportCallback.notNil }) {
					parentCommandManager.queueExportCallback.value(path);
				};
				queue.clear;
			},

			modes[\play], {
				"üé∏ Play mode: no interaction.".postln;
			},
			modes[\numeric], {
				"üî¢ Numeric input mode (not yet implemented).".postln;
			},
			modes[\capture], {
				"üéº Capture mode (not yet implemented).".postln;
			},
			modes[\record], {
				"üî¥ Record mode (not yet implemented).".postln;
			}
		);
	}
	startNavigationFromString { |stringNum|
		if (stringNum < 1) {
			builder.navigationComplete = true;
			"‚úÖ Navigation complete.".postln;
			^this;
		};

		this.listenForNoteFromString(stringNum, { |fret|
			builder.navigateByFret(stringNum, fret);
			this.startNavigationFromString(stringNum - 1);
		});
	}

	listenForNoteFromString { |stringNum, callback|
		waitingForString = stringNum;
		navigationCallback = callback;
		("üéß Waiting for note on string " ++ stringNum).postln;
	}

	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"üéõ Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getDeviceSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " ‚Üí UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getDeviceSrcID(keyOrID);
			symbol = keyOrID;
		}{
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("‚ö†Ô∏è Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("‚ö†Ô∏è No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("üîó Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}

	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("‚ö†Ô∏è No handler bound for srcID: " + srcID).postln;
			}
		});
	}

} // end of MIDIInputManager class


===== CommandTree/test_circularSaves20250826.scd =====
// test_circularSaves20250826.scd
// MD



(
// Step 1: Load the latest saved tree version
~tree = MDCommandTree.new("root");
~loaded = ~tree.loadLatestVersion;

if (~loaded) {
    "Latest tree loaded.".postln;
    "Tree before modification:".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved tree found. Starting with empty tree.".postln;
};
)

(
// Step 2: Save current version for comparison
~originalJSON = ~tree.saver.latestVersion;
)

(
// Step 3: Modify the tree
~newNode = ~tree.addNode(0, "NewNode", 99);

if (~newNode.notNil) {
    "New node added.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add new node.".postln;
};
)

(
// Step 4: Save the modified tree as a new version
~tree.saveVersioned;
)

(
// Step 5: Compare original and new JSON
~newJSON = ~tree.saver.latestVersion;

if (~originalJSON != ~newJSON) {
    "Change confirmed: tree content has been updated.".postln;
} {
    "‚ö†Ô∏è No change detected between versions.".postln;
};
)













// (
// // Step 1: Create a new tree
// ~tree = MDCommandTree.new("root");
//
// // Step 2: Add some nodes
// ~tree.addNode(0, "A", 1);
// ~tree.addNode(1, "B", 2);
// ~tree.addNode(2, "C", 3);
// "‚úÖ Nodes added.".postln;
// ~tree.printTreePretty;
// )
//
// (
// // Step 3: Save the tree using CircularFileSave
// ~tree.saveVersioned;
// )
//
// (
// // Step 4: List saved versions
// ~tree.listSavedVersions;
// )
//
// (
// // Step 5: Load the latest saved version
// ~tree.loadLatestVersion;
// )
//
// (
// // Step 6: Print the tree to confirm it was restored
// "‚úÖ Tree after loading latest version:".postln;
// ~tree.printTreePretty;
// )

===== CommandTree/testCircularSave_20250819.scd =====
// Create a saver
~saver = CircularFileSave.new("myTree");

// Save a version
~saver.saveVersion("This is version " ++ Date.getDate.stamp);

// List saved versions
~saver.listVersions;

// Load a specific version
~saver.loadVersion(0).postln;

===== CommandTree/Tests/TestLogging_CommandBuilder.scd =====
TestLogging_CommandBuilder.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var jsonPath, tree, builder;

MDMiniLogger.get.setverbosity(3); // DEBUG

jsonPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
tree = MDCommandTree.new("root");
tree.importJSONFile(jsonPath);

builder = MDCommandBuilder.new(tree);
builder.printChildren;
builder.navigateByName(nil, "SomeChildName"); // INFO/WARN depending on your tree
builder.resetNavigation;
builder.printfretPath;
)

===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path ‚Üí " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) ‚Äî informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic ‚Äî print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' ‚Üí " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported ‚Üí " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("‚ö†Ô∏è Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== CommandTree/Tests/TestLogging_FullBringUp.scd =====
TestLogging_FullBringUp.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var lps;
MDMiniLogger.get.setverbosity(2); // INFO

lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;

// Switch to DEBUG if you want more detail for a moment
MDMiniLogger.get.setverbosity(3);

lps.commandManager.setStatus("Sanity check: status via MDMiniLogger");
)

===== CommandTree/TestUserDisplay.scd =====
(
~displayTest = UserDisplay.new;

~displayTest.display(\state, "üß≠ State: treeNav");
~displayTest.display(\queue, "üìã Queue: audio ‚Üí noise ‚Üí 100");
~displayTest.display(\lastCommand, "üïò Last Command: 100");
~displayTest.display(\choices, "üéö Choices:\nFret 7: noise\nFret 9: oscillators");
)

===== CommandTree/testVerbosity.scd =====
// temp

(
// üß™ Set verbosity level to 0 (errors only)
Verbosity.setLevel(0);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 2 (up to input/output)
Verbosity.setLevel(2);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 4 (everything)
Verbosity.setLevel(4);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");
)

Verbosity.help;
===== CommandTree/Verbosity.sc =====
// Verbosity.sc
// MD 20250819

// used to manage verbosity levels of my debugging messages

// Verbosity Levels:
// 0 ‚Üí Errors only
// 1 ‚Üí Actions
// 2 ‚Üí Input/Output
// 3 ‚Üí Object and type reporting
// 4 ‚Üí Full debug (everything)






// Verbosity.sc
Verbosity {
    classvar <level = 2; // Default level

	*help {
    "Verbosity Levels:".postln;
    "0 ‚Üí Errors only".postln;
    "1 ‚Üí Actions".postln;
    "2 ‚Üí Input/Output".postln;
    "3 ‚Üí Object and type reporting".postln;
    "4 ‚Üí Full debug (everything)".postln;
}


    *setLevel { |newLevel|
        level = newLevel;
        ("üîß Verbosity level set to: " ++ level).postln;
    }

    *shouldPost { |requiredLevel|
        ^level >= requiredLevel;
    }

    *postIf { |requiredLevel, msg|
        if (level >= requiredLevel) {
            msg.postln;
        };
    }
}

===== concat-files.sh =====
#!/usr/bin/env bash
#
# concat-files.sh ‚Äî Recursively concatenate files of a given type, with path headers
# Usage:
#   ./concat-files.sh -p '*.txt' [-o out.txt] [-x dirToExclude ...] [--mode header|tsv] [--absolute] [--no-sort]
#
# Defaults:
#   - pattern:     '*.txt'
#   - output:      stdout
#   - excludes:    .git, node_modules
#   - mode:        header   (prints a banner line with the path, then the file contents)
#   - path style:  relative (use --absolute for full absolute paths)
#   - sorting:     NUL-safe if GNU sort/gsort is available; otherwise falls back to unsorted
#
# Notes:
#   - NUL-safe (handles any filenames).
#   - Assumes text files. For binary data, consider filtering or adjusting.
#   - If -o is inside the tree, the script will avoid including the output file in its own output.
set -Eeuo pipefail

print_help() {
  sed -n '2,60p' "$0"
  cat <<'EOF'

Examples:
  # Concatenate all .sc files to out.txt with headers
  ./concat-files.sh -p '*.sc' -o out.txt

  # TSV mode: each line = "<path>\t<content with newlines collapsed>"
  ./concat-files.sh -p '*.md' --mode tsv -o files.tsv

  # Exclude extra directories
  ./concat-files.sh -p '*.py' -x build -x dist -o py-all.txt

  # Absolute paths in headers
  ./concat-files.sh -p '*.txt' --absolute -o abs.txt
EOF
}

# --- Defaults ---
pattern='*.txt'
out=''
mode='header'     # 'header' or 'tsv'
absolute=0
no_sort=0
# Default excludes (directory names, matched anywhere in the tree)
excludes=( ".git" "node_modules" )

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--pattern)
      [[ $# -ge 2 ]] || { echo "Error: -p|--pattern requires a value" >&2; exit 2; }
      pattern=$2; shift 2;;
    -o|--out)
      [[ $# -ge 2 ]] || { echo "Error: -o|--out requires a value" >&2; exit 2; }
      out=$2; shift 2;;
    -x|--exclude)
      [[ $# -ge 2 ]] || { echo "Error: -x|--exclude requires a value" >&2; exit 2; }
      excludes+=("$2"); shift 2;;
    --mode)
      [[ $# -ge 2 ]] || { echo "Error: --mode requires a value" >&2; exit 2; }
      case "$2" in header|tsv) mode=$2;; *) echo "Error: --mode must be 'header' or 'tsv'." >&2; exit 2;; esac
      shift 2;;
    --absolute)
      absolute=1; shift;;
    --no-sort)
      no_sort=1; shift;;
    -h|--help)
      print_help; exit 0;;
    *)
      echo "Unknown option: $1" >&2; print_help; exit 2;;
  esac
done
# Compute absolute path of output (if any) to avoid including it
out_abs=""
if [[ -n "$out" ]]; then
  case "$out" in
    /*) out_abs="$out";;
     *) out_abs="$PWD/$out";;
  esac
fi

# Pick a NUL-safe sort if available: prefer gsort (Homebrew coreutils) then GNU sort; else no sorting.
sort_bin=""
if [[ "$no_sort" -eq 0 ]]; then
  if command -v gsort >/dev/null 2>&1; then
    sort_bin="gsort"
  elif sort -z </dev/null >/dev/null 2>&1; then
    sort_bin="sort"
  else
    echo "Note: No NUL-safe sort ('gsort' or 'sort -z') available; output not sorted." >&2
  fi
fi

# Build the find(1) command with prunes and NUL-separated output
# Correct structure:
#   find . -type d \( -name ex1 -o -name ex2 ... \) -prune -o -type f -name "$pattern" -print0
find_cmd=(find .)

if [[ "${#excludes[@]}" -gt 0 ]]; then
  find_cmd+=(-type d '(')
  first=1
  for ex in "${excludes[@]}"; do
    if [[ $first -eq 1 ]]; then
      find_cmd+=(-name "$ex")
      first=0
    else
      find_cmd+=(-o -name "$ex")
    fi
  done
  find_cmd+=(')' -prune -o)
fi

# Always match files by pattern and print NUL-terminated names
find_cmd+=(-type f -name "$pattern" -print0)

# Function to emit the NUL-separated file list (optionally sorted)
find_out_stream() {
  if [[ -n "$sort_bin" ]]; then
    "${find_cmd[@]}" | "$sort_bin" -z
  else
    "${find_cmd[@]}"
  fi
}

# Stream NUL-terminated file names and format output
{
  find_out_stream
} | while IFS= read -r -d '' f; do
  # Normalize absolute path for comparison and optional display
  file_abs="$PWD/${f#./}"

  # Skip the output file itself if it appears
  if [[ -n "$out_abs" && "$file_abs" -ef "$out_abs" ]]; then
    continue
  fi

  if [[ $absolute -eq 1 ]]; then
    display_path="$file_abs"
  else
    display_path="${f#./}"
  fi

  if [[ "$mode" == "tsv" ]]; then
    # One line per file: <path>\t<content with newlines collapsed>
    printf '%s\t' "$display_path"
    tr '\n' ' ' < "$f" | sed -E 's/[[:space:]]+$//'
    printf '\n'
  else
    # Header banner + full content + blank line
    printf '===== %s =====\n' "$display_path"
    cat -- "$f"
    printf '\n'
  fi
done > "${out:-/dev/stdout}"


===== concat-files2.sh =====
#!/usr/bin/env bash
#
# concat-files2.sh ‚Äî Recursively concatenate files, with path headers
# Usage:
#   ./concat-files2.sh [-p '<glob>'] [-o out.txt] [-x dirToExclude ...] \
#                      [--mode header|tsv] [--absolute] [--no-sort] \
#                      [--include-underscore] [--include-dotfiles]
#
# Defaults:
#   - pattern: '*'             (match ALL files; no filetype filtering)
#   - output: stdout           (prefer -o to avoid self-inclusion)
#   - excludes: .git, node_modules, _*  (ignore underscore-prefixed directories)
#   - dotfiles: ignored by default (basenames starting with '.')
#   - mode: header             (prints a banner line with the path, then contents)
#   - path style: relative     (use --absolute for full absolute paths)
#   - sorting: NUL-safe if GNU sort/gsort is available; otherwise unsorted
#
# Notes:
#   - To avoid self-inclusion, prefer:  ./concat-files2.sh -o out.txt
#     (Avoid: ./concat-files2.sh > out.txt ‚Äî the shell redirect creates the file inside the tree.)
#   - NUL-safe (handles any filenames).
#   - If -o is inside the tree, we prune it from find and write to /tmp first, then move.

set -Eeuo pipefail

print_help() {
  cat <<'EOF'
Examples:
  # Concatenate ALL files to out.txt with headers (underscore dirs ignored; dotfiles ignored)
  ./concat-files2.sh -o out.txt

  # TSV mode: each line = "<path>\t<content with newlines collapsed>"
  ./concat-files2.sh --mode tsv -o files.tsv

  # Exclude extra directories
  ./concat-files2.sh -x build -x dist -o all.txt

  # Absolute paths in headers
  ./concat-files2.sh --absolute -o abs.txt

  # Include underscore-prefixed dirs (override default ignore)
  ./concat-files2.sh --include-underscore -o all_including_underscores.txt

  # Include dotfiles as well (override default ignore of .* files)
  ./concat-files2.sh --include-dotfiles -o all_including_dotfiles.txt

  # Filter to a specific glob (e.g., only .sc files)
  ./concat-files2.sh -p '*.sc' -o sc_all.txt
EOF
}

# --- Defaults ---
pattern='*'       # match ALL files by default
out=''
mode='header'     # 'header' or 'tsv'
absolute=0
no_sort=0
ignore_underscore=1   # default: ignore _* directories
ignore_dotfiles=1     # default: ignore files whose basenames start with '.'

# Default excludes (directory names, matched anywhere in the tree)
excludes=( ".git" "node_modules" )

# --- Parse args ---
while [[ $# -gt 0 ]]; do
  case "$1" in
    -p|--pattern)
      [[ $# -ge 2 ]] || { echo "Error: -p|--pattern requires a value" >&2; exit 2; }
      pattern=$2; shift 2;;
    -o|--out)
      [[ $# -ge 2 ]] || { echo "Error: -o|--out requires a value" >&2; exit 2; }
      out=$2; shift 2;;
    -x|--exclude)
      [[ $# -ge 2 ]] || { echo "Error: -x|--exclude requires a value" >&2; exit 2; }
      excludes+=("$2"); shift 2;;
    --mode)
      [[ $# -ge 2 ]] || { echo "Error: --mode requires a value" >&2; exit 2; }
      case "$2" in header|tsv) mode=$2;; *) echo "Error: --mode must be 'header' or 'tsv'." >&2; exit 2;; esac
      shift 2;;
    --absolute)
      absolute=1; shift;;
    --no-sort)
      no_sort=1; shift;;
    --include-underscore)
      ignore_underscore=0; shift;;
    --include-dotfiles)
      ignore_dotfiles=0; shift;;
    -h|--help)
      print_help; exit 0;;
    *)
      echo "Unknown option: $1" >&2; print_help; exit 2;;
  esac
done

# Add the "_*" ignore (underscore-prefixed directories) unless overridden
if [[ $ignore_underscore -eq 1 ]]; then
  excludes+=("_*")
fi

# Compute absolute path of output (if any)
out_abs=""
out_rel_in_tree=""
if [[ -n "$out" ]]; then
  case "$out" in
    /*) out_abs="$out";;
    *)  out_abs="$PWD/$out";;
  esac
  # If the output path sits under $PWD, compute a "./relative" path for find -path pruning
  if [[ "${out_abs#$PWD/}" != "$out_abs" ]]; then
    out_rel_in_tree="./${out_abs#$PWD/}"
  fi
fi

# Pick a NUL-safe sort if available
sort_bin=""
if [[ "$no_sort" -eq 0 ]]; then
  if command -v gsort >/dev/null 2>&1; then
    sort_bin="gsort"
  elif sort -z </dev/null >/dev/null 2>&1; then
    sort_bin="sort"
  else
    echo "Note: No NUL-safe sort ('gsort' or 'sort -z') available; output not sorted." >&2
  fi
fi

# Build the find(1) command with explicit prunes and NUL-separated output.
# Structure:
#   find . \
#     \( -type d \( -name ex1 -o -name ex2 ... \) -prune \
#        -o -path "./rel/out.txt" -prune \
#        -o -type f -name "$pattern" [ -not -name '.*' ] -print0 \)
find_cmd=(find .)
find_cmd+=( '(' )
if [[ "${#excludes[@]}" -gt 0 ]]; then
  find_cmd+=(-type d '(')
  first=1
  for ex in "${excludes[@]}"; do
    if [[ $first -eq 1 ]]; then
      find_cmd+=(-name "$ex")
      first=0
    else
      find_cmd+=(-o -name "$ex")
    fi
  done
  find_cmd+=(')' -prune)
fi

# Prune the output file itself if it's inside the tree
if [[ -n "$out_rel_in_tree" ]]; then
  if [[ "${#excludes[@]}" -gt 0 ]]; then
    find_cmd+=( -o )
  fi
  find_cmd+=( -path "$out_rel_in_tree" -prune )
fi

# File match branch
if [[ "${#excludes[@]}" -gt 0 || -n "$out_rel_in_tree" ]]; then
  find_cmd+=( -o )
fi
find_cmd+=( -type f -name "$pattern" )
if [[ $ignore_dotfiles -eq 1 ]]; then
  find_cmd+=( -not -name '.*' )
fi
find_cmd+=( -print0 ')' )

# Function to emit the NUL-separated file list (optionally sorted)
find_out_stream() {
  if [[ -n "$sort_bin" ]]; then
    "${find_cmd[@]}" | "$sort_bin" -z
  else
    "${find_cmd[@]}"
  fi
}

# Choose output destination:
# - If -o is given: write to a temp file outside the tree, then move to final path.
# - If no -o: write to stdout (NOTE: avoid shell redirection to a file inside the tree).
tmp_out=""
redirect_target="/dev/stdout"
if [[ -n "$out" ]]; then
  tmp_out="$(mktemp "${TMPDIR:-/tmp}/concat-files2.XXXXXXXX")"
  redirect_target="$tmp_out"
fi

# Stream NUL-terminated file names and format output
{
  find_out_stream
} | while IFS= read -r -d $'\0' f; do
  # Normalize absolute path for comparison and optional display
  file_abs="$PWD/${f#./}"

  # Extra guard: skip the final output path if seen (double-protection)
  if [[ -n "$out_abs" && -e "$out_abs" && "$file_abs" -ef "$out_abs" ]]; then
    continue
  fi

  if [[ $absolute -eq 1 ]]; then
    display_path="$file_abs"
  else
    display_path="${f#./}"
  fi

  if [[ "$mode" == "tsv" ]]; then
    # One line per file: <path>\t<content with newlines collapsed>
    printf '%s\t' "$display_path"
    tr '\n' ' ' < "$f" | sed -E 's/[[:space:]]+$//'
    printf '\n'
  else
    # Header banner + full content + blank line
    printf '===== %s =====\n' "$display_path"
    cat -- "$f"
    printf '\n'
  fi
done > "$redirect_target"

# Finalize: if using -o, move the temp file into place
if [[ -n "$out" ]]; then
  mv -f -- "$tmp_out" "$out"
fi

===== Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd =====
// Sim_MIDIInput_Emulator_For_TreeNav.scd
// v0.1.2
// MD 20250924-1510
/*
Purpose
- Emulate hardware control of your system:
  ‚Ä¢ FOOT controller: mode changes (idle/prog/queue/send).
  ‚Ä¢ MIDI GUITAR: string/fret ‚Üí channel/pitch ‚Üí tree navigation.
- Keep everything in ONE file; evaluate section-by-section.

Style
- var-first in every block/closure; lowercase methods; no server.sync.
- Works with your current LivePedalboardSystem, CommandManager, and adapter bridge.
- Generated audio only (no SoundIn); Option A exclusivity remains enforced by your bring-up.
*/

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [0] Bring-up (idempotent): system + GUI + MagicPedalboard + adapter bridge
//    Evaluate once after a fresh compile (or re-run to refresh).
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var needNew, systemRef;

// If an older system exists, shut it down cleanly.
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) {
    ~system.shutdownAll;
};

// Create (or reuse) the LivePedalboardSystem and bring everything up.
needNew = (~system.isNil);
if(needNew) {
    systemRef = LivePedalboardSystem.new(nil); // nil ‚Üí class default JSON path resolver
    ~system = systemRef;
};

~system.bringUpAll;          // server + GUI + pedalboard + command system + meters
~system.installAdapterBridge; // queueExportCallback routes SHORT canonicals to MPB via adapter

// Convenience handles
~cm  = ~system.commandManager;
~mm  = ~cm.midiManager;
~mpb = ~system.pedalboard;
~gui = ~system.statusDisplay;

"‚úÖ System is up. (~system, ~cm, ~mm, ~mpb, ~gui)".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [1] Emulation helpers (define once)
//    These call your actual handlers‚Äîno MIDI devices required.
//    FOOT MAPPING (noteOn): 36‚Üí\idle, 38‚Üí\prog, 40‚Üí\queue, 41‚Üí\send
//    GUITAR MAPPING (channels 0..5 ‚Üí strings 6..1) with bases [40,45,50,55,59,64]
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var ensure, bases;

// Basic guard so we don't call handlers before bring-up.
ensure = {
    var ok;
    ok = ~system.notNil
     and: { ~system.commandManager.notNil }
     and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run section [0] (bring-up) first.".warn };
    ok
};

// E A D G B E (low‚Üíhigh), per your GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40,  // chan 0 ‚Üí string 6 (E2)
    1 -> 45,  // chan 1 ‚Üí string 5 (A2)
    2 -> 50,  // chan 2 ‚Üí string 4 (D3)
    3 -> 55,  // chan 3 ‚Üí string 3 (G3)
    4 -> 59,  // chan 4 ‚Üí string 2 (B3)
    5 -> 64   // chan 5 ‚Üí string 1 (E4)
];

// FOOT: emulate pressing a foot button (note number).
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    // channel is irrelevant for FootControllerHandler; value = note number.
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);
};

// Foot shortcuts
~toIdle  = { ~fc.(36) };  // idle
~toProg  = { ~fc.(38) };  // prog (tree navigation)
~toQueue = { ~fc.(40) };  // queue (enqueue current canonical)
~toSend  = { ~fc.(41) };  // send  (export & apply queue via bridge)

// GUITAR: emulate ‚Äúplay fret‚Äù on given string (1..6).
// Computes channel = 6 - string, pitch = base + fret; calls your GuitarMIDIHandler.
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "‚ö†Ô∏è Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Convenience alias for navigation (string,fret)
~nav = { arg s, f; ~gm.(s, f) };

// Peek: print the builder‚Äôs path and the canonical short form (e.g., "/add/delay").
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);
    ("‚Ä¢ long=" ++ long ++ "  |  canonical=" ++ short).postln;
};

// Optional: show available choices in GUI (if present)
~refreshChoices = {
    if(~system.notNil) { ~system.commandManager.updateDisplay };
};
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [2] Scenario A ‚Äî Add delay to NEXT via guitar nav, then switch
//    Top-level/children/grandchildren frets per your mapping:
//    string 6 fret 1 ‚Üí "audio", string 5 fret 5 ‚Üí "timebased", string 4 fret 3 ‚Üí "delay"
//    Then queue (note 40) and send (note 41) ‚Üí adapter applies "/add/delay"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();           // enter navigation mode
~refreshChoices.();   // optional UI refresh
~nav.(6, 1);          // 6/1 ‚Üí audio
~nav.(5, 5);          // 5/5 ‚Üí timebased
~nav.(4, 3);          // 4/3 ‚Üí delay
~showNav.();          // should report canonical "/add/delay"
~toQueue.();          // enqueue
~toSend.();           // apply via adapter
done = true;
"‚úÖ Scenario A complete (add delay, then you can use Scenario B to switch).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [3] Scenario B ‚Äî Switch chain from top-level ‚Äúswitch‚Äù
//    string 6 fret 5 ‚Üí "switch" ‚Üí queue ‚Üí send
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 5);      // top-level "switch"
~showNav.();      // should be "/switch"
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario B complete (switch with guarded crossfade).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [4] Scenario C ‚Äî Bypass: chain ‚Üí bypass ‚Üí delay ‚Üí on
//    Adjust frets if your JSON uses slightly different grandchildren numbers.
//    Example: 6/3="chain", 5/9="bypass", 4/3="delay", 3/3="on"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 3);   // "chain"
~nav.(5, 9);   // "bypass"
~nav.(4, 3);   // "delay"
~nav.(3, 3);   // "on"    // change to actual fret if needed
~showNav.();
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario C complete (bypass delay ON).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [5] Quick extras
//    ‚Ä¢ Re-run [2] then [3] to hear the effect.
//    ‚Ä¢ To bypass OFF, redo [4] but pick ‚Äú‚Ä¶/off‚Äù as per your tree‚Äôs leaf fret.
//    ‚Ä¢ Inspect the current queue at any time:
//        ~system.commandManager.midiManager.queue.commandList.postln;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

===== index_vsc_entrypoints.scd =====
// index_vsc_entrypoints.scd
// Project Entry Points Index for LivePedalboardSuite
//
// This file lists the main entry points (scripts, bring-up routines, test harnesses, and editors)
// for all major components in the project. Use this as a reference for launching, testing, or exploring the system.
//
// -----------------------------------------------------------------------------
// System Bring-Up & Main Launchers
// -----------------------------------------------------------------------------
"LivePedalboardSystem/Start_LivePedalboardSystem.scd"      // Main system bring-up (Option B)
"MagicPedalboard/MagicPedalboardNew.scd"                   // Main pedalboard engine
"MagicPedalboardTestRunner.sc"                             // Test/bring-up runner

// -----------------------------------------------------------------------------
// CommandTree System: Editors, Tests, Utilities
// -----------------------------------------------------------------------------
"CommandTree/martinTreeEditor.scd"                         // Interactive tree editor (load, add, remove, save nodes)
"CommandTree/MDCommandSystemTest20250804.scd"              // CommandTree structure and navigation test
"CommandTree/MDCommandSystemTest20250812.scd"              // CommandTree structure and navigation test (string+fret)
"CommandTree/MDCommandBuilderTest.scd"                     // CommandBuilder navigation and queue test

// -----------------------------------------------------------------------------
// Utilities & Simulations
// -----------------------------------------------------------------------------
"utilities/Simulate_CommandTree_Queue_AddDelay.scd"        // Simulate queueing "/add/delay" via CommandTree
"utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd"   // Stepwise navigation and queueing
"utilities/Queue_AddDelay_DirectCanonical.scd"             // Direct canonical command queueing
"utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd"       // Inspect tree and auto-route add/delay

// -----------------------------------------------------------------------------
// MagicPedalboard Troubleshooting & Demos
// -----------------------------------------------------------------------------
"MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd" // GUI, server, probe bring-up
"MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd" // Server/meter bring-up

// -----------------------------------------------------------------------------
// Test Harnesses & Acceptance Suites
// -----------------------------------------------------------------------------
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd" // Health check script
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd"       // One-go acceptance suite

// -----------------------------------------------------------------------------
// Miscellaneous & Example Scripts
// -----------------------------------------------------------------------------
"test 31tp8ve.scd"                                        // 31-tone scale test script

// -----------------------------------------------------------------------------
// Notes
// -----------------------------------------------------------------------------
// - For each entry, evaluate the file in VS Code to launch or test the corresponding component.
// - Most scripts assume you have run the main bring-up (Start_LivePedalboardSystem.scd) first.
// - See README.md and LivePedalboardSystem_README.md for further documentation and workflow details.
===== LivePedalboardSystem/CommandTreeStructure.xml =====
<commands>
  <audio>
    <source>
      <testmelody/>
      <sine/>
      <noise/>
      <!-- Add more sources as needed -->
    </source>
    <timebased>
      <delay>
        <multitap/>
        <pingpong/>
        <!-- More delay types -->
      </delay>
      <chorus/>
    </timebased>
    <modulation>
      <tremolo/>
      <phaser/>
      <flanger/>
    </modulation>
    <dynamics>
      <compressor/>
      <limiter/>
    </dynamics>
    <filter>
      <lowpass/>
      <highpass/>
      <bandpass/>
    </filter>
    <reverb/>
    <drive/>
  </audio>
  <chain>
    <addprocessor/>
    <removeprocessor/>
    <swapprocessors/>
    <bypassprocessor/>
    <clearchain/>
    <setsource/>
    <printchains/>
  </chain>
  <switch>
    <crossfade/>
    <crossfade_customtime/>
  </switch>
  <preset>
    <savepreset/>
    <loadpreset/>
  </preset>
  <system>
    <reset/>
    <healthcheck/>
    <showstatus/>
  </system>
</commands>

===== LivePedalboardSystem/CommandTreeStructureDiagram.scd =====
// updated 20250922-2147

root
‚îú‚îÄ‚îÄ audio (string 6, fret 1)
‚îÇ   ‚îú‚îÄ‚îÄ source      (string 5, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ testmelody (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sine       (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ noise      (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ timebased   (string 5, fret 5)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delay     (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ multitap  (string 3, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pingpong  (string 3, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chorus    (string 4, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ modulation (string 5, fret 7)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tremolo   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phaser    (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ flanger   (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ filter (string 5, fret 9)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lowpass   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ highpass  (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bandpass  (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ reverb (string 5, fret 11)
‚îÇ   ‚îî‚îÄ‚îÄ drive  (string 5, fret 13)

‚îú‚îÄ‚îÄ chain (string 6, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ add         (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ remove      (string 5, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ swap        (string 5, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ bypass      (string 5, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ clear       (string 5, fret 11)
‚îÇ   ‚îú‚îÄ‚îÄ setsource   (string 5, fret 13)
‚îÇ   ‚îî‚îÄ‚îÄ print       (string 5, fret 15)

‚îú‚îÄ‚îÄ switch (string 6, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ crossfade         (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ crossfade_custom  (string 5, fret 5)

‚îú‚îÄ‚îÄ preset (string 6, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ save        (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ load        (string 5, fret 5)

‚îú‚îÄ‚îÄ system (string 6, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ reset       (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ healthcheck (string 5, fret 5)
‚îÇ   ‚îî‚îÄ‚îÄ status      (string 5, fret 7)
===== LivePedalboardSystem/DevelopmentPlan_20250922.md =====

# DevelopmentPlan_20250922

**Project:** MagicPedalboardNew + CommandTree Integration  
**Date:** 2025-09-22

---

## Overview

- MagicPedalboardNew is a JITLib-based SuperCollider pedalboard system with A/B chains, managed by Ndefs and a processor registry.
- CommandTree is a hierarchical command system navigated by a hexaphonic guitar (one string per MIDI channel), allowing the performer to select commands by playing specific frets/strings.
- The system is designed for robust, testable, and modular live performance control.

---

## Current Canonical Files and Classes

- **Main pedalboard:** `MagicPedalboardNew.sc`
- **Processor registry:** `MagicProcessorLibrary.sc` and `MagicProcessorLibrary_defs.scd`
- **Test/bring-up runner:** `MagicPedalboardTestRunner.sc`
- **GUI/console display:** `MagicDisplay.sc`, `MagicDisplayGUI.sc`, `MagicDisplayGUI_GridDemo.sc`, `MagicDisplayGUI_Ext_VisualOnly.sc`
- **CommandTree system:**  
  `CommandManager.sc`, `MDCommandTree.sc`, `MDCommandNode.sc`, `MDCommandBuilder.sc`, `MDCommandQueue.sc`,  
  `MIDIInputManager.sc`, `GuitarMIDIHandler.sc`, `FootControllerHandler.sc`, `LaunchpadHandler.sc`, `UserDisplay.sc`

---

## Versioning and File Policy

- No more v3/v5/v6 in file names. Version numbers are kept in file/class headers only.
- Legacy/obsolete/old/shelved folders are left in place but not referenced by current code or documentation.
- When the project is finalized, all main files will be bumped to version 1.x and filenames cleaned up.

---

## CommandTree to Pedalboard Integration

- **Navigation:** Guitar MIDI input (one string per channel) is used to traverse the command tree. Each string/fret selects a branch.
- Navigation is managed by `MDCommandBuilder`, which tracks the current node and fret path.
- When navigation is complete (all strings traversed or user triggers completion), the payload at the reached node is enqueued in `MDCommandQueue`.
- In `queue` mode, the payload is added to the queue. In `send` mode, the queue is exported as an OSC path (e.g., `/add/delay`) and cleared.
- The exported OSC path is sent to the pedalboard adapter (e.g., `~ct_sendAndApply`).
- Partial queues (not at a leaf) may be valid and sent, e.g., `/audio/time-based/delay` as a generic command, or `/audio/time-based/delay/multi-tap` as a specific one.

---

## Integration Points and APIs

- **CommandManager**
    - `.queue` (`MDCommandQueue`): holds commands to send
    - `.builder` (`MDCommandBuilder`): manages navigation
    - `.midiManager` (`MIDIInputManager`): handles MIDI input and mode switching
    - `.setStatus(text)`: updates status in the display

- **MDCommandQueue**
    - `.enqueueCommand(payload)`: add a command
    - `.exportAsOSCPath`: returns a string like `/add/delay`
    - `.clearQueue`: empties the queue

- **MDCommandBuilder**
    - `.isAtLeaf`: true if navigation is at a leaf node
    - `.getCurrentPayload`: returns the payload at the current node

- **MIDIInputManager**
    - `.setMode(modeSymbol)`: changes mode (`prog`, `queue`, `send`, etc.)
    - `.handleModeChange(modeSymbol)`: triggers navigation, queueing, or sending

- **UserDisplay**
    - `.setStatus(text)`: updates status in the display
    - `.updateTextField(box, msg)`: updates specific display fields

---

## Navigation Completion and Sending

- Navigation is complete when all required strings have been played or the user triggers completion (e.g., via foot controller).
- Success is typically reaching a leaf node (`builder.isAtLeaf`), but partial queues are also valid in some cases.
- The pedalboard adapter should be called when the CommandTree is in `send` mode and the queue is exported.
- The actual call to the pedalboard adapter can be done immediately or scheduled on AppClock for thread safety.

---

## Clock Context

- Navigation and queueing: MIDI input and navigation are handled in real time (MIDI callbacks), but UI updates are deferred to AppClock.
- Sending to pedalboard: The call to the pedalboard adapter can be immediate or scheduled on AppClock.

---

## Device and Mode Routing

- Devices are mapped by symbolic names to source IDs in `MIDIInputManager`.
- Handlers are bound per device (guitar, foot controller, launchpad, etc.).
- Modes:  
  - `prog` (navigation)  
  - `queue` (add payload to queue)  
  - `send` (send queue to pedalboard)

---

## Status Callbacks for Display

- `CommandManager.setStatus(text)`: updates the status field in the display.
- Display fields: `modeText`, `queueText`, `lastCommandText`, `userChoicesText`, `statusText`.
- At every step of navigation, available commands or branches should be shown in the display.

---

## Open Questions / To Be Finalized

1. Pedalboard should be called when CommandTree is in `send` mode and the queue is exported (confirmed).
2. Whether to call the pedalboard adapter synchronously or always on AppClock is still open; use whichever is simplest and most robust.
3. Status updates for MagicDisplay/MagicDisplayGUI HUD: eventually needed, but for now, focus on showing available commands/branches at each navigation step.
4. Partial queues are valid and may be sent, not just at leaf nodes.

---

## Next Steps

- Proceed with Phase 1 cleanup and README updates.
- Prepare Phase 2 logger integration patch and test script.
- Prepare Phase 3 CommandTree-to-pedalboard glue code and headless test script.

---

**End of DevelopmentPlan_20250922**

===== LivePedalboardSystem/LivePedalboardSystem_README.md =====

# LivePedalboardSystem

## Overview
This system integrates the MagicPedalboard audio engine with a hierarchical CommandTree navigated via MIDI guitar input. It is designed for live performance, modular control, and real-time feedback.

## Purpose
The `LivePedalboardSystem` class coordinates the bring-up of:
- MagicPedalboard (audio engine and GUI)
- CommandTree (navigation and command queue)
- MIDI input routing
- Tree loading from JSON

## Directory Structure
```
MDClasses/
  LivePedalboardSystem/
    LivePedalboardSystem.sc         # Main integration class
    Start_LivePedalboardSystem.scd  # Launcher script
    MagicPedalboardCommandTree.json # Command tree definition
```

## Bring-Up Sequence
1. **Initialize MagicPedalboard**
   - Boot server
   - Create pedalboard and GUI/test runner

2. **Load CommandTree**
   - Load `MagicPedalboardCommandTree.json`
   - Build tree structure in memory

3. **Set Up MIDI Input**
   - Initialize MIDI manager
   - Bind guitar and foot controller devices

4. **Connect Tree to Pedalboard**
   - Route queued commands to pedalboard adapter

5. **Enable Feedback Display**
   - Show navigation state, queue, and status

## Class Responsibilities
### `LivePedalboardSystem`
- `.bringUpAll` ‚Äî Initializes all subsystems
- `.shutdownAll` ‚Äî Graceful shutdown (optional)
- `.reloadTree` ‚Äî Reloads tree from JSON
- `.showStatus` ‚Äî Posts current system state

## Launcher Script
Example: `Start_LivePedalboardSystem.scd`
```supercollider
(
~system = LivePedalboardSystem.new;
~system.bringUpAll;
)
```

## Notes
- Tree file uses preferred frets: 1, 3, 5, 7, 9
- Payloads are OSC-style paths usable by MagicPedalboard
- Class name can be changed later (e.g. `MDPerformanceSystem`)

## Next Steps
- Implement `LivePedalboardSystem.sc` class
- Test launcher script
- Confirm MIDI routing and pedalboard command execution


===== LivePedalboardSystem/LivePedalboardSystem-AdapterBridge.sc =====
// LivePedalboardSystem-AdapterBridge.sc
// v0.1.1
// MD 2025-09-26 15:22 BST

/* Purpose
   Install a queueExportCallback that routes SHORT canonical commands
   (e.g., "/add/delay") through your adapter (~ct_applyOSCPathToMPB),
   so they apply to MagicPedalboardNew safely.
   Additionally, if the path starts with "/switch", toggle the HUD's
   current-chain flag so the ACTIVE tint stays solid (no pulsing).

   Style
   - var-first; descriptive variable names; no server.sync; no non-local '^'.
   - Safe no-op if adapter or references are missing.
*/

+ LivePedalboardSystem {

  installAdapterBridge {
    var commandManager, pedalboardRef, statusDisplayRef;
    var adapterAvailable, adapterPath;

    commandManager    = this.commandManager;
    pedalboardRef     = this.pedalboard;
    statusDisplayRef  = this.statusDisplay;

    if(commandManager.isNil or: { pedalboardRef.isNil }) {
      "[LPS] installAdapterBridge: commandManager or pedalboard is nil; skipping.".warn;
      ^this;
    };

    // Ensure the adapter function is available
    adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
    if(adapterAvailable.not) {
      adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
      if(File.exists(adapterPath)) {
        adapterPath.load;
        adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      };
    };

    if(adapterAvailable.not) {
      "[LPS] installAdapterBridge: adapter not found; keep existing queueExportCallback.".warn;
      ^this;
    };

    // Bridge: every queued canonical path is applied via the adapter
    commandManager.queueExportCallback = { |canonicalPathString|
      var pathString, isSwitchPath;

      pathString = canonicalPathString.asString;
      ~ct_applyOSCPathToMPB.(pathString, pedalboardRef, statusDisplayRef);

      // ACTIVE chain rule: if the canonical path starts with "/switch", toggle A/B
      // Known-good assumption: "/switch" is a toggle between A and B.
      isSwitchPath = pathString.beginsWith("/switch");
      if(isSwitchPath) {
        // Use the tiny helper defined in MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd
        if(~md_toggleCurrentChain.isKindOf(Function)) {
          ~md_toggleCurrentChain.();
        }{
          // Fallback: initialize to A if helper is missing
          ~md_currentChain = ~md_currentChain ? \A;
          ~md_currentChain = (~md_currentChain == \A).if({ \B }, { \A });
        };
        ("[LPS] ACTIVE chain toggled to " ++ (~md_currentChain ? \A).asString).postln;
      };

      nil  // explicit nil return, no non-local '^'
    };

    "[LPS] installAdapterBridge: adapter bridge active.".postln;
    ^this
  }

}

===== LivePedalboardSystem/LivePedalboardSystem-AdapterBridge.sc.bak =====
// LivePedalboardSystem-AdapterBridge.sc
// v0.1.0
// MD 20250923-1324

/* Purpose
   Install a queueExportCallback that routes SHORT canonical commands
   (e.g., "/add/delay") through your adapter (~ct_applyOSCPathToMPB),
   so they apply to MagicPedalboardNew safely.

   Style
   - var-first; descriptive variable names; no server.sync.
   - Class extension only; safe no-op if adapter or references are missing.
*/

+ LivePedalboardSystem {

  installAdapterBridge {
    var commandManager, pedalboardRef, statusDisplayRef;
    var adapterAvailable, adapterPath;

    commandManager    = this.commandManager;
    pedalboardRef     = this.pedalboard;
    statusDisplayRef  = this.statusDisplay;

    if(commandManager.isNil or: { pedalboardRef.isNil }) {
      "[LPS] installAdapterBridge: commandManager or pedalboard is nil; skipping.".warn;
      ^this;
    };

    // Ensure the adapter function is available
    adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
    if(adapterAvailable.not) {
      adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
      if(File.exists(adapterPath)) {
        adapterPath.load;
        adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      };
    };

    if(adapterAvailable.not) {
      "[LPS] installAdapterBridge: adapter not found; keep existing queueExportCallback.".warn;
      ^this;
    };

    // Bridge: every queued canonical path is applied via the adapter
    commandManager.queueExportCallback = { |canonicalPathString|
      ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
    };

    "[LPS] installAdapterBridge: adapter bridge active.".postln;
    ^this;
  }

}


===== LivePedalboardSystem/LivePedalboardSystem-AutoMeters.sc =====
// LivePedalboardSystem-AutoMeters.sc
// v0.2.0
// MD 20250924-1905

/*
Purpose
- Make meters "just work":
  1) Install inline amplitude taps on sink proxies Ndef(\chainA) and Ndef(\chainB).
     These taps send /ampA and /ampB directly from the actual sink audio.
  2) Auto-reinstall taps after every "/switch" (post crossfade & audit).
  3) Re-arm GUI meter responders and repaint chains.

Style
- Class extension only; var-first; lowercase; no server.sync.
- Server ops in Server.default.bind; GUI ops via AppClock.sched.
*/

+ LivePedalboardSystem {

    enableAutoMeters { arg rate = 18, postSwitchDelay = 0.35;
        var installTaps, rearmGui, wrapAdapter;

        installTaps = {
            Server.default.bind({
                [\chainA, \chainB].do({ arg key, index;
                    var addr;
                    addr = (index == 0).if({ '/ampA' }, { '/ampB' });
                    Ndef(key).filter(\ampTap, { arg in;
                        var sig, aL, aR, r;
                        sig = in.isArray.if({ in }, { [in, in] }); // mono-safe
                        r   = rate.clip(1, 60);
                        aL  = Amplitude.kr(sig[0]).clip(0, 1);
                        aR  = Amplitude.kr(sig[1]).clip(0, 1);
                        SendReply.kr(Impulse.kr(r), addr, [aL, aR]);
                        in // pass-through
                    });
                });
            });
        };

        rearmGui = {
            AppClock.sched(0.05, {
                var g, p;
                g = this.statusDisplay;
                p = this.pedalboard;
                if(g.notNil and: { g.respondsTo(\enableMeters) }) {
                    g.enableMeters(false);
                    g.enableMeters(true);
                };
                if(p.notNil and: { p.respondsTo(\printChains) }) {
                    p.printChains; // repaint CURRENT/NEXT panels
                };
                nil
            });
        };

        wrapAdapter = {
            // Only if adapter is present in the session (~ct_applyOSCPathToMPB)
            if(~ct_applyOSCPathToMPB.isNil) {
                "‚ö†Ô∏è [AutoMeters] adapter not loaded; run installAdapterBridge first".warn;
            }{
                // Preserve the raw adapter once
                if(~ct_applyOSCPathToMPB_raw.isNil) {
                    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
                };
                // Wrap once to reinstall taps after "/switch"
                if(~ct_applyOSCPathToMPB_withMeters.isNil) {
                    ~ct_applyOSCPathToMPB_withMeters = { arg pathString, mpb, gui;
                        var p, res;
                        p = pathString.asString;
                        res = ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
                        if(p == "/switch") {
                            AppClock.sched(postSwitchDelay, {
                                installTaps.();
                                rearmGui.();
                                nil
                            });
                        };
                        res
                    };
                    ~ct_applyOSCPathToMPB = ~ct_applyOSCPathToMPB_withMeters;
                    "[AutoMeters] post-switch reinstaller active".postln;
                };
            };
        };

        // One-shot now, and set up the post-switch hook
        installTaps.();
        rearmGui.();
        wrapAdapter.();

        "[AutoMeters] Inline taps installed (rate=%), GUI re-armed".format(rate).postln;
        ^this
    }
}

===== LivePedalboardSystem/LivePedalboardSystem-Pathing.sc =====
// LivePedalboardSystem-Pathing.sc
// v0.3.1
// MD 20250923-0959

/*
Purpose
- Make LivePedalboardSystem default to a JSON tree INSIDE the repo so a fresh clone runs.
- Allow optional, per-user overrides in Extensions/MDclasses or UserState.
- Preserve explicit constructor path as the highest priority.

Style
- var-first; lowercase method names; no server.sync.
- Class extension only; pure path logic here.
*/

+ LivePedalboardSystem {

    // 1) Repo default (shipped in Git)
    *defaultTreePath {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 2) Optional per-user override in MDclasses (not in Git)
    *userOverrideMDclasses {
        ^Platform.userExtensionDir
        ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 3) Optional per-user override alongside the code (normally .gitignored)
    *userOverrideUserState {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";
    }

  *resolveTreePath { arg maybePath;
    var candidateUserState, candidateRepoDefault, candidateMdLegacy, resolvedPath;

    // 0) explicit path (caller responsibility)
    resolvedPath = maybePath;
    if (resolvedPath.notNil) { ^resolvedPath };

    // 1) per-user override alongside the code (usually .gitignored)
    candidateUserState   = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";

    // 2) repo default (shipped in Git / symlinked into Extensions)
    candidateRepoDefault = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    // 3) legacy (deprecated) MDclasses location
    candidateMdLegacy    = Platform.userExtensionDir
      ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    if (File.exists(candidateUserState))   { ^candidateUserState };
    if (File.exists(candidateRepoDefault)) { ^candidateRepoDefault };
    if (File.exists(candidateMdLegacy)) {
      MDMiniLogger.get.warn("Pathing",
        "[deprecated] Using MDclasses copy: " ++ candidateMdLegacy);
      ^candidateMdLegacy
    };

    // Last resort: return repoDefault even if missing; importer will warn gracefully.
    ^candidateRepoDefault;
  }

}

===== LivePedalboardSystem/LivePedalboardSystem-Taps_Isolated.sc_OBSOLETE =====
// LivePedalboardSystem-Taps_Isolated.sc
// v0.1.0 (isolated GUI taps: /md/levels_gui)
// MD 2025-09-26 16:10 BST

/* Purpose
   Install stable, sanitised, smoothed, log-like visual taps that send to a
   dedicated address "/md/levels_gui" with unique reply IDs:
     GA=32001, GB=32002, GT=31001
   - Unique filter keys: \mdGuiTapA, \mdGuiTapB, \mdGuiTapT (won‚Äôt clash).
   - Re-applies 3√ó (0.0s, 0.5s, 1.0s) to survive late re-binds.
   - Pass-through audio: always return 'in'.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

+ LivePedalboardSystem {

    installGuiMeters {
        var rateHz, rateClamped, applyOnce, passIndex, passCount;
        var atk, rel, floorAmp, oscPath;
        var idA, idB, idT;

        rateHz      = 24;
        rateClamped = rateHz.asInteger.clip(1, 60);
        atk = 0.01; rel = 0.20; floorAmp = 1e-5;
        oscPath = "/md/levels_gui";
        idA = 32001; idB = 32002; idT = 31001;

        passIndex = 0; passCount = 3;

        applyOnce = {
            Server.default.bind({

                // ----- A -----
                Ndef(\chainA).filter(\mdGuiTapA, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idA);
                    in
                });

                // ----- B -----
                Ndef(\chainB).filter(\mdGuiTapB, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idB);
                    in
                });

                // ----- Test probe -----
                Ndef(\testmelody).filter(\mdGuiTapT, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);

                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), oscPath, [visL, visR], idT);
                    in
                });

            });
        };

        // Apply now, then again at 0.5s and 1.0s (survive late re-binds)
        AppClock.sched(0.00, { applyOnce.(); 0.50 });
        AppClock.sched(0.50, { applyOnce.(); 0.50 });
        AppClock.sched(1.00, { applyOnce.(); "[LPS] GUI taps active (/md/levels_gui).".postln; nil });

        this
    }

}

===== LivePedalboardSystem/LivePedalboardSystem-Taps_Stable.sc_OBSOLETE =====
// LivePedalboardSystem-Taps_Stable.sc
// v0.1.2 (sanitised + smoothed + boosted)
// MD 2025-09-26 15:58 BST

/* Purpose
   Install stable, visual-scale taps under unique keys, with NaN/Inf sanitised,
   light smoothing, and a more sensitive floor so meters are visibly responsive.
   - Unique keys: \mdVisTapA, \mdVisTapB, \mdVisTapT (won‚Äôt clash with re-installers).
   - Re-applies 3x (0.0s, 0.5s, 1.0s) to outlast late bindings.
   - Pass-through audio: always return 'in'.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync; no non-local '^'.
*/

+ LivePedalboardSystem {

    installStableMeters {
        var rateHz, rateClamped, applyOnce, passIndex, passCount;
        var atk, rel, floorAmp;

        rateHz     = 24;        // slightly faster UI feel
        rateClamped = rateHz.asInteger.clip(1, 60);
        passIndex  = 0; passCount = 3;

        // meter behaviour
        atk = 0.01;             // Amplitude attack
        rel = 0.20;             // Amplitude release
        floorAmp = 1e-5;        // more sensitive floor than 1e-6

        applyOnce = {
            Server.default.bind({

                // ----- CHAIN A -> replyID 2001 -----
                Ndef(\chainA).filter(\mdVisTapA, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    // Log-like visual map + light smoothing (no audio change)
                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    // Sanitize: replace any NaN/Inf with 0 (quietly)
                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 2001);
                    in
                });

                // ----- CHAIN B -> replyID 2002 -----
                Ndef(\chainB).filter(\mdVisTapB, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 2002);
                    in
                });

                // ----- TEST PROBE -> replyID 1001 -----
                Ndef(\testmelody).filter(\mdVisTapT, { arg in;
                    var sig, ampL, ampR, visL, visR;
                    sig  = in.isArray.if({ in }, { [in, in] });

                    ampL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
                    ampR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);

                    visL = LinExp.kr(ampL, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visR = LinExp.kr(ampR, floorAmp, 1.0, 0.0, 1.0).clip(0, 1);
                    visL = LagUD.kr(visL, 0.02, 0.12).clip(0, 1);
                    visR = LagUD.kr(visR, 0.02, 0.12).clip(0, 1);

                    visL = CheckBadValues.kr(visL, id: 0, post: 0);
                    visR = CheckBadValues.kr(visR, id: 0, post: 0);

                    SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [visL, visR], 1001);
                    in
                });

            });
        };

        // Apply now, then again at 0.5s and 1.0s to survive late re-binds
        AppClock.sched(0.00, { applyOnce.(); passIndex = passIndex + 1; 0.50 });
        AppClock.sched(0.50, { applyOnce.(); passIndex = passIndex + 1; 0.50 });
        AppClock.sched(1.00, { applyOnce.(); "[LPS] stable taps active (sanitised+smoothed).".postln; nil });

        this
    }

}

===== LivePedalboardSystem/LivePedalboardSystem-UsePerfHUD.sc_OBSOLETE =====
// LivePedalboardSystem-UsePerfHUD.sc
// v0.1.7
// MD 2025-09-26 15:38 BST

/* Purpose / Style
   PerfHUD v0.5.4 bring-up + robust meters (listener + stable taps).
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

+ LivePedalboardSystem {

    bringUpMagicDisplayGUI {
        var baseTroubleshooting, perfHudPath, perfExists, windowsList, pickedWindow;

        baseTroubleshooting = (Platform.userExtensionDir
            ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting").standardizePath;
        perfHudPath = (baseTroubleshooting
            ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd").standardizePath;
        perfExists = File.exists(perfHudPath);

        this.closeExistingMagicDisplayWindows;

        if(perfExists) { perfHudPath.load } { statusDisplay = MagicDisplayGUI_GridDemo.new };

        // sources/sinks
        Server.default.bind({
            if(Ndef(\testmelody).source.isNil) {
                Ndef(\testmelody, {
                    var trig, freq, env, pan, scale, indexSel;
                    trig = Impulse.kr(2.2);
                    scale = [60, 62, 64, 67, 69];
                    indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                    freq = Select.kr(indexSel, scale).midicps;
                    env = Decay2.kr(trig, 0.01, 0.40);
                    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
                });
            };
            Ndef(\testmelody).ar(2);
            if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
            Ndef(\chainA).ar(2);
            Ndef(\chainB).ar(2);
        });
        "[LPS] sources/sinks ensured.".postln;

        // /md/levels listener (HUD-side)
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;

        if(OSCdef.all.at(\md_levels_hud).notNil) { OSCdef.all.at(\md_levels_hud).free };
        OSCdef(\md_levels_hud, { arg msg;
            var replyId, leftVal, rightVal;
            if(msg.size >= 5) {
                replyId  = msg[2];
                leftVal  = msg[3].asFloat.clip(0, 1);
                rightVal = msg[4].asFloat.clip(0, 1);
                ~md_levelsById.put(replyId, [leftVal, rightVal]);
                ~md_lastMsgStamp = SystemClock.seconds.asFloat;
            };
            nil
        }, "/md/levels", recvPort: NetAddr.langPort);
        "[HUD] /md/levels listener installed (key=md_levels_hud)".postln;

        // Inline taps (visual scale)
        this.installStableMeters;
        "[LPS] inline taps armed (visual scale, A=2001, B=2002, T=1001).".postln;
//NEW
		this.installGuiMeters;  // installs isolated GUI taps -> /md/levels_gui

        // Front window & return
        windowsList = Window.allWindows;
        pickedWindow = windowsList.detect({ arg w;
            var titleString = w.tryPerform(\name);
            titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
        });
        if(pickedWindow.notNil) { pickedWindow.front };
        pickedWindow
    }
}

===== LivePedalboardSystem/LivePedalboardSystem.sc =====
// LivePedalboardSystem.sc
// v0.2.9
// MD 2025-10-02 1350
// Purpose: Bring-up MagicPedalboard + CommandManager + single MagicDisplayGUI (no duplicate windows).
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

/*
Supplementary header ‚Äî What this class does & key dependencies
----------------------------------------------------------------
Overview
- Orchestrates a complete bring-up sequence for the live pedalboard prototype:
  1) ensure server is up & tree is clean (when freshly booted),
  2) open a single MagicDisplay GUI window (avoid duplicates),
  3) construct & bind the MagicPedalboard,
  4) construct the CommandManager (tree-driven command layer),
  5) ensure audio is audible (safe test sources) and enable meters after initial rebuild.

Primary responsibilities
- Window hygiene (one GUI only), predictable boot order, defensive binding between GUI ‚Üî pedalboard ‚Üî command system,
  and conservative ‚ÄúensureAudioOn‚Äù to guarantee an audible current chain.

Relies on (classes / files assumed present on the classpath)
- MagicPedalboardNew (core pedalboard implementation).
- Command tree stack: CommandManager, MDCommandTree, MDCommandBuilder, MDCommandQueue, MIDIInputManager.
- MagicDisplay / MagicDisplayGUI_GridDemo (status & meters), and MagicDisplay.ensureMeterDefs.
- MDMiniLogger (logging).
- SuperCollider primitives used here: Window, AppClock, Server, Ndef, Platform.userExtensionDir.

External data
- JSON command tree at:
  Platform.userExtensionDir ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json"

Notes
- Methods added in this version: class-side *help, *api, *test (non-invasive; do not change runtime behavior).
- This file intentionally avoids server.sync. s.waitForBoot is used only inside ensureServerReady() on first boot.
*/

LivePedalboardSystem : Object {
    var <>pedalboard;
    var <>pedalboardGUI;
    var <>commandManager;
    var <>statusDisplay; // this will hold a MagicDisplayGUI
    var <>logger;
    var <>treeFilePath;
/*  *new { arg treePath;
        ^super.new.init(treePath);
    } */
     *new { arg treePath;
        var resolvedPath;
        resolvedPath = LivePedalboardSystem.resolveTreePath(treePath);
        ^super.new.init(resolvedPath);
    }
    init { arg treePath;
        var defaultPath;
        logger = MDMiniLogger.get;
        // Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
        defaultPath = Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
        treeFilePath = treePath.ifNil { defaultPath };
        ^this;
    }
    bringUpAll {
        // ‚úÖ Make sure the server is up and the tree is clean *before* we create MPB
        this.ensureServerReady;
        this.bringUpMagicDisplayGUI; // 1) GUI first
        this.bringUpPedalboard; // 2) create MPB (it will create groups)
        this.bringUpCommandSystem; // 3) hook command system
        this.ensureAudioOn; // 4) prime sources + play current (no tree reset here)
        // meters last (you already moved this)
/*      if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
            statusDisplay.enableMeters(true);
        };*/
        //v0.2.8
        AppClock.sched(0.35, { // 350 ms is enough to outlive the initial MPB rebuild
            if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
                statusDisplay.enableMeters(true);
            };
            nil
        });
        logger.info("LivePedalboardSystem", "‚úÖ System is ready.");
        ^this;
    }
/*  bringUpPedalboard {
        pedalboard = MagicPedalboard.new;
        pedalboardGUI = MagicPedalboardTestRunner.new(pedalboard, nil);
        pedalboardGUI.bringUp;
        logger.info("Pedalboard", "Pedalboard and GUI initialized.");
    }*/
/*  bringUpPedalboard {
        // new pedalboard bound to display (if ctor supports it)
        pedalboard = if (statusDisplay.notNil) {
            MagicPedalboardNew.new(statusDisplay)
        } {
            MagicPedalboardNew.new
        };
        // be defensive: wire after construction too, if there is a setter
        if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
            pedalboard.setDisplay(statusDisplay);
        };
        // remove runner usage; it's not needed for the new GUI path
        pedalboardGUI = nil;
        logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
    }*/
    bringUpPedalboard {
        // new pedalboard bound to display (if ctor supports it)
        pedalboard = if (statusDisplay.notNil) {
            MagicPedalboardNew.new(statusDisplay)
        } {
            MagicPedalboardNew.new
        };
        // be defensive: wire after construction too, if there is a setter
        if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
            pedalboard.setDisplay(statusDisplay);
        };
        // remove runner usage; it's not needed for the new GUI path
        pedalboardGUI = nil;
        logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
    }
/*  bringUpCommandSystem {
        commandManager = CommandManager.new(treeFilePath);
        // inject GUI so updateDisplay() can actually update something
        commandManager.display = statusDisplay;
        // Queue export -> pedalboard
        commandManager.queueExportCallback = { |oscPath|
            pedalboard.handleCommand(oscPath);
            logger.info("Integration", "Sent command to pedalboard: " ++ oscPath);
            // If GUI is up, show last command
            if (statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
                statusDisplay.showExpectation("Sent: " ++ oscPath, 0);
            };
        };
        logger.info("CommandSystem", "CommandManager initialized and connected.");
    }*/
    //newer:
     bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;
        // temporary callback: log only; the bridge will overwrite this
        cm.queueExportCallback = { |path|
            MDMiniLogger.get.info("Integration", "Queued path: " ++ path.asString);
        };
        commandManager = cm;
        MDMiniLogger.get.info("CommandSystem", "CommandManager initialized (bridge pending).");
        ^this
    }
    // --- Single MagicDisplayGUI window, with meters enabled ---
    bringUpMagicDisplayGUI {
        // close any previous MagicDisplayGUI windows to avoid duplicates
        this.closeExistingMagicDisplayWindows;
        statusDisplay = MagicDisplayGUI_GridDemo.new; // existing line
        statusDisplay.showExpectation("System ready.", 0);
        // share GUI with CommandManager so CommandManager:setStatus can target it
        if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };
        this.ensureMeterDefs;
        // meters are enabled later in bringUpAll to avoid node races
    }
    // --- Provide \busMeterA / \busMeterB if they don't exist yet ---
    // replaced with the below, which uses MagicDisplay meters instead:
    ensureMeterDefs {
        MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
    }
    // --- Conservative "make sure something is audible" ---
/*  ensureAudioOn {
        var started;
        started = false;
        if (pedalboard.respondsTo(\start)) { pedalboard.start; started = true; }
        { if (pedalboard.respondsTo(\play)) { pedalboard.play; started = true; } };
        if (started.not) {
            this.tryPlayNdefs([\chainA, \chainB, \testmelody]);
        };
        logger.info("Audio", "ensureAudioOn called (started: %).".format(started));
    }*/
    ensureAudioOn {
        var s;
        s = Server.default;
        // Define sources/sinks idempotently
        Server.default.bind({
            if (Ndef(\testmelody).source.isNil) {
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f = Demand.kr(trig, 0, seq);
                    var env = Decay2.kr(trig, 0.01, 0.35);
                    var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                    Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
                });
            };
            Ndef(\testmelody).ar(2);
            if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
            // Ensure sink proxies exist at audio rate; MPB wires them
            Ndef(\chainA).ar(2);
            Ndef(\chainB).ar(2);
        });
        // Route CURRENT to \testmelody + Option A
        if (pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(\testmelody);
        };
        if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
        };
        // Make sure CURRENT sink is actually playing; stop the other
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
            });
        };
        // --- Make sure CURRENT sink is actually playing (single deferred assert) ---
        AppClock.sched(0.25, { // allow the temp SynthDef add to complete
            if (pedalboard.respondsTo(\playCurrent)) {
                pedalboard.playCurrent; // MPB decides which (A/B) should be audible
            } {
                Server.default.bind({
                    if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                    if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                });
            };
            nil
        });
        if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
        logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
    }
    ensureServerReady {
        var s, didBoot;
        s = Server.default;
        didBoot = false;
        if (s.serverRunning.not) {
            s.boot;
            s.waitForBoot; // permitted in your safe-reset pattern
            didBoot = true;
        };
        if (didBoot) {
            // Only wipe the tree on fresh boot, before MPB is constructed
            Server.default.bind({
                s.initTree;
                s.defaultGroup.freeAll;
            });
        };
        ^didBoot
    }
    tryPlayNdefs { arg syms;
        syms.do { arg sym;
            var nd = Ndef(sym);
            if (nd.notNil) { nd.play; };
        };
    }
    showStatus {
        logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
            pedalboard, commandManager
        ));
    }
/*  shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/
    closeExistingMagicDisplayWindows {
        var wins;
        wins = Window.allWindows.select({ |w|
            var nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        AppClock.sched(0.0, {
            wins.do({ |w| w.close });
            nil
        });
        ^this
    }
    shutdownAll {
        var runnerClosed;
        runnerClosed = false;
        if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
            pedalboard.free;
        };
        if (pedalboardGUI.notNil) {
            if (pedalboardGUI.respondsTo(\close)) {
                pedalboardGUI.close; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
                pedalboardGUI.stop; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
                pedalboardGUI.free; runnerClosed = true;
            };
        };
        if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
            statusDisplay.close;
        };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }

    // --- Added in v0.2.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
LivePedalboardSystem.help  ‚Äî  quick guide

Bring-up (headless UI + one LPDisplay/MagicDisplay window)
----------------------------------------------------------
(
var lps;
lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;           // ensure server, open GUI, build pedalboard & command system, enable meters
)

Key instance methods
- bringUpAll(), bringUpPedalboard(), bringUpCommandSystem(), bringUpMagicDisplayGUI()
- ensureMeterDefs(), ensureAudioOn(), ensureServerReady()
- tryPlayNdefs(symbolArray), showStatus(), shutdownAll()

Notes
- Expects the command-tree JSON at:
  Platform.userExtensionDir ++ \"/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json\"
- Avoids duplicate GUI windows and avoids server.sync (uses Server.default.bind & AppClock).
";
        text.postln;
        ^text
    }

    *api {
        var api;
        api = IdentityDictionary[
            \ctor      -> "LivePedalboardSystem.new(treePathOrNil)  // resolves JSON path if nil",
            \bringUp   -> "bringUpAll()  // full bring-up in safe order",
            \gui       -> "bringUpMagicDisplayGUI(), closeExistingMagicDisplayWindows()",
            \pedalboard-> "bringUpPedalboard(), shutdownAll()",
            \command   -> "bringUpCommandSystem()",
            \audio     -> "ensureAudioOn(), ensureMeterDefs(), ensureServerReady(), tryPlayNdefs([...])",
            \status    -> "showStatus()",
            \jsonPath  -> "init(treePath) stores -> this.treeFilePath"
        ];
        api.postln;
        ^api
    }

    *test {
        var lps;
        lps = LivePedalboardSystem.new(nil);
        lps.bringUpAll;
        ^lps
    }
}
===== LivePedalboardSystem/LivePedalboardSystem.sc_0.2.8.txt =====
// LivePedalboardSystem.sc
// v0.2.8
// MD 2025-09-22 1204

// Purpose: Bring-up MagicPedalboard + CommandManager + single MagicDisplayGUI (no duplicate windows).
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

LivePedalboardSystem : Object {
	var <>pedalboard;
	var <>pedalboardGUI;
	var <>commandManager;
	var <>statusDisplay;   // this will hold a MagicDisplayGUI
	var <>logger;
	var <>treeFilePath;

/*	*new { arg treePath;
		^super.new.init(treePath);
	}*/


	    *new { arg treePath;
        var resolvedPath;
        resolvedPath = LivePedalboardSystem.resolveTreePath(treePath);
        ^super.new.init(resolvedPath);
    }

	init { arg treePath;
		var defaultPath;
		logger = MDMiniLogger.get;

		// Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		treeFilePath = treePath.ifNil { defaultPath };
		^this;
	}


	bringUpAll {
		// ‚úÖ Make sure the server is up and the tree is clean *before* we create MPB
		this.ensureServerReady;

		this.bringUpMagicDisplayGUI;   // 1) GUI first
		this.bringUpPedalboard;        // 2) create MPB (it will create groups)
		this.bringUpCommandSystem;     // 3) hook command system
		this.ensureAudioOn;            // 4) prime sources + play current (no tree reset here)


		// meters last (you already moved this)
/*    if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
        statusDisplay.enableMeters(true);
    };*/

		//v0.2.8
		AppClock.sched(0.35, {    // 350 ms is enough to outlive the initial MPB rebuild
			if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
				statusDisplay.enableMeters(true);
			};
			nil
		});

		logger.info("LivePedalboardSystem", "‚úÖ System is ready.");
		^this;
	}


/*	bringUpPedalboard {
		pedalboard = MagicPedalboard.new;
		pedalboardGUI = MagicPedalboardTestRunner.new(pedalboard, nil);
		pedalboardGUI.bringUp;
		logger.info("Pedalboard", "Pedalboard and GUI initialized.");
	}*/

/*	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}*/

	bringUpPedalboard {
		// new pedalboard bound to display (if ctor supports it)
		pedalboard = if (statusDisplay.notNil) {
			MagicPedalboardNew.new(statusDisplay)
		} {
			MagicPedalboardNew.new
		};

		// be defensive: wire after construction too, if there is a setter
		if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
			pedalboard.setDisplay(statusDisplay);
		};

		// remove runner usage; it's not needed for the new GUI path
		pedalboardGUI = nil;

		logger.info("Pedalboard", "MagicPedalboardNew initialized and bound to display.");
	}

/*	bringUpCommandSystem {
		commandManager = CommandManager.new(treeFilePath);


		// inject GUI so updateDisplay() can actually update something
		commandManager.display = statusDisplay;

		// Queue export -> pedalboard
		commandManager.queueExportCallback = { |oscPath|
			pedalboard.handleCommand(oscPath);
			logger.info("Integration", "Sent command to pedalboard: " ++ oscPath);
			// If GUI is up, show last command
			if (statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
				statusDisplay.showExpectation("Sent: " ++ oscPath, 0);
			};
		};

		logger.info("CommandSystem", "CommandManager initialized and connected.");
	}*/

	//newer:
	    bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;
        // temporary callback: log only; the bridge will overwrite this
        cm.queueExportCallback = { |path|
            MDMiniLogger.get.info("Integration", "Queued path: " ++ path.asString);
        };
        commandManager = cm;
        MDMiniLogger.get.info("CommandSystem", "CommandManager initialized (bridge pending).");
        ^this
    }

	// --- Single MagicDisplayGUI window, with meters enabled ---


	bringUpMagicDisplayGUI {
		// close any previous MagicDisplayGUI windows to avoid duplicates
		this.closeExistingMagicDisplayWindows;

		statusDisplay = MagicDisplayGUI_GridDemo.new; // existing line
		statusDisplay.showExpectation("System ready.", 0);

		// share GUI with CommandManager so CommandManager:setStatus can target it
		if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };

		this.ensureMeterDefs;
		// meters are enabled later in bringUpAll to avoid node races
	}



	// --- Provide \busMeterA / \busMeterB if they don't exist yet ---
	// replaced with the below, which uses MagicDisplay meters instead:
	ensureMeterDefs {
		MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
	}

	// --- Conservative "make sure something is audible" ---
/*	ensureAudioOn {
		var started;
		started = false;

		if (pedalboard.respondsTo(\start)) { pedalboard.start; started = true; }
		{ if (pedalboard.respondsTo(\play)) { pedalboard.play; started = true; } };

		if (started.not) {
			this.tryPlayNdefs([\chainA, \chainB, \testmelody]);
		};

		logger.info("Audio", "ensureAudioOn called (started: %).".format(started));
	}*/


	ensureAudioOn {
		var s;
		s = Server.default;

		// Define sources/sinks idempotently
		Server.default.bind({
			if (Ndef(\testmelody).source.isNil) {
				Ndef(\testmelody, {
					var trig = Impulse.kr(3.2);
					var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
					var f = Demand.kr(trig, 0, seq);
					var env = Decay2.kr(trig, 0.01, 0.35);
					var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
					Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
				});
			};
			Ndef(\testmelody).ar(2);

			if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
			Ndef(\ts0).ar(2);

			// Ensure sink proxies exist at audio rate; MPB wires them
			Ndef(\chainA).ar(2);
			Ndef(\chainB).ar(2);
		});

		// Route CURRENT to \testmelody + Option A
		if (pedalboard.respondsTo(\setSourceCurrent)) {
			pedalboard.setSourceCurrent(\testmelody);
		};
		if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
			pedalboard.enforceExclusiveCurrentOptionA(0.1);
		};

		// Make sure CURRENT sink is actually playing; stop the other
		if (pedalboard.respondsTo(\playCurrent)) {
			pedalboard.playCurrent;
		} {
			Server.default.bind({
				if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
				if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
			});
		};

		// One tiny deferred re-assert (survives any late rebuild)
/*		AppClock.sched(0.10, {
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
            });
        };
        nil*/


		// --- Make sure CURRENT sink is actually playing (single deferred assert) ---
		AppClock.sched(0.25, {     // allow the temp SynthDef add to complete
			if (pedalboard.respondsTo(\playCurrent)) {
				pedalboard.playCurrent;  // MPB decides which (A/B) should be audible
			} {
				Server.default.bind({
					if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
					if (Ndef(\chainB).isPlaying)     { Ndef(\chainB).stop };
				});
			};
			nil
		});



		if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
		logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
	}


	ensureServerReady {
		var s, didBoot;

		s = Server.default;
		didBoot = false;

		if (s.serverRunning.not) {
			s.boot;
			s.waitForBoot;   // permitted in your safe-reset pattern
			didBoot = true;
		};

		if (didBoot) {
			// Only wipe the tree on fresh boot, before MPB is constructed
			Server.default.bind({
				s.initTree;
				s.defaultGroup.freeAll;
			});
		};

		^didBoot
	}


	tryPlayNdefs { arg syms;
		syms.do { arg sym;
			var nd = Ndef(sym);
			if (nd.notNil) { nd.play; };
		};
	}

	showStatus {
		logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
			pedalboard, commandManager
		));
	}

/*    shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/


	closeExistingMagicDisplayWindows {
		var wins;
		wins = Window.allWindows.select({ |w|
			var nm = w.tryPerform(\name);
			nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
		});
		AppClock.sched(0.0, {
			wins.do({ |w| w.close });
			nil
		});
		^this
	}



	shutdownAll {
		var runnerClosed;

		runnerClosed = false;

		if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
			pedalboard.free;
		};

		if (pedalboardGUI.notNil) {
			if (pedalboardGUI.respondsTo(\close)) {
				pedalboardGUI.close; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
				pedalboardGUI.stop; runnerClosed = true;
			};
			if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
				pedalboardGUI.free; runnerClosed = true;
			};
		};

		if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
			statusDisplay.close;
		};

		logger.warn("Shutdown", "LivePedalboardSystem shut down.");
	}
}

===== LivePedalboardSystem/LPS_CommandQueueToMPB_Adapter.sc_disabled =====
// LPS_CommandQueueToMPB_Adapter.sc
// v0.1.3
// MD 2025-09-22 23:08 BST

/* Purpose
   - Canonicalize CommandManager's exported path to short verb/object grammar
     for MagicPedalboardNew today.
   Examples:
     "/chain/add/audio/timebased/delay"    -> "/add/delay"
     "/chain/setsource/audio/source/sine"  -> "/setSource/sine"
     "/switch" or "/switch/crossfade*"     -> "/switch"
   Style
   - var-first; lowercase; no server.sync; flat control flow (no nested ^).
*/

+ LivePedalboardSystem {

    canonicalizeCommandPath { |rawPath|
        var parts, first;

        // Tokenize into non-empty segments
        parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
        if(parts.size == 0) { ^rawPath.asString };

        first = parts[0].asString;

        // 1) switch family ‚Üí "/switch"
        if(first == "switch") {
            ^"/switch";
        };

        // 2) chain/* positional mappings
        if(first == "chain") {
            // Guard against short arrays
            if(parts.size >= 3) {
                var second = parts[1].asString;

                // 2a) /chain/add/audio/.../<effect> -> /add/<effect>
                if(second == "add" and: { parts[2].asString == "audio" }) {
                    ^("/add/" ++ parts.last.asString);
                };

                // 2b) /chain/setsource/audio/source/<src> -> /setSource/<src>
                if(second == "setsource"
                   and: { parts.size >= 5 }
                   and: { parts[2].asString == "audio" }
                   and: { parts[3].asString == "source" }) {
                    ^("/setSource/" ++ parts.last.asString);
                };

                // (Extend here for remove/clear/bypass/swap later)
            };

            // If we get here and didn't match any chain rule, fall through to raw.
            ^rawPath.asString;
        };

        // 3) Already-canonical short forms ‚Äî pass through
        if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
            ^("/" ++ parts.join("/"));
        };

        // 4) Fallback: return unchanged
        ^rawPath.asString;
    }

    bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;

        cm.queueExportCallback = { |oscPath|
            var canon;
            canon = this.canonicalizeCommandPath(oscPath);
            pedalboard.handleCommand(canon);
            logger.info("Integration", "Sent command to pedalboard: " ++ canon);
            if(statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
                statusDisplay.showExpectation("Sent: " ++ canon, 0);
            };
        };

        commandManager = cm;
        logger.info("CommandSystem", "CommandManager initialized and connected.");
    }
}

===== LivePedalboardSystem/MagicPedalboardCommandTree_older.json =====
{
  "id": 0,
  "name": "root",
  "fret": 1,
  "payload": "root",
  "children": [
    {
      "id": 1,
      "name": "audio",
      "fret": 3,
      "payload": "audio",
      "children": [
        {
          "id": 2,
          "name": "source",
          "fret": 5,
          "payload": "audio/source",
          "children": [
            {
              "id": 3,
              "name": "testmelody",
              "fret": 7,
              "payload": "audio/source/testmelody",
              "children": []
            },
            {
              "id": 4,
              "name": "sine",
              "fret": 7,
              "payload": "audio/source/sine",
              "children": []
            },
            {
              "id": 5,
              "name": "noise",
              "fret": 7,
              "payload": "audio/source/noise",
              "children": []
            }
          ]
        },
        {
          "id": 6,
          "name": "timebased",
          "fret": 5,
          "payload": "audio/timebased",
          "children": [
            {
              "id": 7,
              "name": "delay",
              "fret": 7,
              "payload": "audio/timebased/delay",
              "children": [
                {
                  "id": 8,
                  "name": "multitap",
                  "fret": 9,
                  "payload": "audio/timebased/delay/multitap",
                  "children": []
                },
                {
                  "id": 9,
                  "name": "pingpong",
                  "fret": 9,
                  "payload": "audio/timebased/delay/pingpong",
                  "children": []
                }
              ]
            },
            {
              "id": 10,
              "name": "chorus",
              "fret": 7,
              "payload": "audio/timebased/chorus",
              "children": []
            }
          ]
        },
        {
          "id": 11,
          "name": "modulation",
          "fret": 5,
          "payload": "audio/modulation",
          "children": [
            {
              "id": 12,
              "name": "tremolo",
              "fret": 7,
              "payload": "audio/modulation/tremolo",
              "children": []
            },
            {
              "id": 13,
              "name": "phaser",
              "fret": 7,
              "payload": "audio/modulation/phaser",
              "children": []
            },
            {
              "id": 14,
              "name": "flanger",
              "fret": 7,
              "payload": "audio/modulation/flanger",
              "children": []
            }
          ]
        },
        {
          "id": 15,
          "name": "filter",
          "fret": 5,
          "payload": "audio/filter",
          "children": [
            {
              "id": 16,
              "name": "lowpass",
              "fret": 7,
              "payload": "audio/filter/lowpass",
              "children": []
            },
            {
              "id": 17,
              "name": "highpass",
              "fret": 7,
              "payload": "audio/filter/highpass",
              "children": []
            },
            {
              "id": 18,
              "name": "bandpass",
              "fret": 7,
              "payload": "audio/filter/bandpass",
              "children": []
            }
          ]
        },
        {
          "id": 19,
          "name": "reverb",
          "fret": 5,
          "payload": "audio/reverb",
          "children": []
        },
        {
          "id": 20,
          "name": "drive",
          "fret": 5,
          "payload": "audio/drive",
          "children": []
        }
      ]
    },
    {
      "id": 21,
      "name": "chain",
      "fret": 3,
      "payload": "chain",
      "children": [
        {
          "id": 22,
          "name": "add",
          "fret": 5,
          "payload": "chain/add",
          "children": []
        },
        {
          "id": 23,
          "name": "remove",
          "fret": 5,
          "payload": "chain/remove",
          "children": []
        },
        {
          "id": 24,
          "name": "swap",
          "fret": 5,
          "payload": "chain/swap",
          "children": []
        },
        {
          "id": 25,
          "name": "bypass",
          "fret": 5,
          "payload": "chain/bypass",
          "children": []
        },
        {
          "id": 26,
          "name": "clear",
          "fret": 5,
          "payload": "chain/clear",
          "children": []
        },
        {
          "id": 27,
          "name": "setsource",
          "fret": 5,
          "payload": "chain/setsource",
          "children": []
        },
        {
          "id": 28,
          "name": "print",
          "fret": 5,
          "payload": "chain/print",
          "children": []
        }
      ]
    },
    {
      "id": 29,
      "name": "switch",
      "fret": 3,
      "payload": "switch",
      "children": [
        {
          "id": 30,
          "name": "crossfade",
          "fret": 5,
          "payload": "switch/crossfade",
          "children": []
        },
        {
          "id": 31,
          "name": "crossfade_custom",
          "fret": 5,
          "payload": "switch/crossfade_custom",
          "children": []
        }
      ]
    },
    {
      "id": 32,
      "name": "preset",
      "fret": 3,
      "payload": "preset",
      "children": [
        {
          "id": 33,
          "name": "save",
          "fret": 5,
          "payload": "preset/save",
          "children": []
        },
        {
          "id": 34,
          "name": "load",
          "fret": 5,
          "payload": "preset/load",
          "children": []
        }
      ]
    },
    {
      "id": 35,
      "name": "system",
      "fret": 3,
      "payload": "system",
      "children": [
        {
          "id": 36,
          "name": "reset",
          "fret": 5,
          "payload": "system/reset",
          "children": []
        },
        {
          "id": 37,
          "name": "healthcheck",
          "fret": 5,
          "payload": "system/healthcheck",
          "children": []
        },
        {
          "id": 38,
          "name": "status",
          "fret": 5,
          "payload": "system/status",
          "children": []
        }
      ]
    }
  ]
}
===== LivePedalboardSystem/MagicPedalboardCommandTree.json =====
{ "children": [ { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 3, "name": "testmelody" }, { "children": [  ], "fret": 5, "id": 4, "name": "sine" }, { "children": [  ], "fret": 7, "id": 5, "name": "noise" } ], "fret": 3, "id": 2, "name": "source" }, { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 8, "name": "multitap" }, { "children": [  ], "fret": 5, "id": 9, "name": "pingpong" } ], "fret": 3, "id": 7, "name": "delay" }, { "children": [  ], "fret": 5, "id": 10, "name": "chorus" } ], "fret": 5, "id": 6, "name": "timebased" }, { "children": [ { "children": [  ], "fret": 3, "id": 12, "name": "tremolo" }, { "children": [  ], "fret": 5, "id": 13, "name": "phaser" }, { "children": [  ], "fret": 7, "id": 14, "name": "flanger" } ], "fret": 7, "id": 11, "name": "modulation" }, { "children": [ { "children": [  ], "fret": 3, "id": 16, "name": "lowpass" }, { "children": [  ], "fret": 5, "id": 17, "name": "highpass" }, { "children": [  ], "fret": 7, "id": 18, "name": "bandpass" } ], "fret": 9, "id": 15, "name": "filter" }, { "children": [  ], "fret": 11, "id": 19, "name": "reverb" }, { "children": [  ], "fret": 13, "id": 20, "name": "drive" } ], "fret": 1, "id": 1, "name": "audio" }, { "children": [ { "children": [  ], "fret": 3, "id": 22, "name": "add" }, { "children": [  ], "fret": 5, "id": 23, "name": "remove" }, { "children": [  ], "fret": 7, "id": 24, "name": "swap" }, { "children": [  ], "fret": 9, "id": 25, "name": "bypass" }, { "children": [  ], "fret": 11, "id": 26, "name": "clear" }, { "children": [  ], "fret": 13, "id": 27, "name": "setsource" }, { "children": [  ], "fret": 15, "id": 28, "name": "print" } ], "fret": 3, "id": 21, "name": "chain" }, { "children": [ { "children": [  ], "fret": 3, "id": 30, "name": "crossfade" }, { "children": [  ], "fret": 5, "id": 31, "name": "crossfade_custom" } ], "fret": 5, "id": 29, "name": "switch" }, { "children": [ { "children": [  ], "fret": 3, "id": 33, "name": "save" }, { "children": [  ], "fret": 5, "id": 34, "name": "load" } ], "fret": 7, "id": 32, "name": "preset" }, { "children": [ { "children": [  ], "fret": 3, "id": 36, "name": "reset" }, { "children": [  ], "fret": 5, "id": 37, "name": "healthcheck" }, { "children": [  ], "fret": 7, "id": 38, "name": "status" } ], "fret": 9, "id": 35, "name": "system" }, { "children": [ { "children": [ { "children": [  ], "fret": 1, "id": 41, "name": "delay" } ], "fret": 1, "id": 40, "name": "add" }, { "children": [ { "children": [ { "children": [  ], "fret": 2, "id": 44, "name": "on" }, { "children": [  ], "fret": 3, "id": 45, "name": "off" } ], "fret": 1, "id": 43, "name": "delay" } ], "fret": 2, "id": 42, "name": "bypass" }, { "children": [  ], "fret": 3, "id": 46, "name": "switch" }, { "children": [ { "children": [  ], "fret": 1, "id": 48, "name": "testmelody" } ], "fret": 4, "id": 47, "name": "setSource" } ], "fret": 10, "id": 39, "name": "commands" } ], "fret": 1, "id": 0, "name": "root" }
===== LivePedalboardSystem/MagicPedalboardCommandTree.json.tmp =====
{ "children": [ { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 3, "name": "testmelody" }, { "children": [  ], "fret": 5, "id": 4, "name": "sine" }, { "children": [  ], "fret": 7, "id": 5, "name": "noise" } ], "fret": 3, "id": 2, "name": "source" }, { "children": [ { "children": [ { "children": [  ], "fret": 3, "id": 8, "name": "multitap" }, { "children": [  ], "fret": 5, "id": 9, "name": "pingpong" } ], "fret": 3, "id": 7, "name": "delay" }, { "children": [  ], "fret": 5, "id": 10, "name": "chorus" } ], "fret": 5, "id": 6, "name": "timebased" }, { "children": [ { "children": [  ], "fret": 3, "id": 12, "name": "tremolo" }, { "children": [  ], "fret": 5, "id": 13, "name": "phaser" }, { "children": [  ], "fret": 7, "id": 14, "name": "flanger" } ], "fret": 7, "id": 11, "name": "modulation" }, { "children": [ { "children": [  ], "fret": 3, "id": 16, "name": "lowpass" }, { "children": [  ], "fret": 5, "id": 17, "name": "highpass" }, { "children": [  ], "fret": 7, "id": 18, "name": "bandpass" } ], "fret": 9, "id": 15, "name": "filter" }, { "children": [  ], "fret": 11, "id": 19, "name": "reverb" }, { "children": [  ], "fret": 13, "id": 20, "name": "drive" } ], "fret": 1, "id": 1, "name": "audio" }, { "children": [ { "children": [  ], "fret": 3, "id": 22, "name": "add" }, { "children": [  ], "fret": 5, "id": 23, "name": "remove" }, { "children": [  ], "fret": 7, "id": 24, "name": "swap" }, { "children": [  ], "fret": 9, "id": 25, "name": "bypass" }, { "children": [  ], "fret": 11, "id": 26, "name": "clear" }, { "children": [  ], "fret": 13, "id": 27, "name": "setsource" }, { "children": [  ], "fret": 15, "id": 28, "name": "print" } ], "fret": 3, "id": 21, "name": "chain" }, { "children": [ { "children": [  ], "fret": 3, "id": 30, "name": "crossfade" }, { "children": [  ], "fret": 5, "id": 31, "name": "crossfade_custom" } ], "fret": 5, "id": 29, "name": "switch" }, { "children": [ { "children": [  ], "fret": 3, "id": 33, "name": "save" }, { "children": [  ], "fret": 5, "id": 34, "name": "load" } ], "fret": 7, "id": 32, "name": "preset" }, { "children": [ { "children": [  ], "fret": 3, "id": 36, "name": "reset" }, { "children": [  ], "fret": 5, "id": 37, "name": "healthcheck" }, { "children": [  ], "fret": 7, "id": 38, "name": "status" } ], "fret": 9, "id": 35, "name": "system" }, { "children": [ { "children": [ { "children": [  ], "fret": 1, "id": 41, "name": "delay" } ], "fret": 1, "id": 40, "name": "add" }, { "children": [ { "children": [ { "children": [  ], "fret": 2, "id": 44, "name": "on" }, { "children": [  ], "fret": 3, "id": 45, "name": "off" } ], "fret": 1, "id": 43, "name": "delay" } ], "fret": 2, "id": 42, "name": "bypass" }, { "children": [  ], "fret": 3, "id": 46, "name": "switch" }, { "children": [ { "children": [  ], "fret": 1, "id": 48, "name": "testmelody" } ], "fret": 4, "id": 47, "name": "setSource" } ], "fret": 10, "id": 39, "name": "commands" } ], "fret": 1, "id": 0, "name": "root" }
===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue‚Üíadapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ‚Üê ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil ‚Üí class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;



	    ~system.installAdapterBridge;         // ‚Üê MUST be before enableAutoMeters


	    // *** NEW: inline meter taps + post-switch auto-reinstall + GUI re-arm
    ~system.enableAutoMeters(18, 0.35);
    }.defer;
)


===== LivePedalboardSystem/Tests/Demo_Today_Playbook_FallbackOnly.scd =====
// Demo_Today_Playbook_FallbackOnly.scd
// v0.1.3
// MD 2025-09-22 23:45 BST

/* Purpose
   - Hardware-independent fallback to demonstrate MagicPedalboardNew.
   - Applies canonical commands in sequence, EVEN IF hardware is connected.
   - If your adapter (~ct_applyOSCPathToMPB) is present, it is used; otherwise
     this script calls MagicPedalboardNew methods directly for /add, /setSource,
/switch, /bypass commands.
   - Uses generated audio only (no SoundIn) and enforces Option A exclusivity.

   Style
   - tilde vars ok at top level; var-first in every function/closure.
   - lowercase method names; no server.sync; Server.default.bind for Ndef ops.
   - AppClock-only UI updates; no caret returns in deferred closures.
*/

(

var gapSeconds, playlistA, playlistB,
    systemReady, pedalboardReady,
    logMessage, showGuiHint,
    ensureGeneratedSources,
    tryEnsureAdapter, adapterAvailable, applyViaAdapter,
    applyDirectToPedalboard, applyOneCommand,
    runPlaylist, stopPlaylist, startGeneration;

"[FALLBACK] entered".postln;
thisProcess.nowExecutingPath.postln;  // helps confirm you ran the right file

// ‚îÄ‚îÄ settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gapSeconds = 0.60;
playlistA  = [ "/add/delay", "/switch" ];
playlistB  = [ "/bypass/delay/on", "/bypass/delay/off", "/switch" ];

// ‚îÄ‚îÄ guards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
systemReady     = ~system.notNil;
pedalboardReady = systemReady and: { ~system.pedalboard.notNil };


if(systemReady.not) {
    "‚ö†Ô∏è  Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B)".warn;
    ^nil;
};

// ‚îÄ‚îÄ logging + GUI hint ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logMessage = { |text| ("[FALLBACK] " ++ text).postln };
showGuiHint = { |text|
    var canShow;
    canShow = (~system.notNil)
        and: { ~system.statusDisplay.notNil }
        and: { ~system.statusDisplay.respondsTo(\showExpectation) };
    if(canShow) { ~system.statusDisplay.showExpectation(text, 0) };
};

// ‚îÄ‚îÄ audio sources + option A exclusivity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ensureGeneratedSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
/*            Ndef(\testmelody, {
                var trig, frequencySeq, freq, env, pan;
                trig         = Impulse.kr(3.2);
                frequencySeq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq         = Demand.kr(trig, 0, frequencySeq);
                env          = Decay2.kr(trig, 0.01, 0.35);
                pan          = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });*/

			Ndef(\testmelody, {
    var trig, freq, env, pan, scale, idx;
    trig = Impulse.kr(2.2); // relaxed tempo
    scale = [60, 62, 64, 67, 69]; // C major pentatonic
    idx = Demand.kr(trig, 0, Dwhite(0, scale.size, inf)); // returns control-rate index
    freq = Select.kr(idx, scale).midicps; // safe indexing
    env = Decay2.kr(trig, 0.01, 0.4);
    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
});

        };
        Ndef(\testmelody).ar(2);

        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    if(~mpb.notNil) {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.setSource(\testmelody);
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
    };
};

// ‚îÄ‚îÄ try to use your adapter (~ct_applyOSCPathToMPB) if available ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tryEnsureAdapter = {
    var scriptFolderPath, candidateNames, found;
    if(~ct_applyOSCPathToMPB.notNil) { ^true };

    scriptFolderPath = PathName(thisProcess.nowExecutingPath).pathOnly;
    candidateNames = [
        "adapter_CommandTree_to_MagicPedalboard.scd",
        "adapter_commandtree_to_magicpedalboard.scd"
    ];
    found = candidateNames.detect({ |leaf|
        var fullPath = scriptFolderPath +/+ leaf;
        File.exists(fullPath).if({ fullPath.load; true }, { false })
    });

    (~ct_applyOSCPathToMPB.notNil)
};
adapterAvailable = tryEnsureAdapter.();

applyViaAdapter = { |canonicalPath|
    var guiRef;
    guiRef = ~system.statusDisplay;
    // signature from your existing adapter: (path, mpb, gui)
    ~ct_applyOSCPathToMPB.(canonicalPath, ~system.pedalboard, guiRef);
};

// ‚îÄ‚îÄ direct mapping for the demo verbs if adapter is absent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyDirectToPedalboard = { |canonicalPath|
    var pathSegments, verbName, effectSymbol, sourceSymbol,
        onOffString, bypassState, pedalboardRef;

    pedalboardRef = ~system.pedalboard;
    if(pedalboardRef.isNil) { logMessage.("pedalboard missing"); ^nil };

    pathSegments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(pathSegments.size == 0) { ^nil };
    verbName = pathSegments[0].asString;

    switch(verbName,

        "add", {
            if(pathSegments.size >= 2) {
                effectSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(effectSymbol);
                }{
                    logMessage.("no pedalboard.add; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /add path: " ++ canonicalPath);
            };
        },

        "setSource", {
            if(pathSegments.size >= 2) {
                sourceSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\setSource)) {
                    pedalboardRef.setSource(sourceSymbol);
                }{
                    logMessage.("no pedalboard.setSource; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /setSource path: " ++ canonicalPath);
            };
        },

        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                pedalboardRef.switchChain(0.12);
            }{
                logMessage.("no pedalboard.switchChain; skipped: " ++ canonicalPath);
            };
        },

        "bypass", {
            if(pathSegments.size >= 3) {
                effectSymbol = pathSegments[1].asSymbol;
                onOffString  = pathSegments[2].asString.toLower;
                bypassState  = (onOffString == "on") or: { onOffString == "true" } or: { onOffString == "1" };
                // for demo: act on CURRENT; your adapter usually controls NEXT
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(effectSymbol, bypassState);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        pedalboardRef.bypass(effectSymbol, bypassState);
                    }{
                        logMessage.("no pedalboard.bypass; skipped: " ++ canonicalPath);
                    };
                };
            }{
                logMessage.("bad /bypass path: " ++ canonicalPath);
            };
        },

        { // default
            logMessage.("unhandled verb: " ++ verbName ++ " (path=" ++ canonicalPath ++ ")");
        }
    );
};

// ‚îÄ‚îÄ unified apply: prefer adapter; fall back to direct mapping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyOneCommand = { |canonicalPath|

    "DEBUG: applyOneCommand called with %".format(canonicalPath).postln;

    logMessage.("apply ‚Üí " ++ canonicalPath);
    if(adapterAvailable) { applyViaAdapter.(canonicalPath) } { applyDirectToPedalboard.(canonicalPath) };
    if(~procHud_update.notNil) { ~procHud_update.() }; // optional HUD refresh
};

// ‚îÄ‚îÄ sequenced playlist runner (AppClock; cancel-safe via generation id) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
runPlaylist = { |listOfCanonicalPaths, gap = 0.6|
    var myGeneration, indexCounter, totalCount, stepOnce, scheduleNext;

    // bump global generation to cancel older chains
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    myGeneration = ~fallback_gen;

    indexCounter = 0;
    totalCount   = listOfCanonicalPaths.size;

    stepOnce = {
        if(~fallback_gen != myGeneration) { ^nil }; // cancelled
        applyOneCommand.( listOfCanonicalPaths[indexCounter] );
        indexCounter = indexCounter + 1;
        if(indexCounter < totalCount) { scheduleNext.() } { logMessage.("done.") };
    };

    scheduleNext = {
        var delaySeconds;
        delaySeconds = gap ? 0.6;
        AppClock.sched(delaySeconds, {
            if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
        });
    };

    AppClock.sched(0.0, {
        if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
    });

    ^myGeneration;
};

// ‚îÄ‚îÄ hard stop utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
stopPlaylist = {
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    logMessage.("stopped.");
};

// ‚îÄ‚îÄ go ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showGuiHint.(
    "Fallback-only demo (adapter=" ++ adapterAvailable ++ "):\n" ++
    "A: " ++ playlistA.asString ++ "\n" ++
    "B: " ++ playlistB.asString
);
ensureGeneratedSources.();
startGeneration = runPlaylist.(playlistA, gapSeconds);

// queue playlist B after A with a tail margin
AppClock.sched((playlistA.size * gapSeconds + 1.0).max(1.0), {
    if(~fallback_gen == startGeneration) {
        runPlaylist.(playlistB, gapSeconds);
    };
    nil
});
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail_Delayed.scd =====
// Fallback_Acceptance_PassFail_Delayed.scd
// v0.1.3
// MD 20250923-1534


/*
Purpose
- Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
- Verify A XOR B only AFTER crossfade settles (avoid false FAIL during fade).
- Extra diagnostics: print plan.size, first path, and every step index.
Style
- var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.
- Generated audio only; Option A enforced if available.
*/

(
var say, trace, assertXorAfter;
var ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne;
var plan, idx, gap, settle, runStep, kickOff;

/* logging helpers */
say   = { |msg| ("[ACCEPT] " ++ msg).postln };
trace = { |msg| ("[TRACE] "  ++ msg).postln };

/* delayed assertion to avoid crossfade overlap */
assertXorAfter = { |expectA, expectB, label, delaySeconds|
    var doCheck, delay;
    delay = delaySeconds ? 0.35; // default settle > 0.12 crossfade
    doCheck = {
        var a, b, okFlag, tag;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        okFlag = (a == expectA) and: { b == expectB };
        tag = if(okFlag) { "PASS" }{ "FAIL" };
        (tag ++ " ‚Äî " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    };
    AppClock.sched(delay, { doCheck.value; nil });
};

/* guards */
ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)"); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

/* ensure generated sources & Option A */
ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

/* application modes */
applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

/* plan: Events with optional verify on switch */
plan = [
    ( idx: 1, total: 5, path: "/add/delay" ),
    ( idx: 2, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: false, expectB: true,  label: "after first switch" ),
    ( idx: 3, total: 5, path: "/bypass/delay/on" ),
    ( idx: 4, total: 5, path: "/bypass/delay/off" ),
    ( idx: 5, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: true,  expectB: false, label: "after second switch" )
];

/* extra instrumentation to confirm the plan really exists */
trace.("plan.size = " ++ plan.size);
if(plan.size > 0) {
    trace.("plan[0].path = " ++ plan[0][\path].asString);
} {
    say.("‚ö†Ô∏è plan is empty ‚Äî aborting to avoid a no-op run."); ^nil;
};

idx    = 0;
gap    = 0.60;
settle = 0.35;

/* run one step, then re-schedule next */
runStep = {
    var step, path, haveVerify, label, eA, eB, vd;
    if(idx >= plan.size) { say.("done."); ^nil; };

    step = plan[idx];
    trace.("step " ++ step[\idx] ++ " / " ++ step[\total]);

    path = step[\path].asString;
    applyOne.value(path);

    haveVerify = step.includesKey(\verifyDelay);
    if(haveVerify) {
        vd   = step[\verifyDelay] ? settle;
        eA   = step[\expectA];
        eB   = step[\expectB];
        label= step[\label].asString;
        assertXorAfter.value(eA, eB, label, vd);
        AppClock.sched(vd.max(gap), { idx = idx + 1; runStep.value; nil });
    }{
        AppClock.sched(gap, { idx = idx + 1; runStep.value; nil });
    };
};

/* go */
ensureSources.value;
kickOff = {
    var scheduled;
    trace.("scheduling kickoff in 0.03s on AppClock‚Ä¶");
    scheduled = AppClock.sched(0.03, { runStep.value; nil });
    ("[TRACE] AppClock.sched ‚Üí " ++ scheduled.asString).postln;
};
kickOff.value;
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 ‚Äî 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " ‚Äî " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== LPDisplay/allcombined.txt =====
LivePedalboardDisplay - README (reStructuredText)
=================================================

Overview
--------
LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

- LPDisplayLayoutTestWindow - a 6-pane grid window with two meters (A/B) driven by SendPeakRMS, plus simple control methods.
- LPDisplaySigChain - a helper to wire a symbol chain [sink, ..., source] using Ndef(left) <<> Ndef(right) with stereo pre-arming.
- LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.

Install
-------
Place the .sc files under this path (copy exactly):

::
    .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually symlinked into Extensions). Then recompile the class library:

::
    Language -> Recompile Class Library

When loaded, you should see lines like:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Quick Start
-----------
SuperCollider snippet (copy/paste into the IDE):

::
    (
        var hud = LPDisplayHudMap.new(-6, -60, 1.0);  // top/floor/gamma
        ~inst = LPDisplayLayoutTestWindow.new(hud);
        ~win  = ~inst.open;  // -> a Window
    )

    // Swap tail sources and write a status line
    ~inst.setSourceA(\srcC);
    ~inst.setSourceB(\srcA);
    ~inst.sendPaneText(\diag, "Ready @ " ++ Date.getDate.stamp);

    // HUD on/off
    ~inst.setHudMap(nil);                             // raw 0..1 meters
    ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close
    ~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

Classes
-------
LPDisplayLayoutTestWindow
^^^^^^^^^^^^^^^^^^^^^^^^^^
- Builds a 6-pane grid with top-left/right meters (LevelIndicator).
- Wires two chains: [\outA, \srcA] and [\outB, \srcB] using LPDisplaySigChain.
- Updates meters from SendPeakRMS via OSCdef(\rmsA_toGUI) and OSCdef(\rmsB_toGUI).
- Prints decimated console levels via OSCdef(\rmsA_console) and OSCdef(\rmsB_console).
- Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw values).

Why replyID?
^^^^^^^^^^^^
We keep replyID as A=1 and B=2 in SendPeakRMS.kr(..., '/peakrmsA', 1) and (..., '/peakrmsB', 2) to preserve continuity with older dumps/tools. The OSC addresses already differ; replyID is kept for backward compatibility.

Key instance methods
^^^^^^^^^^^^^^^^^^^^^
- open -> Window, close
- setSourceA(\sym), setSourceB(\sym)
- sendPaneText(\left|\right|\system|\diag|\choices|\recv, "text")
- setHudMap(instanceOrNil), printHud

Class-side utilities
^^^^^^^^^^^^^^^^^^^^^
- .help, .apihelp, .test

LPDisplaySigChain
^^^^^^^^^^^^^^^^^^
- Wires a chain [sink, ..., source] using Ndef(left) <<> Ndef(right).
- Ensures stereo busses and plays the sink.
- Key methods: rebuild, size, symbols (copy), setTailSource(\srcX), chainToString.
- Class-side utilities: .help, .apihelp, .test

LPDisplayHudMap
^^^^^^^^^^^^^^^^
- Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.
- Pass nil to the window's setHudMap to bypass mapping and show raw values.
- Key methods: set(\top|\floor|\gamma, value), mapLinToUi(linearRms), preview(rmsDb), print.
- Class-side utilities: .help, .apihelp, .test

Smoke Tests
------------
Run these in SuperCollider:

::
    LPDisplaySigChain.test;         // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test;           // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips sources, closes

Troubleshooting
---------------
- Meters not moving:
    OSCdef(\rmsA_toGUI).notNil;  OSCdef(\rmsB_toGUI).notNil.
    Sinks must read ``\in.ar(2)``. Chains should be playing (sink Ndef is .play'ed by LPDisplaySigChain.rebuild).
    If you changed sink OSC addresses, update the OSCdef addresses accordingly.

- string_ DNU on nil:
    The window pre-creates views. If you extend it, create views first, then compose the layout; update UI via ``{ ... }.defer`` with notNil guards.

- Compile errors after edits:
    Class-side methods (*help, *apihelp, *test) must be at class scope (not nested).
    Symbol literals use a single backslash: ``\symbol`` (not ``\\symbol``).

Style and Conventions
----------------------
- *new { ^super.new.init(...) }
- var-first in method bodies; clear names
- No non-local returns inside inner Functions
- GUI updates via ``{ ... }.defer``
- JITLib wiring strictly ``Ndef(left) <<> Ndef(right)``
- Sinks read ``\in.ar(2)``

Versioning
----------
Each class defines classVersion and prints a banner at class load time. You should see lines like these after a recompile:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Optional: One-button regression
--------------------------------
Save as this path (copy exactly):

::
    LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::
    (
        var hudPass, sigPass, win, posted;
        hudPass = LPDisplayHudMap.test;
        sigPass = { LPDisplaySigChain.test; true }.value;
        win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, {
            var allGreen = hudPass and: sigPass;
            ("LivePedalboardDisplay SMOKE: " ++ (allGreen.if("PASS", "WARN/FAIL"))).postln;
            nil
        });
    )// LPDisplay_AllInOne_BringUp.scd
// v0.9.8 ‚Äî open the layout test window + export helpers for a guided tour
// MD 2025-10-01

/*
Purpose
- One-file bring-up for the LivePedalboardDisplay demo window:
  * Open a 6-pane GUI with A/B meters driven by SendPeakRMS.
  * Create a HUD mapper (dB headroom + gamma) and allow on/off toggling.
  * Provide safe, readable one-liners to swap sources and send pane text.
  * Keep to known-good wiring: Ndef(left) <<> Ndef(right); sinks read \in.ar(2).

Style / Conventions
- var-first declarations; descriptive names; tilde vars exported for convenience.
- No server.sync; GUI ops are deferred inside the window class.
- Single bring-up block that returns -> a Window.
- No SoundIn; the window defines internal demo sources/sinks (stereo).
- If the classes are missing, recompile after installing them at:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
*/

(
var hud, inst, win;

// --- Create a HUD map (top/floor/gamma), then build the window instance
hud  = LPDisplayHudMap.new(-6, -60, 1.0);         // defaults: headroom -6 dB, floor -60 dB, gamma 1.0
inst = LPDisplayLayoutTestWindow.new(hud);        // pass nil here if you prefer raw 0..1 meters initially

// --- Open the window (the class ensures only one "Layout Test" window is active)
win = inst.open;                                  // -> a Window

// --- Export handles (tilde vars) so you can drive the demo interactively
~hud  = hud;          // current HUD map instance (may be replaced by ~hud_on)
~inst = inst;         // the layout test window controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;          // the Window; optional use

// --- Demo helpers: all nil-safe through the class methods they call
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;
};

~hud_set = { |key, value|
    // Ensure we have a HUD instance, then tweak a single parameter (\top, \floor, \gamma)
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);  // ensure mapping is active while tweaking
    ~hud.set(key, value).print;  // prints settings
};

~hud_preview = { |rmsDb = -9|
    // Convenience to see the UI mapping for a specific RMS dB value
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);
};

~setA = { |sym|  ~inst.setSourceA(sym) };         // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };         // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|
    // paneKey ‚àà: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    // Close the window and free OSCdefs & Ndefs inside the class
    ~inst.close;
};

// --- Friendly banner so the recipient knows what to try next:
"LivePedalboardDisplay ‚Äî bring-up complete. See 'Quick Tour' below for optional steps.".postln;
"Tip: you can now call ~hud_off.(), ~hud_on.(), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

// Return the Window so SC shows '-> a Window'
win
)

// LPDisplay_AllInOne_Demo_Tour.scd
// v0.9.8 ‚Äî single-file bring-up + guided quick tour (evaluate blocks top-to-bottom)
// MD 2025-10-01

/*
Overview
- This single .scd opens the LivePedalboardDisplay demo window and provides a guided "Quick Tour".
- The window shows A/B chains with meters (via SendPeakRMS), optional HUD mapping (dB headroom + gamma),
  and several text panes you can write to.

Prerequisites
- Ensure these classes are installed and you have recompiled the class library:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
    ‚Ä¢ LPDisplayHudMap.sc
    ‚Ä¢ LPDisplaySigChain.sc
    ‚Ä¢ LPDisplayLayoutTestWindow.sc
  SuperCollider menu: Language ‚Üí Recompile Class Library

How to use this file
1) Evaluate the first block (Bring-Up). You should see '-> a Window'.
2) Then evaluate the Quick Tour chunks (00..06) as needed, one line at a time or a few at a time.
3) To close and clean up, evaluate the Close chunk (06) at the end.

Style / Coding rules
- var-first declarations; descriptive names; GUI updates are deferred in the classes.
- JITLib wiring strictly: Ndef(left) <<> Ndef(right). Sinks read \in.ar(2).
- Generated demo sources only (no SoundIn).
*/

(
// --- Bring-Up: create HUD, create instance, open the window, export helpers ---
var hud, inst, win;

hud  = LPDisplayHudMap.new(-6, -60, 1.0);           // defaults: top=-6 dB, floor=-60 dB, gamma=1.0
inst = LPDisplayLayoutTestWindow.new(hud);          // pass nil if you prefer raw meters initially
win  = inst.open;                                   // -> a Window (ensures only one "Layout Test")

// Export handles for interactive use during the tour
~hud  = hud;                                        // current HUD instance (may be replaced)
~inst = inst;                                       // the controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;                                        // the Window

// Helper one-liners used by the tour
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;               // console prints HUD params
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;                  // console: "HUD mapping: none (raw 0..1)"
};

~hud_set = { |key, value|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);
    ~hud.set(key, value).print;                     // tweak \top/\floor/\gamma; prints settings
};

~hud_preview = { |rmsDb = -9|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);                             // prints UI fraction for given dB RMS
};

~setA = { |sym|  ~inst.setSourceA(sym) };           // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };           // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|                        // pane keys: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    ~inst.close;                                     // frees OSCdefs; stops sink Ndefs; closes window
};

"LivePedalboardDisplay ‚Äî bring-up complete. See Quick Tour blocks below.".postln;
"Tip: try ~hud_off.(), ~hud_on.(-9, -60, 1.0), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

win                                                // return -> a Window
)


// =============================
// Quick Tour 00 ‚Äî Sanity checks
// =============================

// LPDisplay_Tour_00_Sanity
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm bring-up ran and helpers exist before running the tour.
// Style
// - Each line prints a boolean; 'true' means you're good to proceed.

(~inst.notNil).postln;                               // expected: true
~inst.respondsTo(\setHudMap).postln;                 // expected: true
(~text.notNil).postln;                               // expected: true
(~hud_on.notNil and: { ~hud_off.notNil }).postln;    // expected: true


// ==========================================
// Quick Tour 01 ‚Äî Verify window + status text
// ==========================================

// LPDisplay_Tour_01_VerifyAndStatus
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm the window is open and panes update.
// Style
// - Evaluate lines one by one; text should appear immediately.

~text.(\diag,   "Ready @ " ++ Date.getDate.stamp);  // diag pane prints timestamp
~text.(\system, "A/B chains running. HUD is ON by default."); // system pane status


// =======================================
// Quick Tour 02 ‚Äî Swap tail sources (A/B)
// =======================================

// LPDisplay_Tour_02_SwapTailSources
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Swap each chain's tail source; you will hear/see changes.
// Style
// - After swap, the window auto-updates the top labels to show the new chain strings.

~setA.(\srcC);                                       // A tail -> \srcC (LFSaw/tanh) ; left meter responds
~setB.(\srcA);                                       // B tail -> \srcA (PinkNoise)  ; right meter responds
~text.(\diag, "Swapped: A->\\srcC, B->\\srcA");     // diag note confirming the change


// ==============================================
// Quick Tour 03 ‚Äî Toggle HUD mapping & preview UI
// ==============================================

// LPDisplay_Tour_03_ToggleHUD
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Show raw meters (no mapping), then enable HUD with new top/floor/gamma.
// - Preview mapping for a specific RMS dB value.
// Style
// - Use helpers created at bring-up.

~hud_off.();                                         // raw linear RMS on meters ; console prints mapping=none
~hud_on.(-9, -60, 1.0);                              // enable mapping top=-9 ; console prints params
~hud_set.(\gamma, 1.2);                              // add curvature ; console prints updated params
~hud_preview.(-9);                                   // prints UI fraction for -9 dB RMS ; e.g., 0.83
~print_hud.();                                       // print current HUD parameters


// ============================================
// Quick Tour 04 ‚Äî Populate the lower text panes
// ============================================

// LPDisplay_Tour_04_Panes_Content
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Simulate a fuller display by writing to \choices and \recv.
// Style
// - Multiline strings using \n.

~text.(\choices, "Choices:\n  1) Swap A/B\n  2) Toggle HUD\n  3) Send message\n  4) Close");            // choices pane shows 4 options

~text.(\recv,"Receiving:\n  /peakrmsA and /peakrmsB @ 20 Hz\n  Console prints ~1 Hz (decimated)"); // recv pane shows OSC info


// =====================================
// Quick Tour 05 ‚Äî Lightweight smoke tests
// =====================================

// LPDisplay_Tour_05_SmokeTests
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Quick PASS/FAIL checks in the Post window.
// Style
// - Run while the main demo window is open. Avoid LPDisplayLayoutTestWindow.test here.

LPDisplayHudMap.test;                                 // expected: prints cases + "LPDisplayHudMap.test: PASS"
LPDisplaySigChain.test;                               // expected: brief run + "LPDisplaySigChain.test: PASS"


// ================================
// Quick Tour 06 ‚Äî Close and cleanup
// ================================

// LPDisplay_Tour_06_Close
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Cleanly close the window and free responders.
// Style
// - Re-run the Bring-Up block to open again.

~close.();                                            // expected: window closes; OSCdefs freed; sinks stopped


// ======================================================
// Optional: One-button smoke runner (evaluate as a block)
// ======================================================

// LPDisplay_Tour_07_OneButtonSmoke
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Minimal automated walk-through: flip sources, post a diag line, print HUD, then stop.
// Style
// - Safe timings via AppClock; does not assume SoundIn.

(
var step1, step2;
step1 = {
    ~setA.(\srcC); ~setB.(\srcA);                    // swap tails
    ~text.(\diag, "Smoke: swapped A/B @ " ++ Date.getDate.stamp);
};
step2 = {
    ~print_hud.();                                    // print active HUD state
    ~text.(\system, "Smoke: HUD printed; closing in 1s");
    AppClock.sched(1.0, { ~close.(); nil });          // close after 1s
};
AppClock.sched(0.5, { step1.(); AppClock.sched(1.0, { step2.(); nil }); nil });
)
// LPDisplay_CompatExports.scd
// v0.9.2 - shims for old tilde variables + bring-up
// MD 20251001

(
var hud, win;

// Create a HUD map (or set to nil to keep raw 0..1 meters)
hud = LPDisplayHudMap.new(-6, -60, 1.0);

// Open the window (-> a Window)
win = LPDisplayLayoutTestWindow.new(hud).open;

// Export legacy one-liners:
~setSourceA = { |sym| win.setSourceA(sym) };
~setSourceB = { |sym| win.setSourceB(sym) };

// Pane text helper (keys: \left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString| win.sendPaneText(paneKey, aString) };

// HUD helpers to mirror your previous patch commands:
~hud_set     = { |key, value| hud.set(key, value) };
~hud_preview = { |db| hud.preview(db) };
~hud_print   = { hud.print };

// Quick ping:
~hud_print.();
// LPDisplayHudMap.sc
// v0.9.7.2 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local variable names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Map raw linear RMS (0..1) from SendPeakRMS into a UI-friendly 0..1 value using a dB window
 *   (topDb/floorDb) and a perceptual gamma curve. This is optional in the display window:
 *   passing nil for the HUD map means "use raw RMS 0..1".
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; numeric helpers return raw values.
 */

LPDisplayHudMap {
    classvar classVersion = "0.9.7.2";

    // Defaults for headroom window and perceptual curve
    classvar defaultTopDb   = -6.0;
    classvar defaultFloorDb = -60.0;
    classvar defaultGamma   = 1.0;

    // Instance configuration
    var topDb;     // dB at which UI reaches 1.0 (top of meter)
    var floorDb;   // dB at which UI reaches 0.0 (floor of meter)
    var gamma;     // perceptual exponent applied in UI domain

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDbArg, floorDbArg, gammaArg|
        // If any parameter is omitted, fall back to defaults above.
        ^super.new.init(
            topDbArg   ?? { defaultTopDb },
            floorDbArg ?? { defaultFloorDb },
            gammaArg   ?? { defaultGamma }
        )
    }

    init { |topDbInit, floorDbInit, gammaInit|
        // Store parameters and keep gamma numerically safe.
        topDb   = topDbInit.asFloat;
        floorDb = floorDbInit.asFloat;
        gamma   = gammaInit.asFloat.max(1e-6);

        // Ensure a valid window (top must be above floor).
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        // Small setter to tweak parameters at runtime (e.g., \top -> -9, \gamma -> 1.2).
        var paramKey = key.asSymbol;
        var paramVal = value.asFloat;

        if (paramKey == \top)   { topDb = paramVal };
        if (paramKey == \floor) { floorDb = paramVal };
        if (paramKey == \gamma) { gamma = paramVal.max(1e-6) };

        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |linearRms|
        /*
         * Convert a raw linear RMS (0..1) into a UI fraction (0..1):
         * 1) Convert linear amplitude to dBFS.
         * 2) Clip to [floorDb, topDb] window.
         * 3) Normalize to [0,1] and apply gamma.
         */
        var linearClamped      = linearRms.max(1e-9);  // avoid -inf dB
        var amplitudeDb        = linearClamped.ampdb;  // linear -> dBFS
        var topDbLimit         = topDb.asFloat;
        var floorDbLimit       = floorDb.asFloat;
        var gammaLocal         = gamma.asFloat.max(1e-6);
        var uiValue;

        amplitudeDb = amplitudeDb.clip(floorDbLimit, topDbLimit);
        uiValue     = (amplitudeDb - floorDbLimit) / (topDbLimit - floorDbLimit);
        uiValue     = uiValue.pow(gammaLocal);
        ^uiValue.clip(0.0, 1.0)
    }

    preview { |rmsDbValue|
        // Convenience: preview the UI value you‚Äôd get for a given RMS dB input.
        var linearFromDb             = rmsDbValue.dbamp.clip(1e-9, 1.0);
        var uiValue                  = this.mapLinToUi(linearFromDb);
        ("HUD UI -> " ++ uiValue.round(0.003) ++ " for " ++ rmsDbValue ++ " dBFS RMS").postln;
        ^uiValue
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }


	/////



	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplayHudMap ‚Äî purpose:",
        "  Map raw linear RMS (0..1) to UI (0..1) using a dB headroom window and gamma.",
        "",
        "Constructor:",
        "  LPDisplayHudMap.new(topDb = -6, floorDb = -60, gamma = 1.0)",
        "",
        "Key methods:",
        "  .set(\\top|\\floor|\\gamma, value)  // tweak mapping",
        "  .mapLinToUi(linearRms)              // 0..1 -> 0..1 UI",
        "  .preview(rmsDb)                     // prints & returns UI for a dB value",
        "  .print()                            // print current mapping",
        "",
        "Tip: In LPDisplayLayoutTestWindow, setHudMap(nil) disables mapping (raw 0..1)."
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplayHudMap.apihelp ‚Äî quick recipes:",
        "  h = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  h.preview(-9);                // see UI at -9 dB RMS",
        "  h.set(\\top, -9).print;        // move top to -9 dB RMS",
        "  h.set(\\gamma, 1.2).print;     // increase perceptual curvature",
        "  // In the layout window:",
        "  //  ~inst.setHudMap(h);         // enable mapping",
        "  //  ~inst.setHudMap(nil);       // disable mapping (raw 0..1)"
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var hud, dbCases, lastUi, passAll;
    hud = this.new(-6, -60, 1.0);
    dbCases = [-60, -30, -18, -12, -9, -6, -3, 0]; // typical points
    lastUi = -1.0;
    passAll = true;

    "LPDisplayHudMap.test ‚Äî monotonicity & bounds:".postln;
    dbCases.do({ |dbVal|
        var uiVal;
        uiVal = hud.preview(dbVal); // prints & returns
        if (uiVal < lastUi) { passAll = false };
        if ((uiVal < 0.0) or: { uiVal > 1.0 }) { passAll = false };
        lastUi = uiVal;
    });

    if (passAll) {
        "LPDisplayHudMap.test: PASS".postln;
    } {
        "LPDisplayHudMap.test: FAIL (non-monotonic or out-of-bounds)".postln;
    };
    ^passAll
}
}// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01
/*
 * 0.9.7.3 move class-side utility methods (*help/*apihelp/*test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}// LPDisplaySigChain.sc
// v0.9.7.2 ‚Äî minimal [sink, ..., source] JITLib chain wrapper
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local/parameter names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Manage a simple symbol chain [sink, ..., source] using JITLib wiring:
 *   Ndef(left) <<> Ndef(right), where the left node reads \in.ar(2).
 * - Ensure stereo busses prior to wiring; play the sink.
 *
 * Typical usage
 *   LPDisplaySigChain.new([\outA, \srcA]).rebuild;       // wires and plays sink
 *   chain.setTailSource(\srcC).rebuild;                  // swap just the tail
 *   chain.chainToString  // "srcC ‚Üí outA"
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; getters return values.
 */

LPDisplaySigChain {
    classvar classVersion = "0.9.7.2";

    var chainSymbols;  // Array(Symbol): [sink, ..., source]

    *initClass {
        ("LPDisplaySigChain v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |chainSymbolsArray|
        ^super.new.init(chainSymbolsArray ?? { [] })
    }

    init { |chainSymbolsArray|
        chainSymbols = chainSymbolsArray.copy;
        ^this
    }

    size {
        ^chainSymbols.size
    }

    ensureStereo { |ndefKey|
        /*
         * Pre-arm an Ndef as a 2-channel audio node if its bus is missing or not stereo.
         * This prevents wiring failures when we connect nodes with <<>.
         */
        var ndefBus = Ndef(ndefKey).bus;
        if (ndefBus.isNil or: { ndefBus.rate != \audio } or: { ndefBus.numChannels != 2 }) {
            Ndef(ndefKey).ar(2);
        };
        ^this
    }

    rebuild {
        /*
         * Wire the chain left-to-right:
         *   chainSymbols = [sink, mid1, mid2, source]
         * becomes:
         *   Ndef(sink) <<> Ndef(mid1);  Ndef(mid1) <<> Ndef(mid2);  Ndef(mid2) <<> Ndef(source)
         * and then play the sink stereo.
         */
        var chainSize  = chainSymbols.size;
        var linkIndex  = 0;

        if (chainSize < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
            ^this
        };

        chainSymbols.do { |ndefSymbol| this.ensureStereo(ndefSymbol) };

        while({ linkIndex < (chainSize - 1) }, {
            Ndef(chainSymbols[linkIndex]) <<> Ndef(chainSymbols[linkIndex + 1]);
            linkIndex = linkIndex + 1;
        });

        Ndef(chainSymbols[0]).play(numChannels: 2);  // play the sink
        ^this
    }

    chainToString {
        // For display we show "source ‚Üí ... ‚Üí sink"
        var forwardList = chainSymbols.copy.reverse;
        ^forwardList.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |tailSourceSymbol|
        // Replace/append the final element (source) and keep the chain consistent.
        var newSourceSymbol = tailSourceSymbol.asSymbol;

        if (chainSymbols.size >= 2) {
            chainSymbols[chainSymbols.size - 1] = newSourceSymbol;
        } {
            chainSymbols = chainSymbols.add(newSourceSymbol);
        };

        ^this.rebuild
    }

    symbols {
        // Read-only copy so external code doesn‚Äôt mutate internal state.
        var symbolsCopy = chainSymbols.copy;
        ^symbolsCopy
    }



	////////
	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplaySigChain ‚Äî purpose:",
        "  Wrap a symbol chain [sink, ..., source] and wire via:",
        "    Ndef(left) <<> Ndef(right)  (sink reads \\in.ar(2))",
        "",
        "Constructor:",
        "  LPDisplaySigChain.new([\\outA, \\srcA])",
        "",
        "Key methods:",
        "  .rebuild()                   // ensure stereo, wire, play sink",
        "  .setTailSource(\\srcC)       // swap the final source and rebuild",
        "  .chainToString               // e.g., 'srcC ‚Üí outA'",
        "  .symbols                     // copy of [sink, ..., source]",
        ""
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplaySigChain.apihelp ‚Äî quick recipes:",
        "  c = LPDisplaySigChain.new([\\outA, \\srcA]).rebuild;",
        "  c.setTailSource(\\srcC);",
        "  c.chainToString.postln;  // 'srcC ‚Üí outA'",
        "",
        "Note: Ensure sinks read \\in.ar(2) and that sources produce stereo."
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var srcKey, sinkKey, chain, okFlag;

    // Use single-backslash for Symbol literals:
    srcKey  = \_lpdisp_test_src;
    sinkKey = \_lpdisp_test_sink;

    okFlag  = true;

    Server.default.waitForBoot({
        // ephemeral test nodes
        Ndef(srcKey,  { PinkNoise.ar(0.02 ! 2) });  // quiet stereo
        Ndef(sinkKey, {
            var sig = \in.ar(2);
            // no SendPeakRMS here to keep test minimal
            sig
        });

        chain = this.new([sinkKey, srcKey]).rebuild;

        // brief run, then cleanup
        AppClock.sched(0.4, {
            var busOk;
            busOk = Ndef(sinkKey).bus.notNil and: { Ndef(sinkKey).isPlaying };
            if (busOk.not) { okFlag = false };

            Ndef(sinkKey).stop;
            Ndef(srcKey).clear(0.2);  // fade out

            ("LPDisplaySigChain.test: " ++ (okFlag.if("PASS", "FAIL"))).postln;
            nil
        });
    });
    ^this
}

}
===== LPDisplay/LPDisplay_AllInOne_BringUp.scd =====
// LPDisplay_AllInOne_BringUp.scd
// v0.9.8 ‚Äî open the layout test window + export helpers for a guided tour
// MD 2025-10-01

/*
Purpose
- One-file bring-up for the LivePedalboardDisplay demo window:
  * Open a 6-pane GUI with A/B meters driven by SendPeakRMS.
  * Create a HUD mapper (dB headroom + gamma) and allow on/off toggling.
  * Provide safe, readable one-liners to swap sources and send pane text.
  * Keep to known-good wiring: Ndef(left) <<> Ndef(right); sinks read \in.ar(2).

Style / Conventions
- var-first declarations; descriptive names; tilde vars exported for convenience.
- No server.sync; GUI ops are deferred inside the window class.
- Single bring-up block that returns -> a Window.
- No SoundIn; the window defines internal demo sources/sinks (stereo).
- If the classes are missing, recompile after installing them at:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
*/

(
var hud, inst, win;

// --- Create a HUD map (top/floor/gamma), then build the window instance
hud  = LPDisplayHudMap.new(-6, -60, 1.0);         // defaults: headroom -6 dB, floor -60 dB, gamma 1.0
inst = LPDisplayLayoutTestWindow.new(hud);        // pass nil here if you prefer raw 0..1 meters initially

// --- Open the window (the class ensures only one "Layout Test" window is active)
win = inst.open;                                  // -> a Window

// --- Export handles (tilde vars) so you can drive the demo interactively
~hud  = hud;          // current HUD map instance (may be replaced by ~hud_on)
~inst = inst;         // the layout test window controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;          // the Window; optional use

// --- Demo helpers: all nil-safe through the class methods they call
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;
};

~hud_set = { |key, value|
    // Ensure we have a HUD instance, then tweak a single parameter (\top, \floor, \gamma)
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);  // ensure mapping is active while tweaking
    ~hud.set(key, value).print;  // prints settings
};

~hud_preview = { |rmsDb = -9|
    // Convenience to see the UI mapping for a specific RMS dB value
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);
};

~setA = { |sym|  ~inst.setSourceA(sym) };         // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };         // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|
    // paneKey ‚àà: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    // Close the window and free OSCdefs & Ndefs inside the class
    ~inst.close;
};

// --- Friendly banner so the recipient knows what to try next:
"LivePedalboardDisplay ‚Äî bring-up complete. See 'Quick Tour' below for optional steps.".postln;
"Tip: you can now call ~hud_off.(), ~hud_on.(), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

// Return the Window so SC shows '-> a Window'
win
)

===== LPDisplay/LPDisplay_AllInOne_Demo_Tour.scd =====

// LPDisplay_AllInOne_Demo_Tour.scd
// v0.9.8.1 added check that GUI window is open at start of last block
// v0.9.8 ‚Äî single-file bring-up + guided quick tour (evaluate blocks top-to-bottom)
// MD 2025-10-01

/*
Overview
- This single .scd opens the LivePedalboardDisplay demo window and provides a guided "Quick Tour".
- The window shows A/B chains with meters (via SendPeakRMS), optional HUD mapping (dB headroom + gamma),
  and several text panes you can write to.

Prerequisites
- Ensure these classes are installed and you have recompiled the class library:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
    ‚Ä¢ LPDisplayHudMap.sc
    ‚Ä¢ LPDisplaySigChain.sc
    ‚Ä¢ LPDisplayLayoutTestWindow.sc
  SuperCollider menu: Language ‚Üí Recompile Class Library

How to use this file
1) Evaluate the first block (Bring-Up). You should see '-> a Window'.
2) Then evaluate the Quick Tour chunks (00..06) as needed, one line at a time or a few at a time.
3) To close and clean up, evaluate the Close chunk (06) at the end.

Style / Coding rules
- var-first declarations; descriptive names; GUI updates are deferred in the classes.
- JITLib wiring strictly: Ndef(left) <<> Ndef(right). Sinks read \in.ar(2).
- Generated demo sources only (no SoundIn).
*/

(
// --- Bring-Up: create HUD, create instance, open the window, export helpers ---
var hud, inst, win;

hud  = LPDisplayHudMap.new(-6, -60, 1.0);           // defaults: top=-6 dB, floor=-60 dB, gamma=1.0
inst = LPDisplayLayoutTestWindow.new(hud);          // pass nil if you prefer raw meters initially
win  = inst.open;                                   // -> a Window (ensures only one "Layout Test")

// Export handles for interactive use during the tour
~hud  = hud;                                        // current HUD instance (may be replaced)
~inst = inst;                                       // the controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;                                        // the Window

// Helper one-liners used by the tour
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;               // console prints HUD params
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;                  // console: "HUD mapping: none (raw 0..1)"
};

~hud_set = { |key, value|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);
    ~hud.set(key, value).print;                     // tweak \top/\floor/\gamma; prints settings
};

~hud_preview = { |rmsDb = -9|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);                             // prints UI fraction for given dB RMS
};

~setA = { |sym|  ~inst.setSourceA(sym) };           // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };           // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|                        // pane keys: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    ~inst.close;                                     // frees OSCdefs; stops sink Ndefs; closes window
};

"LivePedalboardDisplay ‚Äî bring-up complete. See Quick Tour blocks below.".postln;
"Tip: try ~hud_off.(), ~hud_on.(-9, -60, 1.0), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

win                                                // return -> a Window
)


// =============================
// Quick Tour 00 ‚Äî Sanity checks
// =============================

// LPDisplay_Tour_00_Sanity
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm bring-up ran and helpers exist before running the tour.
// Style
// - Each line prints a boolean; 'true' means you're good to proceed.

(~inst.notNil).postln;                               // expected: true
~inst.respondsTo(\setHudMap).postln;                 // expected: true
(~text.notNil).postln;                               // expected: true
(~hud_on.notNil and: { ~hud_off.notNil }).postln;    // expected: true


// ==========================================
// Quick Tour 01 ‚Äî Verify window + status text
// ==========================================

// LPDisplay_Tour_01_VerifyAndStatus
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Confirm the window is open and panes update.
// Style
// - Evaluate lines one by one; text should appear immediately.

~text.(\diag,   "Ready @ " ++ Date.getDate.stamp);  // diag pane prints timestamp
~text.(\system, "A/B chains running. HUD is ON by default."); // system pane status


// =======================================
// Quick Tour 02 ‚Äî Swap tail sources (A/B)
// =======================================

// LPDisplay_Tour_02_SwapTailSources
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Swap each chain's tail source; you will hear/see changes.
// Style
// - After swap, the window auto-updates the top labels to show the new chain strings.

~setA.(\srcC);                                       // A tail -> \srcC (LFSaw/tanh) ; left meter responds
~setB.(\srcA);                                       // B tail -> \srcA (PinkNoise)  ; right meter responds
~text.(\diag, "Swapped: A->\\srcC, B->\\srcA");     // diag note confirming the change


// ==============================================
// Quick Tour 03 ‚Äî Toggle HUD mapping & preview UI
// ==============================================

// LPDisplay_Tour_03_ToggleHUD
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Show raw meters (no mapping), then enable HUD with new top/floor/gamma.
// - Preview mapping for a specific RMS dB value.
// Style
// - Use helpers created at bring-up.

~hud_off.();                                         // raw linear RMS on meters ; console prints mapping=none
~hud_on.(-9, -60, 1.0);                              // enable mapping top=-9 ; console prints params
~hud_set.(\gamma, 1.2);                              // add curvature ; console prints updated params
~hud_preview.(-9);                                   // prints UI fraction for -9 dB RMS ; e.g., 0.83
~print_hud.();                                       // print current HUD parameters


// ============================================
// Quick Tour 04 ‚Äî Populate the lower text panes
// ============================================

// LPDisplay_Tour_04_Panes_Content
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Simulate a fuller display by writing to \choices and \recv.
// Style
// - Multiline strings using \n.

~text.(\choices, "Choices:\n  1) Swap A/B\n  2) Toggle HUD\n  3) Send message\n  4) Close");            // choices pane shows 4 options

~text.(\recv,"Receiving:\n  /peakrmsA and /peakrmsB @ 20 Hz\n  Console prints ~1 Hz (decimated)"); // recv pane shows OSC info


// =====================================
// Quick Tour 05 ‚Äî Lightweight smoke tests
// =====================================

// LPDisplay_Tour_05_SmokeTests
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Quick PASS/FAIL checks in the Post window.
// Style
// - Run while the main demo window is open. Avoid LPDisplayLayoutTestWindow.test here.

LPDisplayHudMap.test;                                 // expected: prints cases + "LPDisplayHudMap.test: PASS"
LPDisplaySigChain.test;                               // expected: brief run + "LPDisplaySigChain.test: PASS"


// ================================
// Quick Tour 06 ‚Äî Close and cleanup
// ================================

// LPDisplay_Tour_06_Close
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Cleanly close the window and free responders.
// Style
// - Re-run the Bring-Up block to open again.

~close.();                                            // expected: window closes; OSCdefs freed; sinks stopped


// ======================================================
// Optional: One-button smoke runner (evaluate as a block,
// keeping first block running.)
// ======================================================

// LPDisplay_Tour_07_OneButtonSmoke
// v1.0 ‚Äî MD 2025-10-01
//
// Purpose
// - Minimal automated walk-through: flip sources, post a diag line, print HUD, then stop.
// Style
// - Safe timings via AppClock; does not assume SoundIn.

(
var step1, step2;

// Ensure GUI is up before scheduling steps:
if (~inst.isNil or: { ~win.isNil } or: { ~win.isClosed }) {
    var hud = LPDisplayHudMap.new(-6, -60, 1.0);
    ~inst = LPDisplayLayoutTestWindow.new(hud);
    ~win  = ~inst.open;
    ~hud  = hud;
};

step1 = {
    ~setA.(\srcC); ~setB.(\srcA);                    // swap tails
    ~text.(\diag, "Smoke: swapped A/B @ " ++ Date.getDate.stamp);
};
step2 = {
    ~print_hud.();                                    // print active HUD state
    ~text.(\system, "Smoke: HUD printed; closing in 1s");
    AppClock.sched(1.0, { ~close.(); nil });          // close after 1s
};
AppClock.sched(0.5, { step1.(); AppClock.sched(1.0, { step2.(); nil }); nil });
)

===== LPDisplay/LPDisplay_CompatExports.scd =====
// LPDisplay_CompatExports.scd
// v0.9.2 - shims for old tilde variables + bring-up
// MD 20251001

(
var hud, win, inst;

// Create a HUD map (or set to nil to keep raw 0..1 meters)
hud = LPDisplayHudMap.new(-6, -60, 1.0);

// Open the window (-> a Window)
win = LPDisplayLayoutTestWindow.new(hud).open; // the window
win = inst.open; // the controller for the window

// Export legacy one-liners:
~setSourceA = { |sym| inst.setSourceA(sym) };
~setSourceB = { |sym| inst.setSourceB(sym) };

// Pane text helper (keys: \left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString| win.sendPaneText(paneKey, aString) };

// HUD helpers to mirror your previous patch commands:
~hud_set     = { |key, value| hud.set(key, value) };
~hud_preview = { |db| hud.preview(db) };
~hud_print   = { hud.print };

// Quick ping:
~hud_print.();
)
===== LPDisplay/LPDisplayClasses_tests.scd =====
// LPDisplayClasses_tests.scd
// v0.9
// MD 20251002

LPDisplayHudMap.help;
LPDisplayLayoutTestWindow.help;
LPDisplaySigChain.help;



LPDisplayHudMap.apihelp
LPDisplayLayoutTestWindow.apihelp;
LPDisplaySigChain.apihelp;


LPDisplayHudMap.test;
LPDisplayLayoutTestWindow.test;
LPDisplaySigChain.test;
===== LPDisplay/LPDisplayHudMap.sc =====
// LPDisplayHudMap.sc
// v0.9.7.2 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local variable names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Map raw linear RMS (0..1) from SendPeakRMS into a UI-friendly 0..1 value using a dB window
 *   (topDb/floorDb) and a perceptual gamma curve. This is optional in the display window:
 *   passing nil for the HUD map means "use raw RMS 0..1".
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; numeric helpers return raw values.
 */

LPDisplayHudMap {
    classvar classVersion = "0.9.7.2";

    // Defaults for headroom window and perceptual curve
    classvar defaultTopDb   = -6.0;
    classvar defaultFloorDb = -60.0;
    classvar defaultGamma   = 1.0;

    // Instance configuration
    var topDb;     // dB at which UI reaches 1.0 (top of meter)
    var floorDb;   // dB at which UI reaches 0.0 (floor of meter)
    var gamma;     // perceptual exponent applied in UI domain

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDbArg, floorDbArg, gammaArg|
        // If any parameter is omitted, fall back to defaults above.
        ^super.new.init(
            topDbArg   ?? { defaultTopDb },
            floorDbArg ?? { defaultFloorDb },
            gammaArg   ?? { defaultGamma }
        )
    }

    init { |topDbInit, floorDbInit, gammaInit|
        // Store parameters and keep gamma numerically safe.
        topDb   = topDbInit.asFloat;
        floorDb = floorDbInit.asFloat;
        gamma   = gammaInit.asFloat.max(1e-6);

        // Ensure a valid window (top must be above floor).
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        // Small setter to tweak parameters at runtime (e.g., \top -> -9, \gamma -> 1.2).
        var paramKey = key.asSymbol;
        var paramVal = value.asFloat;

        if (paramKey == \top)   { topDb = paramVal };
        if (paramKey == \floor) { floorDb = paramVal };
        if (paramKey == \gamma) { gamma = paramVal.max(1e-6) };

        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |linearRms|
        /*
         * Convert a raw linear RMS (0..1) into a UI fraction (0..1):
         * 1) Convert linear amplitude to dBFS.
         * 2) Clip to [floorDb, topDb] window.
         * 3) Normalize to [0,1] and apply gamma.
         */
        var linearClamped      = linearRms.max(1e-9);  // avoid -inf dB
        var amplitudeDb        = linearClamped.ampdb;  // linear -> dBFS
        var topDbLimit         = topDb.asFloat;
        var floorDbLimit       = floorDb.asFloat;
        var gammaLocal         = gamma.asFloat.max(1e-6);
        var uiValue;

        amplitudeDb = amplitudeDb.clip(floorDbLimit, topDbLimit);
        uiValue     = (amplitudeDb - floorDbLimit) / (topDbLimit - floorDbLimit);
        uiValue     = uiValue.pow(gammaLocal);
        ^uiValue.clip(0.0, 1.0)
    }

    preview { |rmsDbValue|
        // Convenience: preview the UI value you‚Äôd get for a given RMS dB input.
        var linearFromDb             = rmsDbValue.dbamp.clip(1e-9, 1.0);
        var uiValue                  = this.mapLinToUi(linearFromDb);
        ("HUD UI -> " ++ uiValue.round(0.003) ++ " for " ++ rmsDbValue ++ " dBFS RMS").postln;
        ^uiValue
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }


	/////



	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplayHudMap ‚Äî purpose:",
        "  Map raw linear RMS (0..1) to UI (0..1) using a dB headroom window and gamma.",
        "",
        "Constructor:",
        "  LPDisplayHudMap.new(topDb = -6, floorDb = -60, gamma = 1.0)",
        "",
        "Key methods:",
        "  .set(\\top|\\floor|\\gamma, value)  // tweak mapping",
        "  .mapLinToUi(linearRms)              // 0..1 -> 0..1 UI",
        "  .preview(rmsDb)                     // prints & returns UI for a dB value",
        "  .print()                            // print current mapping",
        "",
        "Tip: In LPDisplayLayoutTestWindow, setHudMap(nil) disables mapping (raw 0..1)."
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplayHudMap.apihelp ‚Äî quick recipes:",
        "  h = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  h.preview(-9);                // see UI at -9 dB RMS",
        "  h.set(\\top, -9).print;        // move top to -9 dB RMS",
        "  h.set(\\gamma, 1.2).print;     // increase perceptual curvature",
        "  // In the layout window:",
        "  //  ~inst.setHudMap(h);         // enable mapping",
        "  //  ~inst.setHudMap(nil);       // disable mapping (raw 0..1)"
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var hud, dbCases, lastUi, passAll;
    hud = this.new(-6, -60, 1.0);
    dbCases = [-60, -30, -18, -12, -9, -6, -3, 0]; // typical points
    lastUi = -1.0;
    passAll = true;

    "LPDisplayHudMap.test ‚Äî monotonicity & bounds:".postln;
    dbCases.do({ |dbVal|
        var uiVal;
        uiVal = hud.preview(dbVal); // prints & returns
        if (uiVal < lastUi) { passAll = false };
        if ((uiVal < 0.0) or: { uiVal > 1.0 }) { passAll = false };
        lastUi = uiVal;
    });

    if (passAll) {
        "LPDisplayHudMap.test: PASS".postln;
    } {
        "LPDisplayHudMap.test: FAIL (non-monotonic or out-of-bounds)".postln;
    };
    ^passAll
}
}
===== LPDisplay/LPDisplayLayoutTestWindow.sc =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.4 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints gated
// MD 2025-10-01
/*
 * 0.9.7.4 add consoleLevelsOn flag (default false) to gate console prints
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
 - builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
 - sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
 - receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
 - posts decimated level prints to the console for A/B (~1 Hz),
 - has methods
   open, close
   setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
   sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
   setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping
Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/
LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.4"; // printed at class-load time

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // NEW: console print gate (default OFF)
    var consoleLevelsOn;

    // --- Meter mapping (optional)
    // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
    var meterHudMap;

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |meterHudMapInstance|
        // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
        ^super.new.init(meterHudMapInstance)
    }

    *open { |meterHudMapInstance|
        // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
        ^this.new(meterHudMapInstance).open
    }

    init { |meterHudMapInstance|
        // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
        meterHudMap = meterHudMapInstance;
        paneColor = Color(0.0, 0.35, 0.0);

        // OSCdef keys (names) for GUI and console responders
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;

        // NEW: default OFF
        consoleLevelsOn = false;

        ^this
    }

    // --- Public API -----------------------------------------------------------

    open {
        Window.allWindows.do { |existingWindow|
            if (existingWindow.name == "Layout Test") { existingWindow.close }
        }; // ensure only one with this title
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        // Free any live OSCdefs and stop sinks before closing the window
        var oscGuiDefA = OSCdef(oscNameA);
        var oscGuiDefB = OSCdef(oscNameB);
        var oscConsoleDefA = OSCdef(oscConsoleA);
        var oscConsoleDefB = OSCdef(oscConsoleB);

        if (oscGuiDefA.notNil) { oscGuiDefA.free };
        if (oscGuiDefB.notNil) { oscGuiDefB.free };
        if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
        if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup: onClose will not call back into close()
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |sourceSymbol|
        if (chainA.notNil) {
            chainA.setTailSource(sourceSymbol);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |sourceSymbol|
        if (chainB.notNil) {
            chainB.setTailSource(sourceSymbol);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var paneKeySymbol = paneKey.asSymbol;
        var textString = aString.asString;
        {
            if (paneKeySymbol == \left   and: { topLeftText.notNil  }) { topLeftText.string_(textString) };
            if (paneKeySymbol == \right  and: { topRightText.notNil }) { topRightText.string_(textString) };
            if (paneKeySymbol == \system and: { systemText.notNil   }) { systemText.string_(textString) };
            if (paneKeySymbol == \diag   and: { diagText.notNil     }) { diagText.string_(textString) };
            if (paneKeySymbol == \choices and: { choicesText.notNil }) { choicesText.string_(textString) };
            if (paneKeySymbol == \recv   and: { recvText.notNil     }) { recvText.string_(textString) };
        }.defer;
        ^this
    }

    setHudMap { |hudMapOrNil|
        // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
        // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
        meterHudMap = hudMapOrNil;
        ^this
    }

    printHud {
        if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // NEW: convenience setter to toggle console prints
    setConsoleLevelsOn { |flag = false|
        consoleLevelsOn = flag.asBoolean;
        ^this
    }

    // --- Internal build steps -------------------------------------------------

    /* Make one labeled pane (internal helper)
     * Returns a UserView that draws a border and hosts a label + provided content.
     */
    makePane { |content, label|
        var labelView, inner, pane, inset;
        labelView = StaticText()
            .string_(label)
            .align_(\center)
            .stringColor_(Color.white)
            .background_(paneColor);
        inner = VLayout(labelView, content);
        pane  = UserView().layout_(inner);
        pane.drawFunc_({ |view|
            inset = 0.5;
            Pen.use {
                Pen.color = paneColor;
                Pen.width = 1;
                Pen.addRect(Rect(
                    inset, inset,
                    view.bounds.width - (2 * inset),
                    view.bounds.height - (2 * inset)
                ));
                Pen.stroke;
            };
        });
        ^pane
    }

    buildWindow {
        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText  = TextView().editable_(false);
        topLeftMeter = LevelIndicator().fixedWidth_(30);
        topRightText = TextView().editable_(false);
        topRightMeter= LevelIndicator().fixedWidth_(30);
        systemText   = TextView();
        diagText     = TextView();
        choicesText  = TextView();
        recvText     = TextView();

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var oscGuiDefA = OSCdef(oscNameA);
            var oscGuiDefB = OSCdef(oscNameB);
            var oscConsoleDefA = OSCdef(oscConsoleA);
            var oscConsoleDefB = OSCdef(oscConsoleB);

            if (oscGuiDefA.notNil) { oscGuiDefA.free };
            if (oscGuiDefB.notNil) { oscGuiDefB.free };
            if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
            if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var extractLinearRmsFromOscMessage;
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
            extractLinearRmsFromOscMessage = { |oscMessage|
                var linearRms = 0.0, messageSize;
                if (oscMessage.notNil) {
                    messageSize = oscMessage.size;
                    if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
                };
                linearRms.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
            OSCdef(oscNameA, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation), now gated by 'consoleLevelsOn'
            OSCdef(oscConsoleA, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpA) {
                        ("A first msg: %".format(oscMessage)).postln;
                        firstDumpA = false;
                    };
                    countA = countA + 1;
                    if (countA >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countA = 0;
                    };
                } {
                    // printing disabled ‚Äî keep counters steady or reset if you prefer
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpB) {
                        ("B first msg: %".format(oscMessage)).postln;
                        firstDumpB = false;
                    };
                    countB = countB + 1;
                    if (countB >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countB = 0;
                    };
                } {
                    // printing disabled ‚Äî keep counters steady or reset if you prefer
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 2) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
        // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
        // but keeping these IDs preserves compatibility with prior tools and logs.
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
            sig
        });
        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
            sig
        });
        ^this
    }

    // --- Utility: docs & smoke test (add-only) --------------------------------

    *help {
        var lines;
        lines = [
            "LPDisplayLayoutTestWindow ‚Äî purpose:",
            " Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
            " wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
            "",
            "Constructor & convenience:",
            " w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open; // -> a Window",
            " w = LPDisplayLayoutTestWindow.open(nil); // raw meters (no HUD mapping)",
            "",
            "Key methods (instance):",
            " .open -> a Window .close",
            " .setSourceA(\\sym) .setSourceB(\\sym)",
            " .sendPaneText(\\diag, \"...\")",
            " .setHudMap( mapOrNil ) .printHud",
            "",
            "Notes:",
            " - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
            " - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
        ];
        lines.do(_.postln);
        ^this
    }

    *apihelp {
        var lines;
        lines = [
            "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
            " // bring-up (HUD mapped):",
            " ~hud = LPDisplayHudMap.new(-6, -60, 1.0);",
            " ~inst = LPDisplayLayoutTestWindow.new(~hud);",
            " ~win = ~inst.open; // -> a Window",
            "",
            " // swap sources:",
            " ~inst.setSourceA(\\srcC);",
            " ~inst.setSourceB(\\srcA);",
            "",
            " // pane text:",
            " ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
            "",
            " // HUD on/off:",
            " ~inst.setHudMap(nil);",
            " ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
            "",
            " // console levels on/off:",
            " ~inst.setConsoleLevelsOn(true);   // enable A/B level prints",
            " ~inst.setConsoleLevelsOn(false);  // disable prints (default)",
            "",
            " // class-side one-liner:",
            " LPDisplayLayoutTestWindow.open(nil); // raw meters"
        ];
        lines.do(_.postln);
        ^this
    }

    *test {
        var inst, win, passOsc, posted;
        inst = this.new(nil); // raw meters (no HUD)
        win  = inst.open;     // -> a Window
        // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
        AppClock.sched(0.5, {
            passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };
            inst.setSourceA(\srcC);
            inst.setSourceB(\srcA);
            inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);
            AppClock.sched(1.0, {
                inst.close;
                posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
                posted.postln;
                nil
            });
            nil
        });
        ^win // handy if you want to keep the window reference
    }
}
===== LPDisplay/LPDisplayLayoutTestWindow.sc.txt =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping


Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}
===== LPDisplay/LPDisplaySigChain.sc =====
// LPDisplaySigChain.sc
// v0.9.7.2 ‚Äî minimal [sink, ..., source] JITLib chain wrapper
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local/parameter names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Manage a simple symbol chain [sink, ..., source] using JITLib wiring:
 *   Ndef(left) <<> Ndef(right), where the left node reads \in.ar(2).
 * - Ensure stereo busses prior to wiring; play the sink.
 *
 * Typical usage
 *   LPDisplaySigChain.new([\outA, \srcA]).rebuild;       // wires and plays sink
 *   chain.setTailSource(\srcC).rebuild;                  // swap just the tail
 *   chain.chainToString  // "srcC ‚Üí outA"
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; getters return values.
 */

LPDisplaySigChain {
    classvar classVersion = "0.9.7.2";

    var chainSymbols;  // Array(Symbol): [sink, ..., source]

    *initClass {
        ("LPDisplaySigChain v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |chainSymbolsArray|
        ^super.new.init(chainSymbolsArray ?? { [] })
    }

    init { |chainSymbolsArray|
        chainSymbols = chainSymbolsArray.copy;
        ^this
    }

    size {
        ^chainSymbols.size
    }

    ensureStereo { |ndefKey|
        /*
         * Pre-arm an Ndef as a 2-channel audio node if its bus is missing or not stereo.
         * This prevents wiring failures when we connect nodes with <<>.
         */
        var ndefBus = Ndef(ndefKey).bus;
        if (ndefBus.isNil or: { ndefBus.rate != \audio } or: { ndefBus.numChannels != 2 }) {
            Ndef(ndefKey).ar(2);
        };
        ^this
    }

    rebuild {
        /*
         * Wire the chain left-to-right:
         *   chainSymbols = [sink, mid1, mid2, source]
         * becomes:
         *   Ndef(sink) <<> Ndef(mid1);  Ndef(mid1) <<> Ndef(mid2);  Ndef(mid2) <<> Ndef(source)
         * and then play the sink stereo.
         */
        var chainSize  = chainSymbols.size;
        var linkIndex  = 0;

        if (chainSize < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
            ^this
        };

        chainSymbols.do { |ndefSymbol| this.ensureStereo(ndefSymbol) };

        while({ linkIndex < (chainSize - 1) }, {
            Ndef(chainSymbols[linkIndex]) <<> Ndef(chainSymbols[linkIndex + 1]);
            linkIndex = linkIndex + 1;
        });

        Ndef(chainSymbols[0]).play(numChannels: 2);  // play the sink
        ^this
    }

    chainToString {
        // For display we show "source ‚Üí ... ‚Üí sink"
        var forwardList = chainSymbols.copy.reverse;
        ^forwardList.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |tailSourceSymbol|
        // Replace/append the final element (source) and keep the chain consistent.
        var newSourceSymbol = tailSourceSymbol.asSymbol;

        if (chainSymbols.size >= 2) {
            chainSymbols[chainSymbols.size - 1] = newSourceSymbol;
        } {
            chainSymbols = chainSymbols.add(newSourceSymbol);
        };

        ^this.rebuild
    }

    symbols {
        // Read-only copy so external code doesn‚Äôt mutate internal state.
        var symbolsCopy = chainSymbols.copy;
        ^symbolsCopy
    }



	////////
	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplaySigChain ‚Äî purpose:",
        "  Wrap a symbol chain [sink, ..., source] and wire via:",
        "    Ndef(left) <<> Ndef(right)  (sink reads \\in.ar(2))",
        "",
        "Constructor:",
        "  LPDisplaySigChain.new([\\outA, \\srcA])",
        "",
        "Key methods:",
        "  .rebuild()                   // ensure stereo, wire, play sink",
        "  .setTailSource(\\srcC)       // swap the final source and rebuild",
        "  .chainToString               // e.g., 'srcC ‚Üí outA'",
        "  .symbols                     // copy of [sink, ..., source]",
        ""
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplaySigChain.apihelp ‚Äî quick recipes:",
        "  c = LPDisplaySigChain.new([\\outA, \\srcA]).rebuild;",
        "  c.setTailSource(\\srcC);",
        "  c.chainToString.postln;  // 'srcC ‚Üí outA'",
        "",
        "Note: Ensure sinks read \\in.ar(2) and that sources produce stereo."
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var srcKey, sinkKey, chain, okFlag;

    // Use single-backslash for Symbol literals:
    srcKey  = \_lpdisp_test_src;
    sinkKey = \_lpdisp_test_sink;

    okFlag  = true;

    Server.default.waitForBoot({
        // ephemeral test nodes
        Ndef(srcKey,  { PinkNoise.ar(0.02 ! 2) });  // quiet stereo
        Ndef(sinkKey, {
            var sig = \in.ar(2);
            // no SendPeakRMS here to keep test minimal
            sig
        });

        chain = this.new([sinkKey, srcKey]).rebuild;

        // brief run, then cleanup
        AppClock.sched(0.4, {
            var busOk;
            busOk = Ndef(sinkKey).bus.notNil and: { Ndef(sinkKey).isPlaying };
            if (busOk.not) { okFlag = false };

            Ndef(sinkKey).stop;
            Ndef(srcKey).clear(0.2);  // fade out

            ("LPDisplaySigChain.test: " ++ (okFlag.if("PASS", "FAIL"))).postln;
            nil
        });
    });
    ^this
}

}
===== LPDisplay/older versions/LPDisplayHudMap copy.sc_v0.9.4 =====
// LPDisplayHudMap
// v0.9.4 ‚Äî dB‚ÜíUI mapping (top/floor/gamma) + preview/print
// MD 20251001


// This class at the moment is just rescaling values between 0 and 1 for the meters to more perceptually correct relationships. Top, floor, gamma. It is optional.

LPDisplayHudMap {
    classvar classVersion = "0.9.4";

    var topDb;
    var floorDb;
    var gamma;

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDb, floorDb, gamma|
        ^super.new.init(
            topDb ?? { -6.0 },
            floorDb ?? { -60.0 },
            gamma  ?? { 1.0 }
        )
    }

    init { |t, f, g|
        topDb   = t.asFloat;
        floorDb = f.asFloat;
        gamma   = g.asFloat.max(1e-6);
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        var k = key.asSymbol;
        var v = value.asFloat;
        if (k == \top)   { topDb = v };
        if (k == \floor) { floorDb = v };
        if (k == \gamma) { gamma = v.max(1e-6) };
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |lin|
        var v   = lin.max(1e-9);
        var vdb = v.ampdb;
        var tdb = topDb, fdb = floorDb, g = gamma;
        vdb = vdb.clip(fdb, tdb);
        ^(((vdb - fdb) / (tdb - fdb)).pow(g)).clip(0.0, 1.0)
    }

    preview { |db|
        var lin = db.dbamp.clip(1e-9, 1.0);
        var u   = this.mapLinToUi(lin);
        ("HUD UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
        ^u
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }
}
===== LPDisplay/older versions/LPDisplayHudMap.sc_buggy =====
// LPDisplayHudMap.sc
// v0.9.2 - dB‚ÜíUI mapping for meters (top/floor/gamma) + preview/print
// MD 20251001

/* Purpose
 - Provide a reusable mapping from linear RMS (0..1) to UI (0..1) using dB headroom
   and a perceptual gamma. Includes helpers to set, preview and print.
 Style
 - var-first declarations in every method block
 - lowercase method names
 - no non-local returns (^) in function blocks; normal method returns via last expr
*/

LPDisplayHudMap {
    classvar <>version;
    classvar <>defaultTopDb = -6.0, <>defaultFloorDb = -60.0, <>defaultGamma = 1.0;

    var topDb;
    var floorDb;
    var gamma;

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplayHudMap v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDb, floorDb, gamma|
        var obj, t, f, g;
        t = topDb ?? { defaultTopDb };
        f = floorDb ?? { defaultFloorDb };
        g = gamma  ?? { defaultGamma };
        obj = super.new;
        obj.init(t, f, g);
        obj
    }

    init { |t, f, g|
        var tg;
        topDb = t.asFloat;
        floorDb = f.asFloat;
        tg = g.asFloat.max(1e-6);
        gamma = tg;
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            ("LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.").postln;
        };
        this
    }

    set { |key, value|
        var k, v, tmp;
        k = key.asSymbol;
        v = value.asFloat;
        if (k == \top) { topDb = v };
        if (k == \floor) { floorDb = v };
        if (k == \gamma) { gamma = v.max(1e-6) };
        if (topDb <= floorDb) {
            tmp = topDb;
            topDb = floorDb + 0.1;
            ("LPDisplayHudMap: adjusted top to floor+0.1 (was " ++ tmp ++ ")").postln;
        };
        this
    }

    mapLinToUi { |lin|
        var v, vdb, tdb, fdb, g, u;
        v = lin.max(1e-9);
        vdb = v.ampdb;
        tdb = topDb.asFloat;
        fdb = floorDb.asFloat;
        g = gamma.asFloat.max(1e-6);
        vdb = vdb.clip(fdb, tdb);
        u = (vdb - fdb) / (tdb - fdb);
        u = u.pow(g);
        u.clip(0.0, 1.0)
    }

    preview { |db|
        var lin, dbClipped, u;
        lin = db.dbamp.clip(1e-9, 1.0);
        dbClipped = lin.ampdb.clip(floorDb, topDb);
        u = (dbClipped - floorDb) / (topDb - floorDb);
        u = u.pow(gamma);
        ("HUD UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
        u
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        this
    }
}

===== LPDisplay/older versions/LPDisplayLayoutTestWindow copy.txt =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.1 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1‚ÄØHz),
- has methods
        open, close
        setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
        sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
        setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
    LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
    LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
 */

LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.1";

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // optional; if nil, the meters take raw SendPeakRMS linear RMS.

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } }; //closes any same name window
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------


	/* Make one labeled pane (internal helper)
 * Returns a UserView that draws a border and hosts a label + provided content.
 */
makePane { |content, label|
    var labelView, inner, pane, inset;

    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);

    inner = VLayout(labelView, content);

    pane = UserView().layout_(inner);

    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(
                inset, inset,
                v.bounds.width  - (2 * inset),
                v.bounds.height - (2 * inset)
            ));
            Pen.stroke;
        };
    });

    ^pane
}


    buildWindow {
        //var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

/*        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };*/

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 2) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
			var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_buggy =====
// LPDisplayLayoutTestWindow.sc
// v0.9.2 - Grid window with A/B chains, LevelIndicators, OSC responders & console prints
// MD 20251001

/* Purpose
 - Recreate (and organize) the Layout Test window as a class with:
   labeled panes (left/right/system/diag/choices/recv), moving meters for A/B via
   SendPeakRMS, readable chain labels, quick methods to change tail sources, optional HUD mapping.
 - Keeps console level printers with ~1 Hz decimation and first-message dumps.
 Style
 - var-first declarations in every method block
 - lowercase method names; no non-local returns (^) inside function blocks
 - GUI updates via AppClock.defer; sinks read \in.ar(2)
 - JITLib operator strictly Ndef(left) <<> Ndef(right)
*/

LPDisplayLayoutTestWindow {
    classvar version;

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC names/defs
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // LPDisplayHudMap or nil

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplayLayoutTestWindow v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        var obj;
        obj = super.new;
        obj.init(hudMapInstance);
        obj
    }

    init { |hudMapInstance|
        var hm;
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        hm = hudMapInstance;
        hudMap = hm;
        paneColor = Color(0.0, 0.35, 0.0);
        this
    }

    // -------------------------- Public API --------------------------

    open {
        var wasOpen;
        wasOpen = false;
        Window.allWindows.do({ |w| if (w.name == "Layout Test", { wasOpen = true; w.close }) });
        this.buildWindow;
        this.bootAndBuildGraph;
        window // -> a Window
    }

    close {
        var a, b, ca, cb;
        if (window.notNil) {
            a = OSCdef(oscNameA);
            b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA);
            cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
            window.close;
            window = nil;
        };
        this
    }

    setSourceA { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainA.notNil) {
            chainA.setTailSource(s);
            { topLeftText.string_(chainA.chainToString) }.defer;
        };
        this
    }

    setSourceB { |srcSym|
        var s;
        s = srcSym.asSymbol;
        if (chainB.notNil) {
            chainB.setTailSource(s);
            { topRightText.string_(chainB.chainToString) }.defer;
        };
        this
    }

    sendPaneText { |paneKey, aString|
        var k, t;
        k = paneKey.asSymbol;
        t = aString.asString;
        if (k == \left)  { { topLeftText.string_(t)  }.defer };
        if (k == \right) { { topRightText.string_(t) }.defer };
        if (k == \system)  { { systemText.string_(t)  }.defer };
        if (k == \diag)    { { diagText.string_(t)    }.defer };
        if (k == \choices) { { choicesText.string_(t) }.defer };
        if (k == \recv)    { { recvText.string_(t)    }.defer };
        this
    }

    setHudMap { |mapOrNil|
        var m;
        m = mapOrNil;
        hudMap = m;
        this
    }

    printHud {
        var m;
        m = hudMap;
        if (m.notNil) { m.print } { "HUD mapping: none (raw 0..1)".postln };
        this
    }

    // ------------------------ Internal build steps ------------------------

    buildWindow {
        var buildLabeledPane;

        buildLabeledPane = { |content, label|
            var labelViewLocal, innerLocal, paneLocal, inset;
            labelViewLocal = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            innerLocal = VLayout(labelViewLocal, content);
            paneLocal = UserView().layout_(innerLocal);
            paneLocal.drawFunc_({ |v|
                var insetLocal;
                insetLocal = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(insetLocal, insetLocal, v.bounds.width - (2 * insetLocal), v.bounds.height - (2 * insetLocal)));
                    Pen.stroke;
                };
            });
            paneLocal
        };

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                buildLabeledPane.(HLayout(
                    topLeftText  = TextView().editable_(false),
                    topLeftMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Left Pane"),
                buildLabeledPane.(HLayout(
                    topRightText  = TextView().editable_(false),
                    topRightMeter = LevelIndicator().fixedWidth_(30)
                ), "Top Right Pane")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), systemText  = TextView()), "System State"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), diagText    = TextView()), "Diagnostic Messages")
            ],
            [
                buildLabeledPane.(VLayout(StaticText().align_(\center), choicesText = TextView()), "Choices"),
                buildLabeledPane.(VLayout(StaticText().align_(\center), recvText    = TextView()), "Receiving Commands")
            ]
        );

        window.onClose = {
            var a, b, ca, cb;
            a = OSCdef(oscNameA); b = OSCdef(oscNameB);
            ca = OSCdef(oscConsoleA); cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        this
    }

    bootAndBuildGraph {
        var valueFromMsg;

        Server.default.waitForBoot({
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI
            {
                topLeftText.string_(chainA.chainToString);
                topRightText.string_(chainB.chainToString);
            }.defer;

            // (Re)bind OSC responders (avoid duplicates)
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Extract last numeric value (typically RMS)
            valueFromMsg = { |msg|
                var v, sz;
                v = 0.0;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meter updaters (20 Hz)
            OSCdef(oscNameA, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topLeftMeter.value_(ui) }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v, ui;
                v = valueFromMsg.(msg);
                ui = if (hudMap.notNil) { hudMap.mapLinToUi(v) } { v };
                { topRightMeter.value_(ui) }.defer;
            }, '/peakrmsB');

            // Console printers (~1 Hz via decimation) + first-message dump
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (must read \in.ar(2)) + SendPeakRMS
        // Keep replyIDs A=1, B=2 to match earlier dumps.
        Ndef(\outA, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig;
            sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        this
    }
}

===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.4 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.2 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01
/*
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.2";  // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms     = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi  = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms     = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi  = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.6 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.6 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.6

 * - Pre-create pane views before composing layout to avoid nil during deferred updates
 * - Nil-safe deferred UI writes
 * - onClose only frees resources; close() handles actual window close
 * - Conventional SC class style (*new, *open, ^this / ^window)
 */

LPDisplayLayoutTestWindow {
    classvar version;

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // LPDisplayHudMap or nil

    *initClass {
        version = "0.9.6";
        ("LPDisplayLayoutTestWindow v" ++ version ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } };
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------

    buildWindow {
        var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc_v0.9.7.1 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.1 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*

 * 0.9.7.1 move makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1‚ÄØHz),
- has methods
        open, close
        setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
        sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
        setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping

Works with:
    LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
    LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.
 */

LPDisplayLayoutTestWindow {
    classvar classVersion = "0.9.7.1";

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // --- Meter mapping (optional)
    var hudMap; // optional; if nil, the meters take raw SendPeakRMS linear RMS.

    *initClass {
        ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |hudMapInstance|
        ^super.new.init(hudMapInstance)
    }

    *open { |hudMapInstance|
        ^this.new(hudMapInstance).open
    }

    init { |hudMapInstance|
        hudMap      = hudMapInstance;     // may be nil ‚áí raw 0..1 meters
        paneColor   = Color(0.0, 0.35, 0.0);
        oscNameA    = \rmsA_toGUI;
        oscNameB    = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;
        ^this
    }

    // ---------------------- Public API ----------------------

    open {
        Window.allWindows.do { |w| if (w.name == "Layout Test") { w.close } }; //closes any same name window
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        var a = OSCdef(oscNameA);
        var b = OSCdef(oscNameB);
        var ca = OSCdef(oscConsoleA);
        var cb = OSCdef(oscConsoleB);
        if (a.notNil)  { a.free };
        if (b.notNil)  { b.free };
        if (ca.notNil) { ca.free };
        if (cb.notNil) { cb.free };
        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |srcSym|
        if (chainA.notNil) {
            chainA.setTailSource(srcSym);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |srcSym|
        if (chainB.notNil) {
            chainB.setTailSource(srcSym);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var k = paneKey.asSymbol, t = aString.asString;
        {
            if (k == \left    and: { topLeftText.notNil  }) { topLeftText.string_(t)  };
            if (k == \right   and: { topRightText.notNil }) { topRightText.string_(t) };
            if (k == \system  and: { systemText.notNil   }) { systemText.string_(t)   };
            if (k == \diag    and: { diagText.notNil     }) { diagText.string_(t)     };
            if (k == \choices and: { choicesText.notNil  }) { choicesText.string_(t)  };
            if (k == \recv    and: { recvText.notNil     }) { recvText.string_(t)     };
        }.defer;
        ^this
    }

    setHudMap { |mapOrNil|
        hudMap = mapOrNil; ^this
    }

    printHud {
        if (hudMap.notNil) { hudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // ---------------------- Internal build steps ----------------------


	/* Make one labeled pane (internal helper)
 * Returns a UserView that draws a border and hosts a label + provided content.
 */
makePane { |content, label|
    var labelView, inner, pane, inset;

    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);

    inner = VLayout(labelView, content);

    pane = UserView().layout_(inner);

    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(
                inset, inset,
                v.bounds.width  - (2 * inset),
                v.bounds.height - (2 * inset)
            ));
            Pen.stroke;
        };
    });

    ^pane
}


    buildWindow {
        //var makePane;

        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText   = TextView().editable_(false);
        topLeftMeter  = LevelIndicator().fixedWidth_(30);
        topRightText  = TextView().editable_(false);
        topRightMeter = LevelIndicator().fixedWidth_(30);

        systemText    = TextView();
        diagText      = TextView();
        choicesText   = TextView();
        recvText      = TextView();

/*        makePane = { |content, label|
            var labelView = StaticText().string_(label).align_(\center).stringColor_(Color.white).background_(paneColor);
            var inner     = VLayout(labelView, content);
            var pane      = UserView().layout_(inner);
            pane.drawFunc_({ |v|
                var inset = 0.5;
                Pen.use {
                    Pen.color = paneColor;
                    Pen.width = 1;
                    Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
                    Pen.stroke;
                };
            });
            pane
        };*/

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane.(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane.(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane.(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane.(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane.(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var a = OSCdef(oscNameA), b = OSCdef(oscNameB);
            var ca = OSCdef(oscConsoleA), cb = OSCdef(oscConsoleB);
            if (a.notNil) { a.free };
            if (b.notNil) { b.free };
            if (ca.notNil) { ca.free };
            if (cb.notNil) { cb.free };
            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };

        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var valueFromMsg;

            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: last numeric in message (final RMS)
            valueFromMsg = { |msg|
                var v = 0.0, sz;
                if (msg.notNil) {
                    sz = msg.size;
                    if (sz >= 4) { v = msg[sz - 1].asFloat };
                };
                v.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe
            OSCdef(oscNameA, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(ui) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |msg|
                var v = valueFromMsg.(msg);
                var ui = (hudMap.notNil).if({ hudMap.mapLinToUi(v) }, { v });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(ui) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation)
            OSCdef(oscConsoleA, { |msg|
                var v;
                if (firstDumpA) { ("A first msg: %".format(msg)).postln; firstDumpA = false };
                countA = countA + 1;
                if (countA >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |msg|
                var v;
                if (firstDumpB) { ("B first msg: %".format(msg)).postln; firstDumpB = false };
                countB = countB + 1;
                if (countB >= 20) {
                    v = valueFromMsg.(msg).max(1e-6);
                    ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 1) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
            sig
        });

        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
            sig
        });

        ^this
    }
}
===== LPDisplay/older versions/LPDisplayLayoutTestWindow.sc.0.9.7.3 =====
// LPDisplayLayoutTestWindow.sc
// v0.9.7.3 ‚Äî Grid window with A/B chains, meters via SendPeakRMS, console prints
// MD 2025-10-01

/*
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
- builds a 6‚Äëpane grid GUI with two moving LevelIndicator meters at the top,
- sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
- receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
- posts decimated level prints to the console for A/B (~1 Hz),
- has methods
 open, close
 setSourceA(\sym), setSourceB(\sym) ‚Äî swap the tail source per chain
 sendPaneText(\diag, "‚Ä¶") ‚Äî set any pane text
 setHudMap(mapOrNil), printHud ‚Äî optional meter UI mapping


Works with:
 LPDisplaySigChain ‚Äî the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap ‚Äî optional linear‚ÜíUI mapping (dB headroom + gamma) for the meters.

Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‚ÄòreplyID‚Äô is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/

LPDisplayLayoutTestWindow {
 classvar classVersion = "0.9.7.3"; // printed at class-load time

 // --- UI
 var window;
 var paneColor;
 var topLeftText, topLeftMeter;
 var topRightText, topRightMeter;
 var systemText, diagText, choicesText, recvText;

 // --- Chains
 var chainA; // LPDisplaySigChain
 var chainB; // LPDisplaySigChain

 // --- OSC
 var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
 var firstDumpA = true, firstDumpB = true;
 var countA = 0, countB = 0;

 // --- Meter mapping (optional)
 // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
 var meterHudMap;

 *initClass {
  ("LPDisplayLayoutTestWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
 }

 *new { |meterHudMapInstance|
  // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
  ^super.new.init(meterHudMapInstance)
 }

 *open { |meterHudMapInstance|
  // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
  ^this.new(meterHudMapInstance).open
 }

 init { |meterHudMapInstance|
  // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
  meterHudMap = meterHudMapInstance;

  paneColor = Color(0.0, 0.35, 0.0);

  // OSCdef keys (names) for GUI and console responders
  oscNameA    = \rmsA_toGUI;
  oscNameB    = \rmsB_toGUI;
  oscConsoleA = \rmsA_console;
  oscConsoleB = \rmsB_console;

  ^this
 }

 // ---------------------------- Public API ----------------------------

 open {
  Window.allWindows.do { |existingWindow|
   if (existingWindow.name == "Layout Test") { existingWindow.close }
  }; // ensure only one with this title

  this.buildWindow;
  this.bootAndBuildGraph;
  ^window // -> a Window
 }

 close {
  // Free any live OSCdefs and stop sinks before closing the window
  var oscGuiDefA       = OSCdef(oscNameA);
  var oscGuiDefB       = OSCdef(oscNameB);
  var oscConsoleDefA   = OSCdef(oscConsoleA);
  var oscConsoleDefB   = OSCdef(oscConsoleB);

  if (oscGuiDefA.notNil)     { oscGuiDefA.free };
  if (oscGuiDefB.notNil)     { oscGuiDefB.free };
  if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
  if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

  if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
  if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

  if (window.notNil) {
   // prevent recursive cleanup: onClose will not call back into close()
   window.onClose = { };
   window.close;
   window = nil;
  };
  ^this
 }

 setSourceA { |sourceSymbol|
  if (chainA.notNil) {
   chainA.setTailSource(sourceSymbol);
   {
    if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
   }.defer;
  };
  ^this
 }

 setSourceB { |sourceSymbol|
  if (chainB.notNil) {
   chainB.setTailSource(sourceSymbol);
   {
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;
  };
  ^this
 }

 sendPaneText { |paneKey, aString|
  var paneKeySymbol = paneKey.asSymbol;
  var textString    = aString.asString;

  {
   if (paneKeySymbol == \left    and: { topLeftText.notNil  }) { topLeftText.string_(textString)  };
   if (paneKeySymbol == \right   and: { topRightText.notNil }) { topRightText.string_(textString) };
   if (paneKeySymbol == \system  and: { systemText.notNil   }) { systemText.string_(textString)   };
   if (paneKeySymbol == \diag    and: { diagText.notNil     }) { diagText.string_(textString)     };
   if (paneKeySymbol == \choices and: { choicesText.notNil  }) { choicesText.string_(textString)  };
   if (paneKeySymbol == \recv    and: { recvText.notNil     }) { recvText.string_(textString)     };
  }.defer;

  ^this
 }

 setHudMap { |hudMapOrNil|
  // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
  // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
  meterHudMap = hudMapOrNil;
  ^this
 }

 printHud {
  if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
  ^this
 }

 // ------------------------ Internal build steps ------------------------

 /* Make one labeled pane (internal helper)
  * Returns a UserView that draws a border and hosts a label + provided content.
  */
 makePane { |content, label|
  var labelView, inner, pane, inset;

  labelView = StaticText()
   .string_(label)
   .align_(\center)
   .stringColor_(Color.white)
   .background_(paneColor);

  inner = VLayout(labelView, content);
  pane  = UserView().layout_(inner);

  pane.drawFunc_({ |view|
   inset = 0.5;
   Pen.use {
    Pen.color = paneColor;
    Pen.width = 1;
    Pen.addRect(Rect(
     inset, inset,
     view.bounds.width  - (2 * inset),
     view.bounds.height - (2 * inset)
    ));
    Pen.stroke;
   };
  });

  ^pane
 }

 buildWindow {
  // Pre-create all views explicitly (prevents nil during deferred updates)
  topLeftText   = TextView().editable_(false);
  topLeftMeter  = LevelIndicator().fixedWidth_(30);
  topRightText  = TextView().editable_(false);
  topRightMeter = LevelIndicator().fixedWidth_(30);

  systemText    = TextView();
  diagText      = TextView();
  choicesText   = TextView();
  recvText      = TextView();

  window = Window("Layout Test", Rect(100, 100, 800, 600))
   .background_(Color.white)
   .front;

  window.layout = GridLayout.rows(
   [
    this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
    this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
    this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
   ],
   [
    this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
    this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
   ]
  );

  window.onClose = {
   // Free resources only; do not call window.close here to avoid recursion
   var oscGuiDefA       = OSCdef(oscNameA);
   var oscGuiDefB       = OSCdef(oscNameB);
   var oscConsoleDefA   = OSCdef(oscConsoleA);
   var oscConsoleDefB   = OSCdef(oscConsoleB);

   if (oscGuiDefA.notNil)     { oscGuiDefA.free };
   if (oscGuiDefB.notNil)     { oscGuiDefB.free };
   if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
   if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

   if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
   if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
  };

  ^this
 }

 bootAndBuildGraph {
  Server.default.waitForBoot({
   var extractLinearRmsFromOscMessage;

   this.defineDefaultSourcesAndSinks;

   // Initial chains
   chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
   chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

   // Show full chain strings in the GUI (nil-safe)
   {
    if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
    if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
   }.defer;

   // Avoid duplicates on re-eval
   { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

   // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
   extractLinearRmsFromOscMessage = { |oscMessage|
    var linearRms = 0.0, messageSize;
    if (oscMessage.notNil) {
     messageSize = oscMessage.size;
     if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
    };
    linearRms.clip(0.0, 1.0)
   };

   // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
   OSCdef(oscNameA, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsA');

   OSCdef(oscNameB, { |oscMessage|
    var linearRms    = extractLinearRmsFromOscMessage.(oscMessage);
    var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
    {
     if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
    }.defer;
   }, '/peakrmsB');

   // Console prints (~1 Hz via decimation)
   OSCdef(oscConsoleA, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpA) { ("A first msg: %".format(oscMessage)).postln; firstDumpA = false };
    countA = countA + 1;
    if (countA >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countA = 0;
    };
   }, '/peakrmsA');

   OSCdef(oscConsoleB, { |oscMessage|
    var linearRmsForConsole;
    if (firstDumpB) { ("B first msg: %".format(oscMessage)).postln; firstDumpB = false };
    countB = countB + 1;
    if (countB >= 20) {
     linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
     ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1)) ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
     countB = 0;
    };
   }, '/peakrmsB');
  });
  ^this
 }

 defineDefaultSourcesAndSinks {
  // SOURCES (stereo)
  Ndef(\srcZ, { Silent.ar(numChannels: 2) });
  Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
  Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
  Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

  // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
  // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
  // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
  // but keeping these IDs preserves compatibility with prior tools and logs.
  Ndef(\outA, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
    sig
  });

  Ndef(\outB, {
    var sig = \in.ar(2);
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
    sig
  });

  ^this
 }

 // --- Utility: docs & smoke test (add-only) -----------------------------

 *help {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow ‚Äî purpose:",
        "  Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
        "  wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
        "",
        "Constructor & convenience:",
        "  w = LPDisplayLayoutTestWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open;  // -> a Window",
        "  w = LPDisplayLayoutTestWindow.open(nil);  // raw meters (no HUD mapping)",
        "",
        "Key methods (instance):",
        "  .open -> a Window     .close",
        "  .setSourceA(\\sym)    .setSourceB(\\sym)",
        "  .sendPaneText(\\diag, \"...\")",
        "  .setHudMap( mapOrNil )  .printHud",
        "",
        "Notes:",
        "  - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
        "  - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
    ];
    lines.do(_.postln);
    ^this
 }

 *apihelp {
    var lines;
    lines = [
        "LPDisplayLayoutTestWindow.apihelp ‚Äî useful snippets:",
        "  // bring-up (HUD mapped):",
        "  ~hud  = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  ~inst = LPDisplayLayoutTestWindow.new(~hud);",
        "  ~win  = ~inst.open;  // -> a Window",
        "",
        "  // swap sources:",
        "  ~inst.setSourceA(\\srcC);",
        "  ~inst.setSourceB(\\srcA);",
        "",
        "  // pane text:",
        "  ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
        "",
        "  // HUD on/off:",
        "  ~inst.setHudMap(nil);",
        "  ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
        "",
        "  // class-side one-liner:",
        "  LPDisplayLayoutTestWindow.open(nil);  // raw meters"
    ];
    lines.do(_.postln);
    ^this
 }

 *test {
    var inst, win, passOsc, posted;

    inst = this.new(nil);        // raw meters (no HUD)
    win  = inst.open;            // -> a Window

    // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
    AppClock.sched(0.5, {
        passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };

        inst.setSourceA(\srcC);
        inst.setSourceB(\srcA);
        inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);

        AppClock.sched(1.0, {
            inst.close;
            posted = "LPDisplayLayoutTestWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
            posted.postln;
            nil
        });
        nil
    });

    ^win // handy if you want to keep the window reference
 }
}
===== LPDisplay/older versions/LPDisplaySigChain.sc_buggy =====
// LPDisplaySigChain.sc
// v0.9.2 - minimal [sink, ..., source] chain wrapper with JITLib wiring
// MD 20251001

/* Purpose
 - Manage a simple symbol chain [sink, ... , source] using Ndef and <<> wiring.
 - Ensure stereo busses for nodes prior to wiring; play the sink.
 - Provide a readable string form and a method to switch the tail source.
 Style
 - var-first declarations in every method block
 - lowercase method names / descriptive names
 - JITLib operator strictly Ndef(left) <<> Ndef(right)
 - no non-local returns (^) in function blocks
*/

LPDisplaySigChain {
    classvar <>version;

    var chainArray; // [sink, ..., source] (Symbols)

    *initClass {
        var v;
        v = "0.9.2";
        version = v;
        ("LPDisplaySigChain v" ++ v ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |symbolsArray|
        var obj;
        obj = super.new;
        obj.init(symbolsArray ?? { [] });
        obj
    }

    init { |symbolsArray|
        var arr;
        arr = symbolsArray.copy;
        chainArray = arr;
        this
    }

    size {
        var n;
        n = chainArray.size;
        n
    }

    ensureStereo { |key|
        var bus;
        bus = Ndef(key).bus;
        if (bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2); // pre-arm
        };
        this
    }

    rebuild {
        var i, n;
        n = chainArray.size;
        if (n < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
        } {
            chainArray.do({ |sym| this.ensureStereo(sym) });
            i = 0;
            while({ i < (n - 1) }, {
                Ndef(chainArray[i]) <<> Ndef(chainArray[i + 1]); // sink receives from next
                i = i + 1;
            });
            Ndef(chainArray[0]).play(numChannels: 2);
        };
        this
    }

    chainToString {
        var forward;
        forward = chainArray.copy.reverse; // [source ... sink] for display
        forward.collect(_.asString).join(" ‚Üí ")
    }

    setTailSource { |srcSym|
        var newSym;
        newSym = srcSym.asSymbol;
        if (chainArray.size >= 2) {
            chainArray[chainArray.size - 1] = newSym;
        } {
            chainArray = chainArray.add(newSym);
        };
        this.rebuild
    }

    symbols {
        var copy;
        copy = chainArray.copy;
        copy
    }
}

===== LPDisplay/older versions/starting files/allfiles.txt =====
// commands.scd

// Make a -6 dBFS sine (‚âà -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ‚âà -9 dB RMS
~hud_preview.(-18);
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       ‚Ä¢ 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       ‚Ä¢ pulse clicks and decaying tone pulses for echo testing
       ‚Ä¢ band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       ‚Ä¢ switch A/B sources quickly
       ‚Ä¢ update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready ‚Äî quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands‚Ä¶");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" ‚Üí ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== LPDisplay/older versions/starting files/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (‚âà -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ‚âà -9 dB RMS
~hud_preview.(-18);

===== LPDisplay/older versions/starting files/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== LPDisplay/older versions/starting files/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       ‚Ä¢ 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       ‚Ä¢ pulse clicks and decaying tone pulses for echo testing
       ‚Ä¢ band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       ‚Ä¢ switch A/B sources quickly
       ‚Ä¢ update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready ‚Äî quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands‚Ä¶");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== LPDisplay/older versions/starting files/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" ‚Üí ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== LPDisplay/README_LivePedalboardDisplay.md =====
# LivePedalboardDisplay - README (reStructuredText)

## Overview

LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

-   LPDisplayLayoutTestWindow - a 6-pane grid window with two meters
    (A/B) driven by SendPeakRMS, plus simple control methods.
-   LPDisplaySigChain - a helper to wire a symbol chain \[sink, \...,
    source\] using Ndef(left) \<\<\> Ndef(right) with stereo pre-arming.
-   LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to
    UI (0..1) using a dB window (top/floor) and gamma.

## Install

Place the .sc files under this path (copy exactly):

::

:   \.../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually
symlinked into Extensions). Then recompile the class library:

::

:   Language -\> Recompile Class Library

When loaded, you should see lines like:

::

:   LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

## Quick Start

SuperCollider snippet (copy/paste into the IDE):

::

:   

    (

    :   var hud = LPDisplayHudMap.new(-6, -60, 1.0); // top/floor/gamma
        \~inst = LPDisplayLayoutTestWindow.new(hud); \~win =
        \~inst.open; // -\> a Window

    )

    // Swap tail sources and write a status line
    \~inst.setSourceA(srcC); \~inst.setSourceB(srcA);
    \~inst.sendPaneText(diag, \"Ready @ \" ++ Date.getDate.stamp);

    // HUD on/off \~inst.setHudMap(nil); // raw 0..1 meters
    \~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close \~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

## Classes

### LPDisplayLayoutTestWindow

-   Builds a 6-pane grid with top-left/right meters (LevelIndicator).
-   Wires two chains: \[outA, srcA\] and \[outB, srcB\] using
    LPDisplaySigChain.
-   Updates meters from SendPeakRMS via OSCdef(rmsA_toGUI) and
    OSCdef(rmsB_toGUI).
-   Prints decimated console levels via OSCdef(rmsA_console) and
    OSCdef(rmsB_console).
-   Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw
    values).

### Why replyID?

We keep replyID as A=1 and B=2 in SendPeakRMS.kr(\..., \'/peakrmsA\', 1)
and (\..., \'/peakrmsB\', 2) to preserve continuity with older
dumps/tools. The OSC addresses already differ; replyID is kept for
backward compatibility.

### Key instance methods

-   open -\> Window, close
-   setSourceA(sym), setSourceB(sym)
-   sendPaneText(leftsystemchoices\|recv, \"text\")
-   setHudMap(instanceOrNil), printHud

### Class-side utilities

-   .help, .apihelp, .test

### LPDisplaySigChain

-   Wires a chain \[sink, \..., source\] using Ndef(left) \<\<\>
    Ndef(right).
-   Ensures stereo busses and plays the sink.
-   Key methods: rebuild, size, symbols (copy), setTailSource(srcX),
    chainToString.
-   Class-side utilities: .help, .apihelp, .test

### LPDisplayHudMap

-   Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor)
    and gamma.
-   Pass nil to the window\'s setHudMap to bypass mapping and show raw
    values.
-   Key methods: set(topgamma, value), mapLinToUi(linearRms),
    preview(rmsDb), print.
-   Class-side utilities: .help, .apihelp, .test

## Smoke Tests

Run these in SuperCollider:

::

:   LPDisplaySigChain.test; // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test; // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips
    sources, closes

## Troubleshooting

-   

    Meters not moving:

    :   OSCdef(rmsA_toGUI).notNil; OSCdef(rmsB_toGUI).notNil. Sinks must
        read `\in.ar(2)`. Chains should be playing (sink Ndef is
        .play\'ed by LPDisplaySigChain.rebuild). If you changed sink OSC
        addresses, update the OSCdef addresses accordingly.

-   

    [string]() DNU on nil:

    :   The window pre-creates views. If you extend it, create views
        first, then compose the layout; update UI via `{ ... }.defer`
        with notNil guards.

-   

    Compile errors after edits:

    :   Class-side methods (*help,*apihelp, \*test) must be at class
        scope (not nested). Symbol literals use a single backslash:
        `\symbol` (not `\\symbol`).

## Style and Conventions

-   \*new { \^super.new.init(\...) }
-   var-first in method bodies; clear names
-   No non-local returns inside inner Functions
-   GUI updates via `{ ... }.defer`
-   JITLib wiring strictly `Ndef(left) <<> Ndef(right)`
-   Sinks read `\in.ar(2)`

## Versioning

Each class defines classVersion and prints a banner at class load time.
You should see lines like these after a recompile:

::

:   LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

## Optional: One-button regression

Save as this path (copy exactly):

::

:   LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::

:   

    (

    :   var hudPass, sigPass, win, posted; hudPass =
        LPDisplayHudMap.test; sigPass = { LPDisplaySigChain.test; true
        }.value; win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, { var allGreen = hudPass and: sigPass;
        (\"LivePedalboardDisplay SMOKE: \" ++ (allGreen.if(\"PASS\",
        \"WARN/FAIL\"))).postln; nil });

    )

===== LPDisplay/README_LivePedalboardDisplay.rst =====
LivePedalboardDisplay - README (reStructuredText)
=================================================

Overview
--------
LivePedalboardDisplay is a small toolkit for SuperCollider. It provides:

- LPDisplayLayoutTestWindow - a 6-pane grid window with two meters (A/B) driven by SendPeakRMS, plus simple control methods.
- LPDisplaySigChain - a helper to wire a symbol chain [sink, ..., source] using Ndef(left) <<> Ndef(right) with stereo pre-arming.
- LPDisplayHudMap - an optional mapper converting linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.

Install
-------
Place the .sc files under this path (copy exactly):

::
    .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/

Ensure the LivePedalboardSuite root is scanned by SuperCollider (usually symlinked into Extensions). Then recompile the class library:

::
    Language -> Recompile Class Library

When loaded, you should see lines like:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Quick Start
-----------
SuperCollider snippet (copy/paste into the IDE):

::
    (
        var hud = LPDisplayHudMap.new(-6, -60, 1.0);  // top/floor/gamma
        ~inst = LPDisplayLayoutTestWindow.new(hud);
        ~win  = ~inst.open;  // -> a Window
    )

    // Swap tail sources and write a status line
    ~inst.setSourceA(\srcC);
    ~inst.setSourceB(\srcA);
    ~inst.sendPaneText(\diag, "Ready @ " ++ Date.getDate.stamp);

    // HUD on/off
    ~inst.setHudMap(nil);                             // raw 0..1 meters
    ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;

    // Close
    ~inst.close;

    // Or class-side open (raw meters):
    LPDisplayLayoutTestWindow.open(nil);

Classes
-------
LPDisplayLayoutTestWindow
^^^^^^^^^^^^^^^^^^^^^^^^^^
- Builds a 6-pane grid with top-left/right meters (LevelIndicator).
- Wires two chains: [\outA, \srcA] and [\outB, \srcB] using LPDisplaySigChain.
- Updates meters from SendPeakRMS via OSCdef(\rmsA_toGUI) and OSCdef(\rmsB_toGUI).
- Prints decimated console levels via OSCdef(\rmsA_console) and OSCdef(\rmsB_console).
- Optional HUD mapping via an LPDisplayHudMap instance (or nil for raw values).

Why replyID?
^^^^^^^^^^^^
We keep replyID as A=1 and B=2 in SendPeakRMS.kr(..., '/peakrmsA', 1) and (..., '/peakrmsB', 2) to preserve continuity with older dumps/tools. The OSC addresses already differ; replyID is kept for backward compatibility.

Key instance methods
^^^^^^^^^^^^^^^^^^^^^
- open -> Window, close
- setSourceA(\sym), setSourceB(\sym)
- sendPaneText(\left|\right|\system|\diag|\choices|\recv, "text")
- setHudMap(instanceOrNil), printHud

Class-side utilities
^^^^^^^^^^^^^^^^^^^^^
- .help, .apihelp, .test

LPDisplaySigChain
^^^^^^^^^^^^^^^^^^
- Wires a chain [sink, ..., source] using Ndef(left) <<> Ndef(right).
- Ensures stereo busses and plays the sink.
- Key methods: rebuild, size, symbols (copy), setTailSource(\srcX), chainToString.
- Class-side utilities: .help, .apihelp, .test

LPDisplayHudMap
^^^^^^^^^^^^^^^^
- Maps linear RMS (0..1) to UI (0..1) using a dB window (top/floor) and gamma.
- Pass nil to the window's setHudMap to bypass mapping and show raw values.
- Key methods: set(\top|\floor|\gamma, value), mapLinToUi(linearRms), preview(rmsDb), print.
- Class-side utilities: .help, .apihelp, .test

Smoke Tests
------------
Run these in SuperCollider:

::
    LPDisplaySigChain.test;         // PASS/FAIL (wire/play sink)
    LPDisplayHudMap.test;           // PASS (monotonicity/bounds)
    LPDisplayLayoutTestWindow.test; // opens, checks OSCdefs, flips sources, closes

Troubleshooting
---------------
- Meters not moving:
    OSCdef(\rmsA_toGUI).notNil;  OSCdef(\rmsB_toGUI).notNil.
    Sinks must read ``\in.ar(2)``. Chains should be playing (sink Ndef is .play'ed by LPDisplaySigChain.rebuild).
    If you changed sink OSC addresses, update the OSCdef addresses accordingly.

- string_ DNU on nil:
    The window pre-creates views. If you extend it, create views first, then compose the layout; update UI via ``{ ... }.defer`` with notNil guards.

- Compile errors after edits:
    Class-side methods (*help, *apihelp, *test) must be at class scope (not nested).
    Symbol literals use a single backslash: ``\symbol`` (not ``\\symbol``).

Style and Conventions
----------------------
- *new { ^super.new.init(...) }
- var-first in method bodies; clear names
- No non-local returns inside inner Functions
- GUI updates via ``{ ... }.defer``
- JITLib wiring strictly ``Ndef(left) <<> Ndef(right)``
- Sinks read ``\in.ar(2)``

Versioning
----------
Each class defines classVersion and prints a banner at class load time. You should see lines like these after a recompile:

::
    LPDisplayHudMap vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplaySigChain vX.Y.Z loaded (LivePedalboardDisplay)
    LPDisplayLayoutTestWindow vX.Y.Z loaded (LivePedalboardDisplay)

Optional: One-button regression
--------------------------------
Save as this path (copy exactly):

::
    LivePedalboardDisplay/Tests/LPDisplay_Smoke_All.scd

SuperCollider script:

::
    (
        var hudPass, sigPass, win, posted;
        hudPass = LPDisplayHudMap.test;
        sigPass = { LPDisplaySigChain.test; true }.value;
        win = LPDisplayLayoutTestWindow.test;
        AppClock.sched(2.0, {
            var allGreen = hudPass and: sigPass;
            ("LivePedalboardDisplay SMOKE: " ++ (allGreen.if("PASS", "WARN/FAIL"))).postln;
            nil
        });
    )
===== MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation‚Äôs audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through ‚Äúprocessor‚Äù that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) ‚Üí short delay ‚Üí mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through ‚Äúprocessor‚Äù you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== MagicPedalboard/Adapter_UIHook_Install.scd =====
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)

===== MagicPedalboard/bootstrap_audio_and_fx_min.scd =====
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) ‚Äì guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) ‚Äì matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)

===== MagicPedalboard/compat/Compat_MagicDisplayGUI_QueueUi_Ext.sc =====
// Compat_MagicDisplayGUI_QueueUi_Ext.sc
// v0.1.1
// MD 2025-09-23

+MagicDisplayGUI {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

+MagicDisplayGUI_GridDemo {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

===== MagicPedalboard/demo_apply_after_fix.scd =====
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_hotfix.scd =====
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON ‚Üí OFF ‚Üí final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_now.scd =====
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_milestone.scd =====
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)

===== MagicPedalboard/demo_commandtree_preformed_queues.scd =====
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <‚Äî Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)

===== MagicPedalboard/Demo_Install_MinProcessors.scd =====
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)

===== MagicPedalboard/Diag_BusChannel_Map.scd =====
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2‚Üí1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)

===== MagicPedalboard/docs and references/cheatsheet.scd =====
// cheatsheet.cd
// MD 20250913-1037

// Inspect
~pedalboard.printChains;            // or use your display adaptor

// Build NEXT non-destructively
~pedalboard.add(\delay);
~pedalboard.bypass(\delay, true);
~pedalboard.swap(1, 2);

// Go live with a short crossfade
~pedalboard.switchChain(0.1);

// Adjust CURRENT temporarily
~pedalboard.bypassAtCurrent(1, false);

// Change sources
~pedalboard.setSource(\ts1);
~pedalboard.setSourceCurrent(\ts2);

// Panic-safe reset
~pedalboard.reset;

===== MagicPedalboard/docs and references/README.md =====

# MagicPedalboardNew ‚Äì JITLib/Ndef A/B Pedalboard

**Versions**
- `MagicPedalboardNew.sc` **v0.3.8**
- `MagicDisplay.sc` **v0.1.2**
- `MagicDisplayGUI.sc` **v0.2.3**

## Overview
`MagicPedalboardNew` manages two parallel JITLib Ndef chains (`\chainA` and `\chainB`) for live performance. One chain is CURRENT (audible), the other is NEXT (prepared silently). You can mutate NEXT and then switch to it using a short crossfade.

## Architecture
- Chains are Arrays of Symbols: `[sink, ‚Ä¶ processors ‚Ä¶, source]`
- Sinks: `\chainA`, `\chainB`
- Sources/processors: other Ndef keys (e.g., `	sSaw`, `	remolo`)
- Bypass tracked per chain using dictionaries
- Effective list excludes bypassed processors

## Display Adaptors
### MagicDisplay
- Console logger with `logLevel`
- Methods: `showInit`, `showRebuild`, `showPlay`, `showStop`, `showSwitch`, etc.

### MagicDisplayGUI
- Two columns: CURRENT (green) and NEXT (neutral)
- Top-down flow: source ‚Üí processors ‚Üí sink
- Expectation field + visual countdown
- Operations panel with Next button
- Embedded level meters
- UI-ready queue prevents nil errors

## Style Rules
- Methods start lowercase; no leading underscore
- All `var` declarations first in every method and block
- Descriptive variable names
- No `server.sync`
- Use `Server.default.bind { ‚Ä¶ }` for server ops
- Safe reset only in `reset` using `Server.default.waitForBoot { ‚Ä¶ }`
- Space after accessors (e.g., `classvar < version;`)
- File headers include filename and timestamp like `//MD 20250912-1544`

## Quick Start
```supercollider
Ndef(	s0,  { Silent.ar(2) });
Ndef(	sSaw,{ Saw.ar(200, 0.18) ! 2 });
m = MagicPedalboardNew.new;
m.setSourceCurrent(	sSaw);
m.playCurrent;
m.setSource(	sSaw);
Ndef(	remolo, { arg rate = 4, depth = 0.8; var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1) });
m.add(	remolo);
m.switchChain(0.1);
```

## Troubleshooting
- No sound: check source Ndefs and output device
- Meters update but silent: check routing
- GUI errors: use latest GUI with UI-ready queue
- `'s' not defined`: use `Server.default` in class files

## Version Highlights
- v0.3.8: No reference to `s`; safe reset only in `reset`
- v0.3.5‚Äì0.3.7: Crossfade switching, server ops cleanup
- MagicDisplayGUI v0.2.3: GUI with countdown, ops list, meters

===== MagicPedalboard/docs and references/README2.md =====

# MagicPedalboardNew ‚Äì A/B Chain Manager for Live Audio in SuperCollider

## Introduction
MagicPedalboardNew is a SuperCollider class designed to manage two parallel audio chains using JITLib's Ndef system. It is intended for live performance scenarios where one chain is actively producing sound (CURRENT), and the other is being prepared silently (NEXT). This allows performers to build or modify effects chains in real time and switch between them seamlessly.

## Design Philosophy
The system is built around the idea of non-destructive, real-time manipulation of audio chains. It avoids server resets during normal operation, ensuring stability and continuity of sound. All server interactions are safely wrapped using `Server.default.bind`, and resets are only performed in the `reset` method using `Server.default.waitForBoot`.

## Core Concepts
- **Chains**: Arrays of Symbols representing Ndef keys. Each chain is ordered `[sink, ...processors..., source]`.
- **CURRENT and NEXT**: Two chains, one active and audible (CURRENT), the other silent and editable (NEXT).
- **Switching**: A crossfade mechanism allows smooth transitions from CURRENT to NEXT.
- **Bypassing**: Individual processors can be bypassed without removing them.
- **Effective List**: The chain with bypassed processors removed, used for actual signal routing.

## Class Details
### MagicPedalboardNew
- `currentChain`, `nextChain`: Pointers to the active and editable chains.
- `chainAList`, `chainBList`: Concrete arrays for each chain.
- `bypassA`, `bypassB`: Dictionaries tracking bypassed processors.
- `defaultNumChannels`: Number of audio channels (typically 2).
- `defaultSource`: Default source Ndef key.
- `display`: Optional display adaptor (console or GUI).

### Methods
- `add`, `addAt`, `removeAt`, `swap`, `clearChain`: Modify NEXT chain.
- `bypass`, `bypassAt`: Bypass processors in NEXT.
- `bypassCurrent`, `bypassAtCurrent`: Bypass processors in CURRENT.
- `setSource`, `setSourceCurrent`: Set source for NEXT or CURRENT.
- `switchChain`: Crossfade from CURRENT to NEXT.
- `reset`: Safely reset server and chains.
- `rebuild`, `rebuildUnbound`: Wire chains using `<<>`.

## GUI Explanation
### MagicDisplayGUI
This GUI provides a visual representation of the CURRENT and NEXT chains:
- **Two Columns**: CURRENT (highlighted in green) and NEXT.
- **Top-Down Flow**: Chains are displayed from source (top) to sink (bottom), matching audio signal flow.
- **Expectation Field**: A text area describing what the user should hear. This helps performers anticipate changes.
- **Visual Countdown**: A numeric and graphical countdown timer appears before a change, allowing the performer to shift attention.
- **Operations Panel**: Lists upcoming actions with a "Next" button. Pressing it starts a 3-second countdown before executing the action.
- **Embedded Meters**: Real-time level indicators for chainA and chainB, helping monitor audio activity.

## Style Rules
- Methods start lowercase; no leading underscores.
- All `var` declarations appear first in every method and block.
- Descriptive variable names; no single-letter variables.
- No `server.sync`.
- Use `Server.default.bind { ... }` for server operations.
- Safe reset only in `reset` using `Server.default.waitForBoot { ... }`.
- Space after accessors (e.g., `classvar < version;`).
- File headers include filename and timestamp like `//MD 20250912-1544`.

## Quick Start
```supercollider
Ndef(	s0,  { Silent.ar(2) });
Ndef(	sSaw,{ Saw.ar(200, 0.18) ! 2 });
m = MagicPedalboardNew.new;
m.setSourceCurrent(	sSaw);
m.playCurrent;
m.setSource(	sSaw);
Ndef(	remolo, { arg rate = 4, depth = 0.8; var x = \in.ar(2); x * SinOsc.kr(rate).range(1 - depth, 1) });
m.add(	remolo);
m.switchChain(0.1);
```

## Advanced Usage
- Use `bypass` to temporarily disable processors.
- Use `swap` to reorder processors.
- Use `clearChain` to reset NEXT to `[sink, source]`.
- Use `printChains` or GUI to inspect chain structure.

## Troubleshooting
- No sound: Ensure sources are defined and server is running.
- Meters update but silent: Check audio routing and output device.
- GUI errors: Use latest GUI with UI-ready queue.
- `'s' not defined`: Use `Server.default` in class files.

## Version History
- v0.3.8: No reference to `s`; safe reset only in `reset`.
- v0.3.5‚Äì0.3.7: Crossfade switching, server ops cleanup.
- MagicDisplayGUI v0.2.3: GUI with countdown, ops list, meters.

===== MagicPedalboard/docs and references/RUNBOOK.md =====
# MagicPedalboardNew ‚Äì RUNBOOK (v0.3.8) ‚Äî Test‚ÄëSignal Only

**Today‚Äôs rule:** NO MIC. `\ts0` is overridden to an internal test source.

## Steps
1) Boot the server.
2) Open `MPB_Scenarios_v6.scd` in SuperCollider.
3) Evaluate from the top, **line by line**.
4) Audio sanity:
```supercollider
~pedalboard.reset;
~pedalboard.setSource(\testmelody);
~pedalboard.switchChain(0.1);
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
Ndef(\delay).set(\mix, 0.55, \time, 0.45, \fb, 0.4);

===== MagicPedalboard/docs and references/usingLibraryWithMagicPedalboard.scd =====
// usingLibraryWithMagicPedalboard.scd
// MD 20250915-0914


(
// If you‚Äôve loaded MagicProcessorLibrary_defs.scd already:
~procLib.ensureMany([\ts0, \delay, \tremolo, \reverb, \chorus, \drive], 2);

// Then (re)build your pedalboard chains knowing those symbols resolve:
~pedalboard.reset;
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
)

===== MagicPedalboard/editor_commandtree_add_demo_verbs.scd =====
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "‚úÖ Loaded tree for editing.".postln;
} {
    "‚ùå Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)

===== MagicPedalboard/MagicDisplay.sc =====
/* MagicDisplay.sc  v0.1.3
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

	classvar < version, < metersReady, < meterChannels;

	var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose


	*initClass {
		version = "v0.1.3";
		("MagicDisplay " ++ version).postln;

		// default compile-time meter channel count
		meterChannels = 2;
		metersReady = false;

		// define (or re-define) the meter SynthDefs now
		this.ensureMeterDefs(meterChannels);
	}


	*new { |level = 1|
		^super.new.init(level)
	}

	init { |level|
		var initialLevel;
		initialLevel = level ? 1;
		logLevel = initialLevel;
		^this
	}

	help {
		var text;
		text = "MagicDisplay " ++ version
		++ "\nMethods:\n"
		++ "  showInit(pedalboard, versionString, current, next)\n"
		++ "  showRebuild(which, fullChain, effective)\n"
		++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
		++ "  showMutation(action, args, nextChain)\n"
		++ "  showBypass(which, key, state, chain, bypassKeys)\n"
		++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
		++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
		++ "  showError(message)\n";
		text.postln;
	}

	showInit { |pedalboard, versionString, current, next|
		if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
	}

	showRebuild { |which, fullChain, effective|
		if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
	}

	showPlay { |sinkKey|
		if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
	}

	showStop { |sinkKey|
		if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
	}

	showSwitch { |oldSink, newSink, current, next|
		if(logLevel > 0) {
			("[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink
				++ "  current=" ++ current ++ "  next=" ++ next).postln;
		};
	}

	showMutation { |action, args, nextChain|
		if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
	}

	showBypass { |which, key, state, chain, bypassKeys|
		if(logLevel > 0) {
			("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
				++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
		};
	}

	showReset { |current, next|
		if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
	}

	showChains { |current, next, bypassAKeys, bypassBKeys|
		if(logLevel > 0) {
			"MagicPedalboardNew.printChains:".postln;
			("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
			("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
		};
	}

	showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
		var header, formatOne;

		if(logLevel <= 0) { ^this };

		header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

		formatOne = { |titleString, listRef, bypassKeys, effective|
			var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

			lastIndex = listRef.size - 1;
			sinkKey = listRef[0];
			sourceKey = listRef[lastIndex];

			header.(titleString);
			("sink : " ++ sinkKey).postln;

			indexCounter = 1;
			if(listRef.size > 2) {
				"procs:".postln;
				listRef.copyRange(1, lastIndex - 1).do { |procKey|
					var isBypassed, mark;
					isBypassed = bypassKeys.includes(procKey);
					mark = if(isBypassed) { "BYP" } { "ON " };
					lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
					lineText.postln;
					indexCounter = indexCounter + 1;
				};
			}{
				"procs: (none)".postln;
			};

			("src  : " ++ sourceKey).postln;
			("eff  : " ++ effective.join("  ->  ")).postln;
			"".postln;
		};

		formatOne.("CURRENT", current, bypassAKeys, effCurrent);
		formatOne.("NEXT",    next,    bypassBKeys, effNext);
	}

	showError { |message|
		("[MPB:error] " ++ message).warn;
	}

	// ----- meter SynthDefs (class-level) -----

	*ensureMeterDefs { arg ch = 2;
		var n;
		// clamp to a sensible positive integer
		n = ch.asInteger.max(1);
		meterChannels = n;

		// Define (or re-define) once per class init (safe to call again after recompile).
		// Uses compile-time channel count 'n' inside the UGen graph.
		Server.default.bind({
			SynthDef(\busMeterA, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);                 // compile-time 'n'
				var amp  = Amplitude.ar(sig).clip(0, 1);    // per-channel amplitude
				SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
			}).add;

			SynthDef(\busMeterB, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);
				var amp  = Amplitude.ar(sig).clip(0, 1);
				SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
			}).add;
		});

		metersReady = true;
	}

	*setMeterChannels { arg ch = 2;
		// convenience: re-emit defs with a new compile-time channel count
		this.ensureMeterDefs(ch);
	}

}

===== MagicPedalboard/MagicDisplayGUI_Ext_VisualOnly.sc =====
// MagicDisplayGUI_Ext_VisualOnly.sc
// v0.1.1 (fixed: no ivar; uses window property bag instead)
// MD 20250919-08:05 BST

/*
Purpose
- Add "visual-only" layout controls to MagicDisplayGUI without modifying the class file.
- setVisualOnly(true): hides Ops area; recomputes A/B panel heights so they stop above
  the expectation/countdown block; meters group remains at the bottom.
- relayoutVisualOnly: recompute bounds; attachResize wires window.onResize -> relayout.

Style
- AppClock for UI; no server.sync; methods live in a class extension.
- Uses window.setProperty/getProperty(\visualOnlyFlag) instead of new ivars.
*/

+ MagicDisplayGUI {

    // -- helpers to read/write the visual-only flag using the window as property bag
    getVisualOnlyFlag {
        var v;
        v = false;
        if(window.notNil) {
            v = window.getProperty(\visualOnlyFlag) ? false;
        };
        ^v
    }

    setVisualOnly { arg flag = true;
        var on;
        on = flag ? true;
        this.queueUi({
            if(window.notNil) { window.setProperty(\visualOnlyFlag, on) };

            // Hide or show ops widgets
            if(opsListView.notNil)   { opsListView.visible_(on.not) };
            if(opsNextButton.notNil) { opsNextButton.visible_(on.not) };
            if(opsStatusText.notNil) { opsStatusText.visible_(on.not) };

            this.relayoutVisualOnly;  // recompute layout now
        });
        ^this
    }

    relayoutVisualOnly {
        var pad, metersH, expH, expGap, countH, winRect, colGap;
        var visualOnly, rightW, usableW, colW, colH, leftX, rightX;
        var groupLeft, groupTop, groupW, labelW, barW;

        // Geometry constants (aligned to your class)
        pad     = 10;
        metersH = 86;   // meters block height in your class
        expH    = 52;   // expectation text height
        expGap  = 6;    // spacing between expectation and countdown bar row
        countH  = 20;   // countdown row height
        colGap  = 40;   // gap between columns

        visualOnly = this.getVisualOnlyFlag;

        // Window rect fallback if not created yet
        winRect = (window.notNil).if({ window.view.bounds }, { Rect(0, 0, 980, 520) });

        // If visual-only, reclaim the ops panel width
        rightW  = (visualOnly ? 0 : 320);

        // Compute column widths
        usableW = winRect.width - (2 * pad) - rightW - colGap;
        colW    = (usableW / 2).max(220);

        // Compute column heights so panels stop ABOVE the expectation + countdown region
        colH = winRect.height
            - (2 * pad)   // top + bottom padding
            - metersH     // meters area at bottom
            - expH        // expectation text
            - expGap      // spacing
            - countH      // countdown row
            - 12;         // small margin

        colH = colH.max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        this.queueUi({
            // Left/right column panels
            if(leftPanel.notNil)  { leftPanel.bounds  = Rect(leftX,  pad, colW, colH) };
            if(rightPanel.notNil) { rightPanel.bounds = Rect(rightX, pad, colW, colH) };

            // Expectation + countdown spans both columns
            if(expectationText.notNil) {
                expectationText.bounds = Rect(leftX, leftPanel.bounds.bottom + 6, colW*2 + colGap, expH)
            };
            if(countdownLabel.notNil)   {
                countdownLabel.bounds    = Rect(leftX, expectationText.bounds.bottom + expGap, 120, 20)
            };
            if(countdownBarView.notNil) {
                countdownBarView.bounds  = Rect(leftX + 130, expectationText.bounds.bottom + expGap,
                                                (colW*2 + colGap) - 140, 20)
            };

            // Ops area only when not visual-only
            if(visualOnly.not and: { opsListView.notNil }) {
                opsListView.bounds = Rect(expectationText.bounds.right + pad, pad,
                                          rightW - pad, winRect.height - 2 * pad);
                if(opsStatusText.notNil) {
                    opsStatusText.bounds = Rect(opsListView.bounds.left,
                                                opsListView.bounds.bottom - 52,
                                                opsListView.bounds.width - 110, 20)
                };
                if(opsNextButton.notNil) {
                    opsNextButton.bounds = Rect(opsListView.bounds.right - 100,
                                                opsListView.bounds.bottom - 56, 100, 28)
                };
            };

            // Meters group: reuse the parent of meterViewA/B
            if(meterViewA.notNil and: { meterViewB.notNil } and: { meterViewA.parent.notNil }) {
                groupLeft = pad;
                groupTop  = winRect.height - metersH - pad;
                groupW    = winRect.width  - 2*pad;
                meterViewA.parent.bounds = Rect(groupLeft, groupTop, groupW, metersH);

                // child bars
                labelW = 60;
                barW   = groupW - labelW - 10;
                meterViewA.bounds = Rect(labelW + 6, 4, barW, 20);
                meterViewB.bounds = Rect(labelW + 6, 4 + 38, barW, 20);
            };
        });

        ^this
    }

    attachResize {
        this.queueUi({
            if(window.notNil) {
                window.onResize = { this.relayoutVisualOnly };
            };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_FixChoicesColors_Ext.sc =====
// MagicDisplayGUI_FixChoicesColors_Ext.sc
// v0.1.2  ‚Äî MD 2025-09-24 23:10 BST
/*
Purpose
- Make the "Choices" text high-contrast no matter how it is updated:
  updateTextField(\choices, ...) or setOperations([...]).
Style
- Class extension only; NO new ivars; var-first in every method; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    ensureChoicesPanel {
        var host, build;
        host = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        build = {
            var x, y, w, h;
            x = host.bounds.width - 360; y = 8; w = 352; h = 200;

            this.choicesPanel = this.choicesPanel ?? { CompositeView(host) };
            this.choicesPanel
                .background_(Color(0.15, 0.15, 0.15))
                .resize_(5)
                .bounds_(Rect(x, y, w, h));

            this.choicesTitle = this.choicesTitle ?? { StaticText(this.choicesPanel) };
            this.choicesTitle
                .string_("Choices")
                .stringColor_(Color(0.85, 0.85, 0.85))
                .align_(\left)
                .bounds_(Rect(8, 6, w - 16, 20));

            this.choicesText = this.choicesText ?? { TextView(this.choicesPanel) };
            this.choicesText
                .background_(Color(0.15, 0.15, 0.15))
                .stringColor_(Color.white)
                .font_(Font("Monaco", 12))
                .autoscroll_(true)
                .editable_(false)
                .bounds_(Rect(8, 28, w - 16, h - 36));
        };

        AppClock.sched(0.0, { build.value; nil });
        ^this
    }

    md_applyChoicesText { arg textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            this.ensureChoicesPanel;
            if(this.choicesText.notNil) {
                this.choicesText.stringColor_(Color.white);  // force high contrast
                this.choicesText.string_(txt);
            };
            nil
        });
        ^this
    }

    updateTextField { arg key, textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            switch(key,
                \choices, { this.md_applyChoicesText(txt) },
                \state,   { if(this.expectationView.notNil) { this.expectationView.string = txt } },
                \queue,   { if(this.expectationView.notNil) { this.expectationView.string = "Queue:\n" ++ txt } },
                \lastCommand, { if(this.expectationView.notNil) { this.expectationView.string = "Last: " ++ txt } },
                { /* no-op */ }
            );
            nil
        });
        ^this
    }

    setOperations { arg itemsArray;
        var s;
        s = (itemsArray ? []).collect(_.asString).join("\n");
        this.md_applyChoicesText(s);
        ^this
    }

    // optional manual nudge
    forceHighContrastChoices {
        this.md_applyChoicesText(this.choicesText.tryPerform(\string) ? "");
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd =====
// MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd
// v0.1.0
// MD 2025-09-24 23:55 BST

/*
Purpose
- Ensure the Choices panel uses light text on a dark background.
Style
- Class extension only; var-first; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  fixChoicesContrast { arg fg = Color(0.96,0.96,0.96), bg = Color(0.12,0.12,0.12,0.92);
    var apply;
    apply = {
      if(choicesPanel.notNil) { choicesPanel.background = bg };
      if(choicesTitle.notNil) { choicesTitle.stringColor = fg };
      if(choicesText.notNil)  { choicesText.stringColor  = fg };
    };
    AppClock.sched(0.0, { apply.value; nil });
    ^this
  }

  // Keep existing behavior but guarantee readable \choices text
  updateTextField { arg box, msg;
    var doIt;
    doIt = {
      if(box == \choices) {
        if(choicesText.notNil) {
          choicesText.string = msg.asString;
          choicesText.stringColor = Color(0.96,0.96,0.96);  // light text
          if(choicesTitle.notNil) { choicesTitle.stringColor = Color(0.96,0.96,0.96) };
        };
      }{
        if(expectationView.notNil) {
          expectationView.string = "[" ++ box.asString ++ "] " ++ msg.asString;
        };
      };
    };
    AppClock.sched(0.0, { doIt.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Markers.sc_disabled =====
// MagicDisplayGUI_GridDemo_Ext_Markers.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Place a simple, colored rectangle as a "marker" INSIDE the right CURRENT/NEXT panel
  (middle-right column), directly BELOW the "eff:" row, without touching any layouts.
- Provide simple helpers to show/hide a thin border around the right panel and to post layout info.

Style
- Class extension only; known-good SC syntax.
- Var-first in every block; descriptive variable names (>= 3 chars).
- No layout adds; the marker is an absolutely positioned CompositeView.
*/

+ MagicDisplayGUI_GridDemo {

  // -------- remove marker if present --------
  rp_removeMarker {
    var markerView, childView, childName;

    if(rightPanel.isNil) { "rp_removeMarker: rightPanel is nil".warn; ^this };

    markerView = nil;
    rightPanel.children.do({ arg childViewLocal;
      var nameMaybe;
      nameMaybe = childViewLocal.tryPerform(\name);
      if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
    });

    if(markerView.notNil) { markerView.remove };
    ^this
  }

  // -------- place a colored marker BELOW the 'eff:' line in the RIGHT panel --------
  rp_placeMarkerBelowEff { arg barHeight = 24, fillColor = Color(1, 0.30, 0.20, 0.90);
    var placeFunc;

    if(rightPanel.isNil) { "rp_placeMarkerBelowEff: rightPanel is nil".warn; ^this };
    if(rightEff.isNil)   { "rp_placeMarkerBelowEff: rightEff is nil".warn; ^this };

    placeFunc = {
      var panelBounds, effBounds, leftInset, rightInset, topGap, targetRect;
      var markerView;

      panelBounds = rightPanel.bounds;
      effBounds   = rightEff.bounds;

      leftInset  = 6;
      rightInset = 6;
      topGap     = 4;

      targetRect = Rect(
        leftInset,
        effBounds.bottom + topGap,
        (panelBounds.width - (leftInset + rightInset)).max(8),
        barHeight.max(8)
      );

      // remove any previous marker
      this.rp_removeMarker;

      // create a simple colored view at the computed rectangle
      markerView = CompositeView(rightPanel).name_("MDG_MARKER");
      markerView.background = fillColor;
      markerView.bounds = targetRect;
      markerView.front;  // ensure on top

      ("[marker] placed at " ++ targetRect).postln;
    };

    // schedule after 0 so layout has a chance to settle
    AppClock.sched(0.0, { placeFunc.value; nil });
    ^this
  }

  // -------- raise marker to front (if it was covered) --------
  rp_raiseMarker {
    var markerView;

    if(rightPanel.isNil) { "rp_raiseMarker: rightPanel is nil".warn; ^this };

    markerView = nil;
    rightPanel.children.do({ arg childViewLocal;
      var nameMaybe;
      nameMaybe = childViewLocal.tryPerform(\name);
      if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
    });

    if(markerView.notNil) { markerView.front };
    ^this
  }

  // -------- toggle a thin border overlay around the RIGHT panel (no child iteration) --------
  rp_showRightPanelBorder { arg showBorder = true;
    var ensureFunc;

    if(rightPanel.isNil) { "rp_showRightPanelBorder: rightPanel is nil".warn; ^this };

    ensureFunc = {
      var existingOverlay, borderView;

      // remove existing
      existingOverlay = nil;
      rightPanel.children.do({ arg childViewLocal;
        var nameMaybe;
        nameMaybe = childViewLocal.tryPerform(\name);
        if(nameMaybe == "MDG_BORDER_OVERLAY") { existingOverlay = childViewLocal };
      });
      if(existingOverlay.notNil) { existingOverlay.remove };

      if(showBorder) {
        borderView = UserView(rightPanel).name_("MDG_BORDER_OVERLAY");
        borderView.background = Color.clear;

        // place full-panel; use current bounds (no layout control)
        borderView.bounds = Rect(0, 0, rightPanel.bounds.width, rightPanel.bounds.height);

        borderView.drawFunc = { arg viewLocal;
          var viewBounds;
          viewBounds = viewLocal.bounds;
          Pen.color = Color(1, 0, 0, 0.40);
          Pen.width = 2;
          Pen.strokeRect(Rect(1, 1, viewBounds.width - 2, viewBounds.height - 2));
        };

        borderView.front;
      };
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // -------- print simple layout info for key right-panel subviews --------
  rp_postRightPanelLayoutReport {
    var postFunc;

    if(rightPanel.isNil) { "rp_postRightPanelLayoutReport: rightPanel is nil".warn; ^this };

    postFunc = {
      var markerView;

      "‚Äî‚Äî Right Panel Layout ‚Äî‚Äî".postln;
      ("rightPanel.bounds:     " ++ rightPanel.bounds).postln;

      if(this.respondsTo(\rightHeader) and: { rightHeader.notNil }) {
        ("rightHeader.bounds:    " ++ rightHeader.bounds).postln;
      };

      if(this.respondsTo(\rightListView) and: { rightListView.notNil }) {
        ("rightListView.bounds:  " ++ rightListView.bounds).postln;
      };

      if(rightEff.notNil) {
        ("rightEff.bounds:       " ++ rightEff.bounds).postln;
      };

      markerView = nil;
      rightPanel.children.do({ arg childViewLocal;
        var nameMaybe;
        nameMaybe = childViewLocal.tryPerform(\name);
        if(nameMaybe == "MDG_MARKER") { markerView = childViewLocal };
      });
      if(markerView.notNil) {
        ("marker.bounds:         " ++ markerView.bounds).postln;
      };
    };

    AppClock.sched(0.0, { postFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.sc_DISABLED =====
// MagicDisplayGUI_GridDemo_Ext_Meters.sc
// v0.1.1
// MD 2025-09-24 20:10 BST

/*
Purpose
- Install direct OSC responders on '/ampA' and '/ampB' and update the GUI meter bars.
- Keeps logic inside the GUI class (cleaner than external glue).
- Safe to call multiple times (responders are replaced). Platform-agnostic.

Style
- Class extension; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    installDirectMeterResponders {
        var updateA, updateB, makeResponder;

        updateA = { arg vals;
            var v;
            v = (vals.asArray[0] ? 0).asFloat.clip(0, 1);
            this.queueUi({
                if(meterViewA.notNil) {
                    meterViewA.tryPerform(\value_, v);
                    meterViewA.tryPerform(\refresh);
                };
            });
        };

        updateB = { arg vals;
            var v;
            v = (vals.asArray[0] ? 0).asFloat.clip(0, 1);
            this.queueUi({
                if(meterViewB.notNil) {
                    meterViewB.tryPerform(\value_, v);
                    meterViewB.tryPerform(\refresh);
                };
            });
        };

        // Free prior defs if present, then (re)install
        if(OSCdef(\mdg_ampA).notNil) { OSCdef(\mdg_ampA).free };
        if(OSCdef(\mdg_ampB).notNil) { OSCdef(\mdg_ampB).free };

        // Accept from any src (robust across platforms); GUI updates are AppClock-safe
        OSCdef(\mdg_ampA, { |msg| updateA.(msg[3..]) }, '/ampA');
        OSCdef(\mdg_ampB, { |msg| updateB.(msg[3..]) }, '/ampB');

        "‚úÖ MagicDisplayGUI meters bound to /ampA /ampB".postln;
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.scd =====
// MagicDisplayGUI_GridDemo_Ext_Meters.scd
// v0.3.0
// MD 2025-09-24 23:56 BST

/*
Purpose
- Provide enableMeters(true): listen to /ampA and /ampB (from SendReply.kr)
  and draw two moving bars in meterStrip.
Style
- Class extension only; var-first; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  enableMeters { arg on = true;
    var state, setupUI, install, remove;

    // Simple per-window state (no ivars added)
    state = (
      valA: 0.0,   // 0..1 (A bar)
      valB: 0.0,   // 0..1 (B bar)
      rxA:  nil,   // OSCdef handles
      rxB:  nil
    );

    setupUI = {
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds, pad = 8, w = b.width - (pad*2), h = b.height;
          var barH = ((h - (pad*2) - 4)/2).clip(8,14);
          var top1 = pad, top2 = pad + barH + 4;
          var a = state[\valA].clip(0,1), bb = state[\valB].clip(0,1);

          // backgrounds
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top1, w, barH)); Pen.fill;
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top2, w, barH)); Pen.fill;

          // dynamic fills
          Pen.color = Color(0.20, 0.70, 0.20); Pen.addRect(Rect(pad, top1, w * a,  barH)); Pen.fill;  // A
          Pen.color = Color(0.20, 0.40, 0.90); Pen.addRect(Rect(pad, top2, w * bb, barH)); Pen.fill;  // B

          // border
          Pen.color = Color.gray(0.5); Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
        };
      };
    };

    install = {
      setupUI.value;

      // IMPORTANT: these paths must match the ones used in SendReply.kr
      state[\rxA] = OSCdef(\mdAmpA, { |msg|
        // SendReply places floats after some metadata; first value is msg[3]
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        // quick smoothing
        state[\valA] = (state[\valA] * 0.7) + (max(l, r) * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampA');

      state[\rxB] = OSCdef(\mdAmpB, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var mean = ((l + r) * 0.5).clip(0,1);
        state[\valB] = (state[\valB] * 0.7) + (mean * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampB');
    };

    remove = {
      if(state[\rxA].notNil) { state[\rxA].free; state[\rxA] = nil };
      if(state[\rxB].notNil) { state[\rxB].free; state[\rxB] = nil };
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds;
          Pen.color = Color.gray(0.7);
          Pen.strokeRect(Rect(0.5,0.5,b.width-1,b.height-1));
        };
        meterStrip.refresh;
      };
    };

    AppClock.sched(0.0, { if(on) { install.value } { remove.value }; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_SetOperations.sc =====
// MagicDisplayGUI_GridDemo_Ext_SetOperations.sc
// v0.1.0
// MD 2025-09-22 22:36 BST

/* Purpose
   - Let CommandManager.updateDisplay push the current fret‚Üíchoice list
     into MagicDisplayGUI_GridDemo's "Choices" panel.
   Style
   - AppClock-only UI; var-first; lowercase; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {
    setOperations { |lines|
        var text;
        text = (lines ? []).join("\n");
        this.queueUi({
            if(choicesText.notNil) { choicesText.string = text };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMarker.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMarker.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw unambiguous landmarks INSIDE the right CURRENT/NEXT panel (middle-right column):
  ‚Ä¢ Fuchsia border built from 4 thin CompositeViews (no drawFunc)
  ‚Ä¢ Yellow highlight inside the 'eff' row (anchor)
  ‚Ä¢ Marker bar near 'eff': ORANGE below (clamped) or SKY-BLUE above (clamped)
- Absolutely no layout mutations; no drawing math inside drawFuncs; only known-good SC GUI.

Style
- Class extension; var-first in all methods; descriptive variable names.
- Views are created as named children of rightPanel so we can remove them safely.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- helpers: find/remove named child on rightPanel ----------
  tm_findChildByName { arg childNameString;
    var foundView, childCount, childIndex, childView, childNameMaybe;
    foundView = nil;
    if(rightPanel.notNil) {
      childCount = rightPanel.children.size;
      childIndex = 0;
      childCount.do({
        childView = rightPanel.children[childIndex];
        childNameMaybe = if(childView.respondsTo(\name), { childView.name }, { nil });
        if(childNameMaybe == childNameString) { foundView = childView };
        childIndex = childIndex + 1;
      });
    };
    ^foundView
  }

  tm_removeChildByName { arg childNameString;
    var viewToRemove;
    viewToRemove = this.tm_findChildByName(childNameString);
    if(viewToRemove.notNil) { viewToRemove.remove };
    ^this
  }

  // ---------- clear all test markers/borders ----------
  testMarker_clear {
    this.tm_removeChildByName("MDG_TM_BORDER_TOP");
    this.tm_removeChildByName("MDG_TM_BORDER_BOTTOM");
    this.tm_removeChildByName("MDG_TM_BORDER_LEFT");
    this.tm_removeChildByName("MDG_TM_BORDER_RIGHT");
    this.tm_removeChildByName("MDG_TM_EFF_HI");
    this.tm_removeChildByName("MDG_TM_MARKER");
    ^this
  }

  // ---------- show a bold fuchsia border (4 thin views) ----------
  testMarker_showPanelBorder {
    var ensureFunc;

    if(rightPanel.isNil) { "testMarker_showPanelBorder: rightPanel is nil".warn; ^this };

    ensureFunc = {
      var panelBounds, thickness, topView, bottomView, leftView, rightView, colorFuchsia;

      // clean previous
      this.testMarker_clear;

      panelBounds   = rightPanel.bounds;
      thickness     = 3;
      colorFuchsia  = Color(1.0, 0.0, 1.0, 0.85);

      topView = CompositeView(rightPanel).name_("MDG_TM_BORDER_TOP");
      topView.background = colorFuchsia;
      topView.bounds = Rect(0, 0, panelBounds.width, thickness);

      bottomView = CompositeView(rightPanel).name_("MDG_TM_BORDER_BOTTOM");
      bottomView.background = colorFuchsia;
      bottomView.bounds = Rect(0, panelBounds.height - thickness, panelBounds.width, thickness);

      leftView = CompositeView(rightPanel).name_("MDG_TM_BORDER_LEFT");
      leftView.background = colorFuchsia;
      leftView.bounds = Rect(0, 0, thickness, panelBounds.height);

      rightView = CompositeView(rightPanel).name_("MDG_TM_BORDER_RIGHT");
      rightView.background = colorFuchsia;
      rightView.bounds = Rect(panelBounds.width - thickness, 0, thickness, panelBounds.height);

      // bring to front in a stable order
      topView.front; bottomView.front; leftView.front; rightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- highlight the 'eff' row (yellow translucent) ----------
  testMarker_highlightEff {
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_highlightEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var effBounds, highlightView, colorYellow;

      // remove old eff highlight only
      this.tm_removeChildByName("MDG_TM_EFF_HI");

      effBounds = rightEff.bounds;
      colorYellow = Color(1.0, 1.0, 0.0, 0.45);

      highlightView = CompositeView(rightPanel).name_("MDG_TM_EFF_HI");
      highlightView.background = colorYellow;
      highlightView.bounds = Rect(
        effBounds.left + 2,
        effBounds.top + 2,
        (effBounds.width - 4).max(4),
        (effBounds.height - 4).max(4)
      );
      highlightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- place a marker bar NEAR the 'eff' row (positionSymbol: \below or \above) ----------
  testMarker_showNearEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_showNearEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var panelBounds, effBounds, leftInset, rightInset, gapPixels;
      var desiredTop, finalTop, finalHeight, markerRect, markerView;
      var colorOrange, colorSkyBlue, markerColor;

      // remove any previous marker (keep border/eff highlight)
      this.tm_removeChildByName("MDG_TM_MARKER");

      panelBounds = rightPanel.bounds;
      effBounds   = rightEff.bounds;

      leftInset   = 6;
      rightInset  = 6;
      gapPixels   = 4;
      colorOrange = Color(1.0, 0.50, 0.0, 0.90);
      colorSkyBlue= Color(0.10, 0.65, 1.0, 0.90);

      if(positionSymbol == \below) {
        markerColor = colorOrange;
        desiredTop  = effBounds.bottom + gapPixels;
        finalHeight = barHeight.max(8);
        if(desiredTop + finalHeight > panelBounds.height) {
          finalHeight = (panelBounds.height - desiredTop).max(8);
        };
        finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
      } {
        markerColor = colorSkyBlue;  // \above
        finalHeight = barHeight.max(8);
        desiredTop  = effBounds.top - gapPixels - finalHeight;
        if(desiredTop < 0) {
          finalHeight = (effBounds.top - gapPixels).max(8);
          desiredTop  = 0;
        };
        finalTop = desiredTop;
      };

      markerRect = Rect(
        leftInset,
        finalTop,
        (panelBounds.width - (leftInset + rightInset)).max(8),
        finalHeight
      );

      markerView = CompositeView(rightPanel).name_("MDG_TM_MARKER");
      markerView.background = markerColor;
      markerView.bounds = markerRect;
      markerView.front;

      "‚Äî‚Äî TestMarker ‚Äî‚Äî".postln;
      ("rightPanel.bounds: " ++ panelBounds).postln;
      ("rightEff.bounds:   " ++ effBounds).postln;
      ("marker.bounds:     " ++ markerRect).postln;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMeter.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMeter.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw a small horizontal "debug meter" inside the right CURRENT/NEXT panel (middle-right column),
  positioned relative to the 'eff:' row (just BELOW by default; clamped to stay inside the panel).
- Step 1: run with a smoothed RANDOM driver to prove GUI refresh + horizontal motion.
- Step 2: attach to live audio via SendReply.kr paths '/ampA' or '/ampB'.

Style
- Class extension; known-good SuperCollider only.
- Var-first in all blocks; descriptive variable names (>=3 chars).
- Minimal state stored in Library under category \MD_TM and key this.identityHash.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- tiny state bag in Library (per GUI instance) ----------
  tm2_state {
    var categorySymbol, keyInt, dict;
    categorySymbol = \MD_TM;
    keyInt = this.identityHash;
    dict = Library.at(categorySymbol, keyInt);
    if(dict.isNil) {
      dict = IdentityDictionary.new;
      Library.put(categorySymbol, keyInt, dict);
    };
    ^dict
  }

  tm2_put { arg keySymbol, valueObject;
    var stateDict;
    stateDict = this.tm2_state;
    stateDict.put(keySymbol, valueObject);
    ^this
  }

  tm2_get { arg keySymbol, defaultValue = nil;
    var stateDict;
    stateDict = this.tm2_state;
    ^(stateDict.includesKey(keySymbol).if({ stateDict.at(keySymbol) }, { defaultValue }))
  }

  // ---------- compute the meter rectangle relative to 'eff' (below or above) ----------
  tm2_computeMeterRect { arg positionSymbol = \below, barHeight = 24;
    var panelBounds, effBounds;
    var leftInset, rightInset, gapPixels;
    var desiredTop, finalTop, finalHeight, rectResult;

    if(rightPanel.isNil or: { rightEff.isNil }) { ^Rect(0,0,0,0) };

    panelBounds = rightPanel.bounds;
    effBounds   = rightEff.bounds;

    leftInset   = 6;
    rightInset  = 6;
    gapPixels   = 4;

    if(positionSymbol == \below) {
      desiredTop  = effBounds.bottom + gapPixels;
      finalHeight = barHeight.max(8);
      if(desiredTop + finalHeight > panelBounds.height) {
        finalHeight = (panelBounds.height - desiredTop).max(8);
      };
      finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
    } {
      // \above
      finalHeight = barHeight.max(8);
      desiredTop  = effBounds.top - gapPixels - finalHeight;
      if(desiredTop < 0) {
        finalHeight = (effBounds.top - gapPixels).max(8);
        desiredTop  = 0;
      };
      finalTop = desiredTop;
    };

    rectResult = Rect(
      leftInset,
      finalTop,
      (panelBounds.width - (leftInset + rightInset)).max(8),
      finalHeight
    );
    ^rectResult
  }

  // ---------- create the meter UserView at the computed rectangle ----------
  testMeter_showAtEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMeter_showAtEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var meterRect, meterUserView;

      // remove any previous meter view
      this.testMeter_remove;

      meterRect = this.tm2_computeMeterRect(positionSymbol, barHeight);

      meterUserView = UserView(rightPanel).name_("MDG_TM2_METER");
      meterUserView.background = Color.clear;
      meterUserView.bounds = meterRect;

      // drawFunc: trough + horizontal fill
      meterUserView.drawFunc = { arg viewLocal;
        var viewBounds, padPixels, troughRect, valueNow, fillWidth, fillRect;

        viewBounds = viewLocal.bounds;
        padPixels  = 2;

        troughRect = Rect(
          padPixels, padPixels,
          viewBounds.width  - (padPixels * 2),
          viewBounds.height - (padPixels * 2)
        );

        // trough
        Pen.color = Color(0.80, 0.82, 0.86, 0.60);
        Pen.addRect(troughRect); Pen.fill;

        // horizontal fill
        valueNow  = (this.tm2_get(\meterVal, 0.0)).clip(0, 1);
        fillWidth = (troughRect.width * valueNow).max(0);
        fillRect  = Rect(troughRect.left, troughRect.top, fillWidth, troughRect.height);

        Pen.color = Color(0.15, 0.65, 0.25, 0.95);  // green-ish
        Pen.addRect(fillRect); Pen.fill;

        // border
        Pen.color = Color.gray(0.20);
        Pen.strokeRect(Rect(0.5, 0.5, viewBounds.width - 1, viewBounds.height - 1));
      };

      meterUserView.front;

      this.tm2_put(\meterView, meterUserView);
      this.tm2_put(\meterVal, 0.0);
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- random driver (prove GUI refresh + orientation) ----------
  testMeter_startRandom {
    var startFunc;

    startFunc = {
      var existingTask, meterUserView, meterTaskRoutine;

      // stop any prior driver
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_startRandom: meter not shown‚Äîcall testMeter_showAtEff first.".warn; ^this };

      meterTaskRoutine = Routine({
        var currentVal, targetVal, stepSeconds;
        currentVal = this.tm2_get(\meterVal, 0.0);
        stepSeconds = 0.06;  // ~16 Hz
        inf.do {
          targetVal  = 1.0.rand;
          currentVal = (currentVal * 0.75) + (targetVal * 0.25);
          this.tm2_put(\meterVal, currentVal);
          AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
          stepSeconds.wait;
        }
      });

      this.tm2_put(\meterTask, meterTaskRoutine);
      meterTaskRoutine.play(AppClock);
    };

    AppClock.sched(0.0, { startFunc.value; nil });
    ^this
  }

  // ---------- attach to live audio via '/ampA' or '/ampB' ----------
  testMeter_attach { arg whichChain = \A;
    var attachFunc;

    attachFunc = {
      var meterUserView, oscKeyA, oscKeyB, oscDefAmpA, oscDefAmpB;

      this.testMeter_stop;  // stop prior drivers

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_attach: meter not shown‚Äîcall testMeter_showAtEff first.".warn; ^this };

      // unique OSCdef keys per GUI instance
      oscKeyA = ("mdTmAmpA_" ++ this.identityHash).asSymbol;
      oscKeyB = ("mdTmAmpB_" ++ this.identityHash).asSymbol;

      oscDefAmpA = OSCdef(oscKeyA, { arg msg;
        var leftVal, rightVal, peakVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        peakVal  = max(leftVal, rightVal).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (peakVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampA');

      oscDefAmpB = OSCdef(oscKeyB, { arg msg;
        var leftVal, rightVal, meanVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        meanVal  = ((leftVal + rightVal) * 0.5).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (meanVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampB');

      this.tm2_put(\oscA, oscDefAmpA);
      this.tm2_put(\oscB, oscDefAmpB);

      // enable only one path
      if(whichChain == \A) { oscDefAmpB.disable } { oscDefAmpA.disable };
    };

    AppClock.sched(0.0, { attachFunc.value; nil });
    ^this
  }

  // ---------- stop drivers (random and OSC) ----------
  testMeter_stop {
    var stopFunc;

    stopFunc = {
      var existingTask, oscDefA, oscDefB;

      existingTask = this.tm2_get(\meterTask);
      if(existingTask.notNil) { existingTask.stop; this.tm2_put(\meterTask, nil) };

      oscDefA = this.tm2_get(\oscA);
      if(oscDefA.notNil) { oscDefA.free; this.tm2_put(\oscA, nil) };

      oscDefB = this.tm2_get(\oscB);
      if(oscDefB.notNil) { oscDefB.free; this.tm2_put(\oscB, nil) };
    };

    AppClock.sched(0.0, { stopFunc.value; nil });
    ^this
  }

  // ---------- remove the meter view ----------
  testMeter_remove {
    var removeFunc;

    removeFunc = {
      var meterUserView;
      // stop activity first
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.notNil) { meterUserView.remove; this.tm2_put(\meterView, nil) };
    };

    AppClock.sched(0.0, { removeFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo.sc =====
// MagicDisplayGUI_GridDemo.sc
// v0.1.6
// MD 20250919-10:46 BST

/*
Purpose
- GridLayout-based GUI for VISUAL-ONLY demos (no audio, meters disabled).
- Row 0: CURRENT | NEXT (two equal columns).
- Rows 1..4: full-width using addSpanning (expectation, countdown, thin meters=30px, processors).
- Extra height only goes to Row 0 (chains row).

Debug
- debugGuides(true): overlays red outlines + row labels; postLayoutReport() prints rects.

Style
- var-first; lowercase; AppClock-only UI ops; no caret returns in closures; no server.sync.
*/

MagicDisplayGUI_GridDemo : MagicDisplay {
	classvar <versionGUI;
	var <window;

	// root + top-level row views (children of window.view)
	var rootLayout;
	var leftPanel, rightPanel;
	var expectationView, countdownHolder, meterStrip, bottomHudView;

	// children within panels
	var leftHeader, leftListView, leftEff;
	var rightHeader, rightListView, rightEff;
	var countdownLabel, countdownBar;
	var bottomCurText, bottomNextText;

	// debug overlay
	var debugOn = false;
	var overlayRow0, overlayRow1, overlayRow2, overlayRow3, overlayRow4;

	var metersEnabled;

	//new
	var <choicesPanel, <choicesTitle, <choicesText;
	var buildChoices;

	*initClass {
		var s;
		versionGUI = "v0.1.5";
		s = "MagicDisplayGUI_GridDemo " ++ versionGUI;
		s.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var reqW, reqH, sb, maxW, maxH, winW, winH, rect;
		var metersRowH, hudRowH;
		var buildLeft, buildRight, buildExpectation, buildCountdown, buildMeters, buildBottomHud;

		// window sizing (fits iPad side-screen limit)
		reqW = 1200; reqH = 760;
		sb   = Window.screenBounds ? Rect(0, 0, 1920, 1080);
		maxW = (2560).min(sb.width);
		maxH = (1666).min(sb.height);
		winW = reqW.clip(640, maxW);
		winH = reqH.clip(480, maxH);
		rect = Rect(
			sb.left + ((sb.width - winW) * 0.5),
			sb.top  + ((sb.height - winH) * 0.5),
			winW, winH
		);

		metersRowH = 30;   // thin strips
		hudRowH    = 88;

		window = Window("MagicDisplayGUI ‚Äì GridDemo", rect).front.alwaysOnTop_(true);
		metersEnabled = false;

		// root GridLayout on the VIEW (not the Window)
		rootLayout = GridLayout.new;
		window.view.layout = rootLayout;

		// equal columns globally (row 0 uses them)
		rootLayout.setColumnStretch(0, 1);
		rootLayout.setColumnStretch(1, 1);

		// ---- Row 0: CURRENT / NEXT (two equal columns) ----
		buildLeft = {
			var grid;
			grid = GridLayout.new;
			leftPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			leftPanel.layout = grid;

			leftHeader   = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
			leftListView = ListView(leftPanel).items_([]);
			leftEff      = StaticText(leftPanel).string_("eff: ‚Äî").align_(\center);

			grid.add(leftHeader,   0, 0);
			grid.add(leftListView, 1, 0);
			grid.add(leftEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildRight = {
			var grid;
			grid = GridLayout.new;
			rightPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			rightPanel.layout = grid;

			rightHeader   = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
			rightListView = ListView(rightPanel).items_([]);
			rightEff      = StaticText(rightPanel).string_("eff: ‚Äî").align_(\center);

			grid.add(rightHeader,   0, 0);
			grid.add(rightListView, 1, 0);
			grid.add(rightEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildLeft.value;
		buildRight.value;
		rootLayout.add(leftPanel,  0, 0);
		rootLayout.add(rightPanel, 0, 1);
		rootLayout.setRowStretch(0, 1); // only row allowed to grow

		// ---- Row 1: expectation (FULL width) ----
		buildExpectation = {
			expectationView = TextView(window.view)
			.background_(Color(1, 1, 0.9))
			.string_("Command:");
		};
		buildExpectation.value;
		// rootLayout.addSpanning(expectationView, 1, 0, 1, 2);
		// rootLayout.setRowStretch(1, 0);
		// rootLayout.setMinRowHeight(1, 36);

		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
		// rootLayout.add(choicesPanel, 4, 0);     // left column
		// rootLayout.add(bottomHudView, 4, 1);    // right column

		// Tweaks for row/column growth
		// rootLayout.setRowStretch(4, 0);         // fixed height for bottom row
		// rootLayout.setMinRowHeight(4, hudRowH); // keep same height as before


		// ---- Row 2: countdown (FULL width) ----
		buildCountdown = {
			var sub;
			countdownHolder = CompositeView(window.view);
			sub = GridLayout.new; countdownHolder.layout = sub;
			countdownLabel = StaticText(countdownHolder).string_("Ready");
			countdownBar   = UserView(countdownHolder);
			sub.add(countdownLabel, 0, 0);
			sub.add(countdownBar,   0, 1);
			sub.setColumnStretch(0, 0);
			sub.setColumnStretch(1, 1);
		};
		buildCountdown.value;
		rootLayout.addSpanning(countdownHolder, 2, 0, 1, 2);
		rootLayout.setRowStretch(2, 0);
		rootLayout.setMinRowHeight(2, 24);

		// ---- Row 3: meters (FULL width; 30 px) ----
		buildMeters = {
			meterStrip = UserView(window.view);
			meterStrip.background = Color(0.96, 0.96, 0.96);
			meterStrip.drawFunc = { |view|
				var b, pad, h, barH, top1, top2;
				b   = view.bounds;
				pad = 8;
				h   = b.height;
				barH = (h - (pad * 2) - 4) / 2;
				barH = barH.clip(8, 14);
				top1 = pad;
				top2 = pad + barH + 4;
				Pen.color = Color.gray(0.3);
				Pen.addRect(Rect(pad, top1, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.5);
				Pen.addRect(Rect(pad, top2, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.7);
				Pen.strokeRect(Rect(0.5, 0.5, b.width - 1, b.height - 1));
			};
		};
		buildMeters.value;
		rootLayout.addSpanning(meterStrip, 3, 0, 1, 2);
		rootLayout.setRowStretch(3, 0);
		rootLayout.setMinRowHeight(3, metersRowH);

		// new
		// --- Row 4 (left column): Choices panel (new) ---

		buildChoices = {
			var sub; // nested layout for the choices panel

			choicesPanel = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));

			// install a GridLayout into the choices panel
			sub = GridLayout.new;
			choicesPanel.layout = sub;

			choicesTitle = StaticText(choicesPanel)
			.string_("Choices")
			.stringColor_(Color(0.96, 0.96, 0.96));  // was Color(0.12,0.12,0.12) ... what a pain that was.

			choicesText  = TextView(choicesPanel)
			.string_("‚Äî")
			.editable_(false)
			.stringColor_(Color(0.96,0.96,0.96))     // add this line
			.hasVerticalScroller_(true)
			.background_(Color(0.98, 0.98, 0.98, 0.96))  // very light
			.stringColor_(Color(0.10, 0.10, 0.10))       // near-black text
			.font_(Font("Menlo", 12));





			// add to nested grid: title on row 0, text on row 1 (stretches)
			sub.add(choicesTitle, 0, 0);
			sub.add(choicesText, 1, 0);
			sub.setRowStretch(0, 0);   // title fixed
			sub.setRowStretch(1, 1);   // text grows to fill
			sub.setColumnStretch(0, 1);
		};
		///////
		buildChoices.value;


		// ---- Row 4: processors (FULL width) ----
		buildBottomHud = {
			var grid, title, curLabel, nextLabel;
			bottomHudView = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));
			grid = GridLayout.new; bottomHudView.layout = grid;

			title          = StaticText(bottomHudView).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
			curLabel       = StaticText(bottomHudView).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
			bottomCurText  = StaticText(bottomHudView).string_("‚Äì").stringColor_(Color(0.90, 0.90, 0.90));
			nextLabel      = StaticText(bottomHudView).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
			bottomNextText = StaticText(bottomHudView).string_("‚Äì").stringColor_(Color(0.80, 0.80, 0.80));

			grid.add(title,          0, 0, 1, 2);
			grid.add(curLabel,       1, 0);
			grid.add(bottomCurText,  1, 1);
			grid.add(nextLabel,      2, 0);
			grid.add(bottomNextText, 2, 1);
			grid.setColumnStretch(0, 0);
			grid.setColumnStretch(1, 1);
			grid.hSpacing = 10;
			grid.vSpacing = 4;
		};

		/////////
		buildBottomHud.value;

		// rootLayout.add(choicesPanel, 4, 0);   // left column
		// rootLayout.add(bottomHudView, 4, 1);  // right column
		rootLayout.setRowStretch(4, 0);
		rootLayout.setMinRowHeight(4, hudRowH);

/*        rootLayout.addSpanning(bottomHudView, 4, 0, 1, 2);
        rootLayout.setRowStretch(4, 0);
        rootLayout.setMinRowHeight(4, hudRowH);*/

		//new
		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
/*		rootLayout.add(choicesPanel, 4, 0);     // left column
		rootLayout.add(bottomHudView, 4, 1);    // right column
		rootLayout.setRowStretch(4, 0);         // fixed bottom-row height
		rootLayout.setMinRowHeight(4, hudRowH);*/


		this.attachResizeHandler;
		^this
	}

	// -------- Public (visual-only) --------
	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var fmt, effCText, effNText, aIsCurrent;

		fmt = { arg listRef, bypassKeys, effList;
			var itemsOut, lastIndex, processors, indexCounter;
			itemsOut = Array.new;
			lastIndex = listRef.size - 1;
			itemsOut = itemsOut.add("src : " ++ listRef[lastIndex]);
			if(listRef.size > 2) {
				itemsOut = itemsOut.add("procs:");
				processors = listRef.copyRange(1, lastIndex - 1).reverse;
				indexCounter = 1;
				processors.do({ arg key;
					var byp, badge, lineText;
					byp = bypassKeys.includes(key);
					badge = byp.if({ "[BYP]" }, { "[ON]" });
					lineText = " [" ++ indexCounter ++ "] " ++ key ++ " " ++ badge;
					itemsOut = itemsOut.add(lineText);
					indexCounter = indexCounter + 1;
				});
			}{
				itemsOut = itemsOut.add("procs: (none)");
			};
			itemsOut = itemsOut.add("sink : " ++ listRef[0]);
			itemsOut
		};

		effCText = "eff: " ++ effCurrent.join(" -> ");
		effNText = "eff: " ++ effNext.join(" -> ");

		if(leftListView.notNil)  { leftListView.items_(fmt.value(current, bypassAKeys, effCurrent)) };
		if(rightListView.notNil) { rightListView.items_(fmt.value(next,    bypassBKeys, effNext))    };
		if(leftEff.notNil)  { leftEff.string_(effCText) };
		if(rightEff.notNil) { rightEff.string_(effNText) };

		aIsCurrent = (current[0] == \chainA);
		if(leftHeader.notNil)  { leftHeader.string_((aIsCurrent).if({ "CHAIN A ACTIVE" }, { "CHAIN A NEXT" })) };
		if(rightHeader.notNil) { rightHeader.string_((aIsCurrent).if({ "CHAIN B NEXT"   }, { "CHAIN B ACTIVE" })) };

		// no .trim (SC String has no trim); keep plain join
		if(bottomCurText.notNil)  { bottomCurText.string_(" " ++ effCurrent.copyRange(1, effCurrent.size-1).join(" -> ")) };
		if(bottomNextText.notNil) { bottomNextText.string_(" " ++ effNext.copyRange(1, effNext.size-1).join(" -> ")) };

		^this
	}

	highlightCurrentColumn { arg currentSinkSym;
		var greenBg, neutralBg, isA;
		greenBg   = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		isA = (currentSinkSym == \chainA);
		if(leftPanel.notNil)  { leftPanel.background_((isA).if({ greenBg }, { neutralBg })) };
		if(rightPanel.notNil) { rightPanel.background_((isA).if({ neutralBg }, { greenBg })) };
		^this
	}

/*    showExpectation { arg textString, seconds = 0;
        var secs;
        secs = seconds ? 0;
        if(expectationView.notNil) { expectationView.string_(textString.asString) };
        if(countdownLabel.notNil)  { countdownLabel.string_((secs > 0).if({ "Listen in‚Ä¶ (" ++ secs ++ "s)" }, { "Ready" })) };
        ^this
    }*/

	showExpectation { |text, seconds = 0|
		var messageText;

		messageText = text.asString;
		this.queueUi({
			if (expectationView.notNil) { expectationView.string = messageText };
		});
		this
	}

	//new:
	// Add inside MagicDisplayGUI_GridDemo class:
	setOperations { arg itemsArray;
		var s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
		AppClock.sched(0.0, {
			if(choicesText.notNil) {
				choicesText.string_( (s.size > 0).if({ s }, { "‚Äî" }) );
				// Re-assert color to be safe across themes (match dark/light choice you used)
				choicesText.stringColor_(Color(0.96, 0.96, 0.96));  // dark panel
				// or choicesText.stringColor_(Color(0.10, 0.10, 0.10));  // light panel
			}{
				if(expectationView.notNil) {
					expectationView.string_("Choices:\n" ++ ((s.size > 0).if({ s }, { "‚Äî" })));
				};
			};
			nil
		});
		^this
	}




	enableMeters { arg flag = false; metersEnabled = (flag ? false); ^this }

	attachResizeHandler {
		var run;
		run = {
			var v;
			v = window.tryPerform(\view);
			if(v.notNil) {
				v.onResize = {
					if(debugOn) { this.debugGuides(true) };
				};
			};
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	// -------- Debug overlay --------

	debugGuides { arg on = true;
		var mkOverlay, labelText;
		debugOn = (on ? true);

		mkOverlay = { arg ov;
			var out;
			out = ov;
			if(out.isNil or: { out.isClosed }) {
				out = UserView(window.view);
				out.drawFunc = { |v|
					var b;
					b = v.bounds;
					Pen.color = Color(1, 0, 0, 0.35);
					Pen.width = 2;
					Pen.strokeRect(Rect(1, 1, b.width - 2, b.height - 2));
				};
				out.background = Color.clear;
			};
			out
		};

		AppClock.sched(0.00, {
			overlayRow0 = mkOverlay.value(overlayRow0);
			overlayRow1 = mkOverlay.value(overlayRow1);
			overlayRow2 = mkOverlay.value(overlayRow2);
			overlayRow3 = mkOverlay.value(overlayRow3);
			overlayRow4 = mkOverlay.value(overlayRow4);

			rootLayout.addSpanning(overlayRow0, 0, 0, 1, 2);
			rootLayout.addSpanning(overlayRow1, 1, 0, 1, 2);
			rootLayout.addSpanning(overlayRow2, 2, 0, 1, 2);
			rootLayout.addSpanning(overlayRow3, 3, 0, 1, 2);
			rootLayout.addSpanning(overlayRow4, 4, 0, 1, 2);

			AppClock.sched(0.02, {
				var r0, r1, r2, r3, r4;
				var mkLabel;
				mkLabel = { arg parent, text;
					var st;
					st = StaticText(parent).string_(text).stringColor_(Color(1, 0.2, 0.2)).align_(\left);
					st.background = Color(1, 1, 1, 0.20);
					st  // no caret return in closures
				};

				overlayRow0.children.do(_.remove);
				overlayRow1.children.do(_.remove);
				overlayRow2.children.do(_.remove);
				overlayRow3.children.do(_.remove);
				overlayRow4.children.do(_.remove);

				r0 = overlayRow0.bounds; r1 = overlayRow1.bounds; r2 = overlayRow2.bounds; r3 = overlayRow3.bounds; r4 = overlayRow4.bounds;
				mkLabel.value(overlayRow0, "row 0  " ++ r0.width.round(1) ++ "√ó" ++ r0.height.round(1));
				mkLabel.value(overlayRow1, "row 1  " ++ r1.width.round(1) ++ "√ó" ++ r1.height.round(1));
				mkLabel.value(overlayRow2, "row 2  " ++ r2.width.round(1) ++ "√ó" ++ r2.height.round(1));
				mkLabel.value(overlayRow3, "row 3  " ++ r3.width.round(1) ++ "√ó" ++ r3.height.round(1) ++ " (meters)");
				mkLabel.value(overlayRow4, "row 4  " ++ r4.width.round(1) ++ "√ó" ++ r4.height.round(1) ++ " (processors)");
				nil
			});
			nil
		});

		^this
	}

	postLayoutReport {
		var run;
		run = {
			var r0, r1, r2, r3, r4, unionRow0;
			unionRow0 = leftPanel.bounds.union(rightPanel.bounds);
			r0 = unionRow0; r1 = expectationView.bounds; r2 = countdownHolder.bounds; r3 = meterStrip.bounds; r4 = bottomHudView.bounds;
			("[layout] row0=" ++ r0).postln;
			("[layout] row1=" ++ r1).postln;
			("[layout] row2=" ++ r2).postln;
			("[layout] row3=" ++ r3).postln;
			("[layout] row4=" ++ r4).postln;
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	updateTextField { |box, msg|
		// fallback: write to expectationView only
		if(expectationView.notNil) {
			expectationView.string_("[" ++ box.asString ++ "] " ++ msg.asString);
		};
		^this;
	}



	//new
	// Add inside MagicDisplayGUI_GridDemo class:
	// setOperations { arg itemsArray;
	// 	var s;
	// 	// build a visible list; accept nil and non-strings defensively
	// 	s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
	// 	if(choicesText.notNil) {
	// 		AppClock.sched(0.0, {
	// 			choicesText.string_( (s.size > 0).if({ s }, { "‚Äî" }) );
	// 			nil
	// 		});
	// 	};
	// 	^this
	// }

}

===== MagicPedalboard/MagicDisplayGUI_Meters_Responders_Ext.sc_disabled =====
// MagicDisplayGUI_Meters_Draw_Ext.sc
// v0.3.0
// MD 2025-09-24 22:58 BST

/*
Purpose
- Provide enableMeters(flag=true) without adding ivars.
- Draw simple A/B bars into the existing meterStrip : UserView and keep them
  updated from /reply packets sent by SendReply.kr in your AutoMeters helper.
Style
- Class extension only; var-first; AppClock UI; no server.sync; NO ^ inside closures.
*/

+ MagicDisplayGUI_GridDemo {

    // per-window state bag (no new ivars on the class)
    md_meterState {
        var bag, key, dict;
        bag = ~md_meterState ? IdentityDictionary.new;
        key = this.window.identityHash;
        dict = bag[key] ? IdentityDictionary.new;
        bag[key] = dict;
        ~md_meterState = bag;
        ^dict
    }

    // prepare the UserView and its drawFunc
    md_installMeterUserView {
        var state, host, setup;
        state = this.md_meterState;
        host  = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        setup = {
            var uv, ownUV, makeOwn, w, h, y;
            uv = state[\uv]; ownUV = state[\own];
            if(uv.isNil) {
                uv = this.meterStrip; // preferred: reuse your existing strip
                if(uv.isNil) {
                    // fall back: create a new one at bottom
                    w = host.bounds.width;  h = host.bounds.height; y = h - 46;
                    makeOwn = UserView(host);
                    makeOwn.bounds_(Rect(8, y, w - 16, 38));
                    uv = makeOwn; ownUV = true;
                };
                uv.background_(Color(0.12, 0.12, 0.12));
                uv.drawFunc = { |view|
                    var st, vw, vh, a, b, barW, barH, leftX, rightX, midY, titleY;
                    st = this.md_meterState;
                    vw = view.bounds.width;  vh = view.bounds.height;
                    a = (st[\valA] ? 0.0).clip(0, 1);
                    b = (st[\valB] ? 0.0).clip(0, 1);
                    barW = ((vw * 0.45) - 40).max(80);
                    barH = (vh * 0.40);
                    leftX  = 24;
                    rightX = (vw * 0.50) + 24;
                    midY   = (vh * 0.30);
                    titleY = (vh * 0.18);

                    Pen.color = Color(0.85,0.85,0.85);
                    Pen.stringAtPoint("A", Point(leftX - 18, titleY));
                    Pen.stringAtPoint("B", Point(rightX - 18, titleY));

                    Pen.color = Color(0.30, 0.90, 0.30); // A green
                    Pen.addRect(Rect(leftX, midY, barW * a, barH)); Pen.fill;

                    Pen.color = Color(0.30, 0.60, 0.90); // B blue
                    Pen.addRect(Rect(rightX, midY, barW * b, barH)); Pen.fill;
                };
                state[\uv] = uv; state[\own] = ownUV ? true : false;
                uv.refresh;
            };
        };

        AppClock.sched(0.0, { setup.value; nil });
        ^this
    }

    enableMeters { arg flag = true;
        var state, idStr, oscNameA, oscNameB, install, remove;

        state    = this.md_meterState;
        idStr    = this.window.identityHash.asString;
        oscNameA = ("md_ampA_" ++ idStr).asSymbol;
        oscNameB = ("md_ampB_" ++ idStr).asSymbol;

        remove = {
            var oa, ob, uv;
            oa = OSCdef(oscNameA); if(oa.notNil) { oa.free };
            ob = OSCdef(oscNameB); if(ob.notNil) { ob.free };
            state[\valA] = 0.0; state[\valB] = 0.0;
            uv = state[\uv]; if(uv.notNil) { uv.refresh };
            state[\enabled] = false;
        };

        install = {
            var uv;

            this.md_installMeterUserView;

            OSCdef.new(oscNameA, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampA") || (label == "ampA")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valA] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            OSCdef.new(oscNameB, { arg msg;
                var label, vals, mean, u;
                label = msg[2].asString;
                if((label == "/ampB") || (label == "ampB")) {
                    vals = msg.copyToEnd(3);
                    mean = (((vals[0] ? 0) + (vals[1] ? 0)) * 0.5).clip(0, 1);
                    state[\valB] = mean;
                    AppClock.sched(0.0, { u = state[\uv]; if(u.notNil) { u.refresh }; nil });
                };
            }, '/reply');

            state[\enabled] = true;
        };

        AppClock.sched(0.0, { if(flag) { install.value } { remove.value }; nil });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd
// v0.1.2
// MD 2025-09-26 15:36 BST

/* Purpose
   Provide a tiny, explicit CURRENT chain flag for the HUD (no pulsing).
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_setCurrentChain = { arg chainSymbol;
    var valid;
    valid = (chainSymbol == \A) or: { chainSymbol == \B };
    if(valid) { ~md_currentChain = chainSymbol };
    nil
};

~md_toggleCurrentChain = {
    var now;
    now = ~md_currentChain ? \A;
    ~md_currentChain = (now == \A).if({ \B }, { \A });
    nil
};

~md_isChainAActive = { (~md_currentChain ? \A) == \A };
~md_isChainBActive = { (~md_currentChain ? \A) == \B };
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd
// v0.1.1 (robust attach + returns view)
// MD 2025-09-26 15:58 BST

/* Purpose
   A thin ACTIVE overlay bar at the top of the HUD.
   - A = green, B = blue-ish.
   - Robust window lookup (name contains "MagicDisplayGUI" or "PerfHUD").
   - Returns the overlay view (so "-> a UserView" shows in post).
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_attachActiveOverlay = {
    var windowsList, hudWindow, nameString, barHeight, overlayView, refreshRoutine;
    windowsList = Window.allWindows;

    hudWindow = windowsList.detect({ arg w;
        var n;
        n = w.tryPerform(\name);
        nameString = n.notNil.if({ n.asString }, { "" });
        (nameString.contains("MagicDisplayGUI") or: { nameString.contains("PerfHUD") })
    });

    if(hudWindow.isNil) {
        "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn;
        ^nil
    };

    barHeight = 8;

    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color;
        Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height));
        Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    ~md_activeOverlayView = overlayView;
    ~md_activeOverlayRoutine = refreshRoutine;

    "[HUD] active overlay attached (top bar)".postln;
    overlayView   // IMPORTANT: return the view (not nil)
};

~md_detachActiveOverlay = {
    var view, routine;
    view = ~md_activeOverlayView; routine = ~md_activeOverlayRoutine;
    if(routine.notNil) { routine.stop };
    if(view.notNil) { view.remove };
    ~md_activeOverlayView = nil; ~md_activeOverlayRoutine = nil;
    "[HUD] active overlay removed".postln;
    nil
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Keep the Chain A/B panel backgrounds in sync with ~md_currentChain (solid green).
   - Finds the A/B panels by locating "Chain A"/"Chain B" StaticText labels.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_findHudPanels = {
    var windowRef, collectViews, allViews, panelForLabel, aPanel, bPanel;

    windowRef = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });
    if(windowRef.isNil) { ^[nil, nil] };

    collectViews = { arg rootView, list;
        var children;
        children = rootView.children ? [];
        children.do({ arg c; list.add(c); collectViews.(c, list) });
        list
    };

    allViews = collectViews.(windowRef.view, List.new);

    panelForLabel = { arg labelString;
        var labelView, panelView;
        labelView = allViews.detect({ arg v; v.isKindOf(StaticText) and: { v.string == labelString } });
        panelView = labelView.notNil.if({ labelView.parent }, { nil });
        panelView
    };

    aPanel = panelForLabel.("Chain A");
    bPanel = panelForLabel.("Chain B");
    [aPanel, bPanel]
};

~md_startActiveTintOverlay = {
    var panels, aPanel, bPanel, winRef, routine, activeColor, idleColor;

    panels = ~md_findHudPanels.();
    aPanel = panels[0]; bPanel = panels[1];

    if(aPanel.isNil or: { bPanel.isNil }) {
        "‚ö†Ô∏è Could not locate Chain A/B panels; tint overlay not installed.".warn;
        ^nil
    };

    winRef = aPanel.window;
    activeColor = Color(0.18, 0.28, 0.18);
    idleColor   = Color.grey(0.15);

    routine = Routine({
        var keepRunning, isA, isB;
        keepRunning = true;
        while({ keepRunning and: { winRef.notNil and: { winRef.isClosed.not } } }, {
            isA = (~md_currentChain ? \A) == \A;
            isB = (~md_currentChain ? \A) == \B;
            aPanel.background_( isA.if({ activeColor }, { idleColor }) );
            bPanel.background_( isB.if({ activeColor }, { idleColor }) );
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] ACTIVE tint overlay running (current=" ++ (~md_currentChain ? \A).asString ++ ")".postln;
    routine
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd =====
// MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd
// v0.1.0
// MD 2025-09-26 16:10 BST

/* Purpose
   Listen to /md/levels_gui (GA=32001, GB=32002), fill ~md_gui_levelsById,
   and provide a tiny overlay + helpers that read from that dict.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_gui_levelsById  = ~md_gui_levelsById  ? IdentityDictionary.new;
~md_gui_lastStamp   = ~md_gui_lastStamp   ? SystemClock.seconds.asFloat;

~md_installGuiLevelsListener = {
    var key, existing;
    key = \md_levels_gui_listener;

    existing = OSCdef.all.at(key);
    if(existing.notNil) { existing.free };

    OSCdef(key, { arg msg;
        var replyId, l, r, safeL, safeR, now;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        l = msg[3].asFloat; r = msg[4].asFloat;
        safeL = l.isFinite.if({ l.clip(0, 1) }, { 0.0 });
        safeR = r.isFinite.if({ r.clip(0, 1) }, { 0.0 });
        ~md_gui_levelsById.put(replyId, [safeL, safeR]);
        now = SystemClock.seconds.asFloat;
        ~md_gui_lastStamp = now;
        nil
    }, "/md/levels_gui", recvPort: NetAddr.langPort);

    "[HUD] /md/levels_gui listener installed (key=md_levels_gui_listener)".postln;
    nil
};

~md_attachGuiOverlayMeters = {
    var hudWindow, overlayView, barWidth, pad, height, refreshRoutine;

    // robust window search
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    pad = 8; barWidth = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, barWidth, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        aPair = ~md_gui_levelsById.at(32001) ? [0, 0];
        bPair = ~md_gui_levelsById.at(32002) ? [0, 0];

        aL = aPair[0]; aR = aPair[1];
        bL = bPair[0]; bR = bPair[1];

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B top half
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] overlay meters (GUI) attached (top-left)".postln;
    overlayView  // return view
};

~md_currentChain = ~md_currentChain ? \A;
~md_attachActiveOverlay = {  // reuse name, returns a UserView
    var hudWindow, overlayView, barHeight, refreshRoutine;
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    barHeight = 8;
    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color; Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height)); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    "[HUD] active overlay attached (top bar)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext_V0.1.0.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.1
// MD 2025-09-29 16:58 BST

/* Purpose
   Install language-side OSC responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters. Also install HUD
   meter mapping helpers so UI levels have headroom and do not peg at 1.0.

   Keeper notes
   - 2025-09-29: Ensure ampA/ampB responders auto-install on HUD bring-up (after reset).
                 Added ~hud_map_linear_to_ui (and dB sibling) with defaults:
                 floor -60 dB, top -6 dB, gamma 1.0. Apply at UI write-site.
                 Without responders, ~md_levelsById may be stale/empty ‚Üí solid green meters.

Style
   - var-first; descriptive lowercase names; AppClock-only for UI; no server.sync; no non-local returns.
*/

(
var ensureAmpRespondersInstalled, installHudMeterMappingHelpers;

~md_installAmpToModelResponders = {
    var ensureModelReady, existingResponderA, existingResponderB;

    ensureModelReady = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModelReady.();

    // /ampA -> model[2001]
    existingResponderA = OSCdef.all.at(\ampA_to_model);
    if(existingResponderA.notNil) { existingResponderA.free };
    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingResponderB = OSCdef.all.at(\ampB_to_model);
    if(existingResponderB.notNil) { existingResponderB.free };
    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};

ensureAmpRespondersInstalled = {
    var hasResponderA, hasResponderB;
    hasResponderA = OSCdef.all.at(\ampA_to_model).notNil;
    hasResponderB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasResponderA.not or: { hasResponderB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Keeper defaults (adjust to taste across sessions)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 lifts lows; >1 tames lows

    // Linear (0..1) ‚Üí UI 0..1 via dB mapping + optional perceptual curve
    ~hud_map_linear_to_ui = ~hud_map_linear_to_ui ? { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear ‚Üí dBFS
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dBFS ‚Üí 0..1
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);
        curvedValue
    };

    // dB (e.g., -60..0) ‚Üí UI 0..1 (sibling helper if a dB route is used anywhere)
    ~hud_map_db_to_ui = ~hud_map_db_to_ui ? { arg dbValue;
        var floorDb, topDb, gammaValue, normalizedValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0).clip(0.0, 1.0);
        normalizedValue.pow(gammaValue)
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

// Schedule both on AppClock so they are present after HUD bring-up and after a reset
AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Install language-side responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(

	//new
	var ensureAmpRespondersInstalled;
var installHudMeterMappingHelpers;


~md_installAmpToModelResponders = {
    var ensureModel, existingA, existingB;




    ensureModel = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModel.();

    // /ampA -> model[2001]
    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};


ensureAmpRespondersInstalled = {
    var hasAmpA, hasAmpB;

    hasAmpA = OSCdef.all.at(\ampA_to_model).notNil;
    hasAmpB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasAmpA.not or: { hasAmpB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Display calibration (keeper defaults; tweak to taste)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 raises lows; >1 tames lows

    // Linear (0..1) ‚Üí UI value (0..1) with dB headroom and optional curve
    ~hud_map_linear_to_ui = { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db;
        topDb      = ~hud_meter_top_db;
        gammaValue = ~hud_meter_gamma;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear ‚Üí dB
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dB ‚Üí 0..1 (with top < 0 dBFS)
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);                // perceptual shaping (optional)
        curvedValue
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });

)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_Meters_Ext.scd =====
// MagicDisplayGUI_PerfHUD_Meters_Ext.scd
// v0.1.0
// MD 2025-09-26 15:05 BST

/* Purpose / Style
   Provide a small dbScale helper and an optional overlay you can attach to the HUD.
   - var-first; descriptive lowercase; AppClock-only; no server.sync; no non-local '^'.
*/

(
~md_dbScale = { arg linAmp, dbMin = -60.0;
    var safeAmp, dbVal, norm;
    safeAmp = (linAmp ? 0.0).max(1e-6);
    dbVal   = safeAmp.ampdb;                      // language-side conversion
    norm    = ((dbVal - dbMin) / (0 - dbMin)).clip(0.0, 1.0);
    norm
};

~md_attachOverlayMeters = {
    var hudWindow, pad, width, height, overlayView;

    hudWindow = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });

    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI window found.".warn; ^nil };

    pad = 8; width = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, aLs, aRs, bLs, bRs, h, halfW;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0]; aR = aPair[1]; bL = bPair[0]; bR = bPair[1];

        aLs = ~md_dbScale.(aL, -60.0); aRs = ~md_dbScale.(aR, -60.0);
        bLs = ~md_dbScale.(bL, -60.0); bRs = ~md_dbScale.(bR, -60.0);

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aLs), halfW, (h/2 * aLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aRs), halfW, (h/2 * aRs))); Pen.fill;

        // B top half (lighter)
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bLs), halfW, (h/2 * bLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bRs), halfW, (h/2 * bRs))); Pen.fill;
    });

    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left; dB-scaled)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicDisplayGUI.sc =====
/* MagicDisplayGUI.sc v0.2.7
 CURRENT column highlighted in green; top-down list (src ‚Üí procs ‚Üí sink);
 expectation text + visual countdown; operations list with 3s pre-roll;
 embedded meters (A/B). UI-ready queue prevents touching nil views.
 No server.sync; server ops inside Server.default.bind.
 // MD 20250912-1738
*/
MagicDisplayGUI : MagicDisplay {
	classvar <versionGUI;

	var <window;

	// layout elements
	var leftPanel, rightPanel;
	var leftHeader, rightHeader;
	var leftListView, rightListView;
	var leftEffective, rightEffective;

	// expectation + countdown
	var expectationText;
	var countdownLabel, countdownBarView, countdownTask, countdownSecondsDefault;

	// operations panel
	var opsListView, opsNextButton, opsStatusText;
	var opsItems, opsIndexNext, opsCallback, opsCountdownSeconds;

	// meters
	var meterViewA, meterViewB;
	var meterSynthA, meterSynthB, oscA, oscB;
	var enableMetersFlag;

	// ui-ready machinery
	var uiReadyFlag;
	var uiPendingActions;

	*initClass {
		var text;
		versionGUI = "v0.2.7";
		text = "MagicDisplayGUI " ++ versionGUI;
		text.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var windowRect, panelWidth, listHeight, headerHeight, footerHeight, pad;
		var opsWidth, opsRect;
		var buildWindow;

		windowRect = Rect(100, 100, 980, 520);
		panelWidth = 300;
		listHeight = 300;
		headerHeight = 28;
		footerHeight = 22;
		pad = 10;

		opsWidth = 320;
		opsRect = Rect(2 * pad + 2 * panelWidth + 40, pad, opsWidth, windowRect.height - 2 * pad);

		countdownSecondsDefault = 3.0;
		opsCountdownSeconds = 3.0;
		enableMetersFlag = true;

		uiReadyFlag = false;
		uiPendingActions = Array.new;

		buildWindow = {
			var metersHeight, greenBg, neutralBg;
			var buildColumn, buildMeters, applyInitialHighlight;
			var columnLeftX, columnRightX;
			var columnLeftDict, columnRightDict;

			metersHeight = 86;
			greenBg = Color(0.85, 1.0, 0.85);
			neutralBg = Color(0.92, 0.92, 0.92);

			columnLeftX = pad;
			columnRightX = pad + panelWidth + 40;

			buildColumn = { arg xPos, title;
				var panel, header, listView, effectiveLabel;
				var headerRect, listRect, effRect, resultDict;

				panel = CompositeView(window, Rect(xPos, pad, panelWidth, windowRect.height - 2 * pad - metersHeight));
				panel.background_(neutralBg);

				headerRect = Rect(0, 0, panelWidth, headerHeight);
				header = StaticText(panel, headerRect).string_(title);
				header.align_(\center);

				listRect = Rect(0, headerHeight + 6, panelWidth, listHeight);
				listView = ListView(panel, listRect).items_([]);

				effRect = Rect(0, headerHeight + 6 + listHeight + 6, panelWidth, footerHeight);
				effectiveLabel = StaticText(panel, effRect).string_("eff: ‚Äî");
				effectiveLabel.align_(\center);

				resultDict = (panel: panel, header: header, list: listView, eff: effectiveLabel);
				resultDict
			};

			buildMeters = {
				var metersGroup, labelA, labelB, row1, row2, labelWidth, barWidth, rowHeight;

				labelWidth = 60;
				barWidth = windowRect.width - 2 * pad - labelWidth - 10;
				rowHeight = 30;

				metersGroup = CompositeView(window, Rect(pad, windowRect.height - metersHeight - pad, windowRect.width - 2 * pad, metersHeight));
				metersGroup.background_(Color(0.96, 0.96, 0.96));

				row1 = CompositeView(metersGroup, Rect(0, 0, metersGroup.bounds.width, rowHeight));
				labelA = StaticText(row1, Rect(0, 4, labelWidth, 20)).string_("chainA");
				meterViewA = LevelIndicator(row1, Rect(labelWidth + 6, 4, barWidth, 20));

				row2 = CompositeView(metersGroup, Rect(0, rowHeight + 8, metersGroup.bounds.width, rowHeight));
				labelB = StaticText(row2, Rect(0, 4, labelWidth, 20)).string_("chainB");
				meterViewB = LevelIndicator(row2, Rect(labelWidth + 6, 4, barWidth, 20));
			};

			applyInitialHighlight = {
				var currentBg, nextBg;
				currentBg = greenBg;
				nextBg = neutralBg;
				if(leftPanel.notNil) { leftPanel.background_(currentBg) };
				if(rightPanel.notNil) { rightPanel.background_(nextBg) };
			};

			window = Window("MagicDisplayGUI ‚Äì CURRENT / NEXT", windowRect).front.alwaysOnTop_(true);

			columnLeftDict = buildColumn.value(columnLeftX, "CURRENT");
			leftPanel      = columnLeftDict[\panel];
			leftHeader     = columnLeftDict[\header];
			leftListView   = columnLeftDict[\list];
			leftEffective  = columnLeftDict[\eff];

			columnRightDict = buildColumn.value(columnRightX, "NEXT");
			rightPanel      = columnRightDict[\panel];
			rightHeader     = columnRightDict[\header];
			rightListView   = columnRightDict[\list];
			rightEffective  = columnRightDict[\eff];

			expectationText = TextView(window, Rect(pad, leftPanel.bounds.bottom + 6, 2 * panelWidth + 40, 52));
			expectationText.background_(Color(1, 1, 0.9));
			expectationText.string_("Command:");

			countdownLabel = StaticText(window, Rect(pad, expectationText.bounds.bottom + 6, 120, 20)).string_("Ready");

			countdownBarView = UserView(window, Rect(pad + 130, expectationText.bounds.bottom + 6, panelWidth - 10, 20));
			countdownBarView.background_(Color(0.9, 0.9, 0.9));
			countdownBarView.drawFunc_({ arg view;
				var barWidthNow, fullWidth, progressFraction, colorFill, progressStored;
				progressStored = view.getProperty(\progress) ? 0.0;
				progressFraction = progressStored.clip(0, 1);
				fullWidth = view.bounds.width;
				barWidthNow = fullWidth * progressFraction;
				colorFill = Color(0.3, 0.8, 0.3);
				Pen.fillColor = colorFill;
				Pen.addRect(Rect(0, 0, barWidthNow, view.bounds.height));
				Pen.fill;
			});
			countdownBarView.setProperty(\progress, 0.0);

			opsItems = Array.new;
			opsIndexNext = 0;
			opsCallback = nil;

			opsListView = ListView(window, opsRect).items_([]);
			opsStatusText = StaticText(window, Rect(opsRect.left, opsRect.bottom - 52, opsRect.width - 110, 20)).string_("Next: ‚Äî");
			opsNextButton = Button(window, Rect(opsRect.right - 100, opsRect.bottom - 56, 100, 28))
			.states_([["Next (3s)", Color.white, Color(0, 0.5, 0)]])
			.action_({
				var nextIndexLocal, totalCountLocal, nextLabel;
				nextIndexLocal = opsIndexNext;
				totalCountLocal = opsItems.size;
				if(nextIndexLocal >= totalCountLocal) { "No more operations.".postln; ^nil };
				nextLabel = opsItems[nextIndexLocal];
				this.startCountdown(opsCountdownSeconds, "Next: " ++ nextLabel, {
					var clampedIndex;
					clampedIndex = opsIndexNext.clip(0, opsItems.size - 1);
					this.runNextOperation(clampedIndex);
				});
			});

			buildMeters.value;
			applyInitialHighlight.value;

			uiReadyFlag = true;
			this.flushUiPendingActions;
		};

		AppClock.sched(0, {
			var enableNow;
			buildWindow.value;
			enableNow = enableMetersFlag;
			if(enableNow) { this.enableMeters(true) };
			nil
		});

		^this
	}

	// ui-ready helpers
	queueUi { arg func;
		var fn;
		fn = func;
		if(uiReadyFlag) {
			AppClock.sched(0, { fn.value; nil });
		}{
			uiPendingActions = uiPendingActions.add(fn);
		};
	}

	flushUiPendingActions {
		var actionsToRun;
		actionsToRun = uiPendingActions;
		uiPendingActions = Array.new;
		actionsToRun.do({ arg f;
			AppClock.sched(0, { f.value; nil });
		});
	}


	// visuals

// highlight whichever sink is CURRENT
highlightCurrentColumn { arg currentSinkSym;
    var greenBg, neutralBg, isA;
    greenBg   = Color(0.85, 1.0, 0.85);
    neutralBg = Color(0.92, 0.92, 0.92);
    isA = (currentSinkSym == \chainA);

    this.queueUi({
        if(leftPanel.notNil)  { leftPanel.background_(if(isA) { greenBg } { neutralBg }) };
        if(rightPanel.notNil) { rightPanel.background_(if(isA) { neutralBg } { greenBg }) };
    });
}

/*	highlightCurrentColumn {
		var greenBg, neutralBg;
		greenBg = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		this.queueUi({
			if(leftPanel.notNil) { leftPanel.background_(greenBg) };
			if(rightPanel.notNil) { rightPanel.background_(neutralBg) };
		});
	}*/

	formatListTopDown { arg listRef, bypassKeys, effectiveList;
		var itemsOut, lastIndex, processorsList, indexCounter, sourceKey, sinkKey, isBypassed, badge, lineText;
		itemsOut = Array.new;
		lastIndex = listRef.size - 1;
		sinkKey = listRef[0];
		sourceKey = listRef[lastIndex];

		itemsOut = itemsOut.add("src  : " ++ sourceKey);

		if(listRef.size > 2) {
			itemsOut = itemsOut.add("procs:");
			processorsList = listRef.copyRange(1, lastIndex - 1).reverse;
			indexCounter = 1;
			processorsList.do({ arg procKey;
				isBypassed = bypassKeys.includes(procKey);
				badge = if(isBypassed) { "[BYP]" } { "[ON]" };
				lineText = "  [" ++ indexCounter ++ "] " ++ procKey ++ " " ++ badge;
				itemsOut = itemsOut.add(lineText);
				indexCounter = indexCounter + 1;
			});
		}{
			itemsOut = itemsOut.add("procs: (none)");
		};

		itemsOut = itemsOut.add("sink : " ++ sinkKey);
		itemsOut = itemsOut.add("eff  : " ++ effectiveList.join(" -> "));
		^itemsOut
	}

	// expectation + countdown
	showExpectation { arg textString, seconds = 0;
		var secondsLocal, hasCountdown;
		secondsLocal = seconds ? 0;
		hasCountdown = secondsLocal > 0;

		this.queueUi({
			var labelNow;
			if(expectationText.notNil) { expectationText.string_(textString.asString) };
			if(hasCountdown) {
				this.startCountdown(secondsLocal, "Listen in‚Ä¶", { nil });
			}{
				labelNow = "Ready";
				if(countdownLabel.notNil) { countdownLabel.string_(labelNow) };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, 0.0);
					countdownBarView.refresh;
				};
			};
		});
	}

	startCountdown { arg seconds, labelText, onFinishedFunc;
		var secondsClamped, startTime, stopTime;
		secondsClamped = seconds.clip(0.5, 10.0);
		startTime = Main.elapsedTime;
		stopTime = startTime + secondsClamped;

		if(countdownTask.notNil) { countdownTask.stop; countdownTask = nil };

		this.queueUi({
			var finishedFlag, delaySeconds, updateAndCheckDone;

			if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ secondsClamped.asString ++ "s)") };
			if(countdownBarView.notNil) {
				countdownBarView.setProperty(\progress, 0.0);
				countdownBarView.refresh;
			};

			finishedFlag = false;
			delaySeconds = 0.05;

			updateAndCheckDone = {
				var nowTime, remainingSeconds, progressFraction;
				nowTime = Main.elapsedTime;
				remainingSeconds = (stopTime - nowTime).max(0);
				progressFraction = ((secondsClamped - remainingSeconds) / secondsClamped).clip(0.0, 1.0);

				if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ remainingSeconds.round(0.1).asString ++ "s)") };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, progressFraction);
					countdownBarView.refresh;
				};

				if(remainingSeconds <= 0) { finishedFlag = true };
			};

			countdownTask = Task({
				var localFinished;
				localFinished = false;
				while({ localFinished.not }, {
					updateAndCheckDone.value;
					localFinished = finishedFlag;
					delaySeconds.wait;
				});
				if(countdownLabel.notNil) { countdownLabel.string_("Now") };
				if(onFinishedFunc.notNil) { onFinishedFunc.value };
			}, AppClock).play;
		});
	}

	// operations
	setOperations { arg itemsArray;
		var itemsSafe, entryStrings;
		itemsSafe = itemsArray ? Array.new;
		entryStrings = itemsSafe.collect({ arg it; it.asString });

		this.queueUi({
			opsItems = entryStrings;
			if(opsListView.notNil) { opsListView.items_(opsItems) };
			opsIndexNext = 0;
			this.updateOpsHighlight;
		});
	}

	setNextAction { arg func;
		var f;
		f = func;
		opsCallback = f;
	}

	runNextOperation { arg indexToRun;
		var totalCount, nextIndexComputed;
		totalCount = opsItems.size;

		if(opsCallback.notNil) {
			opsCallback.value(indexToRun);
		}{
			("[ops] No callback for index " ++ indexToRun).warn;
		};

		nextIndexComputed = (indexToRun + 1).clip(0, totalCount);
		opsIndexNext = nextIndexComputed;
		this.updateOpsHighlight;
	}

	updateOpsHighlight {
		var totalCount, entryStrings, nextIndexLocal, statusText;
		totalCount = opsItems.size;
		nextIndexLocal = opsIndexNext.min(totalCount);

		entryStrings = opsItems.collect({ arg item, idx;
			var marker;
			marker = if(idx == opsIndexNext) { "‚Üí " } { "   " };
			marker ++ item
		});

		statusText = if(opsIndexNext < totalCount) {
			"Next: " ++ opsItems[opsIndexNext]
		}{
			"Done."
		};

		this.queueUi({
			if(opsListView.notNil) { opsListView.items_(entryStrings) };
			if(opsStatusText.notNil) { opsStatusText.string_(statusText) };
		});
	}

	/////////////////
	// meters
	// --- canonical enableMeters: waits until sinks are audio-rate, then attaches meters ---
// MagicDisplayGUI.sc
// canonical enableMeters: resend SynthDefs every time; wait until sinks are audio-rate

	enableMeters { arg flag = true;
    var shouldEnable, busA, busB;

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        // Guard: wait until sinks are audio-rate and server is up
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        if(
            Server.default.serverRunning.not
            or: { busA.isNil or: { busB.isNil } }
            or: { busA.rate != \audio or: { busB.rate != \audio } }
        ) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };

        // Meters rely on SynthDefs provided by MagicDisplay.ensureMeterDefs(...)
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };
            meterSynthA = Synth(\busMeterA, [\inBus, Ndef(\chainA).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, Ndef(\chainB).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free }; if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');

        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');

        ^this;
    }{
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}

/*
enableMeters { arg flag = true;
    var shouldEnable, aOK, bOK, busA, busB;

    // When enabling, wait until sinks are audio-rate (no control-rate bus warnings)
    if(flag) {
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        aOK = busA.notNil and: { busA.rate == \audio };
        bOK = busB.notNil and: { busB.rate == \audio };
        if(aOK.not or: { bOK.not }) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
        // Also guard against server being off
        if(Server.default.serverRunning.not) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
    };

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        Server.default.bind({
            var busA_local, busB_local;

            // Always (re)send SynthDefs so they exist on the server now.
            SynthDef(\busMeterA, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
            }).add;
            SynthDef(\busMeterB, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
            }).add;

            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };

            busA_local = Ndef(\chainA).bus;
            busB_local = Ndef(\chainB).bus;

            meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free };
        if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');
        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');
        ^this;

    } {
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}*/
//////
/*	enableMeters { arg flag = true;
		var shouldEnable, aOK, bOK, busA, busB;

		// Only guard when enabling
		if(flag) {
			// read buses once
			busA = Ndef(\chainA).bus;
			busB = Ndef(\chainB).bus;
			// both must exist and be audio-rate
			aOK = busA.notNil and: { busA.rate == \audio };
			bOK = busB.notNil and: { busB.rate == \audio };
			if(aOK.not or: { bOK.not }) {
				// retry shortly on AppClock; do not mutate the audio tree here
				AppClock.sched(0.20, { this.enableMeters(true); nil });
				^this;
			};
		};

		shouldEnable = flag ? true;
		enableMetersFlag = shouldEnable;

		if(shouldEnable) {
			// --- enable path (unchanged except for the pre-check above) ---
			Server.default.bind({
				var hasA, hasB, busA_local, busB_local;
				hasA = SynthDescLib.global.at(\busMeterA).notNil;
				hasB = SynthDescLib.global.at(\busMeterB).notNil;
				if(hasA.not) {
					SynthDef(\busMeterA, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
					}).add;
				};
				if(hasB.not) {
					SynthDef(\busMeterB, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
					}).add;
				};
				if(meterSynthA.notNil) { meterSynthA.free };
				if(meterSynthB.notNil) { meterSynthB.free };
				// read buses post-guard
				busA_local = Ndef(\chainA).bus;
				busB_local = Ndef(\chainB).bus;
				meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
				meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
			});

			if(oscA.notNil) { oscA.free };
			if(oscB.notNil) { oscB.free };
			oscA = OSCdef(\ampA, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
			}, '/ampA');
			oscB = OSCdef(\ampB, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
			}, '/ampB');
			^this;

		} {
			// --- disable path (unchanged) ---
			Server.default.bind({
				if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
				if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
			});
			if(oscA.notNil) { oscA.free; oscA = nil; };
			if(oscB.notNil) { oscB.free; oscB = nil; };
			AppClock.sched(0, {
				if(meterViewA.notNil) { meterViewA.value_(0.0) };
				if(meterViewB.notNil) { meterViewB.value_(0.0) };
				nil
			});
			^this;
		};
	}
*/

	///////////////

	// display hooks
	showInit { arg pedalboard, versionString, current, next;
		var titleText;
		titleText = "MagicDisplayGUI ‚Äì " ++ versionString;
		this.queueUi({
			if(window.notNil) { window.name_(titleText) };
		});
	}

	showRebuild { arg which, fullChain, effective;
		var infoText;
		infoText = "[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ " effective=" ++ effective;
		AppClock.sched(0, { infoText.postln; nil });
	}

	showPlay { arg sinkKey;
		var text;
		text = "[MPB:play] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showStop { arg sinkKey;
		var text;
		text = "[MPB:stop] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showSwitch { arg oldSink, newSink, current, next;
    var infoText;
    infoText = "[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink;
    this.queueUi({
        // was: this.highlightCurrentColumn;
        this.highlightCurrentColumn(newSink);               // <-- pass which sink is now CURRENT

        if(opsStatusText.notNil) {
            opsStatusText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
        }{
            if(expectationText.notNil) {
                expectationText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
            };
        };
    });
    AppClock.sched(0, { infoText.postln; nil });
}

	// showSwitch { arg oldSink, newSink, current, next;
	// 	var infoText;
	// 	infoText = "[MPB:switch] " ++ oldSink ++ " ‚Üí " ++ newSink;
	// 	this.queueUi({
	// 		// keep window title stable; show transient text in labels instead
	// 		this.highlightCurrentColumn;
	// 		if(opsStatusText.notNil) {
	// 			opsStatusText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
	// 		}{
	// 			if(expectationText.notNil) {
	// 				expectationText.string_("Switched: " ++ oldSink ++ " ‚Üí " ++ newSink);
	// 			};
	// 		};
	// 	});
	// 	AppClock.sched(0, { infoText.postln; nil });
	// }


	showMutation { arg action, args, nextChain;
		var text;
		text = "[MPB:mutate] " ++ action ++ " " ++ args ++ " next=" ++ nextChain;
		AppClock.sched(0, { text.postln; nil });
	}

	showBypass { arg which, key, state, chain, bypassKeys;
		var text;
		text = "[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state ++ " active=" ++ bypassKeys;
		AppClock.sched(0, { text.postln; nil });
	}

	showReset { arg current, next;
		var text;
		text = "[MPB:reset] current=" ++ current ++ " next=" ++ next;
		AppClock.sched(0, { text.postln; nil });
	}

	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
    var currentItems, nextItems, effCurrentText, effNextText, aIsPlaying, bIsPlaying, aIsCurrent;

    currentItems   = this.formatListTopDown(current, bypassAKeys, effCurrent);
    nextItems      = this.formatListTopDown(next,   bypassBKeys, effNext);
    effCurrentText = "eff: " ++ effCurrent.join(" -> ");
    effNextText    = "eff: " ++ effNext.join(" -> ");

    // detect which sink is CURRENT by the actual play state of the sink Ndef
    aIsPlaying = Ndef(\chainA).isPlaying;
    bIsPlaying = Ndef(\chainB).isPlaying;
    aIsCurrent = (aIsPlaying and: { bIsPlaying.not });  // Option A expects XOR; if both stopped, keep previous
    this.queueUi({
        if(leftHeader.notNil)  { leftHeader.string_(if(aIsCurrent) { "CHAIN A ACTIVE" } { "CHAIN A NEXT" }) };
        if(rightHeader.notNil) { rightHeader.string_(if(aIsCurrent) { "CHAIN B NEXT"  } { "CHAIN B ACTIVE" }) };

        if(leftListView.notNil)  { leftListView.items_(currentItems) };
        if(rightListView.notNil) { rightListView.items_(nextItems) };

        if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
        if(rightEffective.notNil) { rightEffective.string_(effNextText) };
    });
}

/*	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var currentItems, nextItems, effCurrentText, effNextText;
		currentItems = this.formatListTopDown(current, bypassAKeys, effCurrent);
		nextItems = this.formatListTopDown(next,   bypassBKeys, effNext);
		effCurrentText = "eff: " ++ effCurrent.join(" -> ");
		effNextText    = "eff: " ++ effNext.join(" -> ");

		this.queueUi({
			if(leftHeader.notNil)  { leftHeader.string_("CHAIN A ACTIVE") };
			if(rightHeader.notNil) { rightHeader.string_("CHAIN B NEXT") };
			if(leftListView.notNil)  { leftListView.items_(currentItems) };
			if(rightListView.notNil) { rightListView.items_(nextItems) };
			if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
			if(rightEffective.notNil) { rightEffective.string_(effNextText) };
		});
	}*/

	showError { arg message;
		var text;
		text = "[MPB:error] " ++ message;
		AppClock.sched(0, { text.warn; nil });
	}
}

===== MagicPedalboard/MagicPedalboard.sc =====
/* MagicPedalboard.sc v0.4.9
 A/B pedalboard chain manager built on Ndefs.
 - Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
// MD 2025-10-02 13:58
*/

/*
Supplementary header ‚Äî What this class does & key dependencies
----------------------------------------------------------------
Overview
- Manages two signal chains (CURRENT and NEXT) as symbol arrays [sink, processors..., source],
  built with JITLib NodeProxies (Ndef) and connected using the embedding operator:
  Ndef(left) <<> Ndef(right). Switches are crossfaded; rebuilds are non-destructive.

Core responsibilities
- Materialize and keep \chainA / \chainB sinks alive at audio rate.
- Maintain CURRENT vs NEXT chains, with mutators that operate primarily on NEXT (e.g., add/remove/swap/bypass).
- Provide safe, exclusive playback semantics (NEXT hard-silenced; CURRENT audible) and optional crossfade switch.

Relies on (classes / facilities expected on the classpath)
- JITLib / NodeProxy system: Ndef, embedding via <<>.
- SuperCollider server primitives: Server, Ndef buses, AppClock for light scheduling.
- Optional display adaptor (MagicDisplay / MagicDisplayGUI) for chain prints, status, and meter UX.
- Optional processor library (processorLib) that can .ensureFromChain(list, numChannels).

External interactions
- This class does not reset the server during rebuild; only .reset implements a guarded tree reset.
- Exposes a simple dispatcher .handleCommand(path) that defers to ~ct_applyOSCPathToMPB if present.

Notes
- This update only adds class-side utilities (*help, *api, *test) and a supplementary header.
- No behavior changes to public or internal instance methods (including the existing instance help).
*/

MagicPedalboard : Object {
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // class metadata
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    classvar <version;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // instance state
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var < currentChain; // read-only pointer to Array of Symbols
    var <nextChain; // read-only pointer to Array of Symbols
    var chainAList; // [\chainA, ...processors..., source]
    var chainBList; // [\chainB, ...processors..., source]
    var bypassA; // IdentityDictionary: key(Symbol) -> Bool
    var bypassB; // IdentityDictionary: key(Symbol) -> Bool
    var < defaultNumChannels;
    var < defaultSource;
    var < display; // optional display adaptor
    var < processorLib;
    var < ready; // <-- ADD this line
    *initClass {
        var text;
        version = "v0.4.9";
        text = "MagicPedalboard " ++ version;
        text.postln;
    }
    *new { arg disp = nil;
        var instance;
        instance = super.new;
        ^instance.init(disp);
    }
    init { arg disp;
        var sinkFunc;
        display = disp;
        defaultNumChannels = 2;
        defaultSource = \ts0;
        // less good than the version below
        // sinkFunc = { arg inSignal; inSignal };
        sinkFunc = {
            var inputSignal;
            inputSignal = \in.ar(defaultNumChannels);
            inputSignal
        };
        Ndef(\chainA, sinkFunc);
        Ndef(\chainB, sinkFunc);
        // Guarantee sink buses are audio-rate early (prevents kr-meter races)
        Server.default.bind({
            Ndef(\chainA).ar(defaultNumChannels); // typically 2
            Ndef(\chainB).ar(defaultNumChannels);
        });
        chainAList = [\chainA, defaultSource];
        chainBList = [\chainB, defaultSource];
        bypassA = IdentityDictionary.new;
        bypassB = IdentityDictionary.new;
        currentChain = chainAList;
        nextChain = chainBList;
        Server.default.bind({
            this.rebuildUnbound(nextChain); // stays stopped
            this.rebuildUnbound(currentChain); // plays
        });
/*        this.rebuild(currentChain);
        this.rebuild(nextChain);*/
/* Server.default.bind({
 Ndef(\chainA).play(numChannels: defaultNumChannels);
 });*/
        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };
        // enforce exclusive invariant (Option A) at first bring-up
        this.enforceExclusiveCurrentOptionA(0.1);
        // set initial state; the poll will flip it once conditions are true
        ready = false;
        // OPTION A: enable background poll (comment out if you prefer Option B)
        this.startReadyPoll;
        ^this
    }
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // public API
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // add a setter (public)
    setProcessorLib { arg lib;
        processorLib = lib;
    }
    setDisplay { arg disp;
        var shouldShow;
        display = disp;
        shouldShow = display.notNil;
        if(shouldShow) {
            display.showInit(this, version, currentChain, nextChain);
        };
    }
    help {
        var text;
        text = String.new;
        text = text
        ++ "MagicPedalboard " ++ version ++ "\n"
        ++ "Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].\n"
        ++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
        ++ "Core methods (operate mostly on the *next* chain):\n"
        ++ " printChains\n"
        ++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
        ++ " add(key), addAt(key, index)\n"
        ++ " removeAt(index), swap(indexA, indexB)\n"
        ++ " bypass(key, state=true), bypassAt(index, state=true)\n"
        ++ " clearChain\n"
        ++ "Current-chain bypass helpers:\n"
        ++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
        ++ "Diagnostics/helpers:\n"
        ++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
        ++ "Source setters:\n"
        ++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
        text.postln;
    }
    // Detailed printing routed through display if available
    printChains {
        var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
        var headerFunc, formatOne;
        bypassAKeys = this.bypassKeysForListInternal(chainAList);
        bypassBKeys = this.bypassKeysForListInternal(chainBList);
        effectiveA = this.effectiveListForInternal(chainAList);
        effectiveB = this.effectiveListForInternal(chainBList);
        hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };
        if(hasDisplay) {
            display.showChainsDetailed(
                chainAList, chainBList,
                bypassAKeys, bypassBKeys,
                effectiveA, effectiveB
            );
        }{
            headerFunc = { arg titleString;
                var lineText;
                lineText = "==== " ++ titleString ++ " ====";
                lineText.postln;
            };
            formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
                var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
                lastIndex = listRef.size - 1;
                sinkKey = listRef[0];
                sourceKey = listRef[lastIndex];
                headerFunc.(titleString);
                ("src : " ++ sourceKey).postln;
                if(listRef.size > 2) {
                    "procs:".postln;
                    processorsList = listRef.copyRange(1, lastIndex - 1);
                    indexCounter = 1;
                    processorsList.do({ arg procKey;
                        isBypassed = bypassKeys.includes(procKey);
                        markText = if(isBypassed) { "BYP" } { "ON " };
                        lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
                        lineText.postln;
                        indexCounter = indexCounter + 1;
                    });
                }{
                    "procs: (none)".postln;
                };
                ("sink: " ++ sinkKey).postln;
                ("eff : " ++ effectiveList.join(" -> ")).postln;
                "".postln;
            };
            formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
            formatOne.("NEXT", chainBList, bypassBKeys, effectiveB);
        };
    }
    playCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        this.rebuild(currentChain);
        Server.default.bind({
            Ndef(sinkKey).play(numChannels: defaultNumChannels);
        });
        if(display.notNil) {
            display.showPlay(sinkKey);
        };
        // enforce exclusive invariant (Option A) after play
        this.enforceExclusiveCurrentOptionA(0.1);
    }
    stopCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            Ndef(sinkKey).stop;
        });
        if(display.notNil) {
            display.showStop(sinkKey);
        };
    }
    // Crossfading chain switch (default 0.1 s, clamped to ~80‚Äì200 ms)
    switchChain { arg fadeTime = 0.1;
        var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        actualFadeTime = fadeTime.clip(0.08, 0.2);
        oldSinkKey = currentChain[0];
        newSinkKey = nextChain[0];
        Server.default.bind({
            // set fade durations
            Ndef(oldSinkKey).fadeTime_(actualFadeTime);
            Ndef(newSinkKey).fadeTime_(actualFadeTime);
            // prebuild NEXT so it is ready, then start it (will fade in)
            this.rebuildUnbound(nextChain);
            Ndef(newSinkKey).play(numChannels: defaultNumChannels);
            // stop OLD (will fade out)
            Ndef(oldSinkKey).stop;
            // swap pointers
            temporaryList = currentChain;
            currentChain = nextChain;
            nextChain = temporaryList;
            // ensure both chains are in correct post-swap state
            this.rebuildUnbound(currentChain);
            this.rebuildUnbound(nextChain);
        });
        // enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
        this.enforceExclusiveCurrentOptionA(actualFadeTime);
        if(display.notNil) {
            display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
        };
    }
    // ‚îÄ‚îÄ‚îÄ next-chain mutations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    add { arg key;
        var insertIndex;
        insertIndex = nextChain.size - 1;
        this.addAt(key, insertIndex);
        if(display.notNil) { display.showMutation(\add, [key], nextChain) };
    }
    addAt { arg key, index;
        var indexClamped, newList;
        indexClamped = index.clip(1, nextChain.size - 1);
        newList = nextChain.insert(indexClamped, key);
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
    }
    removeAt { arg index;
        var sizeNow, lastIndex, newList, removedKey;
        sizeNow = nextChain.size;
        lastIndex = sizeNow - 1;
        if(sizeNow <= 2) {
            if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
            { "refuse to remove: need at least [sink, source]".postln };
        }{
            if((index == 0) or: { index == lastIndex }) {
                if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
                { "refuse to remove sink or source".postln };
            }{
                removedKey = nextChain[index];
                newList = nextChain.copy;
                newList.removeAt(index);
                this.setNextListInternal(newList);
                this.bypassDictForListInternal(nextChain).removeAt(removedKey);
                this.rebuild(nextChain);
                if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
            };
        };
    }
    swap { arg indexAParam, indexBParam;
        var lastIndex, indexA, indexB, newList, tempKey;
        lastIndex = nextChain.size - 1;
        indexA = indexAParam.clip(1, lastIndex - 1);
        indexB = indexBParam.clip(1, lastIndex - 1);
        if(indexA == indexB) {
            // nothing to do
        }{
            newList = nextChain.copy;
            tempKey = newList[indexA];
            newList[indexA] = newList[indexB];
            newList[indexB] = tempKey;
            this.setNextListInternal(newList);
            this.rebuild(nextChain);
            if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
        };
    }
    clearChain {
        var sinkKey, sourceKey, newList;
        if(nextChain.size < 2) { ^this };
        sinkKey = nextChain[0];
        sourceKey = nextChain[nextChain.size - 1];
        newList = [sinkKey, sourceKey];
        this.setNextListInternal(newList);
        this.bypassDictForListInternal(nextChain).clear;
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
    }
    bypass { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(nextChain);
        dict[key] = state;
        this.rebuild(nextChain);
        if(display.notNil) {
            display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
        };
    }
    bypassAt { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = nextChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = nextChain[clampedIndex];
        this.bypass(keyAtIndex, state);
    }
    // ‚îÄ‚îÄ‚îÄ current-chain bypass ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    bypassCurrent { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(currentChain);
        dict[key] = state;
        this.rebuild(currentChain);
        if(display.notNil) {
            display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
        };
    }
    bypassAtCurrent { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = currentChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = currentChain[clampedIndex];
        this.bypassCurrent(keyAtIndex, state);
    }
    // ‚îÄ‚îÄ‚îÄ source setters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setSource { arg key;
        var newList, lastIndex;
        lastIndex = nextChain.size - 1;
        newList = nextChain.copy;
        newList[lastIndex] = key;
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
    }
    setSourceCurrent { arg key;
        var newList, lastIndex, isAList;
        lastIndex = currentChain.size - 1;
        newList = currentChain.copy;
        newList[lastIndex] = key;
        isAList = (currentChain === chainAList);
        if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
        this.rebuild(currentChain);
        if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
    }
    setSourcesBoth { arg key;
        var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;
        // pick a sensible key (today we want \testmelody)
        k = key ? \testmelody;
        // guard: require [sink, source] minimum on both chains
        sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
        if(sizeOk.not) { ^this };
        // remember which concrete list object was CURRENT/NEXT *before* we replace them
        curWasA = (currentChain === chainAList);
        nextWasA = (nextChain === chainAList);
        // compute last indices
        lastA = chainAList.size - 1;
        lastB = chainBList.size - 1;
        // replace the *source symbol* (last position) on both lists
        newA = chainAList.copy; newA[lastA] = k;
        newB = chainBList.copy; newB[lastB] = k;
        // publish new lists and restore CURRENT/NEXT pointers to the matching list
        chainAList = newA;
        chainBList = newB;
        currentChain = if(curWasA) { chainAList } { chainBList };
        nextChain    = if(nextWasA) { chainAList } { chainBList };
        // rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
        this.rebuild(currentChain);
        this.rebuild(nextChain);
        // (optional) inform display
        if(display.notNil and: { display.respondsTo(\showMutation) }) {
            display.showMutation(\setSourcesBoth, [k], nextChain);
        };
        ^this
    }
    setDefaultSource { arg key;
        var k;
        // update the instance default; does not modify existing chains immediately
        k = key ? \testmelody;
        defaultSource = k;
        ^this
    }
    // ‚îÄ‚îÄ‚îÄ diagnostics helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
    effectiveNext { ^this.effectiveListForInternal(nextChain) }
    bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
    bypassKeysNext { ^this.bypassKeysForListInternal(nextChain) }
    reset {
        var sinkAKey, sinkBKey, canRun;
        sinkAKey = \chainA;
        sinkBKey = \chainB;
        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];
        bypassA.clear;
        bypassB.clear;
        currentChain = chainAList;
        nextChain = chainBList;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            // soft reset: stop both, then rebuild clean connections
            Ndef(sinkAKey).stop;
            Ndef(sinkBKey).stop;
            // Rebuild NEXT first (stays stopped), then CURRENT (plays)
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);
        });
        // enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
        this.enforceExclusiveCurrentOptionA(0.1);
        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }
/* OLDreset {
 var sinkAKey, sinkBKey;
 sinkAKey = \chainA;
 sinkBKey = \chainB;
 chainAList = [sinkAKey, defaultSource];
 chainBList = [sinkBKey, defaultSource];
 bypassA.clear;
 bypassB.clear;
 currentChain = chainAList;
 nextChain = chainBList;
 // SAFE server reset ONLY here, using Server.default.* (not 's')
 Server.default.waitForBoot({
 Server.default.bind({
 Server.default.initTree;
 Server.default.defaultGroup.freeAll;
 this.rebuildUnbound(nextChain);
 this.rebuildUnbound(currentChain);
 Ndef(sinkBKey).stop;
 Ndef(sinkAKey).play(numChannels: defaultNumChannels);
 });
 });
 if(display.notNil) { display.showReset(currentChain, nextChain) };
 } */
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // internal helpers (lowercase, no leading underscore)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setNextListInternal { arg newList;
        var isAList;
        isAList = nextChain === chainAList;
        if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
    }
    bypassDictForListInternal { arg listRef;
        ^if(listRef === chainAList) { bypassA } { bypassB }
    }
    bypassKeysForListInternal { arg listRef;
        var dict, keysBypassed;
        dict = this.bypassDictForListInternal(listRef);
        keysBypassed = Array.new;
        dict.keysValuesDo({ arg key, state;
            if(state == true) { keysBypassed = keysBypassed.add(key) };
        });
        ^keysBypassed
    }
    ensureStereoInternal { arg key;
        var proxyBus, needsInit;
        proxyBus = Ndef(key).bus;
        needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
        if(needsInit) {
            Ndef(key).ar(defaultNumChannels);
        };
    }
    // Non-destructive: guard only; do not reset here
    ensureServerTree {
        var serverIsRunning;
        serverIsRunning = Server.default.serverRunning;
        ^serverIsRunning
    }
    //
    // v0.4.6 change
    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust \in.ar, stereo shape pinned, playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).mold(chans, \audio); // authoritative shape
            Ndef(currentSink).fadeTime_(fadeCur);
            if(Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans);
            };
            // NEXT: hard-silence + ensure flag drops
            // 1) silence source, then .stop (no audio either way)
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).mold(chans, \audio);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
            // 2) drop monitor/flag deterministically, then re-establish silent sink
            Ndef(nextSink).end; // frees inner players, "stop listen" (NodeProxy help)
            Ndef(nextSink, { Silent.ar(chans) }); // keep NEXT present & silent for prebuild
            Ndef(nextSink).mold(chans, \audio);
            // do NOT play NEXT
        });
        ^this
    }
/*    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust sink that consumes embedded input; ensure playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).ar(chans);
            Ndef(currentSink).fadeTime_(fadeCur);
            if (Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans)
            };
            // NEXT: hard silence at the sink source; stop its monitor quickly
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).ar(chans);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
        });
        ^this
    }*/
    effectiveListForInternal { arg listRef;
        var dict, resultList, lastIndex, isProcessor, isBypassed;
        dict = this.bypassDictForListInternal(listRef);
        resultList = Array.new;
        lastIndex = listRef.size - 1;
        listRef.do({ arg key, indexPosition;
            isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
            isBypassed = isProcessor and: { dict[key] == true };
            if((indexPosition == 0) or: { indexPosition == lastIndex }) {
                resultList = resultList.add(key);
            }{
                if(isBypassed.not) { resultList = resultList.add(key) };
            };
        });
        ^resultList
    }
    // Public rebuild: bundles server ops; guard only
    rebuild { arg listRef;
        var whichChain, canRun;
        whichChain = if(listRef === currentChain) { \current } { \next };
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            this.rebuildUnbound(listRef);
        });
        if(display.notNil) {
            display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
        };
    }
    // Internal rebuild that assumes we are already inside a server bind (no resets)
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        // (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
        if(processorLib.notNil) {
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };
        // From here on, this is your original "effective / do / connect"
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }
/*    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/*    // At end of rebuildUnbound
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
/*        if(processorLib.notNil) {
            // Ask the lib to make sure each symbol in this chain has an Ndef with a function.
            // It will quietly do nothing for unknown keys.
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };*/
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/* OLD rebuildUnbound { arg listRef;
 var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
 hasMinimum = listRef.size >= 2;
 if(hasMinimum.not) { ^this };
 effective = this.effectiveListForInternal(listRef);
 effective.do({ arg keySymbol;
 this.ensureStereoInternal(keySymbol);
 });
 indexCounter = 0;
 while({ indexCounter < (effective.size - 1) }, {
 leftKey = effective[indexCounter];
 rightKey = effective[indexCounter + 1];
 Ndef(leftKey) <<> Ndef(rightKey);
 });
        // sinkKey = effective[0];
        // if(listRef === currentChain) {
        //     Ndef(sinkKey).play(numChannels: defaultNumChannels);
        // }{
        //     Ndef(sinkKey).stop;
        // };
        // At the end of rebuildUnbound:
        sinkKey = effective[0];
        if(listRef === currentChain) {
            if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        } {
            if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
        };
 } */
    // ---- Ready helpers (public API) ----
    // boolean snapshot (no server ops)
    isReady {
        ^ready
    }
    // AppClock polling; onReadyFunc is optional
    waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
        var startTime, tick;
        startTime = Main.elapsedTime;
        AppClock.sched(0, {
            tick = {
                if(this.readyConditionOk) {
                    ready = true;
                    if(onReadyFunc.notNil) { onReadyFunc.value };
                    nil
                }{
                    if((Main.elapsedTime - startTime) > timeoutSec) {
                        // timed out; leave 'ready' as-is
                        nil
                    }{
                        AppClock.sched(pollSec, tick)
                    }
                }
            };
            tick.value;
            nil
        });
        ^this
    }
    // ---- Ready helpers (internal; no leading underscore) ----
    // light background poll started from init (OPTION A)
    startReadyPoll {
        var alreadyTrue;
        alreadyTrue = this.readyConditionOk;
        if(alreadyTrue) { ready = true; ^this };
        this.waitUntilReady(2.0, 0.05, { nil });
        ^this
    }
    // compute the readiness condition; no server ops here
    readyConditionOk {
        var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;
        curSink = currentChain[0];
        nxtSink = nextChain[0];
        serverOk = Server.default.serverRunning;
        curBus = Ndef(curSink).bus;
        nxtBus = Ndef(nxtSink).bus;
        busesOk = curBus.notNil and: { nxtBus.notNil }
        and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };
        currentPlaying = Ndef(curSink).isPlaying;
        ^(serverOk and: { busesOk } and: { currentPlaying })
    }
    // handleCommand { |oscPath|
    //     var path;
    //     path = oscPath.asString;
    //
    //     // Route to your existing mutation logic
    //     // Update this if you use a different handler name
    //     if(this.respondsTo(\applyOSCPath)) {
    //         this.applyOSCPath(path);
    //     } {
    //         ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
    //     };
    //
    //     ^this;
    // }
    handleCommand { |oscPath|
     var path;
     path = oscPath.asString;
     if(~ct_applyOSCPathToMPB.notNil) {
     ~ct_applyOSCPathToMPB.(path, this, display);
     } {
     ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
     };
     ^this;
    }

    // --- Added in v0.4.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
MagicPedalboard.help ‚Äî quick guide (class-side)

Quick start
-----------
(
var mpb;
mpb = MagicPedalboard.new(nil);  // optional display adaptor may be passed
mpb.printChains;                    // see CURRENT/NEXT
// NEXT-chain edits:
mpb.add(\\delay);                   // append before source
mpb.bypass(\\delay, true);          // bypass in NEXT
mpb.setSource(\\testmelody);        // set NEXT source
// Commit and listen:
mpb.switchChain(0.1);               // crossfade CURRENT<->NEXT (80‚Äì200 ms clamp)
// Diagnostics:
mpb.printChains; mpb.effectiveCurrent; mpb.effectiveNext;
)

Design highlights
- Chains are Arrays of Symbols: [sink, processors..., source]
- Embedding: Ndef(left) <<> Ndef(right)
- create sinks \\chainA and \\chainB; CURRENT plays, NEXT is prepared/silenced
- Mutators act on NEXT (add/addAt/removeAt/swap/bypass/bypassAt/clearChain/setSource)
- CURRENT helpers for bypassing and source changes are also available
- Non-destructive rebuilds; .reset is a guarded soft reset
";
        text.postln;
        text
    }

    *api {
        var api;
        api = IdentityDictionary[
            // construction & display
            \ctor         -> "MagicPedalboard.new(displayOrNil)",
            \display      -> "setDisplay(disp), setProcessorLib(lib), setDefaultSource(key)",

            // status & printing
            \status       -> "printChains(), effectiveCurrent(), effectiveNext(), bypassKeysCurrent(), bypassKeysNext()",

            // play control
            \play         -> "playCurrent(), stopCurrent(), switchChain([fadeTime=0.1])",

            // NEXT-chain editing
            \next_edit    -> "add(key), addAt(key, index), removeAt(index), swap(iA, iB), clearChain(), bypass(key[,state]), bypassAt(index[,state]), setSource(key)",

            // CURRENT-chain helpers
            \current_edit -> "bypassCurrent(key[,state]), bypassAtCurrent(index[,state]), setSourceCurrent(key), setSourcesBoth(key)",

            // lifecycle / invariants
            \invariants   -> "enforceExclusiveCurrentOptionA([fade])",
            \reset        -> "reset()  // guarded soft reset with rebuilds",

            // diagnostics / readiness
            \ready        -> "isReady(), waitUntilReady([timeout,poll,onReadyFunc])"
        ];
        api.postln;
        api
    }

    *test {
        var mpb;
        mpb = MagicPedalboard.new(nil);
        // A tiny smoke test that exercises the common NEXT->switch flow.
        mpb.add(\delay);
        mpb.setSource(\testmelody);
        mpb.switchChain(0.1);
        mpb.printChains;
        mpb
    }
}

===== MagicPedalboard/MagicPedalboard.sc_DISABLED =====
// MagicPedalboard.sc
// v0.1.0
// MD 2025-09-21 17:05

// Purpose: Compatibility alias for MagicPedalboardNew
// Style: Minimal, non-breaking, avoids renaming existing class

MagicPedalboard : MagicPedalboardNew {
    // No additional code needed
}

===== MagicPedalboard/MagicPedalboardNew.sc =====
// MagicPedalboardNew.sc (DEPRECATED SHIM)
// v0.0.2 ‚Äî shim subclass; warns at compile-time + first construction only
// MD 2025-10-02

MagicPedalboardNew : MagicPedalboard {
    classvar depWarnedAtRuntime;  // no accessor marker + no leading underscore

    *initClass {
        var msg;
        depWarnedAtRuntime = false;
        msg = "DEPRECATION: MagicPedalboardNew is now a shim. Use MagicPedalboard.";
        msg.warn;  // prints once per class library compile
    }

    // Warn once at first *construction* via MagicPedalboardNew in this process.
    *new { arg display = nil;
        var instance, msg;
        if (depWarnedAtRuntime.not) {
            msg = "DEPRECATION (runtime): MagicPedalboardNew was constructed. "
                ++ "Please migrate to MagicPedalboard.new(...).";
            msg.warn;
            depWarnedAtRuntime = true;
        };
        instance = super.new;
        ^instance.init(display)
    }
}

===== MagicPedalboard/MagicPedalboardNew.sc_buggy =====
/* MagicPedalboardNew.sc v0.4.9
 A/B pedalboard chain manager built on Ndefs.
 - Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
 // MD 20251002-1406
*/

/*
Supplementary header ‚Äî What this class does & key dependencies
----------------------------------------------------------------
Overview
- Manages two audio chains (CURRENT and NEXT) built from Symbols mapped to Ndefs.
- Initializes two sink proxies (\chainA, \chainB), materializes stereo buses, and enforces an
  ‚Äúexclusive current‚Äù invariant (Option A) so only CURRENT is audible while NEXT remains prebuilt and silent.
- Provides NEXT-chain mutation API (add/remove/swap/bypass/clear, setSource) and CURRENT helpers
  (playCurrent/stopCurrent, bypassCurrent variants).
- Switching uses switchChain(fadeTime=0.1) with a short crossfade and pointer swap (CURRENT ‚Üî NEXT).
- Optional display adaptor (MagicDisplay/MagicDisplayGUI) posts mutations, rebuilds, and chain details.

Relies on (classes / subsystems)
- JITLib: Ndef, NodeProxy operator <<> for wiring processors in order.
- SuperCollider server primitives: Server.default.bind for safe server ops; Ndef:ar/mold/fadeTime/play/stop/end.
- (Optional) MagicDisplay adaptor methods: showInit, showChainsDetailed, showMutation, showPlay, showStop, showSwitch, showReset, showBypass.

Optional integration points
- processorLib.ensureFromChain(list, numCh): will pre-ensure processor Ndefs for declared keys when available.
- handleCommand(path) delegates to ~ct_applyOSCPathToMPB if present (command-tree integration).

External data
- None (processors are expected to be provided by your environment / processorLib and Ndef library).

Notes
- Style: var-first; no server.sync; all server-side changes wrapped in Server.default.bind.
- Non-destructive rebuilds (rebuildUnbound) maintain continuity; reset() is available for a safe tree reset pattern.
*/

MagicPedalboardNew : Object {
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // class metadata
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    classvar <version;
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // instance state
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    var < currentChain; // read-only pointer to Array of Symbols
    var <nextChain; // read-only pointer to Array of Symbols
    var chainAList; // [\chainA, ...processors..., source]
    var chainBList; // [\chainB, ...processors..., source]
    var bypassA; // IdentityDictionary: key(Symbol) -> Bool
    var bypassB; // IdentityDictionary: key(Symbol) -> Bool
    var < defaultNumChannels;
    var < defaultSource;
    var < display; // optional display adaptor
    var < processorLib;
    var < ready; // <-- ADD this line
    *initClass {
        var text;
        version = "v0.4.9";
        text = "MagicPedalboardNew " ++ version;
        text.postln;
    }
    *new { arg disp = nil;
        var instance;
        instance = super.new;
        ^instance.init(disp);
    }
    init { arg disp;
        var sinkFunc;
        display = disp;
        defaultNumChannels = 2;
        defaultSource = \ts0;
        // less good than the version below
        // sinkFunc = { arg inSignal; inSignal };
        sinkFunc = {
            var inputSignal;
            inputSignal = \in.ar(defaultNumChannels);
            inputSignal
        };
        Ndef(\chainA, sinkFunc);
        Ndef(\chainB, sinkFunc);
        // Guarantee sink buses are audio-rate early (prevents kr-meter races)
        Server.default.bind({
            Ndef(\chainA).ar(defaultNumChannels); // typically 2
            Ndef(\chainB).ar(defaultNumChannels);
        });
        chainAList = [\chainA, defaultSource];
        chainBList = [\chainB, defaultSource];
        bypassA = IdentityDictionary.new;
        bypassB = IdentityDictionary.new;
        currentChain = chainAList;
        nextChain = chainBList;
        Server.default.bind({
            this.rebuildUnbound(nextChain); // stays stopped
            this.rebuildUnbound(currentChain); // plays
        });
/*        this.rebuild(currentChain);
        this.rebuild(nextChain);*/
/* Server.default.bind({
 Ndef(\chainA).play(numChannels: defaultNumChannels);
 });*/
        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };
        // enforce exclusive invariant (Option A) at first bring-up
        this.enforceExclusiveCurrentOptionA(0.1);
        // set initial state; the poll will flip it once conditions are true
        ready = false;
        // OPTION A: enable background poll (comment out if you prefer Option B)
        this.startReadyPoll;
        ^this
    }
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // public API
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // add a setter (public)
    setProcessorLib { arg lib;
        processorLib = lib;
    }
    setDisplay { arg disp;
        var shouldShow;
        display = disp;
        shouldShow = display.notNil;
        if(shouldShow) {
            display.showInit(this, version, currentChain, nextChain);
        };
    }
    help {
        var text;
        text = String.new;
        text = text
        ++ "MagicPedalboardNew " ++ version ++ "\n"
        ++ "Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].\n"
        ++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
        ++ "Core methods (operate mostly on the *next* chain):\n"
        ++ " printChains\n"
        ++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
        ++ " add(key), addAt(key, index)\n"
        ++ " removeAt(index), swap(indexA, indexB)\n"
        ++ " bypass(key, state=true), bypassAt(index, state=true)\n"
        ++ " clearChain\n"
        ++ "Current-chain bypass helpers:\n"
        ++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
        ++ "Diagnostics/helpers:\n"
        ++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
        ++ "Source setters:\n"
        ++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
        text.postln;
    }
    // Detailed printing routed through display if available
    printChains {
        var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
        var headerFunc, formatOne;
        bypassAKeys = this.bypassKeysForListInternal(chainAList);
        bypassBKeys = this.bypassKeysForListInternal(chainBList);
        effectiveA = this.effectiveListForInternal(chainAList);
        effectiveB = this.effectiveListForInternal(chainBList);
        hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };
        if(hasDisplay) {
            display.showChainsDetailed(
                chainAList, chainBList,
                bypassAKeys, bypassBKeys,
                effectiveA, effectiveB
            );
        }{
            headerFunc = { arg titleString;
                var lineText;
                lineText = "==== " ++ titleString ++ " ====";
                lineText.postln;
            };
            formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
                var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
                lastIndex = listRef.size - 1;
                sinkKey = listRef[0];
                sourceKey = listRef[lastIndex];
                headerFunc.(titleString);
                ("src : " ++ sourceKey).postln;
                if(listRef.size > 2) {
                    "procs:".postln;
                    processorsList = listRef.copyRange(1, lastIndex - 1);
                    indexCounter = 1;
                    processorsList.do({ arg procKey;
                        isBypassed = bypassKeys.includes(procKey);
                        markText = if(isBypassed) { "BYP" } { "ON " };
                        lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
                        lineText.postln;
                        indexCounter = indexCounter + 1;
                    });
                }{
                    "procs: (none)".postln;
                };
                ("sink: " ++ sinkKey).postln;
                ("eff : " ++ effectiveList.join(" -> ")).postln;
                "".postln;
            };
            formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
            formatOne.("NEXT", chainBList, bypassBKeys, effectiveB);
        };
    }
    playCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        this.rebuild(currentChain);
        Server.default.bind({
            Ndef(sinkKey).play(numChannels: defaultNumChannels);
        });
        if(display.notNil) {
            display.showPlay(sinkKey);
        };
        // enforce exclusive invariant (Option A) after play
        this.enforceExclusiveCurrentOptionA(0.1);
    }
    stopCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            Ndef(sinkKey).stop;
        });
        if(display.notNil) {
            display.showStop(sinkKey);
        };
    }
    // Crossfading chain switch (default 0.1 s, clamped to ~80‚Äì200 ms)
    switchChain { arg fadeTime = 0.1;
        var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        actualFadeTime = fadeTime.clip(0.08, 0.2);
        oldSinkKey = currentChain[0];
        newSinkKey = nextChain[0];
        Server.default.bind({
            // set fade durations
            Ndef(oldSinkKey).fadeTime_(actualFadeTime);
            Ndef(newSinkKey).fadeTime_(actualFadeTime);
            // prebuild NEXT so it is ready, then start it (will fade in)
            this.rebuildUnbound(nextChain);
            Ndef(newSinkKey).play(numChannels: defaultNumChannels);
            // stop OLD (will fade out)
            Ndef(oldSinkKey).stop;
            // swap pointers
            temporaryList = currentChain;
            currentChain = nextChain;
            nextChain = temporaryList;
            // ensure both chains are in correct post-swap state
            this.rebuildUnbound(currentChain);
            this.rebuildUnbound(nextChain);
        });
        // enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
        this.enforceExclusiveCurrentOptionA(actualFadeTime);
        if(display.notNil) {
            display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
        };
    }
    // ‚îÄ‚îÄ‚îÄ next-chain mutations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    add { arg key;
        var insertIndex;
        insertIndex = nextChain.size - 1;
        this.addAt(key, insertIndex);
        if(display.notNil) { display.showMutation(\add, [key], nextChain) };
    }
    addAt { arg key, index;
        var indexClamped, newList;
        indexClamped = index.clip(1, nextChain.size - 1);
        newList = nextChain.insert(indexClamped, key);
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
    }
    removeAt { arg index;
        var sizeNow, lastIndex, newList, removedKey;
        sizeNow = nextChain.size;
        lastIndex = sizeNow - 1;
        if(sizeNow <= 2) {
            if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
            { "refuse to remove: need at least [sink, source]".postln };
        }{
            if((index == 0) or: { index == lastIndex }) {
                if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
                { "refuse to remove sink or source".postln };
            }{
                removedKey = nextChain[index];
                newList = nextChain.copy;
                newList.removeAt(index);
                this.setNextListInternal(newList);
                this.bypassDictForListInternal(nextChain).removeAt(removedKey);
                this.rebuild(nextChain);
                if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
            };
        };
    }
    swap { arg indexAParam, indexBParam;
        var lastIndex, indexA, indexB, newList, tempKey;
        lastIndex = nextChain.size - 1;
        indexA = indexAParam.clip(1, lastIndex - 1);
        indexB = indexBParam.clip(1, lastIndex - 1);
        if(indexA == indexB) {
            // nothing to do
        }{
            newList = nextChain.copy;
            tempKey = newList[indexA];
            newList[indexA] = newList[indexB];
            newList[indexB] = tempKey;
            this.setNextListInternal(newList);
            this.rebuild(nextChain);
            if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
        };
    }
    clearChain {
        var sinkKey, sourceKey, newList;
        if(nextChain.size < 2) { ^this };
        sinkKey = nextChain[0];
        sourceKey = nextChain[nextChain.size - 1];
        newList = [sinkKey, sourceKey];
        this.setNextListInternal(newList);
        this.bypassDictForListInternal(nextChain).clear;
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
    }
    bypass { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(nextChain);
        dict[key] = state;
        this.rebuild(nextChain);
        if(display.notNil) {
            display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
        };
    }
    bypassAt { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = nextChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = nextChain[clampedIndex];
        this.bypass(keyAtIndex, state);
    }
    // ‚îÄ‚îÄ‚îÄ current-chain bypass ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    bypassCurrent { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(currentChain);
        dict[key] = state;
        this.rebuild(currentChain);
        if(display.notNil) {
            display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
        };
    }
    bypassAtCurrent { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = currentChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = currentChain[clampedIndex];
        this.bypassCurrent(keyAtIndex, state);
    }
    // ‚îÄ‚îÄ‚îÄ source setters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setSource { arg key;
        var newList, lastIndex;
        lastIndex = nextChain.size - 1;
        newList = nextChain.copy;
        newList[lastIndex] = key;
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
    }
    setSourceCurrent { arg key;
        var newList, lastIndex, isAList;
        lastIndex = currentChain.size - 1;
        newList = currentChain.copy;
        newList[lastIndex] = key;
        isAList = (currentChain === chainAList);
        if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
        this.rebuild(currentChain);
        if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
    }
    setSourcesBoth { arg key;
        var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;
        // pick a sensible key (today we want \testmelody)
        k = key ? \testmelody;
        // guard: require [sink, source] minimum on both chains
        sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
        if(sizeOk.not) { ^this };
        // remember which concrete list object was CURRENT/NEXT *before* we replace them
        curWasA = (currentChain === chainAList);
        nextWasA = (nextChain === chainAList);
        // compute last indices
        lastA = chainAList.size - 1;
        lastB = chainBList.size - 1;
        // replace the *source symbol* (last position) on both lists
        newA = chainAList.copy; newA[lastA] = k;
        newB = chainBList.copy; newB[lastB] = k;
        // publish new lists and restore CURRENT/NEXT pointers to the matching list
        chainAList = newA;
        chainBList = newB;
        currentChain = if(curWasA) { chainAList } { chainBList };
        nextChain    = if(nextWasA) { chainAList } { chainBList };
        // rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
        this.rebuild(currentChain);
        this.rebuild(nextChain);
        // (optional) inform display
        if(display.notNil and: { display.respondsTo(\showMutation) }) {
            display.showMutation(\setSourcesBoth, [k], nextChain);
        };
        ^this
    }
    setDefaultSource { arg key;
        var k;
        // update the instance default; does not modify existing chains immediately
        k = key ? \testmelody;
        defaultSource = k;
        ^this
    }
    // ‚îÄ‚îÄ‚îÄ diagnostics helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
    effectiveNext { ^this.effectiveListForInternal(nextChain) }
    bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
    bypassKeysNext { ^this.bypassKeysForListInternal(nextChain) }
    reset {
        var sinkAKey, sinkBKey, canRun;
        sinkAKey = \chainA;
        sinkBKey = \chainB;
        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];
        bypassA.clear;
        bypassB.clear;
        currentChain = chainAList;
        nextChain = chainBList;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            // soft reset: stop both, then rebuild clean connections
            Ndef(sinkAKey).stop;
            Ndef(sinkBKey).stop;
            // Rebuild NEXT first (stays stopped), then CURRENT (plays)
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);
        });
        // enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
        this.enforceExclusiveCurrentOptionA(0.1);
        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }
/* OLDreset {
 var sinkAKey, sinkBKey;
 sinkAKey = \chainA;
 sinkBKey = \chainB;
 chainAList = [sinkAKey, defaultSource];
 chainBList = [sinkBKey, defaultSource];
 bypassA.clear;
 bypassB.clear;
 currentChain = chainAList;
 nextChain = chainBList;
 // SAFE server reset ONLY here, using Server.default.* (not 's')
 Server.default.waitForBoot({
 Server.default.bind({
 Server.default.initTree;
 Server.default.defaultGroup.freeAll;
 this.rebuildUnbound(nextChain);
 this.rebuildUnbound(currentChain);
 Ndef(sinkBKey).stop;
 Ndef(sinkAKey).play(numChannels: defaultNumChannels);
 });
 });
 if(display.notNil) { display.showReset(currentChain, nextChain) };
 } */
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // internal helpers (lowercase, no leading underscore)
    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    setNextListInternal { arg newList;
        var isAList;
        isAList = nextChain === chainAList;
        if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
    }
    bypassDictForListInternal { arg listRef;
        ^if(listRef === chainAList) { bypassA } { bypassB }
    }
    bypassKeysForListInternal { arg listRef;
        var dict, keysBypassed;
        dict = this.bypassDictForListInternal(listRef);
        keysBypassed = Array.new;
        dict.keysValuesDo({ arg key, state;
            if(state == true) { keysBypassed = keysBypassed.add(key) };
        });
        ^keysBypassed
    }
    ensureStereoInternal { arg key;
        var proxyBus, needsInit;
        proxyBus = Ndef(key).bus;
        needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
        if(needsInit) {
            Ndef(key).ar(defaultNumChannels);
        };
    }
    // Non-destructive: guard only; do not reset here
    ensureServerTree {
        var serverIsRunning;
        serverIsRunning = Server.default.serverRunning;
        ^serverIsRunning
    }
    //
    // v0.4.6 change
    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust \in.ar, stereo shape pinned, playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).mold(chans, \audio); // authoritative shape
            Ndef(currentSink).fadeTime_(fadeCur);
            if(Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans);
            };
            // NEXT: hard-silence + ensure flag drops
            // 1) silence source, then .stop (no audio either way)
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).mold(chans, \audio);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
            // 2) drop monitor/flag deterministically, then re-establish silent sink
            Ndef(nextSink).end; // frees inner players, "stop listen" (NodeProxy help)
            Ndef(nextSink, { Silent.ar(chans) }); // keep NEXT present & silent for prebuild
            Ndef(nextSink).mold(chans, \audio);
            // do NOT play NEXT
        });
        ^this
    }
/*    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust sink that consumes embedded input; ensure playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).ar(chans);
            Ndef(currentSink).fadeTime_(fadeCur);
            if (Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans)
            };
            // NEXT: hard silence at the sink source; stop its monitor quickly
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).ar(chans);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
        });
        ^this
    }*/
    effectiveListForInternal { arg listRef;
        var dict, resultList, lastIndex, isProcessor, isBypassed;
        dict = this.bypassDictForListInternal(listRef);
        resultList = Array.new;
        lastIndex = listRef.size - 1;
        listRef.do({ arg key, indexPosition;
            isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
            isBypassed = isProcessor and: { dict[key] == true };
            if((indexPosition == 0) or: { indexPosition == lastIndex }) {
                resultList = resultList.add(key);
            }{
                if(isBypassed.not) { resultList = resultList.add(key) };
            };
        });
        ^resultList
    }
    // Public rebuild: bundles server ops; guard only
    rebuild { arg listRef;
        var whichChain, canRun;
        whichChain = if(listRef === currentChain) { \current } { \next };
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            this.rebuildUnbound(listRef);
        });
        if(display.notNil) {
            display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
        };
    }
    // Internal rebuild that assumes we are already inside a server bind (no resets)
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        // (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
        if(processorLib.notNil) {
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };
        // From here on, this is your original "effective / do / connect"
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }
/*    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/*    // At end of rebuildUnbound
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
/*        if(processorLib.notNil) {
            // Ask the lib to make sure each symbol in this chain has an Ndef with a function.
            // It will quietly do nothing for unknown keys.
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };*/
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/* OLD rebuildUnbound { arg listRef;
 var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
 hasMinimum = listRef.size >= 2;
 if(hasMinimum.not) { ^this };
 effective = this.effectiveListForInternal(listRef);
 effective.do({ arg keySymbol;
 this.ensureStereoInternal(keySymbol);
 });
 indexCounter = 0;
 while({ indexCounter < (effective.size - 1) }, {
 leftKey = effective[indexCounter];
 rightKey = effective[indexCounter + 1];
 Ndef(leftKey) <<> Ndef(rightKey);
 });
        // sinkKey = effective[0];
        // if(listRef === currentChain) {
        //     Ndef(sinkKey).play(numChannels: defaultNumChannels);
        // }{
        //     Ndef(sinkKey).stop;
        // };
        // At the end of rebuildUnbound:
        sinkKey = effective[0];
        if(listRef === currentChain) {
            if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        } {
            if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
        };
 } */
    // ---- Ready helpers (public API) ----
    // boolean snapshot (no server ops)
    isReady {
        ^ready
    }
    // AppClock polling; onReadyFunc is optional
    waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
        var startTime, tick;
        startTime = Main.elapsedTime;
        AppClock.sched(0, {
            tick = {
                if(this.readyConditionOk) {
                    ready = true;
                    if(onReadyFunc.notNil) { onReadyFunc.value };
                    nil
                }{
                    if((Main.elapsedTime - startTime) > timeoutSec) {
                        // timed out; leave 'ready' as-is
                        nil
                    }{
                        AppClock.sched(pollSec, tick)
                    }
                }
            };
            tick.value;
            nil
        });
        ^this
    }
    // ---- Ready helpers (internal; no leading underscore) ----
    // light background poll started from init (OPTION A)
    startReadyPoll {
        var alreadyTrue;
        alreadyTrue = this.readyConditionOk;
        if(alreadyTrue) { ready = true; ^this };
        this.waitUntilReady(2.0, 0.05, { nil });
        ^this
    }
    // compute the readiness condition; no server ops here
    readyConditionOk {
        var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;
        curSink = currentChain[0];
        nxtSink = nextChain[0];
        serverOk = Server.default.serverRunning;
        curBus = Ndef(curSink).bus;
        nxtBus = Ndef(nxtSink).bus;
        busesOk = curBus.notNil and: { nxtBus.notNil }
        and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };
        currentPlaying = Ndef(curSink).isPlaying;
        ^(serverOk and: { busesOk } and: { currentPlaying })
    }
    // handleCommand { |oscPath|
    //     var path;
    //     path = oscPath.asString;
    //
    //     // Route to your existing mutation logic
    //     // Update this if you use a different handler name
    //     if(this.respondsTo(\applyOSCPath)) {
    //         this.applyOSCPath(path);
    //     } {
    //         ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
    //     };
    //
    //     ^this;
    // }
    handleCommand { |oscPath|
     var path;
     path = oscPath.asString;
     if(~ct_applyOSCPathToMPB.notNil) {
     ~ct_applyOSCPathToMPB.(path, this, display);
     } {
     ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
     };
     ^this;
    }

    // --- Added in v0.4.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
MagicPedalboardNew.help  ‚Äî  quick guide

Create + print chains (no GUI required)
---------------------------------------
(
var mpb;
mpb = MagicPedalboardNew.new(nil);
mpb.printChains;      // CURRENT and NEXT summaries in the post window
)

Typical flow
------------
- Mutate NEXT:   add(key), addAt(key, index), removeAt(index), swap(i,j), bypass(key[,state])
- Set source(s): setSource(key)  [NEXT],  setSourceAbsolutely
===== MagicPedalboard/MagicPedalboardNew.sc_v0.4.8.txt =====
/* MagicPedalboardNew.sc v0.4.8
 A/B pedalboard chain manager built on Ndefs.

 - Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
 // MD 20250912-1838
*/
MagicPedalboardNew : Object {

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// class metadata
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	classvar <version;

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// instance state
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	var < currentChain;     // read-only pointer to Array of Symbols
	var <nextChain;        // read-only pointer to Array of Symbols
	var chainAList;        // [\chainA, ...processors..., source]
	var chainBList;        // [\chainB, ...processors..., source]
	var bypassA;           // IdentityDictionary: key(Symbol) -> Bool
	var bypassB;           // IdentityDictionary: key(Symbol) -> Bool
	var < defaultNumChannels;
	var < defaultSource;
	var < display;          // optional display adaptor
	var < processorLib;
	var < ready;              // <-- ADD this line

	*initClass {
		var text;
		version = "v0.4.7";
		text = "MagicPedalboardNew " ++ version;
		text.postln;
	}

	*new { arg disp = nil;
		var instance;
		instance = super.new;
		^instance.init(disp);
	}

	init { arg disp;
		var sinkFunc;
		display = disp;
		defaultNumChannels = 2;
		defaultSource = \ts0;

		// less good than the version below
		// sinkFunc = { arg inSignal; inSignal };


		sinkFunc = {
			var inputSignal;
			inputSignal = \in.ar(defaultNumChannels);
			inputSignal
		};

		Ndef(\chainA, sinkFunc);
		Ndef(\chainB, sinkFunc);

		// Guarantee sink buses are audio-rate early (prevents kr-meter races)
		Server.default.bind({
			Ndef(\chainA).ar(defaultNumChannels);  // typically 2
			Ndef(\chainB).ar(defaultNumChannels);
		});


		chainAList = [\chainA, defaultSource];
		chainBList = [\chainB, defaultSource];

		bypassA = IdentityDictionary.new;
		bypassB = IdentityDictionary.new;

		currentChain = chainAList;
		nextChain = chainBList;

		Server.default.bind({
			this.rebuildUnbound(nextChain); // stays stopped
			this.rebuildUnbound(currentChain); // plays
		});

/*		this.rebuild(currentChain);
		this.rebuild(nextChain);*/

/*        Server.default.bind({
            Ndef(\chainA).play(numChannels: defaultNumChannels);
        });*/

		if(display.notNil) {
			display.showInit(this, version, currentChain, nextChain);
		};

		// enforce exclusive invariant (Option A) at first bring-up
		this.enforceExclusiveCurrentOptionA(0.1);



		// set initial state; the poll will flip it once conditions are true
		ready = false;

		// OPTION A: enable background poll (comment out if you prefer Option B)
		this.startReadyPoll;


		^this
	}

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// public API
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ


	// add a setter (public)
	setProcessorLib { arg lib;
		processorLib = lib;
	}

	setDisplay { arg disp;
		var shouldShow;
		display = disp;
		shouldShow = display.notNil;
		if(shouldShow) {
			display.showInit(this, version, currentChain, nextChain);
		};
	}

	help {
		var text;
		text = String.new;
		text = text
		++ "MagicPedalboardNew " ++ version ++ "\n"
		++ "Chains are Arrays of Symbols ordered [sink, ‚Ä¶, source].\n"
		++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
		++ "Core methods (operate mostly on the *next* chain):\n"
		++ " printChains\n"
		++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
		++ " add(key), addAt(key, index)\n"
		++ " removeAt(index), swap(indexA, indexB)\n"
		++ " bypass(key, state=true), bypassAt(index, state=true)\n"
		++ " clearChain\n"
		++ "Current-chain bypass helpers:\n"
		++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
		++ "Diagnostics/helpers:\n"
		++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
		++ "Source setters:\n"
		++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
		text.postln;
	}

	// Detailed printing routed through display if available
	printChains {
		var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
		var headerFunc, formatOne;

		bypassAKeys = this.bypassKeysForListInternal(chainAList);
		bypassBKeys = this.bypassKeysForListInternal(chainBList);
		effectiveA = this.effectiveListForInternal(chainAList);
		effectiveB = this.effectiveListForInternal(chainBList);
		hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };

		if(hasDisplay) {
			display.showChainsDetailed(
				chainAList, chainBList,
				bypassAKeys, bypassBKeys,
				effectiveA, effectiveB
			);
		}{
			headerFunc = { arg titleString;
				var lineText;
				lineText = "==== " ++ titleString ++ " ====";
				lineText.postln;
			};

			formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
				var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
				lastIndex = listRef.size - 1;
				sinkKey = listRef[0];
				sourceKey = listRef[lastIndex];

				headerFunc.(titleString);
				("src : " ++ sourceKey).postln;

				if(listRef.size > 2) {
					"procs:".postln;
					processorsList = listRef.copyRange(1, lastIndex - 1);
					indexCounter = 1;
					processorsList.do({ arg procKey;
						isBypassed = bypassKeys.includes(procKey);
						markText = if(isBypassed) { "BYP" } { "ON " };
						lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
						lineText.postln;
						indexCounter = indexCounter + 1;
					});
				}{
					"procs: (none)".postln;
				};

				("sink: " ++ sinkKey).postln;
				("eff : " ++ effectiveList.join(" -> ")).postln;
				"".postln;
			};

			formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
			formatOne.("NEXT",    chainBList, bypassBKeys, effectiveB);
		};
	}

	playCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		this.rebuild(currentChain);
		Server.default.bind({
			Ndef(sinkKey).play(numChannels: defaultNumChannels);
		});
		if(display.notNil) {
			display.showPlay(sinkKey);
		};
		// enforce exclusive invariant (Option A) after play
		this.enforceExclusiveCurrentOptionA(0.1);

	}

	stopCurrent {
		var sinkKey, canRun;
		sinkKey = currentChain[0];
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };
		Server.default.bind({
			Ndef(sinkKey).stop;
		});
		if(display.notNil) {
			display.showStop(sinkKey);
		};
	}

	// Crossfading chain switch (default 0.1 s, clamped to ~80‚Äì200 ms)
	switchChain { arg fadeTime = 0.1;
		var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		actualFadeTime = fadeTime.clip(0.08, 0.2);
		oldSinkKey = currentChain[0];
		newSinkKey = nextChain[0];

		Server.default.bind({
			// set fade durations
			Ndef(oldSinkKey).fadeTime_(actualFadeTime);
			Ndef(newSinkKey).fadeTime_(actualFadeTime);

			// prebuild NEXT so it is ready, then start it (will fade in)
			this.rebuildUnbound(nextChain);
			Ndef(newSinkKey).play(numChannels: defaultNumChannels);

			// stop OLD (will fade out)
			Ndef(oldSinkKey).stop;

			// swap pointers
			temporaryList = currentChain;
			currentChain = nextChain;
			nextChain = temporaryList;

			// ensure both chains are in correct post-swap state
			this.rebuildUnbound(currentChain);
			this.rebuildUnbound(nextChain);
		});

		// enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
		this.enforceExclusiveCurrentOptionA(actualFadeTime);

		if(display.notNil) {
			display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
		};
	}

	// ‚îÄ‚îÄ‚îÄ next-chain mutations ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	add { arg key;
		var insertIndex;
		insertIndex = nextChain.size - 1;
		this.addAt(key, insertIndex);
		if(display.notNil) { display.showMutation(\add, [key], nextChain) };
	}

	addAt { arg key, index;
		var indexClamped, newList;
		indexClamped = index.clip(1, nextChain.size - 1);
		newList = nextChain.insert(indexClamped, key);
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
	}

	removeAt { arg index;
		var sizeNow, lastIndex, newList, removedKey;
		sizeNow = nextChain.size;
		lastIndex = sizeNow - 1;

		if(sizeNow <= 2) {
			if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
			{ "refuse to remove: need at least [sink, source]".postln };
		}{
			if((index == 0) or: { index == lastIndex }) {
				if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
				{ "refuse to remove sink or source".postln };
			}{
				removedKey = nextChain[index];
				newList = nextChain.copy;
				newList.removeAt(index);
				this.setNextListInternal(newList);
				this.bypassDictForListInternal(nextChain).removeAt(removedKey);
				this.rebuild(nextChain);
				if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
			};
		};
	}

	swap { arg indexAParam, indexBParam;
		var lastIndex, indexA, indexB, newList, tempKey;
		lastIndex = nextChain.size - 1;
		indexA = indexAParam.clip(1, lastIndex - 1);
		indexB = indexBParam.clip(1, lastIndex - 1);

		if(indexA == indexB) {
			// nothing to do
		}{
			newList = nextChain.copy;
			tempKey = newList[indexA];
			newList[indexA] = newList[indexB];
			newList[indexB] = tempKey;
			this.setNextListInternal(newList);
			this.rebuild(nextChain);
			if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
		};
	}

	clearChain {
		var sinkKey, sourceKey, newList;
		if(nextChain.size < 2) { ^this };
		sinkKey = nextChain[0];
		sourceKey = nextChain[nextChain.size - 1];
		newList = [sinkKey, sourceKey];
		this.setNextListInternal(newList);
		this.bypassDictForListInternal(nextChain).clear;
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
	}

	bypass { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(nextChain);
		dict[key] = state;
		this.rebuild(nextChain);
		if(display.notNil) {
			display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
		};
	}

	bypassAt { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = nextChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = nextChain[clampedIndex];
		this.bypass(keyAtIndex, state);
	}

	// ‚îÄ‚îÄ‚îÄ current-chain bypass ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	bypassCurrent { arg key, state = true;
		var dict;
		dict = this.bypassDictForListInternal(currentChain);
		dict[key] = state;
		this.rebuild(currentChain);
		if(display.notNil) {
			display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
		};
	}

	bypassAtCurrent { arg index, state = true;
		var lastIndex, clampedIndex, keyAtIndex;
		lastIndex = currentChain.size - 1;
		clampedIndex = index.clip(1, lastIndex - 1);
		keyAtIndex = currentChain[clampedIndex];
		this.bypassCurrent(keyAtIndex, state);
	}

	// ‚îÄ‚îÄ‚îÄ source setters ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	setSource { arg key;
		var newList, lastIndex;
		lastIndex = nextChain.size - 1;
		newList = nextChain.copy;
		newList[lastIndex] = key;
		this.setNextListInternal(newList);
		this.rebuild(nextChain);
		if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
	}

	setSourceCurrent { arg key;
		var newList, lastIndex, isAList;
		lastIndex = currentChain.size - 1;
		newList = currentChain.copy;
		newList[lastIndex] = key;
		isAList = (currentChain === chainAList);
		if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
		this.rebuild(currentChain);
		if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
	}



	setSourcesBoth { arg key;
		var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;

		// pick a sensible key (today we want \testmelody)
		k = key ? \testmelody;

		// guard: require [sink, source] minimum on both chains
		sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
		if(sizeOk.not) { ^this };

		// remember which concrete list object was CURRENT/NEXT *before* we replace them
		curWasA  = (currentChain === chainAList);
		nextWasA = (nextChain    === chainAList);

		// compute last indices
		lastA = chainAList.size - 1;
		lastB = chainBList.size - 1;

		// replace the *source symbol* (last position) on both lists
		newA = chainAList.copy; newA[lastA] = k;
		newB = chainBList.copy; newB[lastB] = k;

		// publish new lists and restore CURRENT/NEXT pointers to the matching list
		chainAList = newA;
		chainBList = newB;
		currentChain = if(curWasA)  { chainAList } { chainBList };
		nextChain    = if(nextWasA) { chainAList } { chainBList };

		// rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
		this.rebuild(currentChain);
		this.rebuild(nextChain);

		// (optional) inform display
		if(display.notNil and: { display.respondsTo(\showMutation) }) {
			display.showMutation(\setSourcesBoth, [k], nextChain);
		};

		^this
	}

	setDefaultSource { arg key;
		var k;
		// update the instance default; does not modify existing chains immediately
		k = key ? \testmelody;
		defaultSource = k;
		^this
	}


	// ‚îÄ‚îÄ‚îÄ diagnostics helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
	effectiveNext    { ^this.effectiveListForInternal(nextChain) }
	bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
	bypassKeysNext    { ^this.bypassKeysForListInternal(nextChain) }

	reset {
		var sinkAKey, sinkBKey, canRun;
		sinkAKey = \chainA;
		sinkBKey = \chainB;

		chainAList = [sinkAKey, defaultSource];
		chainBList = [sinkBKey, defaultSource];

		bypassA.clear;
		bypassB.clear;

		currentChain = chainAList;
		nextChain = chainBList;

		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			// soft reset: stop both, then rebuild clean connections
			Ndef(sinkAKey).stop;
			Ndef(sinkBKey).stop;

			// Rebuild NEXT first (stays stopped), then CURRENT (plays)
			this.rebuildUnbound(nextChain);
			this.rebuildUnbound(currentChain);
		});

		// enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
		this.enforceExclusiveCurrentOptionA(0.1);

		if(display.notNil) { display.showReset(currentChain, nextChain) };
	}



/*    OLDreset {
        var sinkAKey, sinkBKey;
        sinkAKey = \chainA;
        sinkBKey = \chainB;

        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];

        bypassA.clear;
        bypassB.clear;

        currentChain = chainAList;
        nextChain = chainBList;

        // SAFE server reset ONLY here, using Server.default.* (not 's')
        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;

                this.rebuildUnbound(nextChain);
                this.rebuildUnbound(currentChain);

                Ndef(sinkBKey).stop;
                Ndef(sinkAKey).play(numChannels: defaultNumChannels);
            });
        });

        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }*/

	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	// internal helpers (lowercase, no leading underscore)
	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
	setNextListInternal { arg newList;
		var isAList;
		isAList = nextChain === chainAList;
		if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
	}

	bypassDictForListInternal { arg listRef;
		^if(listRef === chainAList) { bypassA } { bypassB }
	}

	bypassKeysForListInternal { arg listRef;
		var dict, keysBypassed;
		dict = this.bypassDictForListInternal(listRef);
		keysBypassed = Array.new;
		dict.keysValuesDo({ arg key, state;
			if(state == true) { keysBypassed = keysBypassed.add(key) };
		});
		^keysBypassed
	}

	ensureStereoInternal { arg key;
		var proxyBus, needsInit;
		proxyBus = Ndef(key).bus;
		needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
		if(needsInit) {
			Ndef(key).ar(defaultNumChannels);
		};
	}

	// Non-destructive: guard only; do not reset here
	ensureServerTree {
		var serverIsRunning;
		serverIsRunning = Server.default.serverRunning;
		^serverIsRunning
	}

	//
	// v0.4.6 change


	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink    = nextChain[0];
		chans       = defaultNumChannels;
		fadeCur     = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust \in.ar, stereo shape pinned, playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).mold(chans, \audio);   // authoritative shape
			Ndef(currentSink).fadeTime_(fadeCur);
			if(Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans);
			};

			// NEXT: hard-silence + ensure flag drops
			// 1) silence source, then .stop (no audio either way)
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).mold(chans, \audio);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;

			// 2) drop monitor/flag deterministically, then re-establish silent sink
			Ndef(nextSink).end;                      // frees inner players, "stop listen" (NodeProxy help)
			Ndef(nextSink, { Silent.ar(chans) });    // keep NEXT present & silent for prebuild
			Ndef(nextSink).mold(chans, \audio);
			// do NOT play NEXT
		});

		^this
	}

/*	enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
		var currentSink, nextSink, chans, fadeCur;
		currentSink = currentChain[0];
		nextSink = nextChain[0];
		chans = defaultNumChannels;
		fadeCur = fadeCurrent.clip(0.05, 0.2);

		Server.default.bind({
			// CURRENT: robust sink that consumes embedded input; ensure playing
			Ndef(currentSink, { \in.ar(chans) });
			Ndef(currentSink).ar(chans);
			Ndef(currentSink).fadeTime_(fadeCur);
			if (Ndef(currentSink).isPlaying.not) {
				Ndef(currentSink).play(numChannels: chans)
			};

			// NEXT: hard silence at the sink source; stop its monitor quickly
			Ndef(nextSink, { Silent.ar(chans) });
			Ndef(nextSink).ar(chans);
			Ndef(nextSink).fadeTime_(0.01);
			Ndef(nextSink).stop;
		});

		^this
	}*/


	effectiveListForInternal { arg listRef;
		var dict, resultList, lastIndex, isProcessor, isBypassed;
		dict = this.bypassDictForListInternal(listRef);
		resultList = Array.new;
		lastIndex = listRef.size - 1;

		listRef.do({ arg key, indexPosition;
			isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
			isBypassed = isProcessor and: { dict[key] == true };

			if((indexPosition == 0) or: { indexPosition == lastIndex }) {
				resultList = resultList.add(key);
			}{
				if(isBypassed.not) { resultList = resultList.add(key) };
			};
		});
		^resultList
	}

	// Public rebuild: bundles server ops; guard only
	rebuild { arg listRef;
		var whichChain, canRun;
		whichChain = if(listRef === currentChain) { \current } { \next };
		canRun = this.ensureServerTree;
		if(canRun.not) { ^this };

		Server.default.bind({
			this.rebuildUnbound(listRef);
		});

		if(display.notNil) {
			display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
		};
	}


	// Internal rebuild that assumes we are already inside a server bind (no resets)

	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		// (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
		if(processorLib.notNil) {
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};

		// From here on, this is your original "effective / do / connect"
		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}


/*	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;

		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;
		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/*	// At end of rebuildUnbound
	rebuildUnbound { arg listRef;
		var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;


/*		if(processorLib.notNil) {
			// Ask the lib to make sure each symbol in this chain has an Ndef with a function.
			// It will quietly do nothing for unknown keys.
			processorLib.ensureFromChain(listRef, defaultNumChannels);
		};*/


		hasMinimum = listRef.size >= 2;
		if(hasMinimum.not) { ^this };

		effective = this.effectiveListForInternal(listRef);
		effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });

		indexCounter = 0;
		while({ indexCounter < (effective.size - 1) }, {
			leftKey = effective[indexCounter];
			rightKey = effective[indexCounter + 1];
			Ndef(leftKey) <<> Ndef(rightKey);
			indexCounter = indexCounter + 1;
		});

		sinkKey = effective[0];
		shouldPlay = (listRef === currentChain);
		isPlaying = Ndef(sinkKey).isPlaying;

		if(shouldPlay) {
			if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		}{
			if(isPlaying) { Ndef(sinkKey).stop };
		};
	}*/

/* OLD   rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };

        effective = this.effectiveListForInternal(listRef);

        effective.do({ arg keySymbol;
            this.ensureStereoInternal(keySymbol);
        });

        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });

		// sinkKey = effective[0];
		// if(listRef === currentChain) {
		// 	Ndef(sinkKey).play(numChannels: defaultNumChannels);
		// }{
		// 	Ndef(sinkKey).stop;
		// };
		// At the end of rebuildUnbound:
		sinkKey = effective[0];
		if(listRef === currentChain) {
			if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
		} {
			if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
		};

    }*/

	// ---- Ready helpers (public API) ----
	// boolean snapshot (no server ops)
	isReady {
		^ready
	}

	// AppClock polling; onReadyFunc is optional
	waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
		var startTime, tick;
		startTime = Main.elapsedTime;

		AppClock.sched(0, {
			tick = {
				if(this.readyConditionOk) {
					ready = true;
					if(onReadyFunc.notNil) { onReadyFunc.value };
					nil
				}{
					if((Main.elapsedTime - startTime) > timeoutSec) {
						// timed out; leave 'ready' as-is
						nil
					}{
						AppClock.sched(pollSec, tick)
					}
				}
			};
			tick.value;
			nil
		});
		^this
	}

	// ---- Ready helpers (internal; no leading underscore) ----

	// light background poll started from init (OPTION A)
	startReadyPoll {
		var alreadyTrue;
		alreadyTrue = this.readyConditionOk;
		if(alreadyTrue) { ready = true; ^this };
		this.waitUntilReady(2.0, 0.05, { nil });
		^this
	}

	// compute the readiness condition; no server ops here
	readyConditionOk {
		var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;

		curSink = currentChain[0];
		nxtSink = nextChain[0];

		serverOk = Server.default.serverRunning;

		curBus = Ndef(curSink).bus;
		nxtBus = Ndef(nxtSink).bus;

		busesOk = curBus.notNil and: { nxtBus.notNil }
		and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };

		currentPlaying = Ndef(curSink).isPlaying;

		^(serverOk and: { busesOk } and: { currentPlaying })
	}

	// handleCommand { |oscPath|
	// 	var path;
	// 	path = oscPath.asString;
	//
	// 	// Route to your existing mutation logic
	// 	// Update this if you use a different handler name
	// 	if(this.respondsTo(\applyOSCPath)) {
	// 		this.applyOSCPath(path);
	// 	} {
	// 		("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
	// 	};
	//
	// 	^this;
	// }
handleCommand { |oscPath|
    var path;
    path = oscPath.asString;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(path, this, display);
    } {
        ("[MPB] handleCommand: " ++ path ++ " ‚Üí no handler found").warn;
    };

    ^this;
}




}

===== MagicPedalboard/MagicPedalboardTestRunner.sc =====
// MagicPedalboardTestRunner.sc
// v0.2.2
// MD 20250919

/*
Purpose:
- Unified bring-up, audio reset, GUI sync, and test runner for MagicPedalboardNew.
- Replaces StartHere_CleanBoot_OneWindow_BringUp.scd.
- Logs all steps using MDMiniLogger.
- Extensible with new test methods.

Style:
- var-first; lowercase methods; no server.sync.
- Server ops inside Server.default.bind; GUI ops on AppClock.
- No single-letter vars; all var declarations at top of each block.
*/

MagicPedalboardTestRunner : Object {
    var <logger, <pedalboard, <>gui;

    *new { arg mpb, gui;
        ^super.new.init(mpb, gui);
    }

    init { arg mpb, gui;
        pedalboard = mpb;
        this.gui = gui;
        logger = MDMiniLogger.new("MagicPedalboardTestRunner");
        ^this;
    }

    bringUp {
        var trigger, sequence, freqDemand, envelope, toneSignal, panPosition;
        var isPlayingA, isPlayingB, currentSink;

        logger.info("Starting full bring-up...");

        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;
                logger.info("Server tree initialized.");
            });
        });

        Server.default.bind({
            Ndef(\chainA, { \in.ar(2) }).ar(2);
            Ndef(\chainB, { \in.ar(2) }).ar(2);
            Ndef(\ts0, { Silent.ar(2) }).ar(2);
            Ndef(\testmelody, {
                trigger = Impulse.kr(3.2);
                sequence = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
                freqDemand = Demand.kr(trigger, 0, sequence);
                envelope = Decay2.kr(trigger, 0.01, 0.35);
                toneSignal = SinOsc.ar(freqDemand) * envelope * 0.25;
                panPosition = ToggleFF.kr(trigger).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(toneSignal, panPosition);
            }).ar(2);
            logger.info("Sinks and sources defined.");
        });

        pedalboard.reset;
        pedalboard.setSourceCurrent(\testmelody);
        pedalboard.playCurrent;
        pedalboard.enforceExclusiveCurrentOptionA(0.1);

        if(gui.notNil) {
            gui.enableMeters(false);
            gui.enableMeters(true);
            gui.window.front;
            gui.showExpectation("System ready", 0);
        };

        pedalboard.printChains;

        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Playback state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
        logger.info("Bring-up complete.");
    }

    audioReset {
        logger.info("Running ~audioReset...");
        if(~audioReset.notNil) {
            ~audioReset.();
            logger.info("~audioReset complete.");
        } {
            logger.warn("~audioReset is not defined.");
        };
    }

    syncGui {
        var currentSink;
        if(gui.notNil) {
            currentSink = pedalboard.effectiveCurrent[0];
            gui.window.front;
            gui.highlightCurrentColumn(currentSink);
            gui.showChainsDetailed(
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext,
                pedalboard.bypassKeysCurrent,
                pedalboard.bypassKeysNext,
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext
            );
            logger.info("GUI synced with audio state.");
        };
    }

    runAcceptanceTest {
        logger.info("Running acceptance test...");
        pedalboard.add(\delay);
        pedalboard.switchChain(0.12);
        pedalboard.bypassCurrent(\delay, true);
        pedalboard.bypassCurrent(\delay, false);
        pedalboard.switchChain(0.12);
        pedalboard.printChains;
        logger.info("Acceptance test complete.");
    }

    verifyAudioState {
        var isPlayingA, isPlayingB;
        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Audio state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
    }

    help {
        "Available methods: bringUp, audioReset, syncGui, runAcceptanceTest, verifyAudioState".postln;
    }
}

===== MagicPedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects ‚Äì same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== MagicPedalboard/MagicProcessorLibrary.sc =====
/* MagicProcessorLibrary.sc
   Holds a registry of processor/source functions and can ensure Ndefs exist.
   MD 20250913
*/
MagicProcessorLibrary : Object {
    var <defs;           // IdentityDictionary: Symbol -> Function
    var <defaultNumChannels;

    *new { ^super.new.init }

    init {
        var empty;
        defaultNumChannels = 2;
        empty = IdentityDictionary.new;
        defs = empty;
        ^this
    }

    register { arg key, func;
        defs[key] = func;
        ^this
    }

    has { arg key;
        ^defs.includesKey(key)
    }

    get { arg key;
        ^defs[key]
    }

    keys { ^defs.keys }

    // Create or update an Ndef for key
    ensure { arg key, chans;
        var func, numCh, canRun;
        func = defs[key];
        if(func.isNil) { ^this }; // silently ignore if not registered
        numCh = chans ? defaultNumChannels;
        canRun = Server.default.serverRunning;
        if(canRun) {
            Server.default.bind({
                Ndef(key, func);
                Ndef(key).ar(numCh);
            });
        };
        ^this
    }

    // Ensure many keys at once
    ensureMany { arg keyArray, chans;
        keyArray.do({ arg key; this.ensure(key, chans) });
        ^this
    }

    // Convenience: ensure whatever appears in a chain array
    ensureFromChain { arg chainArray, chans;
        var lastIndex, idx;
        if(chainArray.isNil or: { chainArray.size < 2 }) { ^this };
        lastIndex = chainArray.size - 1;
        idx = 0;
        while({ idx <= lastIndex }, {
            this.ensure(chainArray[idx], chans);
            idx = idx + 1;
        });
        ^this
    }
}

===== MagicPedalboard/Manage_MagicDisplayGUI_Singleton.scd =====
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)

===== MagicPedalboard/MPBTest/Classes/MPBTest_AcceptanceSuites.sc =====
// MPBTest_AcceptanceSuites.sc
// v0.1.1
// MD 20250920-1608

// Purpose
// - Ready-made, extensible step lists for acceptance.
// Style
// - var-first; lowercase; data-only class methods.

MPBTest_AcceptanceSuites : Object {
    *classic { arg fade = 0.12;
        ^[
            (verb:\add,           args:[\delay]),
            (verb:\switch,        args:[fade]),
            (verb:\bypassCurrent, args:[\delay, true]),
            (verb:\bypassCurrent, args:[\delay, false]),
            (verb:\switch,        args:[fade])
        ]
    }

    *mutatorsBasic { arg fade = 0.12;
        ^[
            (verb:\insert,   args:[\chorus]),
            (verb:\addAt,    args:[\reverb, 1]),
            (verb:\swap,     args:[1, 2]),
            (verb:\removeAt, args:[2]),
            (verb:\switch,   args:[fade])
        ]
    }

    *bypassNextCycle {
        ^[
            (verb:\add,    args:[\delay]),
            (verb:\bypass, args:[\delay, \on]),
            (verb:\bypass, args:[\delay, \off]),
            (verb:\switch, args:[0.12])
        ]
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Assertions.sc =====
// MPBTest_Assertions.sc
// v0.1.0
// MD 20250920-1540
//
// Purpose
// - Centralized assertions used across scenarios (A XOR B, single \delay in list, NEXT audible tail...)
// Style
// - var-first; lowercase; no server.sync; no single-letter locals.

MPBTest_Assertions : Object {
    *xorPlaying { arg expectA = true, expectB = false;
        var a, b, ok;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ok = (a == expectA) and: { b == expectB };
        ("[ASSERT] XOR A="++a++" B="++b++" expect("++expectA++","++expectB++") -> "++
            (ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }

    *countKey { arg list, key;
        var count = 0;
        list.do({ arg k; if(k == key) { count = count + 1 } });
        ^count
    }

    *exactlyOne { arg list, key, label="count";
        var n, pass;
        n = this.countKey(list, key);
        pass = (n == 1);
        ("[ASSERT] "++label++" '"++key.asString++"' = "++n++" -> "++
            (pass.if({"PASS"},{"FAIL"}))).postln;
        ^pass
    }

    *nextTailNotTs0 { arg mpb;
        var last, ok;
        last = mpb.effectiveNext.last;
        ok = (last != \ts0);
        ("[ASSERT] NEXT tail != \\ts0 -> "++(ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_BringUp.sc =====
// MPBTest_BringUp.sc
// v0.1.9
// MD 20250920-1919

// Purpose
// - Fresh-boot bring-up with Grid GUI by default; avoids display=nil and close/create races.
// Style
// - var-first; lowercase; AppClock for GUI; Server.default.bind for audio; no server.sync.

MPBTest_BringUp : Object {
    classvar < version;
    var < logger, < pedalboard, < gui, < readyFlag, < numChannels, < testAmp;

    *initClass { version = "v0.1.9"; ("MPBTest_BringUp " ++ version).postln; }

    *new {
        arg useGui = true, channels = 2, sourceAmp = 0.40, publishToTildes = true,
            freshBoot = true, guiClassSym = \MagicDisplayGUI_GridDemo, closeExistingGUIs = true;
        ^super.new.init(useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs)
    }

    init { arg useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs;
        var s, doFreshBoot, startBoot, afterBoot, scheduleGuiClose, scheduleGuiCreate;
        var ensureSinks, ensureSources, setSourcesAndPlay, enforceOptionA, attachMeters, postBaseline, maybePublish;

        logger     = MDMiniLogger.new("MPBTest_BringUp");
        readyFlag  = false;
        numChannels = (channels ? 2).asInteger.max(1);
        testAmp     = (sourceAmp ? 0.40).asFloat.clip(0.05, 1.0);
        s = Server.default;

        // --- audio preparation ---
        ensureSinks = {
            Server.default.bind({
                Ndef(\chainA, { \in.ar(numChannels) }); Ndef(\chainA).ar(numChannels);
                Ndef(\chainB, { \in.ar(numChannels) }); Ndef(\chainB).ar(numChannels);
            });
        };

        ensureSources = {
            Server.default.bind({
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f    = Demand.kr(trig, 0, seq);
                    var env  = Decay2.kr(trig, 0.01, 0.35);
                    var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                    Pan2.ar(SinOsc.ar(f) * env * testAmp, pan)
                });
                Ndef(\testmelody).ar(numChannels);
                Ndef(\ts0, { Silent.ar(numChannels) }).ar(numChannels);
            });
        };

        setSourcesAndPlay = {
            pedalboard.setDefaultSource(\testmelody);
            pedalboard.setSourceCurrent(\testmelody);
            pedalboard.playCurrent;
        };

        enforceOptionA = {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
            Server.default.bind({
                var nextSink = pedalboard.nextChain[0];
                Ndef(nextSink).end;
                Ndef(nextSink).mold(numChannels, \audio);
            });
        };

        attachMeters = {
            if(gui.notNil and: { gui.respondsTo(\enableMeters) }) {
                gui.enableMeters(false); gui.enableMeters(true);
            };
        };

        postBaseline = {
            pedalboard.printChains;
            ("[[PLAY]] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            readyFlag = true;
        };

        maybePublish = {
            if(publishToTildes) { ~bring = this; ~mpb = pedalboard; ~gui = gui };
        };

        // --- GUI sequencing to avoid races ---
        scheduleGuiClose = {
            if(closeExistingGUIs and: { useGui }) {
                AppClock.sched(0.00, {
                    var wins = Window.allWindows.select({ arg w;
                        var nm = w.tryPerform(\name) ? "";
                        nm.asString.beginsWith("MagicDisplayGUI")
                    });
                    wins.do(_.close);
                    nil
                });
            };
        };

        scheduleGuiCreate = {
            if(useGui) {
                AppClock.sched(0.05, {
                    gui = guiClassSym.asClass.new;   // MagicDisplayGUI_GridDemo by default
                    gui.window.front.alwaysOnTop_(true);
                    // Build pedalboard only **after** GUI exists so display is bound at construction
                    pedalboard = MagicPedalboardNew.new(gui);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    attachMeters.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            }{
                // Headless: create pedalboard immediately (no display)
                AppClock.sched(0.00, {
                    pedalboard = MagicPedalboardNew.new(nil);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            };
        };

        // --- boot choreography ---
        afterBoot = {
            ensureSinks.value;
            ensureSources.value;
            scheduleGuiClose.value;
            scheduleGuiCreate.value;
        };

        startBoot = {
            s.doWhenBooted({ afterBoot.value });
            if(s.serverRunning.not) { s.boot };
        };

        doFreshBoot = {
            var waitDown;
            if(s.serverRunning) {
                if(gui.notNil and: { gui.respondsTo(\enableMeters) }) { gui.enableMeters(false) };
                s.quit;
                waitDown = {
                    if(s.serverRunning.not) { startBoot.value; nil } {
                        AppClock.sched(0.05, waitDown)
                    }
                };
                AppClock.sched(0.05, waitDown);
            }{
                startBoot.value;
            };
        };

        if(freshBoot) { doFreshBoot.value } { startBoot.value };
        ^this
    }

    isReady { ^readyFlag }
    getPedalboard { ^pedalboard }
    getGui { ^gui }
    getChannels { ^numChannels }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Scenario.sc =====
// MPBTest_Scenario.sc
// v0.2.2
// MD 20250920-2015

// Purpose
// - Timed acceptance runner (add/insert/addAt/removeAt/swap/bypass/.../switch/wait)
//   with optional CommandTree path hook via .setPathApplier.
// - Removes caret-returns from AppClock closures to avoid OutOfContextReturnError.
// Style
// - var-first; lowercase; AppClock scheduling; no server.sync.

MPBTest_Scenario : Object {
    classvar < version;
    var < pedalboard, < gui, < logger;
    var pathApplierFunc;

    *initClass { version = "v0.2.2" }

    *new { arg mpb, guiObj = nil; ^super.new.init(mpb, guiObj) }

    init { arg mpb, guiObj;
        var lg;
        pedalboard = mpb;
        gui = guiObj;
        logger = MDMiniLogger.new("MPBTest_Scenario");
        pathApplierFunc = nil;
        ^this
    }

    setPathApplier { arg func;
        pathApplierFunc = func;
        ^this
    }

    useDefaultAdapterIfPresent {
        if(pathApplierFunc.isNil and: { ~ct_applyOSCPathToMPB.notNil }) {
            pathApplierFunc = { arg pathString;
                ~ct_applyOSCPathToMPB.(pathString.asString, pedalboard, gui);
            };
            logger.info("Using ~ct_applyOSCPathToMPB as default path applier.");
        };
        ^this
    }

    run { arg stepsArray;
        var indexCounter, totalCount, runOne;

        this.useDefaultAdapterIfPresent;

        indexCounter = 0;
        totalCount   = stepsArray.size;

        runOne = {
            var stepDict, verb, args, hasMore;

            hasMore = indexCounter < totalCount;

            if(hasMore) {
                stepDict = stepsArray[indexCounter];
                verb = stepDict[\verb];
                args = stepDict[\args] ? [];

                this.applyStep(verb, args);

                indexCounter = indexCounter + 1;

                // Schedule next step tick; explicit \wait steps still add their own delay.
                AppClock.sched(0.20, { runOne.value; nil });
            }{
                // finished; nothing to return from a scheduled closure
                logger.info("scenario complete (" ++ totalCount ++ " steps).");
            };
            nil
        };

        AppClock.sched(0.00, { runOne.value; nil });
        ^this
    }

    applyStep { arg verb, args;
        var v, brief;
        v = verb;
        brief = {
            pedalboard.printChains;
            this.refreshGui;
        };

        switch(v,
            \wait, {
                var delaySec;
                delaySec = (args[0] ? 0.25).asFloat.max(0.0);
                AppClock.sched(delaySec, { nil }); // no return
            },

            \add, {
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \insert, { // alias of add
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \addAt, {
                var proc, idx;
                proc = args[0];
                idx  = (args[1] ? 1).asInteger;
                pedalboard.addAt(proc, idx);
                brief.value;
            },

            \removeAt, {
                var idx;
                idx = (args[0] ? 1).asInteger;
                pedalboard.removeAt(idx);
                brief.value;
            },

            \swap, {
                var idxA, idxB;
                idxA = (args[0] ? 1).asInteger;
                idxB = (args[1] ? 2).asInteger;
                pedalboard.swap(idxA, idxB);
                brief.value;
            },

            \bypass, { // NEXT chain
                var key, stateSym, state;
                key = args[0];
                stateSym = args[1] ? \on;
                state = (stateSym == \on) or: { stateSym == \true } or: { stateSym == 1 };
                pedalboard.bypass(key, state);
                brief.value;
            },

            \unbypass, {
                var key;
                key = args[0];
                pedalboard.bypass(key, false);
                brief.value;
            },

            \bypassCurrent, {
                var key, state;
                key   = args[0];
                state = (args[1] ? true);
                pedalboard.bypassCurrent(key, state);
                brief.value;
            },

            \bypassAt, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAt(indexParam, stateParam);
                brief.value;
            },

            \bypassAtCurrent, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAtCurrent(indexParam, stateParam);
                brief.value;
            },

            \setSource, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSource(key);
                brief.value;
            },

            \setSourceCurrent, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSourceCurrent(key);
                brief.value;
            },

            \switch, {
                var fade;
                fade = (args[0] ? 0.12).asFloat.clip(0.08, 0.20);
                if(pedalboard.effectiveNext.last == \ts0) {
                    if(pathApplierFunc.notNil) { pathApplierFunc.value("/setSource/testmelody") } {
                        pedalboard.setSource(\testmelody);
                    };
                };
                pedalboard.switchChain(fade);
                this.refreshGui;
            },

            \ctPath, {
                var path;
                path = args[0].asString;
                if(pathApplierFunc.notNil) { pathApplierFunc.value(path) } {
                    logger.warn("[ctPath] adapter missing; ignored: " ++ path);
                };
                this.refreshGui;
            },

            { logger.warn("Unknown step: " ++ v.asString) }
        );
    }

    refreshGui {
        if(gui.notNil and: { gui.respondsTo(\showChainsDetailed) }) {
            var effC, effN;
            effC = pedalboard.effectiveCurrent;
            effN = pedalboard.effectiveNext;
            gui.highlightCurrentColumn(effC[0]);
            gui.showChainsDetailed(effC, effN, pedalboard.bypassKeysCurrent, pedalboard.bypassKeysNext, effC, effN);
        };
    }
}

===== MagicPedalboard/MPBTest/docs/README_MPBTest.md =====
# MPBTest: Test Harness and Acceptance Suite

This folder contains the modular test harness and acceptance suite for the MagicPedalboard project. It is organized for clarity, reproducibility, and ease of extension.

---

## Folder Structure

- `Classes/`  
  Main test harness classes:
    - `MPBTest_BringUp.sc`
    - `MPBTest_Scenario.sc`
    - `MPBTest_AcceptanceSuites.sc`
    - `MPBTest_Assertions.sc`
- `Scripts/`  
  Utility and acceptance scripts:
    - `MPBTest_Run_HealthCheck.scd`
    - `MPBTest_Run_OneGo.scd`
    - `MPBTest_Record_WorkingState.scd`
    - `MPBTest_FreshBootBringUp_Now.scd`
    - `MPBTest_RebindAndFillGUI.scd`
    - `MPBTest_CloseRecreateBind_GUI_GridDemo.scd`
- `docs/`  
  Working state snapshots and documentation (add your Markdown or JSON here).
- `_archive/`  
  For archiving old or superseded test scripts and snapshots.

---

## Usage

```shell
# Health Check
sclang MPBTest/Scripts/MPBTest_Run_HealthCheck.scd

# Bring-Up
sclang MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd

# Record Working State
sclang MPBTest/Scripts/MPBTest_Record_WorkingState.scd

# Run All Acceptance Tests
sclang MPBTest/Scripts/MPBTest_Run_OneGo.scd
```

---

## Conventions

- All test harness classes are in `Classes/` and use the `MPBTest_` prefix.
- Scripts in `Scripts/` are named for their function and are safe to run independently.
- Snapshots and documentation should be placed in `docs/`.
- Archive old scripts in `_archive/` to keep the suite clean.

_Last updated: 2025-09-20_

===== MagicPedalboard/MPBTest/docs/WorkingState_250921-111637.json =====
('timestamp': "250921-111637", 'environment': ('sampleRate': 48000.0, 'blockSize': 64, 'outDevice': "default"), 'versions': ('MPBTest_BringUp': "v0.1.9", 'MagicDisplayGUI': "v0.1.3", 'MPBTest_Assertions': "unknown", 'MagicDisplayGUI_GridDemo': "v0.1.3", 
  'MagicPedalboardNew': "v0.4.7", 'MPBTest_AcceptanceSuites': "unknown", 'MPBTest_Scenario': "v0.2.2", 'MagicDisplay': "v0.1.3"), 'classFiles': [])
===== MagicPedalboard/MPBTest/docs/WorkingState_250921-111637.md =====
# MagicPedalboard ‚Äì Working State (250921-111637)

## Versions
- MPBTest_BringUp: v0.1.9
- MPBTest_Scenario: v0.2.2
- MPBTest_AcceptanceSuites: unknown
- MPBTest_Assertions: unknown
- MagicPedalboardNew: v0.4.7
- MagicDisplay: v0.1.3
- MagicDisplayGUI: v0.1.3
- MagicDisplayGUI_GridDemo: v0.1.3

## Environment
- output device: default
- sample rate: 48000.0
- block size: 64

## Class Files
- 

## Chain Snapshot
- no ~mpb

===== MagicPedalboard/MPBTest/Scripts/MPBTest_CloseRecreateBind_GUI_GridDemo.scd =====
// MPBTest_CloseRecreateBind_GUI_GridDemo.scd
// v0.1.0
// MD 20250920-1919
(
var closeExisting, createGrid, bindAndFill;

/*closeExisting = {
    AppClock.sched(0.00, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            var nm = w.tryPerform(\name) ? "";
            nm.asString.beginsWith("MagicDisplayGUI")
        });
        wins.do(_.close);
        nil
    });
};*/

closeExisting = {
    AppClock.sched(0.00, {
        var windowList;

        windowList = Window.allWindows.select({ arg w;
            var nameString;
            nameString = w.tryPerform(\name) ? "";
            nameString.asString.beginsWith("MagicDisplayGUI")
        });

        windowList.do({ arg w; w.close });
        nil
    });
};

createGrid = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
        nil
    });
};

bindAndFill = {
    AppClock.sched(0.10, {
        if(~mpb.notNil and: { ~gui.notNil }) {
            ~mpb.setDisplay(~gui);
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            ~mpb.printChains;
            ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
        }{
            "[REBIND] ~mpb or ~gui missing".warn;
        };
        nil
    });
};

closeExisting.value;
createGrid.value;
bindAndFill.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd =====
// MPBTest_FreshBootBringUp_Now.scd
// v0.1.1
// MD 20250920-1642

(
var s, startBoot, afterBoot, waitDown, doFreshBoot;

s = Server.default;

afterBoot = {
    AppClock.sched(0.00, {
        ~bring = MPBTest_BringUp.new(true, 2, 0.40, true); // use loud test source & publish tildes
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };
        nil
    })
};

startBoot = {
    s.doWhenBooted({ afterBoot.value });
    if(s.serverRunning.not) { s.boot };
};

waitDown = {
    if(s.serverRunning.not) { startBoot.value; nil } {
        AppClock.sched(0.05, waitDown)
    }
};

doFreshBoot = {
    if(s.serverRunning) {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };
        s.quit;
        AppClock.sched(0.05, waitDown);
    }{
        startBoot.value;
    };
};

doFreshBoot.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_RebindAndFillGUI.scd =====
// MPBTest_RebindAndFillGUI.scd
// v0.1.0
// MD 20250920-1919

(
var need;

// 0) Precondition: we want ~mpb and ~gui alive
need = (~mpb.notNil) && (~gui.notNil);
if(need.not) {
    "[REBIND] need ~mpb and ~gui; run MPBTest_BringUp first.".warn;
    ^nil;
};

// 1) If the GUI was created after MPB, bind it now
if(~mpb.display.isNil or: { ~mpb.display !== ~gui }) {
    ~mpb.setDisplay(~gui);
    "[REBIND] bound ~gui to ~mpb".postln;
};

// 2) Make sure it‚Äôs in front (and visible)
AppClock.sched(0.02, {
    var w;
    w = ~gui.tryPerform(\window);
    if(w.notNil) { w.front; w.alwaysOnTop_(true) };
    nil
});

// 3) Reattach meters (guards inside GUI)
AppClock.sched(0.04, {
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
    nil
});

// 4) Fill the chains view now
AppClock.sched(0.06, {
    ~mpb.printChains; // drives showChainsDetailed when a display is bound
    // highlight current column for good measure
    ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
    nil
});
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Record_WorkingState.scd =====
// MPBTest_Record_WorkingState.scd
// v0.1.1
// MD 20250920-1930

(
var now, stamp, docDir, mdPath, jsonPath, mkDir;
var s, o, outDev, sr, blk, scv, lines, md, js;
var v_mpbtest_bring, v_mpbtest_scen, v_mpbtest_suites, v_mpbtest_assert;
var v_mpb, v_md, v_mdgui, v_mdgrid;
var fileList, classPaths;

/*// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930
docDir = PathName(thisProcess.nowExecutingPath ?? thisProcess.cwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;*/

// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930

// Use script location if available, else current working directory
docDir = PathName(thisProcess.nowExecutingPath ? File.getcwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;


mkDir = { |p|
    var pn = PathName(p);
    if(pn.isFolder.not) {
        File.mkdir(p);
    };
};


// 1) Ensure docs dir
mkDir.(docDir);

// 2) Environment
s  = Server.default;
o  = s.options;
outDev = o.outDevice ? "default";
sr  = s.sampleRate ? 0;
blk = o.blockSize;
/*scv = Main.scVersionString ? Main.scVersion;*/
/*scv = Platform.version.asString;*/
scv = thisProcess.interpreter.version;


// 3) Versions
v_mpbtest_bring  = (MPBTest_BringUp.respondsTo(\version)).if({ MPBTest_BringUp.version },{ "unknown" });
v_mpbtest_scen   = (MPBTest_Scenario.respondsTo(\version)).if({ MPBTest_Scenario.version },{ "unknown" });
v_mpbtest_suites = (MPBTest_AcceptanceSuites.respondsTo(\version)).if({ MPBTest_AcceptanceSuites.version },{ "unknown" });
v_mpbtest_assert = (MPBTest_Assertions.respondsTo(\version)).if({ MPBTest_Assertions.version },{ "unknown" });

v_mpb    = (MagicPedalboardNew.respondsTo(\version)).if({ MagicPedalboardNew.version },{ "unknown" });
v_md     = (MagicDisplay.respondsTo(\version)).if({ MagicDisplay.version },{ "unknown" });
v_mdgui  = (MagicDisplayGUI.respondsTo(\version)).if({ MagicDisplayGUI.version },{ "unknown" });
v_mdgrid = (MagicDisplayGUI_GridDemo.respondsTo(\version)).if({ MagicDisplayGUI_GridDemo.version },{ "unknown" });

// 4) Class file paths (confirm there‚Äôs only one of each)
classPaths = Class.allClasses
    .select({ |c| ["MPBTest_BringUp","MPBTest_Scenario","MPBTest_AcceptanceSuites","MPBTest_Assertions"].includes(c.name.asString) })
    .collect(_.filenameSymbol.asString);

// 5) Chain snapshot
~mpb = ~mpb ?? { nil };
fileList = if(~mpb.notNil, {
    var effC = ~mpb.effectiveCurrent, effN = ~mpb.effectiveNext;
    [
        "CURRENT=" ++ effC.asString,
        "NEXT   =" ++ effN.asString,
        "[PLAY] A=" ++ Ndef(\chainA).isPlaying ++ " B=" ++ Ndef(\chainB).isPlaying
    ]
}, { ["no ~mpb"] });

// 6) Write Markdown + JSON
mdPath   = docDir +/+ ("WorkingState_" ++ stamp ++ ".md");
jsonPath = docDir +/+ ("WorkingState_" ++ stamp ++ ".json");

// Markdown
md = String.new;
md = md
++ "# MagicPedalboard ‚Äì Working State (" ++ stamp ++ ")\n\n"
++ "## Versions\n"
++ "- MPBTest_BringUp: "   ++ v_mpbtest_bring  ++ "\n"
++ "- MPBTest_Scenario: "  ++ v_mpbtest_scen   ++ "\n"
++ "- MPBTest_AcceptanceSuites: " ++ v_mpbtest_suites ++ "\n"
++ "- MPBTest_Assertions: "++ v_mpbtest_assert ++ "\n"
++ "- MagicPedalboardNew: "++ v_mpb ++ "\n"
++ "- MagicDisplay: "      ++ v_md  ++ "\n"
++ "- MagicDisplayGUI: "   ++ v_mdgui  ++ "\n"
++ "- MagicDisplayGUI_GridDemo: " ++ v_mdgrid ++ "\n\n"
++ "## Environment\n"
++ "- sclang: " ++ scv ++ "\n"
++ "- output device: " ++ outDev ++ "\n"
++ "- sample rate: " ++ sr ++ "\n"
++ "- block size: " ++ blk ++ "\n\n"
++ "## Class Files\n- " ++ classPaths.join("\n- ") ++ "\n\n"
++ "## Chain Snapshot\n- " ++ fileList.join("\n- ") ++ "\n";

File.writeText(mdPath, md);

// JSON (minimal)
js = (
    timestamp: stamp,
    versions: (
        MPBTest_BringUp: v_mpbtest_bring, MPBTest_Scenario: v_mpbtest_scen,
        MPBTest_AcceptanceSuites: v_mpbtest_suites, MPBTest_Assertions: v_mpbtest_assert,
        MagicPedalboardNew: v_mpb, MagicDisplay: v_md,
        MagicDisplayGUI: v_mdgui, MagicDisplayGUI_GridDemo: v_mdgrid
    ),
    environment: (
        sclang: scv, outDevice: outDev, sampleRate: sr, blockSize: blk
    ),
    classFiles: classPaths
).asCompileString;

File.writeText(jsonPath, js);

("[RECORD] wrote\n- " ++ mdPath ++ "\n- " ++ jsonPath).postln;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== MagicPedalboard/old but good/Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd
// MD 20250912-1527

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets; no double /n_free


(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight (avoid double free: only clear Ndefs)
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var exists;
            exists = proxyRef.notNil;
            if(exists) {
                proxyRef.clear; // no proxy.stop here ‚Üí avoids duplicate /n_free
            };
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (GUI queues until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== MagicPedalboard/PERFHUD_UIWriter_Headroom_Overlay.scd =====
// PERFHUD_UIWriter_Headroom_Overlay.scd
// v0.1.0
// MD 2025-09-29

(
var disableLegacyHudOsc, findPerfHudWindow, collectIndicatorsRecursively;
var bindMetersOnce, updateMetersFromModelMapped, startHudTicker;
var desiredFps, mappingExists, meterOrderNote;

// Desired HUD update cadence
desiredFps = 24.0;

// 1) Disable the legacy /md/levels HUD OSCdef so it cannot overwrite our mapped values
disableLegacyHudOsc = {
    var existingHudOsc, resultText;
    existingHudOsc = OSCdef.all.at(\md_levels_hud);
    if(existingHudOsc.notNil) {
        existingHudOsc.free;
        resultText = "[HUD] Disabled legacy OSCdef(\\md_levels_hud) for /md/levels to prevent raw 0..1 pegging.";
    }{
        resultText = "[HUD] Legacy OSCdef(\\md_levels_hud) not present (nothing to disable).";
    };
    resultText.postln;
    nil
};

// 2) Utilities to find the PerfHUD window and collect all LevelIndicators
findPerfHudWindow = {
    var perfWindow;
    perfWindow = Window.allWindows.detect({ arg eachWindow;
        var windowNameString;
        windowNameString = (eachWindow.tryPerform(\name) ? "").asString;
        windowNameString.beginsWith("MagicDisplayGUI")
    });
    perfWindow
};

collectIndicatorsRecursively = { arg rootView;
    var allIndicators, recurseChildren;
    allIndicators = List.new;
    recurseChildren = { arg viewToScan;
        if(viewToScan.isKindOf(LevelIndicator)) { allIndicators.add(viewToScan) };
        viewToScan.children.do({ arg childView; recurseChildren.(childView) });
    };
    recurseChildren.(rootView);
    allIndicators.asArray
};

// 3) Cache references to the first 4 meters (A L, A R, B L, B R)
//    Adjust here if your layout uses a different order or more meters.
bindMetersOnce = {
    var perfWindow, rootView, allMeters, bindOk;
    bindOk = false;

    perfWindow = findPerfHudWindow.();
    if(perfWindow.isNil) {
        "PerfHUD window not found (MagicDisplayGUI...). Will retry.".warn;
    }{
        rootView = perfWindow.tryPerform(\view);
        if(rootView.isNil) {
            "PerfHUD host view missing. Will retry.".warn;
        }{
            allMeters = collectIndicatorsRecursively.(rootView);
            if(allMeters.size < 4) {
                ("[HUD] Found only " ++ allMeters.size ++ " LevelIndicators; expecting ‚â• 4. Will retry.").warn;
            }{
                // Cache the first four meters (override if you have a specific order)
                ~hud_meterA_left   = allMeters[0];
                ~hud_meterA_right  = allMeters[1];
                ~hud_meterB_left   = allMeters[2];
                ~hud_meterB_right  = allMeters[3];

                meterOrderNote = "[HUD] Bound meters: [0]=A_L  [1]=A_R  [2]=B_L  [3]=B_R (override if your layout differs)";
                meterOrderNote.postln;
                bindOk = true;
            };
        };
    };
    bindOk
};

// 4) Mapped update from model ‚Üí LevelIndicators
updateMetersFromModelMapped = {
    var levelsA, levelsB;
    var mappedAL, mappedAR, mappedBL, mappedBR;

    // Ensure mapping helper exists (installed by your responders extender file)
    mappingExists = (~hud_map_linear_to_ui.notNil);
    if(mappingExists.not) {
        "‚ö†Ô∏è ~hud_map_linear_to_ui is not defined. Evaluate MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd first.".warn;
        ^nil;
    };

    // Pull linear A/B pairs from model; default to zeros
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });

    // Map linear (0..1) ‚Üí UI value (0..1) using your headroom + gamma
    mappedAL = ~hud_map_linear_to_ui.(levelsA[0]);
    mappedAR = ~hud_map_linear_to_ui.(levelsA[1]);
    mappedBL = ~hud_map_linear_to_ui.(levelsB[0]);
    mappedBR = ~hud_map_linear_to_ui.(levelsB[1]);

    // Assign to cached meters (guards in case binding failed)
    if(~hud_meterA_left.notNil)   { ~hud_meterA_left.value   = mappedAL };
    if(~hud_meterA_right.notNil)  { ~hud_meterA_right.value  = mappedAR };
    if(~hud_meterB_left.notNil)   { ~hud_meterB_left.value   = mappedBL };
    if(~hud_meterB_right.notNil)  { ~hud_meterB_right.value  = mappedBR };
    nil
};

// 5) Start/replace one AppClock ticker that updates HUD at desiredFps
startHudTicker = {
    var makeTicker;

    // Stop a previous ticker if present
    if(~hud_tickerRoutine.notNil) {
        ~hud_tickerRoutine.stop;
        ~hud_tickerRoutine = nil;
        "[HUD] Replaced previous HUD ticker.".postln;
    };

    makeTicker = {
        ~hud_tickerRoutine = Routine({
            var waitSeconds;
            waitSeconds = 1.0 / desiredFps;
            while({ true }) {
                updateMetersFromModelMapped.();
                waitSeconds.yield;
            }
        });
        ~hud_tickerRoutine.play(AppClock);
        ("[HUD] HUD ticker active @ " ++ desiredFps.round(0.1) ++ " fps.").postln;
        nil
    };

    makeTicker.();
};

// Execute overlay
AppClock.sched(0.0, {
    var bound;
    disableLegacyHudOsc.();
    bound = bindMetersOnce.();
    if(bound.not) {
        // try again shortly in case the window just spawned
        AppClock.sched(0.25, {
            if(bindMetersOnce.()) { startHudTicker.() }{ "[HUD] Binding failed again; run this block once the HUD window is visible.".warn };
            nil
        });
    }{
        startHudTicker.();
    };
    nil
});
)

===== MagicPedalboard/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "‚ö†Ô∏è queueExportCallback missing.".warn };
)

===== MagicPedalboard/QuickRestore_AudioAndExclusive.scd =====
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== MagicPedalboard/README_DesignAndAPI_20250915.md =====
<!-- Filename: README_DesignAndAPI_20250915.md -->

# Design highlights (SC 3.14, macOS, Qt)

- All GUI work is scheduled on AppClock.
- No `server.sync`.
- No watchers or background polling in the runner.
- Exactly one GUI window: duplicates are closed or a live one is reused.
- Deterministic runs are token-gated; stale scheduled steps are ignored.
- Scripts/tests follow style: tilde interpreter vars, lowercase names, `var` at top of each block, no single-letter locals, and no `^` in .scd scripts.
- Do not override or monkey-patch `queueUi`. Call it if present; otherwise skip.

## Architecture

- MagicPedalboardNew manages two chains (`\chainA`, `\chainB`) built from Ndefs.
- Chains are arrays of symbols: `[sink, ... processors ..., source]`.
- Crossfading `switchChain` swaps CURRENT and NEXT with a short fade.
- MagicDisplay is a console adaptor.
- MagicDisplayGUI is a Qt GUI that shows CURRENT / NEXT lists, an expectation box, countdown, and optional meters.
- MagicProcessorLibrary registers processors/sources and ensures the corresponding Ndefs exist.

---

# Class summaries & key API

## MagicPedalboardNew (Object)

- Role: Manage A/B chains of Ndefs; maintain bypass state; rebuild non-destructively; notify display.
- Construction:
  - `MagicPedalboardNew.new(displayOrNil)`
- Playback:
  - `playCurrent`
  - `stopCurrent`
  - `switchChain(fadeTime = 0.1)`  // short crossfade, clamps to a safe range
- Mutators (operate on NEXT):
  - `add(key)`
  - `addAt(key, index)`
  - `removeAt(index)`
  - `swap(indexA, indexB)`
  - `clearChain`
- Bypass:
  - NEXT: `bypass(key, state=true)`, `bypassAt(index, state=true)`
  - CURRENT: `bypassCurrent(key, state=true)`, `bypassAtCurrent(index, state=true)`
- Sources:
  - `setSource(key)`            // NEXT
  - `setSourceCurrent(key)`     // CURRENT
- Diagnostics:
  - `printChains`
  - `effectiveCurrent`, `effectiveNext`
  - `bypassKeysCurrent`, `bypassKeysNext`
  - `reset`
- Notes:
  - Rebuilds run in `Server.default.bind { ... }` after `ensureServerTree`.
  - A small helper normalizes Ndef channel counts before connections.
  - Pair connections use JITLib‚Äôs `<<>>` operator to embed/patch Ndefs.

## MagicDisplay (Object)

- Role: Console display adaptor.
- Selected methods:
  - `showInit(ped, versionString, current, next)`
  - `showRebuild(which, fullChain, effective)`
  - `showPlay(sink)`, `showStop(sink)`
  - `showSwitch(oldSink, newSink, current, next)`
  - `showMutation(action, args, nextChain)`
  - `showBypass(which, key, state, chain, bypassKeys)`
  - `showReset(current, next)`
  - `showChains`, `showChainsDetailed(...)`
  - `showError(message)`

## MagicDisplayGUI (MagicDisplay)

- Role: Visual GUI for CURRENT/NEXT chains, expectation/countdown, operations list, optional A/B meters.
- Construction:
  - `MagicDisplayGUI.new()`   // builds the window from `initGui` on AppClock
- UI queue:
  - `queueUi { |f| ... }`     // buffers until views exist; then runs on AppClock
- Visualization:
  - `highlightCurrentColumn`
  - `formatListTopDown(listRef, bypassKeys, effectiveList)`
- Expectation & countdown:
  - `showExpectation(text, seconds=0)`
  - `startCountdown(seconds, labelText, onFinished)`
- Operations pane:
  - `setOperations(items)`
  - `setNextAction(func)`
  - `runNextOperation(index)`
  - `updateOpsHighlight`
- Meters:
  - `enableMeters(flag=true)`  // may define lightweight meter SynthDefs on demand
- Display hooks:
  - Overrides `showInit / showRebuild / showPlay / showStop / showSwitch / showMutation / showBypass / showReset / showChainsDetailed / showError`.

## MagicProcessorLibrary (Object)

- Role: Registry for processors/sources; server helpers to ensure Ndefs exist.
- API:
  - `register(key, func)`
  - `has(key)`, `get(key)`, `keys`
  - `ensure(key, chans=2)`
  - `ensureMany(keyArray, chans=2)`
  - `ensureFromChain(chainArray, chans=2)`

===== MagicPedalboard/README_MagicPedalboard_Demo.md =====

# Magic Pedalboard (SuperCollider) ‚Äì Demo Readme

**Status**: demo-ready (visual + audio) ‚Ä¢ **Date**: 2025-09-19 09:27

This document explains what the Magic Pedalboard system does, how its demo works, how to run it, how the pieces fit together, and what to improve next. It is written for a third‚Äëparty developer who needs to understand and reproduce today‚Äôs demo in SuperCollider.

---

## 1) What the system is

Magic Pedalboard is a SuperCollider system for live guitar processing split into three layers:

1) Audio Engine (SC / JITLib)
   - Two processing chains using Ndef: Chain A (CURRENT) and Chain B (NEXT).
   - Option A safety: NEXT is muted at the source (built silently) and becomes audible only when switched.
   - Effects are attached with Ndef(\chainX).filter from a small effect dictionary (delay, reverb, chorus, tremolo).
   - A small set of helpers controls NEXT‚Äôs effect and toggles CURRENT/NEXT.

2) Display GUI (MagicDisplayGUI_GridDemo)
   - A single window named ‚ÄúMagicDisplayGUI ‚Äì GridDemo‚Äù using GridLayout.
   - Row 0: two equal columns (CURRENT left, NEXT right).
   - Rows 1‚Äì4: full‚Äëwidth blocks for expectation, countdown, thin meters (~30 px), and a bottom Processors panel.
   - No mouse interaction required; it reflects state changes from code.

3) Command Tree + MIDI (classes provided)
   - CommandManager / MDCommandTree / MDCommandNode / MDCommandBuilder / MDCommandQueue / MIDIInputManager
   - Modes: \idle, \prog (navigate by fretted notes), \queue (enqueue payload), \send (export OSC path).
   - A bridge maps the exported OSC path tail (e.g. single-delay, freeverb) to an effect symbol and applies it to NEXT.

---

## Resume Prompt

Resume: Magic Pedalboard (SuperCollider) ‚Äî continue where we left off.

Context snapshot:
- Audio working with JITLib Ndefs: Chain A (CURRENT, audible) and Chain B (NEXT, Option A muted at source). Effects via Ndef(\chainX).filter.
- GUI = MagicDisplayGUI_GridDemo using GridLayout. Row 0 is two equal columns; rows 1‚Äì4 are full width (expectation, countdown, thin meters ~30 px, bottom Processors). Visual-only (no clicks).
- Command Tree classes present: CommandManager, MDCommandTree, MDCommandNode, MDCommandBuilder, MDCommandQueue, MIDIInputManager (+ handlers). Modes: \idle ‚Üí \prog ‚Üí \queue ‚Üí \send. Bridge maps OSC tail tokens (e.g. single-delay, freeverb) to effect symbols and applies to NEXT.
- Runtime helpers: ~applyCTEffect.(\effect), ~clearNext.(), ~switchNow.(), ~audioReset.(). GUI‚Äìaudio sync patch installed so headers/highlight/lists match ~currentIsA, and NEXT shows ~nextEffectSym.

Prescriptions / rules (must follow):
- SuperCollider style: var-first in every block/closure; method names lowercase; avoid single-letter locals; interpreter vars are ~lowercase; no loadRelative.
- GUI ops on AppClock only; no server.sync. Server ops inside Server.default.bind at boot. Safe resets: s.waitForBoot; s.initTree; s.defaultGroup.freeAll.
- For demos/tests: generated audio only; NO SoundIn.
- GUI: single window whose name begins with ‚ÄúMagicDisplayGUI‚Äù. Use GridLayout. Keep meters thin strips.
- Audio safety: enforce Option A (NEXT silent at source) until switched.
- When negating a var, multiply by -1 (e.g., depth * -1) instead of a bare unary minus on identifiers.

What to do next (priority):
1) Implement a 50‚Äì100 ms crossfade in ~switchNow (dual-gain fade, no clicks).
2) Map Command Tree payload parameters to effect params (e.g., delay time/feedback), with safe ranges and GUI reflection.
3) Confirm hex guitar MIDI routing (ch 0‚Äì5 ‚Üí strings 6‚Üí1) and live fret navigation in \prog; integrate foot controller mode changes.
4) Optional: real meters (audio-driven) while keeping thin-strip look.

===== MagicPedalboard/README20250915.md =====
<!-- Filename: README20250915.md -->

# MagicPedalboardNew + MagicDisplayGUI (SC 3.14, macOS / Qt)

This repo contains:
- **MagicPedalboardNew**: a JITLib (Ndef) A/B pedalboard manager.
- **MagicDisplay**: console display adaptor.
- **MagicDisplayGUI**: Qt GUI displaying CURRENT and NEXT chains, with optional meters.
- **MagicProcessorLibrary**: registry for sources/effects and helpers to ensure Ndefs.

All GUI work is scheduled on **AppClock**. No `server.sync`. No watchers/pollers. One window.

---

## Versions (as printed by classes at init)

- MagicPedalboardNew **v0.3.8**
- MagicDisplay **v0.1.2**
- MagicDisplayGUI **v0.2.4**

(Your test runner may show a separate runner version string.)

---

## Quick start

1. **Boot the server** (if your scenarios need audio), or let the GUI run meterless.
2. **Create the GUI** using the constructor (no args). The GUI builds its window on AppClock internally:

```supercollider
~gui = MagicDisplayGUI.new();   // builds window during initGui on AppClock

3. Create the pedalboard and attach the display:

~pedalboard = MagicPedalboardNew(~gui);
~pedalboard.printChains;  // also drives GUI detailed view

4. Run the one-button runner (if present in your test scripts):

~md_bootProbeScenario.();   // ensures 1 window, shows PROBE FRAME, runs Scenario 1 (fast)

===== MagicPedalboard/retargetMeters.scd_OBSOLETE =====
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)

===== MagicPedalboard/RMS_From_ChainAB_Busses_ToHUD.scd_OBSOLETE =====
// RMS_From_ChainAB_Busses_ToHUD.scd
// v0.1.0
// MD 2025-09-29

/* Purpose
   - Read audio at the *ends* of chainA and chainB via their Ndef output busses.
   - Compute RMS per channel using RMS.ar(sig, 500).
   - Convert to dBFS, map to 0..1 for display headroom, and send to /md/levels
     (the standard PerfHUD path: [A_L, A_R, B_L, B_R]).
   - Also send raw dBFS to /md/rms_db so we can verify numbers in the console.

Style
   - var-first; descriptive lowercase; Server.default.bind for server ops; AppClock for UI; no server.sync.
*/

(
var getProxyBusInfo, chainAProxy, chainBProxy, busAIndex, busBIndex, channelsA, channelsB;
var uiFloorDb, uiTopDb, updatesPerSecond;
var installSynthDef, startRmsMeter, installDbPrinter, stopExisting, sanityReport;

// --- configuration (adjust only these if needed) ---
uiFloorDb        = -72.0;  // visual floor
uiTopDb          =   3.0;  // 0 dBFS maps to 1.0 (use +3.0 for extra headroom)
updatesPerSecond = 15;     // HUD refresh cadence

// Helpers
getProxyBusInfo = { arg symbol;
    var proxy, busObject, infoDict;
    proxy = Ndef(symbol);
    busObject = proxy.bus;
    infoDict = (
        symbol: symbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    infoDict
};

// 0) Inspect chain busses (so we *know* what we‚Äôre reading)
chainAProxy = getProxyBusInfo.(\chainA);
chainBProxy = getProxyBusInfo.(\chainB);
busAIndex   = chainAProxy[\busIndex];
busBIndex   = chainBProxy[\busIndex];
channelsA   = chainAProxy[\numChannels];
channelsB   = chainBProxy[\numChannels];

sanityReport = "[RMS] chainA bus=" ++ (busAIndex ? "nil")
    ++ "  chans=" ++ channelsA
    ++ "   |   chainB bus=" ++ (busBIndex ? "nil")
    ++ "  chans=" ++ channelsB;
sanityReport.postln;

if(busAIndex.isNil or: { busBIndex.isNil }) {
    "‚ö†Ô∏è Could not get Ndef bus indices (are chainA/chainB playing?). Aborting RMS bring-up.".warn;
    ^nil;
};

// 1) Define one synth to read both busses, compute RMS‚ÜídB‚ÜíUI and send to HUD
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15, floorDb = -72, topDb = 0;

            var sigA, sigB, aL, aR, bL, bR;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var uiAL, uiAR, uiBL, uiBR;
            var tick, minLin;

            // Read 2 channels from each bus; duplicate left if mono
            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aL = sigA[0];
            aR = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });

            bL = sigB[0];
            bR = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS at audio rate (user-specified: RMS.ar(sig, 500) ~ 500 Hz lowpass)
            rmsAL = RMS.ar(aL, 500);
            rmsAR = RMS.ar(aR, 500);
            rmsBL = RMS.ar(bL, 500);
            rmsBR = RMS.ar(bR, 500);

            // Convert to dBFS (guard floor)
            minLin = 1e-9;
            dbAL = (max(rmsAL, minLin)).log10 * 20.0;
            dbAR = (max(rmsAR, minLin)).log10 * 20.0;
            dbBL = (max(rmsBL, minLin)).log10 * 20.0;
            dbBR = (max(rmsBR, minLin)).log10 * 20.0;

            // Map dBFS -> 0..1 for HUD (headroom)
            uiAL = ((dbAL - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiAR = ((dbAR - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiBL = ((dbBL - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);
            uiBR = ((dbBR - floorDb) / (topDb - floorDb)).clip(0.0, 1.0);

            // Emit both: raw dB (for console) and mapped UI (for HUD)
            tick = Impulse.kr(fps);

            // For verification
            SendReply.kr(tick, "/md/rms_db", [dbAL, dbAR, dbBL, dbBR]);

            // For HUD: /md/levels expects [A_L, A_R, B_L, B_R]
            SendReply.kr(tick, "/md/levels", [uiAL, uiAR, uiBL, uiBR]);
        }).add;
    });
    "[RMS] SynthDef \\md_rms_from_busses installed.".postln;
};

// 2) Stop any previous RMS meter synth; start a fresh one on the detected busses
stopExisting = {
    if(~md_rmsSynth.notNil) {
        ~md_rmsSynth.free; ~md_rmsSynth = nil;
        "[RMS] previous md_rms_from_busses stopped.".postln;
    };
};

startRmsMeter = {
    Server.default.bind({
        ~md_rmsSynth = Synth(\md_rms_from_busses, [
            \inBusA, busAIndex,
            \inBusB, busBIndex,
            \fps, updatesPerSecond,
            \floorDb, uiFloorDb,
            \topDb, uiTopDb
        ]);
    });
    ("[RMS] started on A=" ++ busAIndex ++ "  B=" ++ busBIndex
        ++ "  floor=" ++ uiFloorDb ++ " dB  top=" ++ uiTopDb ++ " dB").postln;
};

// 3) Print a few dB lines to console so we *see* the measured numbers
installDbPrinter = {
    var keyName, linesRemaining;
    keyName = \md_rms_db_console;
    linesRemaining = 8;

    if(OSCdef(keyName).notNil) { OSCdef(keyName).free };
    OSCdef(keyName, { arg message;
        var dbAL, dbAR, dbBL, dbBR, line;
        if(message.size >= 5) {
            dbAL = message[3].round(0.1);
            dbAR = message[4].round(0.1);
            dbBL = message[5].round(0.1);
            dbBR = message[6].round(0.1);
            line = "[RMS dB]  A: L=" ++ dbAL ++ "  R=" ++ dbAR
                ++ "   |   B: L=" ++ dbBL ++ "  R=" ++ dbBR;
            line.postln;
            linesRemaining = linesRemaining - 1;
            if(linesRemaining <= 0) {
                OSCdef(keyName).free;
                "[RMS dB] console printer finished.".postln;
            };
        };
    }, '/md/rms_db');
};

// Execute
installSynthDef.();
stopExisting.();
startRmsMeter.();
installDbPrinter.();
)

===== MagicPedalboard/switchDelayCheck.scd =====
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optional Final) probes using your stereo BUS INDICES.
   - A uses replyID 2001, B uses 2002, Final uses 2101.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain stereo bus base index (e.g., 16)
busB = -1;      // TODO: set to your B chain stereo bus base index (e.g., 24)
busFinal = -1;  // optional final mix stereo bus base index (e.g., 32)

ok = true;

if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd
// v0.3.13
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter filters to avoid duplicate /md/levels.
   - Announce everything in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, aResult, bResult, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, def1, def2;

    ok2 = true;

    // mono probe
    def1 = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // silent synth
        Silent.ar(1).mute;
    }).add;

    // stereo probe
    def2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        Silent.ar(2).mute;
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any in-proxy meter/tap filters to identity (no duplicate SendReply)
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Collect Ndef info: exists, playing, bus index, channel count, group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2; // default to stereo if unknown
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, tagSym, outVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            // Free previous probe if any
            freeIfPlaying.value(thisProcess.interpreter.getVar(outVarSym));

            // Ensure a fresh group placed after the Ndef's group
            grp = Group.after(groupTarget);

            // Attach appropriate probe
            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            // Publish references
            thisProcess.interpreter.setVar(tagSym, grp);
            thisProcess.interpreter.setVar(outVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

// Ensure our probe SynthDefs exist
ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, ~md_probeGroupA, ~md_probeA);
attachAfterNdef.value(bInfo, 2002, ~md_probeGroupB, ~md_probeB);

("Attach_ProbesAfterNdefs: done.").postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd
// v0.3.14
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announces itself in the console so logs show what ran and in what order.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe (no Out, just SendReply)
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output; silent by design
    }).add;

    // stereo probe (no Out, just SendReply)
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output; silent by design
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any prior filters (meter/tap) to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Gather Ndef info: existence, playing, bus index, channel count (clamped 1..2), and group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, groupVarSym, synthVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            freeIfPlaying.value(thisProcess.interpreter.getVar(synthVarSym));
            thisProcess.interpreter.setVar(synthVarSym, nil);

            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            thisProcess.interpreter.setVar(groupVarSym, grp);
            thisProcess.interpreter.setVar(synthVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, \~md_probeGroupA, \~md_probeA);
attachAfterNdef.value(bInfo, 2002, \~md_probeGroupB, \~md_probeB);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd
// v0.3.15
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (mono or stereo).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announce actions in console so logs clearly show what ran.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyFilters,
    detectInfo, freeIfPlaying, attachAfterNdef,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe: reads 1 channel, sends a single float
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output
    }).add;

    // stereo probe: reads 2 channels, sends an array of two floats
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output
    }).add;

    ok2;
};

neutralizeInProxyFilters = {
    var ok2;

    ok2 = true;

    // Overwrite prior filters/taps to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Inspect an Ndef and report (exists, playing, bus index, channel count, group)
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group AFTER the Ndef's group and attach the proper probe synth.
// Uses setter closures to store references in ~vars (no reflection).
attachAfterNdef = { |info, replyID, setGroupFunc, setSynthFunc, freeOldSynthFunc|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        // free the previous synth if any (quietly)
        freeOldSynthFunc.value;

        s.bind({
            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };
        });

        setGroupFunc.value(grp);
        setSynthFunc.value(synth);

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Ensure our base routing exists WITHOUT clearing your Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy filters/taps
neutralizeInProxyFilters.value;

// Detect chains (prints status)
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes AFTER the Ndef groups (ordering-safe)
attachAfterNdef.value(
    aInfo, 2001,
    { |g| ~md_probeGroupA = g },            // set group
    { |sy| ~md_probeA = sy },               // set synth
    { freeIfPlaying.value(~md_probeA); ~md_probeA = nil }  // free old synth if any
);

attachAfterNdef.value(
    bInfo, 2002,
    { |g| ~md_probeGroupB = g },
    { |sy| ~md_probeB = sy },
    { freeIfPlaying.value(~md_probeB); ~md_probeB = nil }
);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd =====
// MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - For JITLib chains Ndef(\chainA) and Ndef(\chainB), install .filter taps
     that mirror their outputs to private 2ch busses for metering.
   - Attach probes to those busses (replyID 2001 for A, 2002 for B).
   - Provides a removal helper for the taps and busses.

   Style
   - var-first in every block; no non-local returns (^).
   - Uses .filter as you prefer; does not alter chain sound (passes input through).
*/

(
var setupBusTaps, removeBusTaps;

setupBusTaps = {
    var ok, haveA, haveB;

    ok = true;
    haveA = false;
    haveB = false;

    // preflight: Ndefs must exist
    if (Ndef(\chainA).notNil) { haveA = true; } { "Ndef(\\chainA) not found.".postln; };
    if (Ndef(\chainB).notNil) { haveB = true; } { "Ndef(\\chainB) not found.".postln; };

    if (haveA.not and: { haveB.not }) {
        "Neither chainA nor chainB found; nothing to attach.".postln;
    } {
        // free previous busses if any
        if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
        if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

        // allocate new private 2ch busses
        ~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
        ~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

        // install taps using .filter; each tap writes to its bus, then passes input through
        if (haveA) {
            Ndef(\chainA).filter(\mdProbeTapA, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busA.index, outSig);
                outSig
            });
        };
        if (haveB) {
            Ndef(\chainB).filter(\mdProbeTapB, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busB.index, outSig);
                outSig
            });
        };

        // attach probes to those busses
        if (~md_attachProbesAB.notNil) {
            ~md_attachProbesAB.value(
                busA: (if (haveA) { ~md_busA.index } { -1 }),
                busB: (if (haveB) { ~md_busB.index } { -1 })
            );
            ("Attached A bus=" ++ (if (haveA) { ~md_busA.index.asString } { "none" })
             ++ " B bus=" ++ (if (haveB) { ~md_busB.index.asString } { "none" })).postln;
        } {
            "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
        };
    };

    ok;
};

removeBusTaps = {
    var ok;

    ok = true;

    // remove taps if present
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).removeFilter(\mdProbeTapA);
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).removeFilter(\mdProbeTapB);
    };

    // free private busses
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    ok;
};

// ---------- run setup now ----------
setupBusTaps.value;

// Later, to remove taps + free busses:
// removeBusTaps.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optionally Final) probes by BUS INDICES you provide.
   - Leaves the window unchanged; meters switch to A/B once replies arrive.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain bus index (stereo base index)
busB = -1;      // TODO: set to your B chain bus index (stereo base index)
busFinal = -1;  // optional: set to your final mix bus index

ok = true;

// sanity check
if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    } {
        "Final bus not set; skipping.".postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd =====
// MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Fix "sound but meters not moving" by:
     * ensuring OUR routing non-destructively
     * reinstalling receiver
     * auto-attaching A(2001)/B(2002) probes to Ndef buses
     * printing quick status
   - Assumes your chains are Ndef(\chainA) and Ndef(\chainB) and are PLAYING.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, detectBusIndex, aIdx, bIdx, reinstallReceiver, postStatus;

("MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd").postln;
ok = true;

if (~md_ensureRouting.isNil or: { ~md_attachProbesAB.isNil }) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure our bus/groups/probe exist without killing your Ndefs
    ~md_ensureRouting.value;

    // reinstall receiver safely
    reinstallReceiver = {
        var existing;
        existing = OSCdef(\md_levels);
        if (existing.notNil) { existing.free; };
        ~md_levelsById = IdentityDictionary.new;
        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = Main.elapsedTime;

        OSCdef(
            \md_levels,
            { |msg, time, addr, recvPort|
                var nodeId, replyId, count, i, outArray;

                nodeId = 0;
                replyId = 0;
                count = 0;
                i = 0;
                outArray = nil;

                if (msg.size >= 3) {
                    nodeId = msg[1].asInteger;
                    replyId = msg[2].asInteger;
                    count = msg.size - 3;
                    outArray = Array.newClear(count);
                    i = 0;
                    while { i < count } {
                        outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                        i = i + 1;
                    };
                    ~md_levelsById[replyId] = outArray;
                    ~levels = outArray;
                    ~md_lastLevelAt = Main.elapsedTime;
                };
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );

        true;
    };

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid when proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    postStatus = {
        var keys, msg;
        keys = ~md_levelsById.keys.asArray.sort;
        msg = "Active replyIDs: " ++ keys.asString;
        msg.postln;
        if (~md_levelsById[2001].notNil) { ("A: " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B: " ++ ~md_levelsById[2002].asString).postln; };
    };

    reinstallReceiver.value;

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected Ndef buses ‚Üí A=" ++ aIdx.asString ++ "  B=" ++ bIdx.asString).postln;

    // attach probes directly to those buses (skip -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // small delayed status check (allow first /md/levels to arrive)
    AppClock.sched(0.5, {
        postStatus.value;
        nil;
    });
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd =====
// MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Add simple HUD labels inside the existing MagicDisplayGUI A/B window.
   - Top-left anchored, no FlowLayout; read-only labels for the demo.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, win, content, hudTitle, hudA, hudB;

ok = true;

win = ~mdGui_window;

if (win.isNil) {
    "No MagicDisplayGUI window found. Open MagicDisplayGUI_New_Window_AB_v0.3.7.scd first.".postln;
} {
    content = win.view;

    // Title HUD
    hudTitle = StaticText(content, Rect(16, 0, 400, 12));
    hudTitle.string = "HUD: A=replyID 2001 | B=replyID 2002 | fallback=test 1001";
    hudTitle.stringColor = Color.gray(0.8);
    hudTitle.background = Color.clear;
    hudTitle.align = \left;

    // Chain labels (editable here if you want different names)
    hudA = StaticText(content, Rect(16, 24, 200, 12));
    hudA.string = "A: Ndef(\\chainA)";
    hudA.stringColor = Color.gray(0.8);
    hudA.background = Color.clear;
    hudA.align = \left;

    hudB = StaticText(content, Rect(292, 24, 200, 12));
    hudB.string = "B: Ndef(\\chainB)";
    hudB.stringColor = Color.gray(0.8);
    hudB.background = Color.clear;
    hudB.align = \left;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.1.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.1.scd
// v0.3.1
// MD timestamp: 2025-09-25

/* Purpose
   - Fast way to remove GUI, OSC receiver, synths, groups, bus; leave server running clean.
*/

(
var ok;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// Receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Synths
if (~md_testSynth.notNil) { ~md_testSynth.free; ~md_testSynth = nil; };
if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };

// Groups
if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

s.defaultGroup.freeAll;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.5.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Close GUI, free OSC receiver, clear server nodes/bus, and reset state.
   - Silent and idempotent: safe to run multiple times; no 'Node not found' noise.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, hadServer;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// OSC receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Server nodes (only if server running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
}

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// ensure final expression is a simple boolean
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.6.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.6.scd
// v0.3.6
// MD timestamp: 2025-09-25

/* Purpose
   - Close MagicDisplayGUI windows, stop GUI ticker, free OSC receiver.
   - Clear server default group (if running), free private bus, reset state vars.
   - Silent and idempotent; final expression is 'true' (never returns a Window).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, hadServer, windows, i, w, nameString;

ok = true;

// stop GUI ticker if present
if (~mdGui_ticker.notNil) {
    ~mdGui_ticker.stop;
    ~mdGui_ticker = nil;
};

// close any MagicDisplayGUI windows (explicitly; this does not return the window)
windows = Window.allWindows;
i = 0;
while { i < windows.size } {
    w = windows[i];
    nameString = w.name.asString;
    if (nameString.beginsWith("MagicDisplayGUI")) {
        w.close;
    };
    i = i + 1;
};

// free OSC receiver if present
if (OSCdef(\md_levels).notNil) {
    OSCdef(\md_levels).free;
};

// clear server nodes (only if server is running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
};

// free private bus if allocated
if (~md_mixBus.notNil) {
    ~md_mixBus.free;
    ~md_mixBus = nil;
};

// nil any cached node/bus references
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

// final value: simple boolean (prevents '-> a Window')
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot the server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create a private bus, groups, relay-to-hardware and a level probe.
   - Install an OSC receiver bound to '/md/levels' (matches SendReply).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probe reads a private bus; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // Close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // Reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = 0.0;
    ~md_testSynth = nil;
    ~md_probe = nil;
    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // Reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // Test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // Relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // Level probe (2ch fixed) ‚Üí '/md/levels'
    // Message format: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// Install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// Create routing (fresh bus + fresh groups + relay + probe). Clears default group first.
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // Clear any stale nodes from previous runs
        s.defaultGroup.freeAll;

        // Fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // Fresh groups in strict order: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // Relay and probe (safe even without source)
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // No source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    // Always rebuild routing to avoid stale groups after a server reboot
    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // Clean everything (leave server running)
    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  OSC: listening on /md/levels".postln;

    ok;
};

// ---------- Run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
// ~md_ensureRouting.value;
// ~md_reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd
// v0.3.7
// MD 2025-09-25 15:10 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Returns input unchanged (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz;

var windowNote, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        // free old one if present (idempotent reset)
        existing = OSCdef(defName);
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var each;
    each = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    each.value(\chainA, ids[\A]);
    each.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId, ~slotName;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ~md_probeA = ~md_probeA ? { makeOne.value(\chainA, ids[\A]) } !? { ~md_probeA };
    ~md_probeB = ~md_probeB ? { makeOne.value(\chainB, ids[\B]) } !? { ~md_probeB };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
        // leave signal path untouched; if silent they‚Äôll still meter 0.0
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> You can switch to Plan B by calling: ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};
apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:22 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Pass-through (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        existing = OSCdef(defName); // returns nil or the OSCdef
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var installOne;
    installOne = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    installOne.value(\chainA, ids[\A]);
    installOne.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ensureDef.value;
    if(~md_probeA.isNil) { ~md_probeA = makeOne.value(\chainA, ids[\A]) };
    if(~md_probeB.isNil) { ~md_probeB = makeOne.value(\chainB, ids[\B]) };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

// expose helpers as requested
~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> To switch to Plan B later:
//    ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.1.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels‚Ä¶";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views‚Äô bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels‚Ä¶";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views‚Äô bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd
// v0.4.4
// MD 2025-09-25 16:48 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, meterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay, startTicker, stopTicker, tickerFlag;
var identityBanner;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === identity banner (after var-first) ======================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) ‚Äî tweak here to adjust spacing
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;
labelWidth = 84;   // wider, more readable
meterWidth = 360;

// init meter values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, getLevelFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, meterWidth, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD string with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    stepFunc = {
        readLevelsAndUpdateDisplay.value;
        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;
        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// compute total height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + labelWidth + 8 + meterWidth + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=false, border=true -> proper title bar visible
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.4)", windowRect, false, true);

// HUD
hudLabel = StaticText(windowRef, Rect(paddingX, paddingY, labelWidth + 8 + meterWidth, headerHeight));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame area that draws section boxes
meterFrameView = makeFrameView.value(windowRef, Rect(
    paddingX,
    paddingY + headerHeight + rowGap,
    (labelWidth + 8 + meterWidth),
    (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)
));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

// Deterministic Y positions (no dependency on .bounds of other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// Chain A
chainATitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainATitleY, 120, sectionTitleHeight));
chainATitleLabel.string = "Chain A";

chainALabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight));
chainALabelLeft.string = "A-L";
barViewALeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar1Y, { displayALevelLeft });

chainALabelRight = StaticText(windowRef, Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight));
chainALabelRight.string = "A-R";
barViewARight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar2Y, { displayALevelRight });

// Chain B
chainBTitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainBTitleY, 120, sectionTitleHeight));
chainBTitleLabel.string = "Chain B";

chainBLabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight));
chainBLabelLeft.string = "B-L";
barViewBLeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar1Y, { displayBLevelLeft });

chainBLabelRight = StaticText(windowRef, Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight));
chainBLabelRight.string = "B-R";
barViewBRight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar2Y, { displayBLevelRight });

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd
// v0.4.5
// MD 2025-09-25 16:58 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout akin to your previous GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch HORIZONTALLY as you resize.
  (No FlowLayout; manual top-left anchored layout on AppClock.)

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rect metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, minMeterWidth, maxMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics)
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;            // readable label width
minMeterWidth = 260;         // minimum bar width
maxMeterWidth = 900;         // clamp to keep drawing pleasant

// deterministic Y positions (do not depend on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- layout that responds to window width (manual, no FlowLayout) ------------
computeAndApplyLayout = {
    var innerWidth, currentMeterWidth, frameWidth, frameHeight;

    // NOTE: keep vertical metrics fixed; stretch horizontally
    innerWidth = windowRef.bounds.width - (paddingX * 2);
    currentMeterWidth = (innerWidth - (labelWidth + 8)).clip(minMeterWidth, maxMeterWidth);

    frameWidth  = (labelWidth + 8 + currentMeterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, currentMeterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, currentMeterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, currentMeterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, currentMeterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with a reasonable initial width; height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + minMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=true, border=true -> proper title + resizeable window
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.5)", windowRect, true, true);

// HUD label
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10)); // will be set by computeAndApplyLayout
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame + section titles + bars (create; exact bounds set in computeAndApplyLayout)
meterFrameView = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string = "Chain A";
chainALabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string  = "A-L";
barViewALeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelLeft });
chainALabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string = "A-R";
barViewARight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelRight });

chainBTitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string = "Chain B";
chainBLabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string  = "B-L";
barViewBLeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelLeft });
chainBLabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string = "B-R";
barViewBRight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker will keep it current on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd
// v0.4.6
// MD 2025-09-25 17:10 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout similar to yesterday‚Äôs GUI:
  ‚Ä¢ HUD at top-left
  ‚Ä¢ Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  ‚Ä¢ Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch horizontally and ALWAYS fit within the content area
  (no FlowLayout; manual top-left anchored layout on AppClock).

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed vertical metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, defaultMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics; match ‚Äúyesterday‚Äù proportions)
paddingX = 12; paddingY = 10;
rowGap = 10;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;           // readable label width (yesterday‚Äôs GUI was ~72‚Äì100)
defaultMeterWidth = 340;    // comfortable default; will stretch or shrink to fit

// deterministic Y positions (no dependency on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- responsive layout (bars always fit horizontally) -----------------------
computeAndApplyLayout = {
    var interiorWidth, meterWidth, frameWidth, frameHeight;

    // Keep vertical metrics fixed; stretch/shrink horizontally to ALWAYS fit
    interiorWidth = windowRef.bounds.width - (paddingX * 2);
    meterWidth = (interiorWidth - (labelWidth + 8)).max(40); // lower bound only; never off-screen
    frameWidth  = (labelWidth + 8 + meterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, meterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, meterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, meterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, meterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with proportions like yesterday‚Äôs GUI (fits on first open)
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + defaultMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B
    + paddingY
);

// resizable=true, border=true -> proper title + resizable window
windowRef = Window("MagicDisplayGUI ‚Äî Status + A/B Meters (v0.4.6)", windowRect, true, true);

// HUD label (bounds set by computeAndApplyLayout)
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels‚Ä¶";

// Frame + section titles + bars (create once; bounds set in computeAndApplyLayout)
meterFrameView    = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string  = "Chain A";
chainALabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string   = "A-L";
barViewALeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelLeft });
chainALabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string  = "A-R";
barViewARight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelRight });

chainBTitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string  = "Chain B";
chainBLabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string   = "B-L";
barViewBLeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelLeft });
chainBLabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string  = "B-R";
barViewBRight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker keeps it updated on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.10.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.10.scd
// v0.3.10
// MD 2025-09-25 15:48 BST

/*
Purpose
- Single window "MagicDisplayGUI ..." with 4 bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- If A/B are effectively silent, mirror test(1001) into the bars (visual fallback) for the demo.
- HUD top-left; AppClock ticker ~30 Hz; fixed rects; single-window policy.

Style
- var-first in every block; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC API only; final expression -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var dAL=0.0, dAR=0.0, dBL=0.0, dBR=0.0; // displayed values after fallback logic
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;
var fallbackThreshold, uiGamma;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum below this = "effectively zero" for demo
uiGamma = 1.0;               // 1.0 = linear; you can set 0.5 for sqrt visual boost if needed

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.10)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        // optional gamma for low-level visibility (uiGamma <= 1 boosts lows)
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { dAL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { dAR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { dBL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { dBR });

// read levels and compute display values with fallback
readLevels = {
    var a, b, t, sumAB, sumT, txt, showAL, showAR, showBL, showBR;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // Fallback rule: if both A and B effectively zero, mirror test into both A and B displays
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        showAL = tL; showAR = tR;
        showBL = tL; showBR = tR;
    } {
        showAL = aL; showAR = aR;
        showBL = bL; showBR = bR;
    };

    dAL = showAL.clip(0, 1);
    dAR = showAR.clip(0, 1);
    dBL = showBL.clip(0, 1);
    dBR = showBR.clip(0, 1);

    // HUD with finer precision so quiet values are visible
    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.7.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window with FOUR meters:
       A-L, A-R (replyID 2001), B-L, B-R (replyID 2002)
     and fall back to the default test probe (replyID 1001) if A/B not attached.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        labelA, aLeft, aRight, aDbL, aDbR,
        labelB, bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî A/B Window (v0.3.7)";

    window = Window.new(titleString, Rect(60, 60, 560, 260), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // A section
    labelA = StaticText(content, Rect(16, 12, 240, 22));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    // B section
    labelB = StaticText(content, Rect(292, 12, 240, 22));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    barWidth = 26;
    barHeight = 160;

    // A meters
    aLeft  = LevelIndicator(content, Rect(40,  44, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    aLeft.warning = (-6).dbamp; aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(32, 210, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(92, 210, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(316, 44, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(376, 44, barWidth, barHeight));
    bLeft.warning = (-6).dbamp; bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(308, 210, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(368, 210, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age
    statusA = StaticText(content, Rect(180, 44, 100, 18));
    statusA.string = "A rx: ‚Äî";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, 44, 100, 18));
    statusB.string = "B rx: ‚Äî";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // test controls (optional)
    startButton = Button(content, Rect(180, 80, 100, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    stopButton = Button(content, Rect(180, 114, 100, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbL, aDbR, bDbL, bDbR,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbL = ampToDbString.value(aL);
            aDbR = ampToDbString.value(aR);
            bDbL = ampToDbString.value(bL);
            bDbR = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbL; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbR; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbL; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbR; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.8.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:10 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001); B-L, B-R (replyID 2002).
- HUD at top-left; AppClock ticker ~30 Hz; fallback to test (1001) if A/B absent.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).
Style
- var-first; AppClock only; fixed rects (no FlowLayout); no non-local returns.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver, w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = { ~md_levelsById ? IdentityDictionary.new }!(); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var have;
    have = (OSCdef(\md_levels) !? { true }) ? false; // just to probe
    ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } // idempotent
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.8)", rect, false, false);
w.alwaysOnTop_(false);

w.drawFunc = { }; // no background drawing; keep it simple

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// Row helpers
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

makeBars = { arg left, top;
    var v;
    v = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var b, vNorm;
        b = uv.bounds;
        // caller sets a closure to draw current level (0..1)
        vNorm = uv.userCanDraw.value(uv);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm.clip(0,1), b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)));
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)));
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)));
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)));

viewAL.userCanDraw = { arg v; aL };
viewAR.userCanDraw = { arg v; aR };
viewBL.userCanDraw = { arg v; bL };
viewBR.userCanDraw = { arg v; bR };

// read levels (with fallback to test=1001 if A/B missing)
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    // update 4 numbers
    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];

    // HUD line
    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";
    // Fallback annotate if both A/B are zeros but test moves
    if((aL+aR+bL+bR) <= 0.0001 && (t[0]+t[1]) > 0.0, {
        txt = txt ++ "  (fallback: test " ++ t.collect(_.round(0.01)) ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, go;
    period = 1.0 / fps;
    go = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { ticker !? { go.value } });
        nil
    };
    ticker = true;
    AppClock.sched(0.0, { go.value; nil });
};

killTicker = {
    ticker = nil;
};

// clean close
w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.9.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.9.scd
// v0.3.9
// MD 2025-09-25 15:34 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- HUD top-left; AppClock ticker ~30 Hz; fallback shows test(1001) hint if A/B are zero.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).

Style
- var-first in every block; descriptive lowercase names; AppClock only for GUI.
- Known-good SC syntax only; no custom slots on views; no server.sync.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI ‚Äî A/B Meters (v0.3.9)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels‚Ä¶";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, vNorm;
        b = v.bounds;
        vNorm = getLevelFunc.value.clip(0, 1);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { aL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { aR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { bL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { bR });

// read levels from shared dict (set by /md/levels receiver)
// fallback shows test=1001 if both A and B sum to ~0
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";

    if(((aL+aR+bL+bR) <= 0.0001) and: { (tL+tR) > 0.0 }, {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.01), tR.round(0.01)] ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd
// v0.5.0
// MD 2025-09-25 17:35 BST

/*
Purpose
- Performance HUD window for live use (single, resizable "MagicDisplayGUI ..." window).
- Top row: Chain A (left) and Chain B (right) panels.
  * Active chain panel shows a green background (CURRENT inferred from Ndef.isPlaying).
  * Per-chain vertical meters (L/R) at each panel‚Äôs outer edge (A: left; B: right).
- Second row: full-width yellow status box (‚Äúsystem read‚Äù by default).
- Bottom-left: Choices pane (safe: reads CommandManager builder if present).
- Bottom-right: Messages/Next pane (safe: shows md/levels rate & last values; optional queued canonical).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- GUI uses AppClock only; no server.sync; avoids destructive operations.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var borderWidth, minTextWidth, minMeterWidth;
var headerString;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var statusLabel;
var chainAPanel, chainBPanel, chainAMeterView, chainBMeterView;
var choicesTitle, choicesText, messagesTitle, messagesText;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
var makePanelView, makeVerticalMeterView, drawVerticalMeters, setPanelActiveColor, setPanelNeutralColor;
var readLevelsAndUpdate, refreshChoicesFromBuilder, refreshMessages;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;
var identityBanner;

// === console identity (var-first ensured) ====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd";
identityBanner.postln;

// --- constants / state -------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B quiet, mirror test for display continuity (demo-safe)
uiGamma = 1.0;               // 1.0 linear; 0.7..0.5 boosts low levels

// layout metrics (tuned for iPad side-screen; adjust as needed)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 10;

topRowHeight    = 120;       // Chain A/B row height
statusRowHeight = 26;        // yellow status row
bottomRowHeight = 160;       // bottom panes row height
borderWidth     = 1;
minTextWidth    = 180;       // minimal inner text panel width per side
minMeterWidth   = 18;        // slim vertical meter (two bars drawn inside this view)

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;  testLevelRight  = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existing;
    existing = Window.allWindows.select({ arg w;
        var title;
        title = w.tryPerform(\name);
        title.notNil and: { title.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existing.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// simple panel with border whose background we can recolor for "active"
makePanelView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.94,0.94,0.94)); // neutral; greener when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

// slim vertical meter container; draw two vertical bars (L/R)
makeVerticalMeterView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        drawVerticalMeters.value(uv);
    };
    v
};

drawVerticalMeters = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    // A or B values are injected by caller through display* variables
    // Decide which pair to draw by reading a tag on the view name (set below)
    if(uv.name == \metersA) {
        leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    } {
        leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    };

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    // backgrounds
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    // dynamic fills (bottom-up)
    Pen.color = Color(0.20, 0.70, 0.20); // green-ish for visibility
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    // borders
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

setPanelActiveColor = { arg uv;
    uv.background = Color(0.86, 0.97, 0.86); // soft green for "active"
};

setPanelNeutralColor = { arg uv;
    uv.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // demo-safe fallback: if A/B are effectively zero but test is alive, mirror test
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // active chain (CURRENT) visual
    isAActive = Ndef(\chainA).isPlaying; // safe, non-blocking check
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil and: { chainBPanel.notNil }) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // lightweight HUD text
    statusLabel.string = "system read"; // change to "system ready" if you prefer
};

// bottom-left: print current navigation choices if CommandManager is present
refreshChoicesFromBuilder = {
    var haveSystem, cm, builder, lines, text;
    haveSystem = (~system.notNil);
    if(haveSystem.not) {
        text = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = ~system.commandManager;
        builder = (cm.notNil).if({ cm.builder }, { nil });
        if(builder.notNil and: { builder.currentNode.notNil }) {
            lines = builder.currentNode.children.collect({ arg ch;
                ("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString)
            });
            text = "Choices:\n" ++ lines.join("\n");
        } {
            text = "Choices:\n(n/a ‚Äî no builder or no node)";
        };
    };
    choicesText.string = text;
};

// bottom-right: last A/B values + optional canonical ‚Äúnext‚Äù
refreshMessages = {
    var cm, canonicalPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ",R=" ++ chainALevelRight.round(0.01) ++ "]  " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ",R=" ++ chainBLevelRight.round(0.01) ++ "]";
    cm = (~system.notNil).if({ ~system.commandManager }, { nil });
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        canonicalPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesText.string = base ++ "\nNext: " ++ canonicalPath.asString;
    } {
        messagesText.string = base;
    };
};

// --- layout ------------------------------------------------------------------
computeAndApplyLayout = {
    var w, h, contentW, contentH;
    var halfW, meterW, textW, panelY, statusY, bottomY;

    // guard window bounds
    w = windowRef.bounds.width; h = windowRef.bounds.height;
    if((w.isNumber.not) or: { h.isNumber.not }) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (w - (paddingX * 2)).max(320);
        contentH = (h - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + rowGap*3);

        halfW = ((contentW - columnGap) / 2).max(minTextWidth + minMeterWidth + 20);
        meterW = minMeterWidth;                    // fixed slim meter strip
        textW  = (halfW - meterW - 10).max(minTextWidth);

        // y anchors
        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // ---- Chain A (left) ----
        chainAPanel.bounds     = Rect(paddingX, panelY, halfW, topRowHeight);
        chainAMeterView.bounds = Rect(paddingX + 4, panelY + 8, meterW, topRowHeight - 16); // left edge (outer)
        // A text area (inside panel, to the right of meter) ‚Äî if you later want chain text, add a StaticText here.

        // ---- Chain B (right) ----
        chainBPanel.bounds     = Rect(paddingX + halfW + columnGap, panelY, halfW, topRowHeight);
        chainBMeterView.bounds = Rect(paddingX + halfW + columnGap + halfW - 4 - meterW, panelY
===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd
// v0.5.1
// MD 2025-09-25 17:56 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: Chain A (left) and Chain B (right). The ACTIVE one is highlighted (soft green).
  ‚Ä¢ Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width yellow status row with "system ready".
- Bottom-left: Choices pane (safe; reads from ~system.commandManager.builder if present).
- Bottom-right: Messages / Next pane (safe; last A/B values and optional canonical next).
- Non-intrusive: reads /md/levels A=2001 B=2002 (fallback mirrors test=1001 when A/B quiet).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

var chainAPanel, chainBPanel;
var meterViewBetweenA, meterViewBetweenB; // A's meters (at A right edge), B's meters (at B left edge)
var statusLabel;
var choicesTitleLabel, choicesTextView, messagesTitleLabel, messagesTextView;

var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

var makePanelView, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB;
var setPanelActiveColor, setPanelNeutralColor;

var readLevelsAndUpdate, refreshChoicesPane, refreshMessagesPane;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;

var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;               // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (kept steady vertically for predictability on iPad)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight    = 124;       // Chain A/B row height
statusRowHeight = 26;        // "system ready" row
bottomRowHeight = 168;       // bottom panes row height

minPanelTextWidth = 220;     // minimal inner text area width per chain panel
meterStripWidth   = 18;      // width of each slim vertical meter (2 bars drawn inside)
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, rect;
    var panelView;
    panelView = UserView(parent, rect);
    panelView.background_(Color(0.94, 0.94, 0.94)); // neutral; will be greener when active
    panelView.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    panelView
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    statusLabel.string = "system ready";
};

// bottom-left: Choices (safe; optional)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = "Choices:\n" ++ textLines.join($\n);
        } {
            s = "Choices:\n(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// bottom-right: Messages / Next (safe; optional)
refreshMessagesPane = {
    var sysObj, cm, nextPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ", R=" ++ chainALevelRight.round(0.01) ++ "]   " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ", R=" ++ chainBLevelRight.round(0.01) ++ "]";
    sysObj = ~system;
    cm = sysObj.tryPerform(\commandManager);
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        nextPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesTextView.string = base ++ "\nNext: " ++ nextPath.asString;
    } {
        messagesTextView.string = base;
    };
};

// --- layout (always fit; meters between chains) ------------------------------
computeAndApplyLayout = {
    var winBounds, contentW, contentH;
    var halfW, panelY, statusY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;

    winBounds = windowRef.bounds;
    if(winBounds.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (winBounds.width - (paddingX * 2)).max(520);
        contentH = (winBounds.height - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + (rowGap*3));

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // panel bounds
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // meters BETWEEN chains
        meterY = panelY + 8;
        meterH = topRowHeight - 16;

        // A meters at RIGHT edge (inside A panel)
        meterAX = aX + aW - 8 - meterStripWidth;
        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);

        // B meters at LEFT edge (inside B panel)
        meterBX = bX + 8;
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // status row
        statusLabel.bounds = Rect(paddingX, statusY, contentW, statusRowHeight);
        statusLabel.background = Color(1.0, 0.95, 0.6); // yellow

        // bottom panes
        choicesTitleLabel.bounds  = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds    = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        messagesTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        messagesTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates ~5 Hz
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshMessagesPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- bring-up + construct ----------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// start with proportions that fit on first open
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 40,
    paddingY + topRowHeight + rowGap + statusRowHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.1)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// status row
statusLabel = StaticText(windowRef, Rect(0,0,10,10));
statusLabel.stringColor = Color.black;
statusLabel.align = \left;

// bottom row
choicesTitleLabel   = StaticText(windowRef, Rect(0,0,10,10)); choicesTitleLabel.string = "Choices"; choicesTitleLabel.stringColor = Color.black;
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));  choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

messagesTitleLabel  = StaticText(windowRef, Rect(0,0,10,10)); messagesTitleLabel.string = "Messages / Next"; messagesTitleLabel.stringColor = Color.black;
messagesTextView    = TextView(windowRef, Rect(0,0,10,10));  messagesTextView.editable = false; messagesTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd
// v0.5.2
// MD 2025-09-25 18:12 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ...").
- Top row: Chain A (left) and Chain B (right), EACH with a title. The ACTIVE chain is highlighted (soft green).
  ‚Ä¢ Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width "System State" section (title + triple-height yellow panel, text "system ready").
- Bottom-left: "Choices" section (title + text).
- Bottom-right: "Processors" section (title + text; safe placeholder until you point me to the API).
- Non-intrusive: reads /md/levels (A=2001, B=2002); if A/B quiet, mirrors test=1001 for visual continuity.

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + layout metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowTitleHeight, statusRowBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;

// ids + levels + render shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB; // A‚Äôs meters (right edge), B‚Äôs meters (left edge)

// status row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// state values
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitledLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// data + UI refresh
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;

// layout + ticker
var computeAndApplyLayout, lastWidth, lastHeight, startTicker, stopTicker, tickerFlag;

// identity banner
var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;  // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;              // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (steady verticals for iPad mirroring)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight          = 140; // Chain A/B panels
statusRowTitleHeight  = 18;  // "System State" title
statusRowBodyHeight   = 78;  // triple-height yellow body (‚âà3√ó a standard line)
bottomRowHeight       = 180; // Choices + Processors row

minPanelTextWidth = 220;     // min inner width per chain panel
meterStripWidth   = 18;      // slim vertical meter strip
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var titleString;
        titleString = w.tryPerform(\name);
        titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94)); // neutral; turn soft green when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitledLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data + UI refresh -------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback for demo continuity
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // visual active state (CURRENT)
    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // "System State" text (yellow panel)
    systemStateTextView.string = "system ready";
};

// "Choices" (safe placeholder; reads from ~system if present)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// "Processors" (safe placeholder; wire up when you point me to the API)
refreshProcessorsPane = {
    var s;
    // TODO: replace with your chain processor query (e.g., ~system.listProcessors() or similar)
    s = "Processors:\n(A) ‚Ä¶\n(B) ‚Ä¶\n(Provide the method to query each chain‚Äôs processor list and I‚Äôll wire it.)";
    processorsTextView.string = s;
};

// --- layout (titles added; meters between chains; System State 3√ó height) ---
computeAndApplyLayout = {
    var wb, contentW, contentH;
    var halfW, panelY, statusTitleY, statusBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleHeight;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        contentH = (wb.height - (paddingY * 2)).max(
            topRowHeight + rowGap +
            statusRowTitleHeight + statusRowBodyHeight + rowGap +
            bottomRowHeight
        );

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        // y anchors
        panelY       = paddingY;
        statusTitleY = panelY + topRowHeight + rowGap;
        statusBodyY  = statusTitleY + statusRowTitleHeight + 4;
        bottomY      = statusBodyY + statusRowBodyHeight + rowGap;

        // panels A/B
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // titles inside panels (top-left)
        titleHeight = 16;
        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleHeight);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleHeight);

        // meter strips BETWEEN chains (inside panels near center gap)
        meterY = panelY + 8 + titleHeight + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;

        meterAX = aX + aW - 8 - meterStripWidth;          // right edge of A panel
        meterBX = bX + 8;                                  // left edge of B panel

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State section
        systemStateTitleLabel.bounds = Rect(paddingX, statusTitleY, contentW, statusRowTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, statusBodyY, contentW, statusRowBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6); // yellow

        // Bottom panes: Choices (L) and Processors (R)
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates at ~5 Hz for text panes
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshProcessorsPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + statusRowTitleHeight + statusRowBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.2)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel   = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel= makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView  = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd
// v0.5.3
// MD 2025-09-25 18:45 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: "Chain A" (left) and "Chain B" (right). ACTIVE chain highlighted (soft green).
  ‚Ä¢ Vertical meters BETWEEN the chains (right of A, left of B).
- Second row: "System State" title + triple-height yellow panel with "system ready".
- Bottom-left: "Choices" (title + text).
- Bottom-right: "Processors" (title + text placeholder‚Äîwire once you provide API).
- Non-intrusive: reads /md/levels A=2001 B=2002; if A/B quiet, mirrors test=1001 to keep visuals moving.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC/Qt calls only. Final expression returns -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;

// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;

// system row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;

// identity banner
var identityBanner;

// === console identity (var-first ensured) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

fallbackThreshold = 0.003;  // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0;              // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight      = 140;  // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight  = 78;   // ~triple height
bottomRowHeight   = 180;  // Choices + Processors

minPanelTextWidth = 220;
meterStripWidth   = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView; panelView.background = Color(0.86, 0.97, 0.86) };
setPanelNeutralColor = { arg panelView; panelView.background = Color(0.94, 0.94, 0.94) };

// --- data + UI refresh -------------------------------------------------------
/*readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    systemStateTextView.string = "system ready";
};*/

readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // Keep demo visual continuity: mirror test if A/B effectively zero but test alive.
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // ACTIVE tint based on displayed energy (robust when both Ndefs are "playing")
    sumAEnergy = (displayALevelLeft + displayALevelRight);
    sumBEnergy = (displayBLevelLeft + displayBLevelRight);
    epsilon    = 0.001;

    isAActive = (sumAEnergy > sumBEnergy + epsilon);
    isBActive = (sumBEnergy > sumAEnergy + epsilon);

    if(chainAPanel.notNil) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
    };
    if(chainBPanel.notNil) {
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // System State text + last /md/levels age (requires ~md_lastMsgStamp from bring-up)
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string = "system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)";
};


refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

refreshProcessorsPane = {
    var s;
    s = "Processors:\n(A) ‚Ä¶\n(B) ‚Ä¶\n(Provide the method to query each chain‚Äôs processor list; I‚Äôll wire it.)";
    processorsTextView.string = s;
};

// --- layout (GUARDED; never writes nil Rect) ---------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY       = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY      = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        titleH = 16;

        // Panels
        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleH);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleH);

        // Meters between panels
        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth;        // A: right edge
        meterBX = bX + 8;                                // B: left edge

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State
        systemStateTitleLabel.bounds = Rect(paddingX, systemTitleY, contentW, systemTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, systemBodyY, contentW, systemBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6);

        // Bottom row
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ---------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    // Do a first layout AFTER all views exist and the window has bounds.
    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    // Start the periodic step slightly AFTER initial layout to avoid any race.
    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;

            // Re-layout only if size changed AND layout initialized
            if(layoutInitialized) {
                w = windowRef.bounds.width; h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };

            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;

            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = {
    tickerFlag = nil;
};

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.3)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel     = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView       = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView    = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4 copy.scd.txt =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd
// v0.5.4
// MD 2025-09-25 19:15 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
- Top row: "Chain A" (left) and "Chain B" (right). ACTIVE chain highlighted (soft green).
  ‚Ä¢ Vertical meters BETWEEN the chains (right of A, left of B).
- Second row: "System State" title + triple-height yellow panel with "system ready" + last /md/levels age.
- Bottom-left: "Choices" (title + text).
- Bottom-right: "Processors" (title + text via user hook ~md_cmdTextProvider).
- Non-intrusive: reads /md/levels A=2001 B=2002; if A/B quiet, mirrors test=1001 to keep visuals moving.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC/Qt calls only. Final expression returns -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;

// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;

// system row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;

// identity banner
var identityBanner;

// === console identity (var-first ensured) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

fallbackThreshold = 0.003;  // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0;              // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight      = 140;  // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight  = 78;   // ~triple height
bottomRowHeight   = 180;  // Choices + Processors

minPanelTextWidth = 220;
meterStripWidth   = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background_(Color(0.86, 0.97, 0.86));
};

setPanelNeutralColor = { arg panelView;
    panelView.background_(Color(0.94, 0.94, 0.94));
};

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    // Safe fetch helper: returns [0.0, 0.0] unless we have a proper 2-element number array
    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
            .if({ arr }, { [0.0, 0.0] })
    };

    // Ensure levelsDict is a dictionary
    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    // Pull raw pairs safely
    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    // Assign channel values
    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    // Demo-safe fallback: mirror test if A/B effectively zero but test alive
    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // Defensive numeric coercion for energy sums
    sumAEnergy = (
        (displayALevelLeft.isNumber  .if({ displayALevelLeft  }, { 0.0 })) +
        (displayALevelRight.isNumber .if({ displayALevelRight }, { 0.0 }))
    );
    sumBEnergy = (
        (displayBLevelLeft.isNumber  .if({ displayBLevelLeft  }, { 0.0 })) +
        (displayBLevelRight.isNumber .if({ displayBLevelRight }, { 0.0 }))
    );

    epsilon = 0.001;

    // ACTIVE tint (only one side green unless equal within epsilon)
    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
    };
    if(chainBPanel.notNil) {
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // System State with last /md/levels age (requires ~md_lastMsgStamp from bring-up)
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

// "Choices" (safe pull from ~system if present)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

// "Processors" (malleable via user hook ~md_cmdTextProvider)
refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });

    if(providerFunc.notNil) {
        s = providerFunc.value;
    } {
        s = "Processors / Queue:\n"
          ++ "(no provider)\n"
          ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
          ++ "Example (temporary):\n"
          ++ "~md_cmdTextProvider = {\n"
          ++ "  var cm, next;\n"
          ++ "  cm = (~system.tryPerform(\\commandManager));\n"
          ++ "  next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
          ++ "      .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
          ++ "  \"Next: \" ++ next.asString\n"
          ++ "};";
    };

    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ---------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY       = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY      = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        titleH = 16;

        // Panels
        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));

        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        // Meters between panels
        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth;        // A: right edge
        meterBX = bX + 8;                                // B: left edge

        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        // System State
        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));
        systemStateTextView.background_(Color(1.0, 0.95, 0.6));

        // Bottom row
        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));

        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ---------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    // Do a first layout AFTER all views exist and the window has bounds.
    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    // Start the periodic step slightly AFTER initial layout to avoid any race.
    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;

            // Re-layout only if size changed AND layout initialized
            if(layoutInitialized) {
                w = windowRef.bounds.width; h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };

            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;

            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = {
    tickerFlag = nil;
};

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
systemStateTextView.background_(Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel     = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView       = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
choicesTextView.background_(Color(0.97,0.97,0.97));

processorsTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView    = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
processorsTextView.background_(Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd  / v0.5.4-p1 (safe background) / MD 2025-09-28
//
// Purpose
// - Performance HUD window (single, resizable "MagicDisplayGUI ‚Ä¶").
// - Same layout and features as v0.5.4, but with SAFE deferred background color
//   assignment for TextView widgets to avoid 'base_' on nil during early layout.
//
// Style
// - var-first in every block/closure; AppClock-only; no server.sync; known-good SC/Qt calls.
// - Final expression returns -> a Window.

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;
// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;
// system row views
var systemStateTitleLabel, systemStateTextView;
// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;
// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;
var safeSetBackground; // NEW: safe, deferred TextView background setter
// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;
// identity banner
var identityBanner;

// === console identity =========================================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ----------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003; // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0; // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap = 8;
columnGap= 12;
topRowHeight = 140;       // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight = 78;    // ~triple height
bottomRowHeight = 180;    // Choices + Processors
minPanelTextWidth = 220;
meterStripWidth = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0; testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;
isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ----------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

// NEW: safe, deferred setter for TextView backgrounds (prevents 'base_' on nil)
safeSetBackground = { |view, color, delay=0.03|
    AppClock.sched(delay, {
        if(view.notNil and: { view.isClosed.not }) {
            view.background_(color);
        };
        nil
    });
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersA.value(uv) };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersB.value(uv) };
    v
};

setPanelActiveColor  = { arg panelView;  panelView.background_(Color(0.86, 0.97, 0.86)) };
setPanelNeutralColor = { arg panelView;  panelView.background_(Color(0.94, 0.94, 0.94)) };

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
        .if({ arr }, { [0.0, 0.0] })
    };

    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    chainALevelLeft = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft   = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    }{
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    sumAEnergy = ((displayALevelLeft.isNumber.if({ displayALevelLeft }, { 0.0 })) +
                  (displayALevelRight.isNumber.if({ displayALevelRight }, { 0.0 })));
    sumBEnergy = ((displayBLevelLeft.isNumber.if({ displayBLevelLeft }, { 0.0 })) +
                  (displayBLevelRight.isNumber.if({ displayBLevelRight }, { 0.0 })));
    epsilon = 0.001;

    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // System State with last /md/levels age
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a ‚Äî no ~system)";
    }{
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " ‚Üí " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        }{
            s = "(n/a ‚Äî no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });
    if(providerFunc.notNil) {
        s = providerFunc.value;
    }{
        s = "Processors / Queue:\n"
        ++ "(no provider)\n"
        ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
        ++ "Example (temporary):\n"
        ++ "~md_cmdTextProvider = {\n"
        ++ " var cm, next;\n"
        ++ " cm = (~system.tryPerform(\\commandManager));\n"
        ++ " next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
        ++ " .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
        ++ " \"Next: \" ++ next.asString\n"
        ++ "};";
    };
    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ----------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    }{
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW    = (((contentW - columnGap) / 2)).max(minPanelTextWidth + meterStripWidth + 16);
        panelY = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX; aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;
        titleH = 16;

        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));
        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth; // A: right edge
        meterBX = bX + 8; // B: left edge
        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));

        // SAFE: defer TextView background (prevents 'base_' on nil)
        safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));

        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));
        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ----------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;
            if(layoutInitialized) {
                w = windowRef.bounds.width;  h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };
            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;
            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ----------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Initial size (fits on first open)
windowRect = Rect(
  70, 70,
  paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
  paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// Resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI ‚Äî Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
// SAFE: defer initial background too
safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel   = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
safeSetBackground.(choicesTextView,    Color(0.97,0.97,0.97));

processorsTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView   = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
safeSetBackground.(processorsTextView, Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.2.scd =====
// MagicDisplayGUI_New_Window_v0.3.2.scd
// v0.3.2
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call ~md_startTestSource / ~md_stopTestSource.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.5.scd =====
// MagicDisplayGUI_New_Window_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call robust API (~md_startTestSource / ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.5)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;  // auto-heals routing if server rebooted
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_QuickPeek_Levels.scd =====
// MagicDisplayGUI_NewPath_QuickPeek_Levels.scd
// v0.1.0
// MD timestamp: 2025-09-25

/* Purpose
   - Print ~levels a few times to verify updates.
   - No top-level 'var'; local vars are inside the Routine function.

   Style
   - var-first inside the Routine; no non-local returns (^).
*/

~md_levelsPeek = Routine({
    var i;
    i = 0;
    12.do {
        ("~levels now: " ++ ~levels.asString).postln;
        0.25.wait;
    };
}).play(AppClock);

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd =====
// MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd
// v0.2.2
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall the /reply receiver for level updates with explicit recvPort.
   - Keep updating ~levels and record a heartbeat time (~md_lastLevelAt) for GUI status.
   - Non-invasive: does not touch groups/synths/busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; known-good SC syntax.
*/

(
var reinstallReceiver;

reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var tag, count, i, outArray;

            tag = msg[2];
            count = 0;
            i = 0;
            outArray = nil;

            if (tag == "/md/levels") {
                count = msg.size - 3;
                outArray = Array.newClear(count);
                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };
                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/reply',
        recvPort: NetAddr.langPort  // explicit
    );

    true;
};

"Reinstalling /reply receiver...".postln;
reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd =====
// MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd
// v0.2.4
// MD timestamp: 2025-09-25

/* Purpose
   - Bind OSC receiver to '/md/levels' (matches SendReply in the probe SynthDef).
   - Parse values at indices 3..end and update ~levels and ~md_lastLevelAt.
   - No top-level 'var' declarations to avoid parse errors.

   Style
   - var-first inside function bodies; no non-local returns (^).
   - descriptive lowercase variable names; known-good SC syntax.
*/

(
// remove any previous receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = Main.elapsedTime;

// Expected message from SendReply:
// [ '/md/levels', nodeID, replyID, val1, val2, ... ]
OSCdef(
    \md_levels,
    { |msg, time, addr, recvPort|
        var nodeId, replyId, count, i, outArray;

        nodeId = 0;
        replyId = 0;
        count = 0;
        i = 0;
        outArray = nil;

        if (msg.size >= 3) {
            nodeId = msg[1].asInteger;
            replyId = msg[2].asInteger;

            count = msg.size - 3;
            outArray = Array.newClear(count);

            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };

            ~levels = outArray;
            ~md_lastLevelAt = Main.elapsedTime;
        };
    },
    '/md/levels',
    recvPort: NetAddr.langPort
);
"Patch C installed: listening on /md/levels".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd =====
// MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd
// v0.2.1
// MD timestamp: 2025-09-25
/* Purpose
   - Cleanly (re)initialize the audio server tree, build a generated-only test signal path,
     and install a level probe that reports channel levels via /reply.
   - Publish public tilde helpers (~md_startTestSource, ~md_stopTestSource, ~md_cleanup) for GUI use.
   - Use compile-time channel counts (2ch) in SynthDefs.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; no server.sync; server ops wrapped in s.bind where relevant.
   - generated audio only; probe reads a private bus.
*/

(
var prepareServerAndDefs, setupRouting, installOscReceiver, definePublicAPI, startStartupSequence;

prepareServerAndDefs = {
    var ok;
    ok = true;

    s.waitForBoot({
        var def_testSource, def_toHardware2, def_levelProbe2;

        s.initTree;
        s.defaultGroup.freeAll;

        ~levels = [0.0, 0.0];

        // Test source: stereo beeps
        def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.20|
            var trig, freqSeq, sig, env, stereo;
            trig = Impulse.kr(2);
            freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
            env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
            sig = SinOsc.ar(freqSeq) * env;
            stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
            Out.ar(outBus, stereo * amp);
        }).add;

        // Relay to hardware (fixed 2ch)
        def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
            var sig;
            sig = In.ar(inBus, 2);
            Out.ar(0, sig);
        }).add;

        // Level probe (fixed 2ch) ‚Üí /reply
        def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, sendID = 1001|
            var sig, amps, ticker;
            sig = In.ar(inBus, 2);
            amps = Amplitude.kr(sig, 0.01, 0.30);
            ticker = Impulse.kr(20);
            SendReply.kr(ticker, "/md/levels", amps, sendID);
        }).add;
    });

    ok;
};

setupRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        ~md_mixBus = Bus.audio(s, 2);

        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \sendID, 1001]);

        ~md_testSynth = nil;
    });

    ok;
};

installOscReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];

    OSCdef(\md_levels, { |msg, time, addr, recvPort|
        var tag, count, i, outArray;

        tag = msg[2];
        count = 0;
        i = 0;
        outArray = nil;

        if (tag == "/md/levels") {
            count = msg.size - 3;
            outArray = Array.newClear(count);
            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };
            ~levels = outArray;
        };
    }, '/reply');

    true;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_startTestSource = {
        var ok2;
        ok2 = true;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.20]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        if (~md_probe.notNil) {
            ~md_probe.free;
            ~md_probe = nil;
        };

        if (~md_toHardware.notNil) {
            ~md_toHardware.free;
            ~md_toHardware = nil;
        };

        if (~md_outGroup.notNil) {
            ~md_outGroup.free;
            ~md_outGroup = nil;
        };
        if (~md_meterGroup.notNil) {
            ~md_meterGroup.free;
            ~md_meterGroup = nil;
        };
        if (~md_srcGroup.notNil) {
            ~md_srcGroup.free;
            ~md_srcGroup = nil;
        };

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        s.defaultGroup.freeAll;

        ok2;
    };

    ok;
};

startStartupSequence = {
    var ok;

    ok = true;

    "Step 1: preparing server + defs...".postln;
    prepareServerAndDefs.value;

    "Step 1: setting up routing (bus, groups, probe)...".postln;
    setupRouting.value;

    "Step 1: installing OSC receiver...".postln;
    installOscReceiver.value;

    // ‚úÖ Publish the API so Step 2 can call it
    "Step 1: defining public API...".postln;
    definePublicAPI.value;

    "Step 1: ready. Use ~md_startTestSource.value to begin audio.".postln;

    ok;
};

// ---------- run ----------
startStartupSequence.value;

// Tips:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd =====
// MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd
// v0.2.3
// MD timestamp: 2025-09-25

/* Purpose
   - Add a status label showing seconds since last level message ('rx age').
   - Helps confirm receiver is live.

   Style
   - var-first inside function bodies; no non-local returns (^).
*/

(
if (~mdGui_window.notNil) {
    var content, statusLabel;

    content = ~mdGui_window.view;

    statusLabel = StaticText(content, Rect(200, 120, 180, 18));
    statusLabel.string = "rx age: ‚Äî";
    statusLabel.stringColor = Color.gray(0.85);
    statusLabel.background = Color.clear;
    statusLabel.align = \left;

    ~mdGui_status = statusLabel;

    // start an AppClock updater (store it so we can stop later)
    ~mdGui_statusTicker = Routine({
        var running, age, lastAt;

        running = true;
        while { running } {
            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_status.notNil) {
                ~mdGui_status.string = "rx age: " ++ age.asString ++ " s";
            };

            0.2.yield;
            running = (~mdGui_window.notNil);
        };
    }).play(AppClock);

    "Status label installed.".postln;
} {
    "Open the MagicDisplayGUI window first, then run this patch.".postln;
};
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd =====
// MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd
// v0.2.0
// MD timestamp: 2025-09-25
/* Purpose
   - Build a robust single-window GUI that follows the window patterns you used in MagicPedalboard-WindowDisplayExamples:
     * one window whose name starts with "MagicDisplayGUI"
     * no FlowLayout
     * AppClock-only refresh loop
     * LevelIndicators for meters
   - Buttons call the public Step 1 tilde helpers (~md_startTestSource, ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; LevelIndicator values in [0..1].
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString, levelLeft, levelRight, labelLeft, labelRight, labelTitle, buttonRowY, startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Path (Step 2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // title
    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    // level bars
    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    // db readouts
    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    // control buttons (call Step 1 helpers if present)
    buttonRowY = 44;

    startButton = Button(content, Rect(200, buttonRowY, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, buttonRowY + 36, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    // store references for the ticker
    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30; // ~30 Hz

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) {
                ~mdGui_levelLeft.value = leftVal;
            };
            if (~mdGui_levelRight.notNil) {
                ~mdGui_levelRight.value = rightVal;
            };
            if (~mdGui_labelLeft.notNil) {
                ~mdGui_labelLeft.string = leftDb;
            };
            if (~mdGui_labelRight.notNil) {
                ~mdGui_labelRight.string = rightDb;
            };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) {
        ~mdGui_window.close;
        ~mdGui_window = nil;
    };
    ok;
};

// ---------- run ----------
mdGuiOpen.value;

// Later: mdGuiClose.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd =====
// MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Trace /md/levels briefly and then print active replyIDs with current values.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^).
*/

(
var postStatus;

"=== RUN MagicDisplayGUI_OSC_TraceAndReport_v0.3.11 ===".postln;

postStatus = {
    var keys, msg;
    keys = if (~md_levelsById.notNil) { ~md_levelsById.keys.asArray.sort } { [] };
    msg = "Active replyIDs: " ++ keys.asString;
    msg.postln;
    if (~md_levelsById.notNil) {
        if (~md_levelsById[2001].notNil) { ("A (2001): " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B (2002): " ++ ~md_levelsById[2002].asString).postln; };
        if (~md_levelsById[1001].notNil) { ("Test (1001): " ++ ~md_levelsById[1001].asString).postln; };
    };
};

OSCFunc.trace(true);
AppClock.sched(1.0, {
    var ok;
    ok = true;
    OSCFunc.trace(false);
    postStatus.value;
    ok;
});
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd =====
// MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Replace ~md_ensureRouting with a NON-DESTRUCTIVE version:
     * does NOT call s.defaultGroup.freeAll
     * only creates/repairs OUR groups/bus/probes if missing or not playing
   - Keeps your Ndefs and any other nodes intact.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var safeEnsure;

("MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd").postln;

safeEnsure = {
    var ok, needBus, needGroups, needRelay, needProbe, defaultGroup;

    ok = true;

    if (s.serverRunning.not) {
        s.boot;
        s.waitForBoot({
            var ok2;
            ok2 = true;
            s.initTree;
            ok2;
        });
    };

    defaultGroup = s.defaultGroup;

    // bus
    needBus = (~md_mixBus.isNil);

    // groups
    needGroups = (
        ~md_srcGroup.isNil or: { ~md_meterGroup.isNil } or: { ~md_outGroup.isNil } or: {
            (~md_srcGroup.notNil and: { ~md_srcGroup.isPlaying.not })
            or: (~md_meterGroup.notNil and: { ~md_meterGroup.isPlaying.not })
            or: (~md_outGroup.notNil and: { ~md_outGroup.isPlaying.not })
        }
    );

    // relay + default probe
    needRelay = (~md_toHardware.isNil or: { ~md_toHardware.isPlaying.not });
    needProbe = (~md_probe.isNil or: { ~md_probe.isPlaying.not });

    s.bind({
        // bus
        if (needBus) {
            if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };
            ~md_mixBus = Bus.audio(s, 2);
        };

        // groups in strict order
        if (needGroups) {
            if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
            if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
            if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

            ~md_srcGroup = Group.head(defaultGroup);
            ~md_meterGroup = Group.after(~md_srcGroup);
            ~md_outGroup = Group.after(~md_meterGroup);

            // force re-create relay/probe after new groups
            needRelay = true;
            needProbe = true;
        };

        if (needRelay) {
            if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };
            ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        };

        if (needProbe) {
            if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
            ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);
        };
    });

    ok;
};

// replace the old ensure with the safe one
~md_ensureRouting = {
    var ok;
    ok = true;
    safeEnsure.value;
    ok;
};

"Patched ~md_ensureRouting to be non-destructive.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd =====
// MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd
// v0.3.12
// MD timestamp: 2025-09-25

/* Purpose
   - Install .filter meters *inside* Ndef(\chainA) and Ndef(\chainB):
       * compute Amplitude.kr on the proxy signal
       * SendReply.kr directly to '/md/levels' with replyIDs 2001/2002
       * return the input signal unchanged (no audio change)
   - Neutralize any previous tap filters (bus mirroring) by overwriting them to identity.
   - Free any old external probe synths/busses used for taps; they are no longer needed.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables; known-good SC syntax.
*/

(
var hasA, hasB, attackTime, releaseTime, updateRateHz,
    installMeterFor, neutralizeTap, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_FilterMeters_v0.3.12 ===".postln;

hasA = (Ndef(\chainA).notNil);
hasB = (Ndef(\chainB).notNil);

attackTime = 0.01;
releaseTime = 0.30;
updateRateHz = 20;

// overwrite old bus-mirror taps to identity (safe if they don't exist)
neutralizeTap = { |name, key|
    var proxy, canFilter;
    proxy = Ndef(name);
    canFilter = false;
    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|  // identity pass-through
                var outSig;
                outSig = inputSig;
                outSig
            });
        };
    };
};

// install the actual meter filter (no bus, direct SendReply)
installMeterFor = { |name, replyID, key|
    var proxy, canFilter, ok;
    proxy = Ndef(name);
    canFilter = false;
    ok = true;

    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|
                var amps, ticker, outSig;
                amps = Amplitude.kr(inputSig, attackTime, releaseTime);
                ticker = Impulse.kr(updateRateHz);
                SendReply.kr(ticker, "/md/levels", amps, replyID);
                outSig = inputSig; // no audio change
                outSig
            });
            (("Installed meter on " ++ name.asString) ++ " (replyID " ++ replyID.asString ++ ").").postln;
        } {
            (name.asString ++ ": .filter not supported; skipped.").postln;
        };
    } {
        (name.asString ++ " not found; skipped.").postln;
    };

    ok;
};

// neutralize any prior tap keys used before (safe no-ops if absent)
neutralizeTap.value(\chainA, \mdProbeTapA);
neutralizeTap.value(\chainB, \mdProbeTapB);

// install in-proxy meters (distinct keys so they are idempotent)
if (hasA) { installMeterFor.value(\chainA, 2001, \mdMeterA); };
if (hasB) { installMeterFor.value(\chainB, 2002, \mdMeterB); };

// free old external probe synths/busses (from the tap approach)
freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

freeIfPlaying.value(~md_probeA);  ~md_probeA = nil;
freeIfPlaying.value(~md_probeB);  ~md_probeB = nil;

if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

"Installed in-proxy meters; removed external probes/tap busses.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.10.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Make A/B meters move reliably by reinstating .filter taps on Ndef(\chainA/\chainB).
   - Mirror audio to private stereo busses, then attach A(2001)/B(2002) probes to those busses.
   - Non-destructive: does not modify chain sound; taps return 'in'.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, haveA, haveB, tapBusA, tapBusB;

("MagicDisplayGUI_Reenable_Taps_v0.3.10.scd").postln;

ok = true;
haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

// (re)allocate private tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// install/overwrite taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes to tap busses (free stale ones first)
s.bind({
    if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
    if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
    };
});

("A probe -> inBus " ++ tapBusA.asString).postln;
("B probe -> inBus " ++ tapBusB.asString).postln;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.11.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall .filter taps on Ndef(\chainA/\chainB) to mirror audio to private 2ch busses.
   - Attach probes A(2001) and B(2002) to those busses.
   - Quiet stale frees; print nodeIDs of created probes.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables.
*/

(
var haveA, haveB, tapBusA, tapBusB, newProbeA, newProbeB, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_Taps_v0.3.11 ===".postln;

haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

// fresh tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// (re)install taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes (free stale ones only if playing)
s.bind({
    freeIfPlaying.value(~md_probeA);
    ~md_probeA = nil;

    freeIfPlaying.value(~md_probeB);
    ~md_probeB = nil;

    newProbeA = nil;
    newProbeB = nil;

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
        newProbeA = ~md_probeA;
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
        newProbeB = ~md_probeB;
    };
});

if (newProbeA.notNil) { ("A probe nodeID: " ++ newProbeA.nodeID.asString).postln; } { "A probe not created.".postln; };
if (newProbeB.notNil) { ("B probe nodeID: " ++ newProbeB.nodeID.asString).postln; } { "B probe not created.".postln; };

"Re-enable taps: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_ResetReceiver_v0.3.11.scd =====
// MagicDisplayGUI_ResetReceiver_v0.3.11.scd
// v0.3.11
// MD 2025-09-25 15:10 BST

/*
Purpose
- Reinstall the /md/levels receiver on NetAddr.langPort (idempotent).
- Posts identity banner so logs show exact order of actions.
Style
- var-first; no server.sync; returns -> true.
*/

(
// === RUN ===
var ok, dict;
dict = (~md_levelsById ? IdentityDictionary.new);
~md_levelsById = dict;
ok = ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } ? false;
("Receiver reset: " ++ ok).postln;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd
// v0.3.8
// MD timestamp: 2025-09-25
/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if playing).
   - Attach A (replyID 2001) and B (replyID 2002) probes directly to those busses.
   - Remove previously-installed .filter taps and free their private busses (if present).
   - Non-invasive: does not change your chain sound.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var detectBusIndex, aIdx, bIdx, ok, hadBringUp;

ok = true;
hadBringUp = (~md_attachProbesAB.notNil);

if (hadBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid if the proxy has produced output (ideally playing)
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // attach probes directly to A/B buses (even if one is -1, the helper skips it)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // remove taps if they exist (safe if none present)
    if (Ndef(\chainA).notNil) { Ndef(\chainA).removeFilter(\mdProbeTapA); };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).removeFilter(\mdProbeTapB); };

    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps removed (if present).".postln;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd
// v0.3.9
// MD timestamp: 2025-09-25

/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if present).
   - Ensure routing (bus/groups) exists even after a server reboot.
   - Attach A (2001) and B (2002) probes directly to those busses.
   - Neutralize any prior .filter taps (identity pass-through) and free their private busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, haveBringUp, detectBusIndex, aIdx, bIdx, neutralizeTap;

ok = true;
haveBringUp = (~md_attachProbesAB.notNil);

if (haveBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure routing exists (rebuilds groups/bus/probe if server rebooted)
    ~md_ensureRouting.value;

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus;   // valid when the proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    neutralizeTap = { |name, key|
        var proxy, canFilter;
        proxy = Ndef(name);
        canFilter = false;
        if (proxy.notNil) {
            canFilter = proxy.respondsTo(\filter);
            if (canFilter) {
                // Overwrite any existing tap with identity to stop extra Out.ar
                proxy.filter(key, { |in| in });
            };
        };
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // Attach probes directly (skips -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // Neutralize taps (works in all versions; no removeFilter needed)
    neutralizeTap.value(\chainA, \mdProbeTapA);
    neutralizeTap.value(\chainB, \mdProbeTapB);

    // Free the private tap busses if they exist
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps neutralized and tap busses freed.".postln;
};

ok;
)

===== MagicPedalboard/utils_mpb_force_reconnect.scd =====
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)

===== MagicPedalboard/WindowDisplayExamples/examplesSlidersButtons.scd =====
// examplesSlidersButtons.scd
// taken from Eli Fieldsteel book examples for chatper 8.

(
Window("Layout Management", Rect(100, 100, 250, 500)).front
.layout_(
	VLayout(
		HLayout(Knob(), Knob(), Knob(), Knob()),
		HLayout(Slider(), Slider(), Slider(), Slider()),
		Slider2D(),
		Button()
	)
);
)
===== MagicPedalboard/WindowDisplayExamples/SC_GUI_Meters_Summary_v1_0.sc =====
/*
SuperCollider GUI + Meters: Working Pattern & Pitfalls
v1.0
MD 2025-09-25 10:27

============================================================

‚úÖ WHAT MAKES THIS WORK

1) Separate GUI from Audio Boot
   - Build the window and layout first so something is visible immediately.
   - Use s.waitForBoot Ellipsis or a Routine for audio bring‚Äëup; never block the AppClock.
   - Avoid server.sync in GUI paths to prevent freezes and blank windows.

2) Use Layout Managers for Predictability
   - Prefer GridLayout or VLayout/HLayout so panes resize reliably.
   - Avoid manual Rect math unless you need pixel‚Äëperfect control.

3) Draw Borders with UserView.drawFunc
   - CompositeView does not implement drawFunc_.
   - Create a UserView inside the pane to draw colored borders/fills.

4) Var‚Äëfirst and Descriptive Names
   - Declare all locals at the top of every block (functions, drawFunc, actions).
   - No single‚Äëletter variables; use paneView, meterColumnView, amplitudeBusA, etc.
   - This prevents parser errors like ‚Äúunexpected VAR‚Äù.

5) Atomic Server Operations
   - If you rewire NodeProxies, wrap changes in Server.default.bind Ellipsis.
   - Keep GUI responsive by avoiding synchronous waits.

6) Smooth, Click‚Äëfree Level Changes
   - Apply Lag.kr to amplitude controls before multiplying the audio signal.
   - Update LevelIndicator values on AppClock and defer GUI writes with Ellipsis.defer.

7) Clean Meter Updates
   - Use control buses for metering (Out.kr), and read them with .get on AppClock.
   - Always .defer updates to the actual GUI widgets.

8) Deterministic Cleanup
   - In window.onClose_, stop routines, free buses, and stop+clear Ndefs.
   - Also close any previous MagicDisplayGUI windows on start.

------------------------------------------------------------

‚ö†Ô∏è COMMON PITFALLS

‚Ä¢ drawFunc_ on CompositeView has no effect ‚Üí use UserView.
‚Ä¢ Multiple assignment to array elements (e.g., #array[i], ‚Ä¶ = ...) is invalid ‚Üí assign to locals first, then store.
‚Ä¢ server.sync in GUI code blocks the AppClock ‚Üí freezes or blank windows.
‚Ä¢ Non‚Äëvar‚Äëfirst blocks ‚Üí ‚Äúunexpected VAR, expecting ‚Ä¶‚Äù parse errors.
‚Ä¢ Updating widgets directly from audio/server callbacks ‚Üí must .defer GUI writes.
‚Ä¢ Leaving old Ndefs and buses running ‚Üí audio chaos and resource leaks on re‚Äërun.
‚Ä¢ Hard‚Äëcoded sizes on HiDPI/Sidecar ‚Üí panes appear tiny; layouts fix scaling.

------------------------------------------------------------

üîç EASY‚ÄëTO‚ÄëOVERLOOK DETAILS

‚Ä¢ Close prior MagicDisplayGUI windows before building a new one.
‚Ä¢ Free control buses used for meters in onClose_.
‚Ä¢ Convert dB ‚Üí linear with .dbamp and clamp to [0, 1] for LevelIndicator.
‚Ä¢ Give LevelIndicator a minSize_ (e.g., Size(20, 180)) so layouts don‚Äôt collapse it.
‚Ä¢ Add small spacers (UserView().minWidth_/minHeight_) in H/V layouts for readable gaps.
‚Ä¢ If GUI must appear even when audio fails, build the window first, then boot server.

------------------------------------------------------------

‚û°Ô∏è UPGRADE PATH / NEXT STEPS

1) Keep the proven GUI skeleton (GridLayout or V/HLayout) and slot in top‚Äërow meters.
2) Add one audible Ndef test source; meter its amplitude via a control bus.
3) Layer routing gradually:
   - one source ‚Üí one effect ‚Üí one sink;
   - then two sinks with A/B selection (use Lag/XFade2 to avoid clicks);
   - finally expand to 3 sources, 3 effects, 2 sinks, preserving the GUI contract.
4) Only after routing is stable, attach real meters to each chain point as needed.

------------------------------------------------------------

CHEAT SHEET (DO / AVOID)

DO
- window first; audio later (non‚Äëblocking).
- UserView.drawFunc for borders and custom visuals.
- var‚Äëfirst, descriptive names everywhere.
- AppClock for GUI updates, with .defer inside callbacks.
- Lag.kr for level changes; XFade2 + Lag for A/B.
- onClose_: stop routines, free buses, clear Ndefs.

AVOID
- server.sync in any GUI path.
- drawFunc_ on CompositeView.
- Multiple assignment to array elements.
- Single‚Äëletter variable names; hidden locals mid‚Äëblock.
- Direct GUI writes from non‚ÄëGUI threads.

============================================================
*/
===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes in GridLayout (3x2); top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, p;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

p = Array.newClear(6);

// ---------- factories ----------
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView();
    textColumn.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    pane
};

// ---------- build six panes (index 0 gets the meter) ----------
p[0] = makePaneWithMeter.(paneTitles[0], paneColors[0]); // top-left with meter
p[1] = makePane.(paneTitles[1], paneColors[1]);
p[2] = makePane.(paneTitles[2], paneColors[2]);
p[3] = makePane.(paneTitles[3], paneColors[3]);
p[4] = makePane.(paneTitles[4], paneColors[4]);
p[5] = makePane.(paneTitles[5], paneColors[5]);

// ---------- install grid 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with GridLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, paneArray;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build six panes ----------
paneArray = Array.newClear(6);
paneArray[0] = makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A); // top-left with meter A
paneArray[1] = makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B); // top-right with meter B
paneArray[2] = makeTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = makeTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = makeTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = makeTextPane.(paneTitles[5], paneBorderColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with two meters in the top row.
// - Meter A (top-left) is real (Ndef test source -> control bus); Meter B (top-right) is simulated.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterRoutine, serverBootRoutine;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI Grid + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build 3x2 grid: top row has meters ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"); // top-left real
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B"); // top-right simulated
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with 2 meters in the top row.
// - Audible test source (Ndef) plays; its amplitude steps in 10 dB increments every second.
// - Meters A and B both follow the same stepped level.
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0];
stepIntervalSeconds = 1.0;

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- assemble grid (top row has meters) ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A");
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B");
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- AUDIO bring-up (audible Ndef + stepped amplitude) ----------
serverBringUpRoutine = Routine({
    s.waitForBoot({
        var defaultNumChannels, leftFrequency, rightFrequency;
        defaultNumChannels = 2;
        s.initTree; s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\stepToneA, {
            var stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20, 20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30, 30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // smooth the steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            monoSignal    = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP meters + audible amplitude ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);

        { if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
          if(meterViewB.notNil, { meterViewB.value_(currentLinear) }); }.defer;

        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters.scd
// v0.3.1
// MD 2025-09-25 14:20
//
// Purpose / Style:
// - GUI-only: 6 panes in a GridLayout (3x2).
// - Top-left and top-right contain simulated meters (no audio).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makeTextPane, makeMeterPane, p;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

// returns [pane, meterView]
makeMeterPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    [pane, meterView]
};

// ---------- build six panes ----------
p = Array.newClear(6);
var pane, m;

#pane, m = makeMeterPane.(paneTitles[0], paneColors[0]); p[0] = pane; meterViewA = m; // top-left
#pane, m = makeMeterPane.(paneTitles[1], paneColors[1]); p[1] = pane; meterViewB = m; // top-right
p[2] = makeTextPane.(paneTitles[2], paneColors[2]);
p[3] = makeTextPane.(paneTitles[3], paneColors[3]);
p[4] = makeTextPane.(paneTitles[4], paneColors[4]);
p[5] = makeTextPane.(paneTitles[5], paneColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valA) });
            if(meterViewB.notNil, { meterViewB.value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_Grid.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_Grid.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: six colored panes arranged with GridLayout (3 rows x 2 columns).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles, makePane;
var p = Array.newClear(6);

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes GridLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

// ---------- styles ----------
titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView().background_(paneFill).minSize_(Size(500, 230));
    border = UserView(pane).resize_(1).drawFunc_({ |v|
        var rect; rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11,0.11,0.12); Pen.strokeColor = borderColor; Pen.width = 2;
        Pen.fillRect(rect); Pen.strokeRect(rect);
    });
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    pane.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane
};

// ---------- build array of six panes ----------
6.do({ |i| p[i] = makePane.(paneTitles[i], paneColors[i]) });

// ---------- grid layout: 3 rows √ó 2 columns ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));

window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_VH.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_VH.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: draw 6 "pane" rectangles (colored borders) arranged with VLayout/HLayout.
// - No audio, no Ndefs, no server. Pure Qt layout.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, row1, row2, row3, rootLayout;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes VHLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill  = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

// six distinct colors and titles
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory: a container with colored border and two text lines ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView()  // no parent yet; layout will parent it
        .background_(paneFill)
        .minSize_(Size(500, 230)); // give layout something decent to work with

    border = UserView(pane)
        .resize_(1)
        .drawFunc_({ |v|
            var rect;
            rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
            Pen.fillColor = Color(0.11, 0.11, 0.12);
            Pen.strokeColor = borderColor;
            Pen.width = 2;
            Pen.fillRect(rect);
            Pen.strokeRect(rect);
        });

    titleText = StaticText()
        .string_(titleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyText = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    // inner stack inside each pane (title above body)
    pane.layout_(VLayout(
        // top margin shim
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        // bottom stretch
        nil
    ));

    pane
};

// ---------- build six panes ----------
row1 = HLayout(
    makePane.(paneTitles[0], paneColors[0]),
    UserView().minWidth_(cellPadding), // spacer
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout: 3 rows stacked, with vertical spacers ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding), // top margin
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)  // bottom margin
);

// install the layout on the window
window.layout_(rootLayout);
window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter on the right side
makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left uses the meter) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0]), // top-left with meter
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        // simple sine-driven value with a hint of noise, clipped to [0,1]
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, rowTop, rowMiddle, rowBottom, rootLayout;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B (decides which global meterView to write)
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A), // top-left
    UserView().minWidth_(cellPadding),
    makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B)  // top-right
);

rowMiddle = HLayout(
    makeTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    makeTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with two meters in the top row.
// - Meter A (top-left) shows a real level from a tiny Ndef test source.
// - Meter B (top-right) is simulated (sine + noise) to verify GUI update path.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterRoutine;           // GUI meter widgets + updater
var serverBootRoutine;                               // guard: keep GUI responsive
var amplitudeBusA;                                   // control bus for real meter A
var meterLabelFont;                                  // tiny label above meters

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VH + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    paneView.layout_(VLayout(
        UserView().minHeight_(6),
        textColumnView,
        nil
    ));

    paneView
};

// Pane with meter and label (labelTextString = "A" or "B")
// Returns: the pane view; assigns meterViewA/meterViewB internally
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    meterLabelView = StaticText()
        .string_(labelTextString)
        .font_(meterLabelFont)
        .stringColor_(Color.white)
        .align_(\center);

    localMeterView = LevelIndicator()
        .warning_(0.7)
        .critical_(0.95)
        .minSize_(Size(20, 180));

    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });

    meterColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(4),
        meterLabelView,
        UserView().minHeight_(4),
        localMeterView,
        nil
    ));

    paneView.layout_(HLayout(
        UserView().minWidth_(6),
        textColumnView,
        UserView().minWidth_(10),
        meterColumnView,
        UserView().minWidth_(6)
    ));

    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"), // top-left: meter A (real)
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")  // top-right: meter B (simulated)
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);

window.layout_(rootLayout);
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    // 1) Boot + minimal server prep
    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        // 2) Control bus for meter A
        amplitudeBusA = Bus.control(s, 1);

        // 3) Tiny test source -> real meter A (no OutputProxy indexing; no server.sync)
        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue;
            var meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);   // language sets this before/around play
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        // set meter bus, then play quietly to out
        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    // 4) Update both meters on AppClock (A from control bus, B simulated)
    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            // real meter A (read from control bus written by Ndef)
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            // simulated meter B (sine + noise)
            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with 2 meters in the top row.
// - Audible test source (Ndef) plays a soft stereo tone whose amplitude
//   steps through dB values once per second (default: [-60,-50,...,0] dB).
// - Meters A and B show the same stepped level (so you hear the same step).
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0]; // edit as you like
stepIntervalSeconds = 1.0;                                // 1 second per step

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Pane with labeled meter ("A" or "B"); assigns to meterViewA / meterViewB
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top has two meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"),
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- AUDIO bring-up (small audible Ndef + AMP stepping) ----------
serverBringUpRoutine = Routine({
    var defaultNumChannels;
    s.waitForBoot({
        defaultNumChannels = 2;
        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        // Test source with controlled amplitude (stepped)
        Ndef(\stepToneA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            // slow-moving, gentle timbre
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // prevent clicks on level steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            // drive a meter bus so GUI can also poll (optional)
            monoSignal   = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP both meters + audible level every 1s ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);     // e.g. -60 .. 0 dB
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);     // convert to 0..1

        // update meters
        {
            if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
            if(meterViewB.notNil, { meterViewB.value_(currentLinear) });
        }.defer;

        // update audible amplitude
        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters.scd
// v0.3.0
// MD 2025-09-25 14:08
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right contain simulated meters.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterViews, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// store two meter views [A, B]
meterViews = Array.newClear(2);

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter; meterIndex: 0 for top-left (A), 1 for top-right (B)
makePaneWithMeter = { |titleString, borderColor, meterIndex|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterViews.put(meterIndex, meterView);

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left & top-right use meters) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0], 0), // top-left meter A
    UserView().minWidth_(cellPadding),
    makePaneWithMeter.(paneTitles[1], paneColors[1], 1)  // top-right meter B
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single AppClock routine for both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 1.2; // offset so A and B differ
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViews[0].notNil, { meterViews[0].value_(valA) });
            if(meterViews[1].notNil, { meterViews[1].value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MDMiniLogger/MDMiniLogger.sc =====
// MDMiniLogger.sc
// v0.3.3
// MD 20250919-13:51

// access with MDMiniLogger.get (which creates the instance if there isn't one)
// verbosity levels: 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=TRACE

MDMiniLogger : Object {
	classvar < logger;
	classvar verbosityNames;
	var < verbosity;
	var < enabled;

	// 3.1 fix
	*initClass {
		verbosityNames = ["ERROR", "WARN", "INFO", "DEBUG", "TRACE"];
		logger = nil; // discard any stale instance after class library recompile
	}

	init {
		verbosity = 2;
		enabled = true;
	}
	*get {
		// return existing, otherwise create one
		^logger ?? { logger = MDMiniLogger.new };
	}

	shouldLog { |msgVerbosity|
		var messageLevel, thresholdLevel, isOn;

		messageLevel   = (msgVerbosity ? 0).clip(0, 4);  // if nil default to 0
		thresholdLevel = (verbosity ? 0).clip(0, 4);     // the logger's current threshold
		isOn = (enabled ? true);
		// Print when:
		//  - logging is enabled, AND
		//  - the message is at least as important as the threshold (lower number = more important)
/*		^(isOn and: { messageLevel <= thresholdLevel });*/

// fix 0.3.2
^((enabled == true) and: { messageLevel <= thresholdLevel });

	}

	setverbosity { |newverbosity| verbosity = (newverbosity ? 0).clip(0, 4); ^verbosity }

	enable  { enabled = true;  ^enabled }

	disable { enabled = false; ^enabled }

	format {|argVerbosity, argLabel, argMessage |
		var line, logVerbosity, logLabel, logMessage;

		// check we have a verbosity
		logVerbosity = (argVerbosity ? 0).clip(0,4); // 0 if nil

		// check we have a label
		logLabel = argLabel ? "GENERIC";

		// check we have a message:
		logMessage = argMessage ? "";

		line = "[" ++ Date.getDate.stamp
		++ " | " ++ verbosityNames.at(logVerbosity)
		++ " | " ++ logLabel ++ "] "
		++ logMessage;
		^line;
	}

	log { |msgVerbosity, label, message|
		if (this.shouldLog(msgVerbosity)) {
			this.format(msgVerbosity, label, message).postln;
		};
		^this
	}

	// helpers

	error { |label, message| ^this.log(0, label, message) }  // ERROR
	warn  { |label, message| ^this.log(1, label, message) }  // WARN
	info  { |label, message| ^this.log(2, label, message) }  // INFO
	debug { |label, message| ^this.log(3, label, message) }  // DEBUG
	trace { |label, message| ^this.log(4, label, message) }  // TRACE

}
===== MDMiniLogger/test_MDMiniLogger.scd =====
// test_MDMiniLogger.scd

m = MDMiniLogger.get;

m.setverbosity(0);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(1);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(2);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");


===== newClassExtensions/CommandManager_CanonicalPaths.sc =====
// CommandManager_CanonicalPaths.sc
// v1.0 ‚Äî restore canonical path helpers (non-invasive extension)
// MD 2025-10-02

+ CommandManager {

    buildLongPathFromBuilder { |builderRef|
        var names, filtered;
        if (builderRef.isNil or: { builderRef.currentNode.isNil }) { "/" } {
            names    = builderRef.currentNode.getPathToRoot;        // ["root", ...]
            filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
            "/" ++ filtered.join("/")
        }
    }

    canonicalizeCommandPath { |rawPath|
        var parts, first;
        parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
        if (parts.isEmpty) { rawPath.asString } {
            first = parts[0].asString;
            if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
                "/" ++ parts.join("/")
            } {
                if (first == "switch") { "/switch" } {
                    if (first == "chain") {
                        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
                            "/add/" ++ parts.last.asString
                        } {
                            if (parts.size >= 5
                                and: { parts[1] == "setsource" }
                                and: { parts[2] == "audio" }
                                and: { parts[3] == "source" }) {
                                "/setSource/" ++ parts.last.asString
                            } {
                                rawPath.asString
                            }
                        }
                    } {
                        rawPath.asString
                    }
                }
            }
        }
    }

    canonicalPathFromBuilder { |builderRef|
        var longPath;
        longPath = this.buildLongPathFromBuilder(builderRef);
        this.canonicalizeCommandPath(longPath)
    }
}

===== newClassExtensions/LivePedalboardSystem_ApplyCanonical.sc =====
// LivePedalboardSystem_ApplyCanonical.sc
// v1.1 ‚Äî add applyCanonicalPath (adapter shim) mapping canonical verbs to pedalboard
// MD 2025-10-02

+ LivePedalboardSystem {

    applyCanonicalPath { |shortPath|
        var pedalboardRef, parts, verbSymbol, argSymbol, applied, switchCandidates;

        pedalboardRef = this.tryPerform(\pedalboard);
        parts         = shortPath.asString.split($/).reject({ |s| s.size == 0 });
        applied       = false;

        if (pedalboardRef.notNil and: { parts.size > 0 }) {
            verbSymbol = parts[0].asSymbol;
            argSymbol  = (parts.size > 1).if({ parts[1].asSymbol }, { nil });

            switch(verbSymbol,
                \add, {
                    if (pedalboardRef.respondsTo(\add) and: { argSymbol.notNil }) {
                        pedalboardRef.add(argSymbol); applied = true;
                    };
                },
                \setSource, {
                    if (pedalboardRef.respondsTo(\setSource) and: { argSymbol.notNil }) {
                        pedalboardRef.setSource(argSymbol); applied = true;
                    };
                },
                \bypass, {
                    if (pedalboardRef.respondsTo(\bypass) and: { argSymbol.notNil }) {
                        pedalboardRef.bypass(argSymbol); applied = true;
                    };
                },
                \clear, {
                    if (pedalboardRef.respondsTo(\clear)) {
                        pedalboardRef.clear; applied = true;
                    };
                },
                \switch, {
                    // Try likely names; keep this list small and explicit.
                    switchCandidates = [ \switchChain, \switchChains, \toggleAB, \toggleChain, \nextChain ];
                    switchCandidates.do({ |selectorSym|
                        if (applied.not and: { pedalboardRef.respondsTo(selectorSym) }) {
                            pedalboardRef.perform(selectorSym);
                            applied = true;
                        };
                    });
                },
                { } // default ‚Äî do nothing
            );
        };

        (applied.if({
            ("[LPS] applyCanonicalPath applied: " ++ shortPath).postln;
        },{
            ("[LPS] applyCanonicalPath could not apply: " ++ shortPath).warn;
        }));

        applied
    }
}
===== newClassExtensions/MDCommandBuilder_NavHelpers.sc =====
// MDCommandBuilder_NavHelpers.sc
// v1.0 ‚Äî add robust navigation helpers with fallback to currentNode_
// MD 2025-10-02

+ MDCommandBuilder {

    navigateByNameOrForce { |parentRef, nameString|
        var beforeNode, afterNode, children, targetNode, didSet;
        beforeNode = this.currentNode;
        this.navigateByName(parentRef, nameString.asString);
        afterNode = this.currentNode;

        if (afterNode == beforeNode) {
            children   = beforeNode.children;
            targetNode = children.detect({ |n| n.name.asString == nameString.asString });
            didSet     = false;
            if (targetNode.notNil and: { this.respondsTo(\currentNode_) }) {
                this.perform(\currentNode_, targetNode);
                didSet = true;
            };
            (didSet.if({ ("[Builder] forced to '" ++ nameString.asString ++ "'").postln }, { ("[Builder] could not force '" ++ nameString.asString ++ "'").warn }));
        };
        this.currentNode
    }

    navigateByNamesWithFallback { |nameArray|
        var names;
        names = nameArray.collect(_.asString);
        names.do({ |nm| this.navigateByNameOrForce(nil, nm) });
        this.currentNode
    }
}

===== notes/LPDisplay Layout Test (Windo.textClipping =====
bplist00“[OSType-DataXUTI-Data—POhttps://m365.cloud.microsoft‘	
_public.utf16-plain-text[public.html_$com.apple.traditional-mac-plain-text_public.utf8-plain-textOpL P D i s p l a y   L a y o u t   T e s t   ( W i n d o w )                  ≤%                 %    ( p a n e s   +   m e t e r s   v i a   S e n d P e a k R M S ;   n o   P e r f H U D )                  % L i v e P e d a l b o a r d S y s t e m   ( h e a d l e s s   U I   t o d a y )      % %  b r i n g U p P e d a l b o a r d   í!  M a g i c P e d a l b o a r d N e w      % %  b r i n g U p C o m m a n d S y s t e m   í!  C o m m a n d M a n a g e r   +   C o m m a n d T r e e   +   M I D I      % %  i n s t a l l A d a p t e r B r i d g e   í!  r o u t e s   c a n o n i c a l   p a t h s   í!  M P B O¨<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"><pre node="[object Object]" style="border-radius: 4px; border-width: 1px; border-style: solid; border-color: rgb(209, 209, 209); padding: 23px 24px; margin: 17px 0px 23px; font-size: 15px; overflow-x: auto; white-space: pre-wrap; overflow-wrap: break-word; color: rgb(66, 66, 66); font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(250, 250, 250); text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;"><code style="font-family: source-code-pro, Menlo, Monaco, Consolas, &quot;Courier New&quot;, monospace;">LPDisplay Layout Test (Window)
        ‚ñ≤
        ‚îÇ  (panes + meters via SendPeakRMS; no PerfHUD)
        ‚îÇ
LivePedalboardSystem (headless UI today)
  ‚îú‚îÄ bringUpPedalboard ‚Üí MagicPedalboardNew
  ‚îú‚îÄ bringUpCommandSystem ‚Üí CommandManager + CommandTree + MIDI
  ‚îî‚îÄ installAdapterBridge ‚Üí routes canonical paths ‚Üí MPB</code></pre>O'LPDisplay Layout Test (Window)        o8 L P D i s p l a y   L a y o u t   T e s t   ( W i n d o w ) 
                %≤ 
                %     ( p a n e s   +   m e t e r s   v i a   S e n d P e a k R M S ;   n o   P e r f H U D ) 
                % 
 L i v e P e d a l b o a r d S y s t e m   ( h e a d l e s s   U I   t o d a y ) 
    %%    b r i n g U p P e d a l b o a r d  !í   M a g i c P e d a l b o a r d N e w 
    %%    b r i n g U p C o m m a n d S y s t e m  !í   C o m m a n d M a n a g e r   +   C o m m a n d T r e e   +   M I D I 
    %%    i n s t a l l A d a p t e r B r i d g e  !í   r o u t e s   c a n o n i c a l   p a t h s  !í   M P B    " % & E N h t õ ¥(ÿ                           
v
===== README.md =====
# LivePedalboardSuite

## Overview

LivePedalboardSuite is a modular, scriptable, and extensible live audio processing environment for SuperCollider. It is designed for rapid prototyping, testing, and demonstration of pedalboard-style audio effect chains, with or without hardware integration.

---

## Project Structure

- **Scripts/** ‚Äî Demo scripts, playbooks, and acceptance tests (e.g., `Demo_Today_Playbook_FallbackOnly.scd`)
- **LivePedalboardSystem/** ‚Äî Core system classes, adapters, and utilities
- **MagicPedalboardNew.scd** ‚Äî Main pedalboard engine (chain management, switching, bypass, etc.)
- **Adapters/** ‚Äî Bridges for hardware or OSC-based control (e.g., CommandTree adapter)
- **Processors/** ‚Äî Effect definitions (delay, chorus, drive, etc.)
- **GUI/** ‚Äî MagicDisplayGUI and related visual components
- **Utilities/** ‚Äî Helper scripts, test utilities, and fallback routines

---

## Main Components

- **LivePedalboardSystem**: Top-level system manager. Handles bring-up, shutdown, and coordination of pedalboard, GUI, and adapters.
- **MagicPedalboardNew**: The core pedalboard class. Manages two chains (CURRENT and NEXT), supports adding/removing/bypassing effects, switching with crossfade, and enforcing Option A (exclusive audio path).
- **Adapters**: Optional bridges (e.g., `~ct_applyOSCPathToMPB`) that translate high-level commands (like `/add/delay`) to pedalboard actions, supporting both hardware and software control.
- **Processors**: Individual effect modules (delay, chorus, reverb, etc.), defined as SynthDefs or Ndefs, and added to chains by symbolic name.
- **GUI**: MagicDisplayGUI provides a visual overview of chain state, effect status, and demo progress. Level meters and HUDs may be included.

---

## How It Works

- **Bring-up**: `Start_LivePedalboardSystem.scd` initializes the system, pedalboard, GUI, and (optionally) adapters.
- **Demo Scripts**: Scripts like `Demo_Today_Playbook_FallbackOnly.scd` apply a sequence of canonical commands (e.g., `/add/delay`, `/switch`) to demonstrate effect switching, bypass, and chain management.
- **Audio Sources**: Uses generated sources (e.g., `Ndef(\testmelody)`) for hardware-independent testing. Option A ensures only one chain is audible at a time.
- **Adapters**: If present, adapters handle OSC or hardware commands; otherwise, scripts call pedalboard methods directly.
- **GUI**: The GUI updates in response to commands, showing current/next chain, effect status, and demo progress.

---

## Customization & Extensibility

- Add new effects by defining new SynthDefs/Ndefs and registering them as processors.
- Extend adapters for new hardware or OSC protocols.
- Write new demo scripts/playbooks for custom test scenarios.

---

## Troubleshooting & Support

- See `StartHere.md` for step-by-step instructions and troubleshooting tips.
- Check the SuperCollider console for errors and warnings.
- For advanced debugging, inspect `~system`, `~system.pedalboard`, and GUI state.
- For help, open an issue on the project repository or contact the maintainer.

---

---

Happy patching!
===== README.txt =====

README.txt ‚Äî LivePedalboardSuite Overview
========================================

LivePedalboardSuite is a modular, scriptable, and extensible live audio processing environment for SuperCollider. It is designed for rapid prototyping, testing, and demonstration of pedalboard-style audio effect chains, with or without hardware integration.

Project Structure
-----------------
- **Scripts/** ‚Äî Demo scripts, playbooks, and acceptance tests (e.g., Demo_Today_Playbook_FallbackOnly.scd)
- **LivePedalboardSystem/** ‚Äî Core system classes, adapters, and utilities
- **MagicPedalboardNew.scd** ‚Äî Main pedalboard engine (chain management, switching, bypass, etc.)
- **Adapters/** ‚Äî Bridges for hardware or OSC-based control (e.g., CommandTree adapter)
- **Processors/** ‚Äî Effect definitions (delay, chorus, drive, etc.)
- **GUI/** ‚Äî MagicDisplayGUI and related visual components
- **Utilities/** ‚Äî Helper scripts, test utilities, and fallback routines

Main Components
---------------
- **LivePedalboardSystem**: Top-level system manager. Handles bring-up, shutdown, and coordination of pedalboard, GUI, and adapters.
- **MagicPedalboardNew**: The core pedalboard class. Manages two chains (CURRENT and NEXT), supports adding/removing/bypassing effects, switching with crossfade, and enforcing Option A (exclusive audio path).
- **Adapters**: Optional bridges (e.g., ~ct_applyOSCPathToMPB) that translate high-level commands (like /add/delay) to pedalboard actions, supporting both hardware and software control.
- **Processors**: Individual effect modules (delay, chorus, reverb, etc.), defined as SynthDefs or Ndefs, and added to chains by symbolic name.
- **GUI**: MagicDisplayGUI provides a visual overview of chain state, effect status, and demo progress. Level meters and HUDs may be included.

How It Works
------------
- **Bring-up**: Start_LivePedalboardSystem.scd initializes the system, pedalboard, GUI, and (optionally) adapters.
- **Demo Scripts**: Scripts like Demo_Today_Playbook_FallbackOnly.scd apply a sequence of canonical commands (e.g., /add/delay, /switch) to demonstrate effect switching, bypass, and chain management.
- **Audio Sources**: Uses generated sources (e.g., Ndef(\testmelody)) for hardware-independent testing. Option A ensures only one chain is audible at a time.
- **Adapters**: If present, adapters handle OSC or hardware commands; otherwise, scripts call pedalboard methods directly.
- **GUI**: The GUI updates in response to commands, showing current/next chain, effect status, and demo progress.

Customization & Extensibility
-----------------------------
- Add new effects by defining new SynthDefs/Ndefs and registering them as processors.
- Extend adapters for new hardware or OSC protocols.
- Write new demo scripts/playbooks for custom test scenarios.

Troubleshooting & Support
-------------------------
- See StartHere.txt for step-by-step instructions and troubleshooting tips.
- Check the SuperCollider console for errors and warnings.
- For advanced debugging, inspect ~system, ~system.pedalboard, and GUI state.


Happy patching!

===== RulesForChatGPT-Copilot.scd =====
// RulesForChatGPT-Copilot.scd

/*
STYLE, SYNTAX & CODING RULES (STRICT)
- SuperCollider ONLY known‚Äëgood syntax. Do NOT invent methods or pseudo‚Äëslots.
- Variable style: descriptive lowercase names; **var-first in EVERY block and closure** (do a second pass each time).
- No non‚Äëlocal returns; no `try` or `protect` (not supported).
- No `server.sync`. Use `Server.default.bind` for server ops. `s.waitForBoot` is allowed in bring‚Äëup only.
- GUI: AppClock ONLY; NO FlowLayout; fixed vertical metrics; top‚Äëleft anchored; resizable width with safe layout; single titled window (‚ÄúMagicDisplayGUI ‚Ä¶‚Äù).
- Windows MUST return **‚Üí a Window** as final expression.
- Titles/headers: Every SC file starts with my standard header:
  - Line 1: `<file name>`
  - Line 2: `// vX.Y.Z`
  - Line 3: `// MD <YYYY-MM-DD HH:MM TZ>`
  - Blank line
  - `/* Purpose / Style */`
  - Then code.
- Do not use any ‚Äúv6‚Äù labels (legacy).
- JITLib connect operator: **`Ndef(left) <<> Ndef(right)`** ONLY (never `<>` or `<<>>`).
- Sinks/processors read from `\in.ar(defaultNumChannels)`.
- Acceptance tests: generated audio only; NO SoundIn.

- ALWAYS do a second pass to check for variables after statements before showing me code.
*/
===== RunBook_20251002_Diagnostics_VARFIRST.scd =====
// RunBook_20251002_Diagnostics_1311.scd
// v1.0.0 ‚Äî diagnostic-first bring-up for LPS (headless) + LPDisplay window
// MD 2025-10-02

/*
Purpose
- Give you a single, self-contained runbook to bring up LivePedalboardSystem (headless)
  while using the new LPDisplay Layout Test window as the UI.
- Add strong diagnostics you can see in the LPDisplay panes: system status, chain info,
  and received canonical commands.
- Provide safe toggles and probes: enable/disable LPDisplay‚Äôs demo sources, retap meters
  from LPS chain ends, insert a test tremolo on Chain A (audible), and refresh a HUD summary.
- Provide a robust canonical sender (~sendCanonicalPath) that tries multiple adapter entry
  points and falls back to a safe subset of pedalboard verbs if needed (never calls mpb.switch()).

Style
- var-first in every block/closure; lowercase descriptive names; no server.sync; no ^ returns.
- Server.default.bind for server operations; AppClock only for UI (none scheduled here).
- Single-window policy: closes prior LPDisplay/MagicDisplay windows on cleanup.
*/

//////////////////////////////////////////////////////
// 1) Preflight cleanup (safe, idempotent; no errors)
//////////////////////////////////////////////////////
(
var windowsToClose, demoOscKeys, demoNdefSymbols;

windowsToClose = Window.allWindows.select({ |oneWindow|
    var nameString;
    nameString = (oneWindow.tryPerform(\name) ? "").asString;
    nameString.beginsWith("MagicDisplayGUI") or: { nameString == "Layout Test" }
});
windowsToClose.do(_.close);

// Free LPDisplay demo responders (if they exist)
demoOscKeys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
demoOscKeys.do({ |keySym| var def;
    def = OSCdef(keySym);
    if (def.notNil) { def.free };
});

// Stop LPDisplay demo Ndefs (if present)
demoNdefSymbols = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
demoNdefSymbols.do({ |ndefName|
    var ndefRef;
    ndefRef = Ndef(ndefName);
    if (ndefRef.notNil) { ndefRef.stop };
});

// Remove any prior visualization taps we may have installed
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"‚úî Cleanup done.".postln;
)

//////////////////////////////////////////////////////////
// 2) Open the LPDisplay window + install PANE HELPERS
//////////////////////////////////////////////////////////
(
var displayController, displayWindow;

// Controller + window (-> a Window titled "Layout Test")
displayController = LPDisplayLayoutTestWindow.new(nil);  // nil HUD => raw meters
displayWindow     = displayController.open;

// Mute LPDisplay‚Äôs own demo tail sources (we‚Äôll retap from LPS)
displayController.setSourceA(\srcZ);
displayController.setSourceB(\srcZ);

// Optional: quiet console if your class has the gate
try { displayController.setConsoleLevelsOn(false) } { };

// Export handles
~inst = displayController;
~win  = displayWindow;

// ---- Pane helpers ----
~pane = { |paneKey, paneText|
    var okController, paneKeySymbol, paneTextString;
    okController   = (~inst.notNil) and: { ~inst.respondsTo(\sendPaneText) };
    paneKeySymbol  = paneKey.asSymbol;
    paneTextString = paneText.asString;
    if (okController) {
        ~inst.sendPaneText(paneKeySymbol, paneTextString)
    } {
        paneTextString.postln;  // fallback to console
    };
};

~paneAppend = { |paneKey, lineText|
    var textString;
    textString = lineText.asString;
    ~pane.(paneKey, textString);
};

~statusHUD = { |messageString|
    var msgString;
    msgString = "[HUD] " ++ messageString.asString;
    msgString.postln;
    ~pane.(\system, msgString);
};

// Initial HUD
~pane.(\diag,   "LPDisplay ready @ " ++ Date.getDate.stamp);
~pane.(\system, "System: waiting for LPS‚Ä¶");
~pane.(\left,   "A: (LPDisplay demo source muted)");
~pane.(\right,  "B: (LPDisplay demo source muted)");
~pane.(\choices,"‚Äî");
~pane.(\recv,   "‚Äî");

// Ready check
[ displayController.notNil, displayWindow.notNil, displayWindow.class ].postln;
"‚Üí a Window".postln;
)

////////////////////////////////////////////////////////////
// 3) Bring up LivePedalboardSystem (headless) + HUD sanity
////////////////////////////////////////////////////////////
(
var liveSystem, sanityAssoc;

liveSystem = LivePedalboardSystem.new(nil);
liveSystem.ensureServerReady;
liveSystem.bringUpPedalboard;
liveSystem.bringUpCommandSystem;
liveSystem.installAdapterBridge;

~system = liveSystem;

"‚úî LPS up (headless).".postln;
~statusHUD.("LPS up (headless)");

// Materialize 2‚Äëch busses (does not force play state)
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
});

// Show core boolean sanity in console AND pane:
sanityAssoc = (
    system: ~system.notNil,
    pedalboard: ~system.pedalboard.notNil,
    commandManager: ~system.commandManager.notNil
);
sanityAssoc.postln;
~pane.(\diag, ("Sanity: " ++ sanityAssoc).asString);
)

///////////////////////////////////////////////////////////////
// 4) Retap meters so LPDisplay follows LPS chain A/B (safe)
///////////////////////////////////////////////////////////////
(
var updateRateHz, oscStateAssoc;

updateRateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |inSignal|
            var stereoSignal, rmsPair, tick;
            stereoSignal = inSignal.isArray.if({ inSignal }, { [inSignal, inSignal] });
            rmsPair      = RMS.kr(stereoSignal, 500);
            tick         = Impulse.kr(updateRateHz);
            SendReply.kr(tick, "/peakrmsA",   [rmsPair[0], rmsPair[1]], 1);
            SendReply.kr(tick, "/rmsA_toGUI", [rmsPair[0], rmsPair[1]], 1);
            inSignal
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |inSignal|
            var stereoSignal, rmsPair, tick;
            stereoSignal = inSignal.isArray.if({ inSignal }, { [inSignal, inSignal] });
            rmsPair      = RMS.kr(stereoSignal, 500);
            tick         = Impulse.kr(updateRateHz);
            SendReply.kr(tick, "/peakrmsB",   [rmsPair[0], rmsPair[1]], 2);
            SendReply.kr(tick, "/rmsB_toGUI", [rmsPair[0], rmsPair[1]], 2);
            inSignal
        });
    };
});

"‚úî LPDisplay retap installed.".postln;

// Confirm which responders are live
oscStateAssoc = (
    rmsA_toGUI:   OSCdef(\rmsA_toGUI).notNil,
    rmsB_toGUI:   OSCdef(\rmsB_toGUI).notNil,
    rmsA_console: OSCdef(\rmsA_console).notNil,
    rmsB_console: OSCdef(\rmsB_console).notNil
);
oscStateAssoc.postln;
~pane.(\diag, ("OSC responders: " ++ oscStateAssoc).asString);
)

///////////////////////////////////////////////////////
// 5) Diagnostic controls (pane writers, toggles, probes)
///////////////////////////////////////////////////////
(
var chainInfoString;

// A) Toggle LPDisplay‚Äôs INTERNAL demo sources (UI-only; does not touch LPS)
~lpDemo_on = {
    var ok;
    ok = (~inst.notNil);
    if (ok) {
        ~inst.setSourceA(\srcA);
        ~inst.setSourceB(\srcB);
    };
    ~pane.(\left,  "A: LPDisplay demo src = \\srcA");
    ~pane.(\right, "B: LPDisplay demo src = \\srcB");
    ~statusHUD.("LPDisplay demo sources ON");
};

~lpDemo_off = {
    var ok;
    ok = (~inst.notNil);
    if (ok) {
        ~inst.setSourceA(\srcZ);
        ~inst.setSourceB(\srcZ);
    };
    ~pane.(\left,  "A: LPDisplay demo src = \\srcZ (muted)");
    ~pane.(\right, "B: LPDisplay demo src = \\srcZ (muted)");
    ~statusHUD.("LPDisplay demo sources OFF");
};

// B) Chain probes (prints + panes)
~probeChains = {
    var aPlaying, bPlaying, busA, busB, summaryText;
    aPlaying    = Ndef(\chainA).isPlaying;
    bPlaying    = Ndef(\chainB).isPlaying;
    busA        = (Ndef(\chainA).bus ? \nil);
    busB        = (Ndef(\chainB).bus ? \nil);
    summaryText = "A playing=" ++ aPlaying ++ " bus=" ++ busA
        ++ " | B playing=" ++ bPlaying ++ " bus=" ++ busB;
    summaryText.postln;
    ~pane.(\system, "Chains ‚Äî " ++ summaryText);
};

// C) Audible test insert/remove on chain A (tremolo) ‚Äî safe pass-through
~diag_addTremA = {
    Server.default.bind({
        Ndef(\chainA).filter(\diag_tremA, { |inSignal|
            var lfo;
            lfo = LFTri.kr(1).range(0.25, 1.0);
            inSignal * lfo
        });
    });
    ~statusHUD.("Inserted test tremolo on chain A");
};

~diag_clearTrem = {
    Server.default.bind({
        if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\diag_tremA) };
    });
    ~statusHUD.("Cleared test tremolo on chain A");
};

// D) Try to describe chains via pedalboard API if present (best-effort)
~describeChains = {
    var pedalboardRef, leftText, rightText, canDescribe, canChainToString;

    pedalboardRef   = ~system.tryPerform(\pedalboard);
    leftText        = "A: (unknown)";
    rightText       = "B: (unknown)";
    canDescribe     = pedalboardRef.notNil and: { pedalboardRef.respondsTo(\describe) };
    canChainToString= pedalboardRef.notNil and: { pedalboardRef.respondsTo(\chainToString) };

    if (canDescribe) {
        leftText  = pedalboardRef.describe(\A);
        rightText = pedalboardRef.describe(\B);
    } {
        if (canChainToString) {
            leftText  = pedalboardRef.chainToString(\A);
            rightText = pedalboardRef.chainToString(\B);
        };
    };

    chainInfoString = "ChainDesc: " ++ leftText.asString ++ " | " ++ rightText.asString;
    chainInfoString.postln;
    ~pane.(\left,  leftText.asString);
    ~pane.(\right, rightText.asString);
};

// E) HUD refresh bundle
~refreshHUD = {
    ~probeChains.();
    ~describeChains.();
    ~pane.(\choices, "Nav helpers: ~toProg, ~navName(\"‚Ä¶\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend");
};

"‚úî Diagnostics installed. Use: ~lpDemo_on/off, ~probeChains, ~diag_addTremA, ~diag_clearTrem, ~describeChains, ~refreshHUD".postln;
)

/////////////////////////////////////////////////////////////
// 6) Inline emulator + robust canonical sender (no mpb.switch)
/////////////////////////////////////////////////////////////
(
var commandManagerRef, midiManagerRef, builderRef;
var buildLongPathFromBuilder, canonicalizePath, applyCanonicalPath, sendCanonicalPath;
var showChildrenList, navigateByName, navigateByFret;

// gather references (var-first)
commandManagerRef = ~system.commandManager;
midiManagerRef    = commandManagerRef.midiManager;
builderRef        = commandManagerRef.builder;

// Build long path (drop "root")
buildLongPathFromBuilder = {
    var nameList, filteredNames, builtPath;
    nameList      = builderRef.currentNode.getPathToRoot;     // ["root", ...]
    filteredNames = (nameList.size > 1).if({ nameList.copyRange(1, nameList.size-1) }, { [] });
    builtPath     = "/" ++ filteredNames.join("/");
    builtPath
};

// Map long -> short canonical
canonicalizePath = { |rawPath|
    var parts, firstToken, resultString;

    parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { resultString = rawPath.asString } {
        firstToken = parts[0].asString;

        // already-canonical verbs are pass-through
        if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstToken)) {
            resultString = "/" ++ parts.join("/");
        } {
            if (firstToken == "switch") {
                resultString = "/switch";
            } {
                if (firstToken == "chain") {
                    if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
                        resultString = "/add/" ++ parts.last.asString;
                    } {
                        if (parts.size >= 5
                            and: { parts[1] == "setsource" }
                            and: { parts[2] == "audio" }
                            and: { parts[3] == "source" }) {
                            resultString = "/setSource/" ++ parts.last.asString;
                        } {
                            resultString = rawPath.asString;
                        };
                    };
                } {
                    resultString = rawPath.asString;
                };
            };
        };
    };

    resultString
};

// Apply canonical via adapter bridge (robust; avoids mpb.switch name clash)
applyCanonicalPath = { |shortPath|
    var adapterAny, appliedFlag, pedalboardRef, tokenList, verbSymbol, argSymbol, didFallback;

    appliedFlag = false;

    // 1) System-level applyCanonicalPath
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath);
        appliedFlag = true;
    } {
        // 2) adapterBridge object with .applyPath ?
        adapterAny = ~system.tryPerform(\adapterBridge);
        if (adapterAny.notNil and: { adapterAny.respondsTo(\applyPath) }) {
            adapterAny.applyPath(shortPath);
            appliedFlag = true;
        } {
            // 3) Sometimes adapterBridge is a Function
            if (adapterAny.isKindOf(Function)) {
                adapterAny.value(shortPath);
                appliedFlag = true;
            } {
                // 4) Sometimes adapterBridge is a Symbol that names another entry point
                if (adapterAny.isKindOf(Symbol)) {
                    var maybeMethodName;
                    maybeMethodName = adapterAny.asSymbol; // attempt ~system.perform on that symbol
                    if (~system.respondsTo(maybeMethodName)) {
                        ~system.perform(maybeMethodName, shortPath);
                        appliedFlag = true;
                    };
                };
            };
        };
    };

    if (appliedFlag) {
        ("Adapter applied: " ++ shortPath).postln;
        ~pane.(\recv, "Applied: " ++ shortPath);
        true
    } {
        // Fallback: direct pedalboard verbs if exposed (safe subset only)
        pedalboardRef = ~system.tryPerform(\pedalboard);
        didFallback   = false;

        if (pedalboardRef.notNil) {
            tokenList = shortPath.asString.split($/).reject(_.isEmpty);
            verbSymbol = tokenList[0].asSymbol;
            argSymbol  = (tokenList.size > 1).if({ tokenList[1].asSymbol }, { nil });

            switch(verbSymbol,
                \add, {
                    if (pedalboardRef.respondsTo(\add) and: { argSymbol.notNil }) {
                        pedalboardRef.add(argSymbol); didFallback = true;
                    };
                },
                \bypass, {
                    if (pedalboardRef.respondsTo(\bypass) and: { argSymbol.notNil }) {
                        pedalboardRef.bypass(argSymbol); didFallback = true;
                    };
                },
                \clear, {
                    if (pedalboardRef.respondsTo(\clear)) {
                        pedalboardRef.clear; didFallback = true;
                    };
                },
                \setSource, {
                    if (pedalboardRef.respondsTo(\setSource) and: { argSymbol.notNil }) {
                        pedalboardRef.setSource(argSymbol); didFallback = true;
                    };
                },
                \switch, {
                    // never call mpb.switch(); Object:switch is a control construct
                    // switching should be handled by the adapter
                },
                { } // default: do nothing
            );
        };

        if (didFallback) {
            ("Fallback MPB applied: " ++ shortPath).postln;
            ~pane.(\recv, "Fallback applied: " ++ shortPath);
            true
        } {
            ("‚ö† No adapter for: " ++ shortPath).warn;
            ~pane.(\recv, "‚ö† No adapter for: " ++ shortPath);
            false
        };
    };
};

sendCanonicalPath = { |shortPath|
    var okApply;
    okApply = applyCanonicalPath.(shortPath);
    ~refreshHUD.();
    okApply
};

// Navigation helpers
showChildrenList = {
    var items, shownText;
    items = builderRef.currentNode.children.collect({ |childNode| [childNode.name, childNode.fret] });
    shownText = "Children: " ++ items.asString;
    shownText.postln;
    ~pane.(\choices, items.asString);
    items
};

navigateByName = { |nameString|
    var nameStr;
    nameStr = nameString.asString;
    builderRef.navigateByName(nil, nameStr);
    commandManagerRef.updateDisplay;
    showChildrenList.();
};

navigateByFret = { |stringNumber, fretNumber|
    builderRef.navigateByFret(stringNumber, fretNumber);
    commandManagerRef.updateDisplay;
    showChildrenList.();
};

// Top-level aliases (emulator-like)
~toProg = {
    commandManagerRef.currentState = \prog;
    commandManagerRef.updateDisplay;
    "Navigation started (prog).".postln;
    ~pane.(\system, "Mode: prog (nav)");
    showChildrenList.();
};

~showNav = {
    var longPath, shortPath;
    longPath  = buildLongPathFromBuilder.();
    shortPath = canonicalizePath.(longPath);
    ("Long:  " ++ longPath).postln;
    ("Short: " ++ shortPath).postln;
    ~pane.(\diag, "Long=" ++ longPath ++ "  Short=" ++ shortPath);
};

~toQueue = {
    var shortPath;
    shortPath = canonicalizePath.( buildLongPathFromBuilder.() );
    commandManagerRef.queue.enqueueCommand(shortPath);
    ("Queued: " ++ shortPath).postln;
    ~pane.(\recv, "Queued: " ++ shortPath);
    shortPath
};

~toSend  = {
    var shortPath;
    shortPath = canonicalizePath.( buildLongPathFromBuilder.() );
    sendCanonicalPath.(shortPath);
};

~navName = navigateByName;
~navFret = navigateByFret;

"‚úî Emulator online. Use: ~toProg, ~navName(\"‚Ä¶\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend".postln;
)

//////////////////////////////////////////////////////
// 7) Scenarios (NAME-based first; then direct CANONICAL)
//////////////////////////////////////////////////////
(
var unused;
~toProg.();
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();               // expect Short: /add/delay
~toSend.();                // robust adapter call (or safe fallback)
unused = nil; // keep var-first pattern satisfied
)

(
var unused;
~sendCanonicalPath.("/add/delay");
unused = nil;
)

(
var unused;
~toProg.();
~navName.("switch");
~showNav.();               // expect Short: /switch
~toSend.();                // apply via adapter (or try: ~sendCanonicalPath.("/switch"))
unused = nil;
)

//////////////////////////////////////////////////////
// 8) Fast audible checks (optional, reversible)
//////////////////////////////////////////////////////
// ~lpDemo_on.();       // UI demo ON: bars should move immediately
// ~lpDemo_off.();      // UI demo OFF: back to LPS retap
// ~diag_addTremA.();   // audible wobble on Chain A proves we are in LPS path
// ~diag_clearTrem.();  // remove wobble
// ~refreshHUD.();      // panes: status/chain text

===== RunBook_20251002_Diagnostics.scd =====
// RunBook_20251002_Diagnostics.scd
// MD + Copilot 2025-10-02
// --- > RUN BLOCK BY BLOCK! <---
// Goal: Diagnosable bring-up of LPS headless + LPDisplay window.
// Adds pane writers, source toggles, retaps, chain probes, and robust adapter send.

//////////////////////////////////////////////////////
// 1) Preflight cleanup (safe, idempotent; no errors)
//////////////////////////////////////////////////////
(
var wins, demoKeys, demoSyms;

wins = Window.allWindows.select({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    or: { w.tryPerform(\name) == "Layout Test" }
});
wins.do(_.close);

// Free LPDisplay demo responders (if they exist)
demoKeys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
demoKeys.do({ |k| var d = OSCdef(k); if(d.notNil) { d.free } });

// Stop LPDisplay demo Ndefs (if present)
demoSyms = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
demoSyms.do({ |sym| var nd = Ndef(sym); if(nd.notNil) { nd.stop } });

// Remove any prior visualization taps we may have installed in an earlier run
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"‚úî Cleanup done.".postln;
)


//////////////////////////////////////////////////////////
// 2) Open the LPDisplay window + install PANE HELPERS
//////////////////////////////////////////////////////////
(
var inst, win;

// Controller + window  (-> a Window titled "Layout Test")
inst = LPDisplayLayoutTestWindow.new(nil);  // nil HUD = raw meters
win  = inst.open;                           // -> a Window

// Keep LPDisplay's own demo quiet by default (we'll offer toggles)
inst.setSourceA(\srcZ);
inst.setSourceB(\srcZ);

// Optional console gate (if your class has it)
try { inst.setConsoleLevelsOn(false) } { };

// Export handles
~inst = inst; ~win = win;

// ---- Pane helpers (so we can write quickly) ----
// pane keys seen in LPDisplayLayoutTestWindow: \left \right \system \diag \choices \recv
~pane = { |paneKey, text|
    // failsafe if sendPaneText not present
    var ok = (~inst.notNil and: { ~inst.respondsTo(\sendPaneText) });
    if (ok) { ~inst.sendPaneText(paneKey.asSymbol, text.asString) } { text.postln };
};
~paneAppend = { |paneKey, text|
    // naive append: readback not available, so just post new line
    ~pane.(paneKey, text)
};
~statusHUD = { |msg|  // put important status in the system pane & console
    ("[HUD] " ++ msg).postln;
    ~pane.(\system, msg);
};

// Initial HUD
~pane.(\diag, "LPDisplay ready @ " ++ Date.getDate.stamp);
~pane.(\system, "System: waiting for LPS‚Ä¶");
~pane.(\left,  "A: (LPDisplay demo source muted)");
~pane.(\right, "B: (LPDisplay demo source muted)");
~pane.(\choices, "‚Äî");
~pane.(\recv, "‚Äî");

// Quick confirmation
[ inst.notNil, win.notNil, win.class ].postln;
"‚Üí a Window".postln;
)


////////////////////////////////////////////////////////////
// 3) Bring up LivePedalboardSystem (headless) + quick HUD
////////////////////////////////////////////////////////////
(
var system;
var san;
system = LivePedalboardSystem.new(nil);
system.ensureServerReady;
system.bringUpPedalboard;
system.bringUpCommandSystem;
system.installAdapterBridge;

~system = system;

"‚úî LPS up (headless).".postln;
~statusHUD.("LPS up (headless)");

Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2) });  // assert stereo busses

// Show core boolean sanity in console AND pane:
san = [ \system: ~system.notNil, \pedalboard: ~system.pedalboard.notNil, \cm: ~system.commandManager.notNil ];
san.postln;
~pane.(\diag, ("Sanity: " ++ san).asString);
)


///////////////////////////////////////////////////////////////
// 4) LPDisplay RETAP from LPS chain ends (safe pass-through)
///////////////////////////////////////////////////////////////
(
var rateHz;
var r;

rateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsA",  [rms[0], rms[1]], 1);   // console/legacy path
            SendReply.kr(t, "/rmsA_toGUI",[rms[0], rms[1]], 1);   // GUI path
            in
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsB",  [rms[0], rms[1]], 2);
            SendReply.kr(t, "/rmsB_toGUI",[rms[0], rms[1]], 2);
            in
        });
    };
});
"‚úî LPDisplay retap installed.".postln;

// Confirm which responders are live
r = [
    \rmsA_toGUI: (OSCdef(\rmsA_toGUI).notNil),
    \rmsB_toGUI: (OSCdef(\rmsB_toGUI).notNil),
    \rmsA_console: (OSCdef(\rmsA_console).notNil),
    \rmsB_console: (OSCdef(\rmsB_console).notNil)
];
r.postln;
~pane.(\diag, ("OSC responders: " ++ r).asString);
)


///////////////////////////////////////////////////////
// 5) Quick DIAGNOSTIC CONTROLS & INSPECTION HELPERS
///////////////////////////////////////////////////////
(
// A) Toggle LPDisplay‚Äôs INTERNAL demo sources (pure UI demo, not LPS):
~lpDemo_on  = { ~inst.setSourceA(\srcA); ~inst.setSourceB(\srcB);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcA");
                ~pane.(\right, "B: LPDisplay demo src = \\srcB");
                ~statusHUD.("LPDisplay demo sources ON") };

~lpDemo_off = { ~inst.setSourceA(\srcZ); ~inst.setSourceB(\srcZ);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcZ (muted)");
                ~pane.(\right, "B: LPDisplay demo src = \\srcZ (muted)");
                ~statusHUD.("LPDisplay demo sources OFF") };

// B) Chain probes (prints + panes)
~probeChains = {
    var aPlay = Ndef(\chainA).isPlaying, bPlay = Ndef(\chainB).isPlaying;
    var busA  = (Ndef(\chainA).bus ? \nil), busB = (Ndef(\chainB).bus ? \nil);
    var msg   = ("A playing="++aPlay++" bus="++busA) ++ " | " ++ ("B playing="++bPlay++" bus="++busB);
    msg.postln;
    ~pane.(\system, "Chains ‚Äî " ++ msg);
};

// C) Audible test insert/remove on chain A (tremolo) ‚Äî safe pass-through
~diag_addTremA = {
    Server.default.bind({
        Ndef(\chainA).filter(\diag_tremA, { |in| in * LFTri.kr(1).range(0.25, 1.0) });
    });
    ~statusHUD.("Inserted test tremolo on chain A");
};
~diag_clearTrem = {
    Server.default.bind({
        if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\diag_tremA) };
    });
    ~statusHUD.("Cleared test tremolo on chain A");
};

// D) Try to describe chains via pedalboard API if present (best-effort)
~describeChains = {
    var pb = ~system.tryPerform(\pedalboard);
    var aTxt = "A: (unknown)", bTxt = "B: (unknown)";
    if (pb.notNil) {
        if (pb.respondsTo(\describe))      { aTxt = pb.describe(\A); bTxt = pb.describe(\B) } {
        if (pb.respondsTo(\chainToString)) { aTxt = pb.chainToString(\A); bTxt = pb.chainToString(\B) } };
    };
    ("ChainDesc: " ++ aTxt ++ " | " ++ bTxt).postln;
    ~pane.(\left,  aTxt.asString);
    ~pane.(\right, bTxt.asString);
};

// E) Minimal HUD refresh bundle
~refreshHUD = {
    ~probeChains.();
    ~describeChains.();
    ~pane.(\choices, "Nav helpers: ~toProg, ~navName(\"‚Ä¶\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend");
};

"‚úî Diagnostics installed. Use: ~lpDemo_on/off, ~probeChains, ~diag_addTremA, ~diag_clearTrem, ~describeChains, ~refreshHUD".postln;
)


/////////////////////////////////////////////////////////////
// 6) Inline Emulator: navigation + robust canonical sender
/////////////////////////////////////////////////////////////
(
// --- var-first: gather references
var cm, mm, builder;
var longFromBuilder, canonicalize, applyCanonical, sendCanonical;
var showChildren, navName, navFret;

cm      = ~system.commandManager;
mm      = cm.midiManager;
builder = cm.builder;

// --- path builders (drop "root")
longFromBuilder = {
    var names = builder.currentNode.getPathToRoot;
    var filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

canonicalize = { |rawPath|
    var parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };
    var first = parts[0].asString;

    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"));
    };
    if (first == "switch") { ^"/switch" };

    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString);
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString);
        };
    };

    ^rawPath.asString
};

// --- ROBUST sender: try bridge method names, then fallback direct to pedalboard if present
applyCanonical = { |shortPath|
    var bridge, applied=false;

    // 1) System-level applyCanonicalPath
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied=true;
    } {
        // 2) adapterBridge object with .applyPath ?
        bridge = ~system.tryPerform(\adapterBridge);
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied=true;
        } {
            // 3) Sometimes adapterBridge is a Function or symbol-wrapped
            if (bridge.isKindOf(Function)) {
                bridge.value(shortPath); applied=true;
            };
        };
    };

    if (applied) {
        ("Adapter applied: " ++ shortPath).postln;
        ~pane.(\recv, "Applied: " ++ shortPath);
        ^true
    } {
        // 4) Fallback: direct pedalboard verbs if exposed (best-effort)
        var pb = ~system.tryPerform(\pedalboard);
        if (pb.notNil) {
            var toks = shortPath.asString.split($/).reject(_.isEmpty);
            var verb = toks[0].asSymbol;
            var arg  = (toks.size>1).if({ toks[1].asSymbol }, { nil });
            var did  = false;

            switch(verb,
                \add,      { if (pb.respondsTo(\add) and: { arg.notNil }) { pb.add(arg); did=true } },
                \bypass,   { if (pb.respondsTo(\bypass) and: { arg.notNil }) { pb.bypass(arg); did=true } },
                \clear,    { if (pb.respondsTo(\clear)) { pb.clear; did=true } },
                \setSource,{ if (pb.respondsTo(\setSource) and: { arg.notNil }) { pb.setSource(arg); did=true } },
                \switch,   { /* NO direct mpb.switch() (name clashes with Object:switch) */ },
                { } // default
            );

            if (did) {
                ("Fallback MPB applied: " ++ shortPath).postln;
                ~pane.(\recv, "Fallback applied: " ++ shortPath);
                ^true
            };
        };

        ("‚ö† Adapter not available for: " ++ shortPath).warn;
        ~pane.(\recv, "‚ö† No adapter for: " ++ shortPath);
        ^false
    };
};

sendCanonical = { |shortPath|
    var ok = applyCanonical.(shortPath);
    ~refreshHUD.();  // update panes after any change
    ok
};

// --- Navigation helpers
showChildren = {
    var info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children: " ++ info).postln;
    ~pane.(\choices, info.asString);
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};
navFret = { |stringNum, fretNum|
    builder.navigateByFret(stringNum, fretNum);
    cm.updateDisplay;
    showChildren.();
};

// --- Top-level API (like the old emulator)
~toProg = {
    cm.currentState = \prog;
    cm.updateDisplay;
    "Navigation started (prog).".postln;
    ~pane.(\system, "Mode: prog (nav)");
    showChildren.();
};

~showNav  = {
    var long = longFromBuilder.(), short = canonicalize.(long);
    ("Long:  " ++ long).postln;  ("Short: " ++ short).postln;
    ~pane.(\diag, "Long="++long++"  Short="++short);
};

~toQueue  = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    ~pane.(\recv, "Queued: " ++ short);
    short
};

~toSend   = {
    var short = canonicalize.( longFromBuilder.() );
    sendCanonical.(short);
};

~navName  = navName;
~navFret  = navFret;
"‚úî Emulator online. Use: ~toProg, ~navName(\"‚Ä¶\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend".postln;
)


//////////////////////////////////////////////////////
// 7) Scenarios ‚Äî first by NAME, then direct CANONICAL
//////////////////////////////////////////////////////

// 7A) NAME-based Add Delay
(
~toProg.();
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();               // expect Short: /add/delay
~toSend.();                // robust adapter call or fallback
)

// 7B) Direct CANONICAL (no nav) ‚Äî prove the path independently
(
~sendCanonical.("/add/delay");
)

// 7C) Switch chains ‚Äî ALWAYS via adapter (no direct mpb.switch())
(
~toProg.();
~navName.("switch");
~showNav.();               // expect Short: /switch
~toSend.();                // robust adapter call
// OR direct canonical:
// ~sendCanonical.("/switch");
)

//////////////////////////////////////////////////////
// 8) Quick audible checks (optional, reversible)
//////////////////////////////////////////////////////

// 8A) Turn LPDisplay demo sources ON (just to see UI move), then OFF
// ~lpDemo_on.();
// ~lpDemo_off.();

// 8B) Insert tremolo on A (you should hear amplitude wobble), then clear
// ~diag_addTremA.();
// ~diag_clearTrem.();

// 8C) Refresh HUD summary
// ~refreshHUD.();
===== Sim_MIDI_FootAndGuitar_Demo_v0.1.scd =====
// Sim_MIDI_FootAndGuitar_Demo_v0.1.scd
// v0.1.2
// MD 2025-09-26 10:45 BST

/* Purpose / Style
   Simulate foot controller + hex guitar without hardware:
   - FOOT (noteOn): 36‚Üí\idle, 38‚Üí\prog, 40‚Üí\queue, 41‚Üí\send
   - GUITAR (channels 0..5 ‚Üí strings 6..1) bases [40,45,50,55,59,64]
   - Drives MIDIInputManager handlers + CommandManager + adapter bridge if present.

   Style
   - var-first everywhere; descriptive lowercase variable names; AppClock-only; no server.sync.
   - Generated audio only; exclusivity Option A remains enforced by bring-up (no SoundIn).
*/

(
var ensureSystem, basePitches, ensureReady, footToIdle, footToProg, footToQueue, footToSend;
var guitarNote, navFret, showCanonical, refreshChoices;
var runScenarioAddDelay, runScenarioSwitch, runScenarioBypassOn, runAllScenarios, logger;

logger = { arg message; ("[SIM] " ++ message).postln };

ensureSystem = {
    var systemInstance;
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    systemInstance = LivePedalboardSystem.new(nil);  // nil -> class path resolver
    ~system = systemInstance;
    ~system.bringUpAll;
    if(~system.respondsTo(\installAdapterBridge)) { ~system.installAdapterBridge };
    logger.("system is up (GUI + MPB + CommandTree)");
};

ensureReady = {
    var ok;
    ok = ~system.notNil
        and: { ~system.commandManager.notNil }
        and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run ensureSystem.() first".warn };
    ok
};

basePitches = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

footToIdle  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 36) } };
footToProg  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 38) } };
footToQueue = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 40) } };
footToSend  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 41) } };

guitarNote = { arg stringNumber, fretNumber;
    var midiManager, channelIndex, baseNote, midiPitch;
    if(ensureReady.().not) { ^nil };
    midiManager = ~system.commandManager.midiManager;
    channelIndex = (6 - stringNumber.asInteger).clip(0, 5);
    baseNote = basePitches[channelIndex];
    if(baseNote.isNil) { "‚ö†Ô∏è Invalid string number".warn; ^nil };
    midiPitch = (baseNote + fretNumber.asInteger).asInteger;
    midiManager.guitarHandler.handleMessage(channelIndex, \noteOn, midiPitch);
};
navFret = { arg stringNumber, fretNumber; guitarNote.(stringNumber, fretNumber) };

showCanonical = {
    var cmRef, builderRef, longPath, shortPath;
    if(ensureReady.().not) { ^nil };
    cmRef = ~system.commandManager; builderRef = cmRef.builder;
    builderRef.printPathToRoot;
    longPath  = cmRef.buildLongPathFromBuilder(builderRef);
    shortPath = cmRef.canonicalPathFromBuilder(builderRef);
    ("‚Ä¢ long=" ++ longPath ++ "  canonical=" ++ shortPath).postln;
};
refreshChoices = { if(~system.notNil) { ~system.commandManager.updateDisplay } };

runScenarioAddDelay = {
    footToProg.(); refreshChoices.();
    navFret.(6, 1); navFret.(5, 5); navFret.(4, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario A complete (add delay)");
};

runScenarioSwitch = {
    footToProg.();
    navFret.(6, 5);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario B complete (switch)");
};

runScenarioBypassOn = {
    footToProg.();
    navFret.(6, 3); navFret.(5, 9); navFret.(4, 3); navFret.(3, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario C complete (bypass delay on)");
};

runAllScenarios = {
    var stepIndex;
    stepIndex = 0;
    AppClock.sched(0.0, {
        switch(stepIndex,
            0, { ensureSystem.(); stepIndex = 1; AppClock.sched(0.40, { runAllScenarios.(); nil }) },
            1, { runScenarioAddDelay.(); stepIndex = 2; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            2, { runScenarioSwitch.();   stepIndex = 3; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            3, { runScenarioBypassOn.(); nil },
            { nil }
        );
        nil
    });
    "[SIM] queued runAllScenarios".postln;
};

~sim_runAll = { runAllScenarios.() };
logger.("Evaluate:  ensureSystem.();  then  ~sim_runAll.();");
)

===== StartHere_LivePedalboardSuite.scd =====
// StartHere_LivePedalboardSuite.scd
// v0.6.1
// MD 20250928-1824
//
// Purpose
// - Canonical bring-up for LivePedalboardSuite using ONE GUI with WORKING METERS.
// - Avoid duplicate GUI/taps: rely on LivePedalboardSystem.bringUpAll to open GUI,
//   then install the adapter bridge and auto-meters once.
//
// Style / Guard Rails
// - single () block; var-first; lowercase names; no server.sync; no non-local '^'.
// - UI via AppClock; server ops inside Server.default.bind when needed.
// - Returns -> a Window (MagicDisplayGUI‚Ä¶).

(
var meterRate, postSwitchDelay, systemRef, windowRef;
var findMagicDisplayWindow, closeExistingMagicDisplayWindows, frontWindow, afterBringUp;

// ---- tunables ----
meterRate = 24;
postSwitchDelay = 0.35;

// ---- helpers ----
closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows; i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }) {
            w.close;
        };
        i = i + 1;
    };
};

findMagicDisplayWindow = {
    var win;
    win = Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    win
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    // Adapter: route short canonical commands to MagicPedalboard (+HUD toggle on /switch)
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    // Meters: assert one set of taps + GUI re-arm (idempotent)
    if(lps.respondsTo(\enableAutoMeters)) { lps.enableAutoMeters(meterRate, postSwitchDelay) };
    // detect and front the GUI window
    frontWindow.(findMagicDisplayWindow.());
};

// ---- run ----

// 0) keep one GUI window only
closeExistingMagicDisplayWindows.();

// 1) shutdown existing system cleanly (if present)
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };

// 2) construct and bring up everything (this will open the GUI once)
systemRef = LivePedalboardSystem.new(nil);
systemRef.bringUpAll;

// 3) post-steps: adapter bridge + meters + front window
windowRef = afterBringUp.(systemRef);

// 4) publish handles
~system = systemRef;
~mpb = systemRef.pedalboard;
~gui = systemRef.statusDisplay;

// 5) return the GUI window
windowRef
)

===== StartHere.md =====

StartHere.txt ‚Äî Quick Start for LivePedalboardSuite Demo
======================================================

\1. Prerequisites
----------------
- SuperCollider 3.11 or newer installed and working
- Clone or download the LivePedalboardSuite repository to your computer
- (Optional) Audio interface or headphones for best sound

\2. Launch SuperCollider
-----------------------
- Open SuperCollider (scide)
- Open the file: Start_LivePedalboardSystem.scd (usually in the root or a Scripts/ folder)

\3. Bring Up the System
----------------------
- Evaluate the following block (select and press Cmd+Return or Ctrl+Return):

(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
    ~system.installAdapterBridge;
}.defer;
)

- Wait for the GUI window to appear and for console logs to confirm bring-up.

\4. Run the Demo
---------------
- Open the file: Demo_Today_Playbook_FallbackOnly.scd (or similarly named demo script)
- Evaluate the entire file (select all, Cmd+Return/Ctrl+Return)
- You should see console output like:
    [FALLBACK] entered
    [FALLBACK] apply ‚Üí /add/delay
    ...
    [FALLBACK] done.
- The GUI window should update with each step.
- You should hear a pleasant melody and effect changes.

\5. Troubleshooting
------------------
- **No sound?**
    - Make sure your audio interface is selected in SuperCollider (check ServerOptions)
    - Check your system volume and headphones/speakers
    - Confirm that the Ndef(\testmelody) is playing (see code in ensureGeneratedSources)
    - Try re-evaluating Start_LivePedalboardSystem.scd and then the demo script
- **No GUI window?**
    - Make sure you ran the bring-up block in step 3
    - Check for errors in the SuperCollider console
    - Try closing all SuperCollider windows and re-running from step 3
- **No effect changes?**
    - Confirm the demo script is running (look for [FALLBACK] logs)
    - Check that ~system.pedalboard is not nil (type ~system.pedalboard; in the console)
    - Try restarting SuperCollider and repeating steps 3 and 4
- **Still stuck?**
    - Paste any error messages into an issue on the project repo or ask your team lead

\6. Stopping the Demo
--------------------
- To stop all sound, evaluate:
    s.meter; // open meters
    s.quit;  // stop audio server
    // or close SuperCollider

Enjoy exploring LivePedalboardSuite!
===== SystemSpecification_ModularGuitarPedalboard.md =====

# System Specification: Modular Guitar-Controlled Audio Pedalboard with Hierarchical Command Navigation

## 1. System Overview

This system is a modular, software-based audio pedalboard designed for live performance and experimentation. It is controlled by a hexaphonic (six-string) guitar, where each string is mapped to a separate MIDI channel. The performer navigates a hierarchical command tree by playing specific frets on each string, allowing for rapid, hands-free selection and execution of audio processing commands. The system is designed for flexibility, robust state management, and clear feedback to the performer.

## 2. Core Concepts

### 2.1. Audio Pedalboard Engine

- **Signal Chains:**
  The audio engine maintains two parallel signal chains (A and B), each consisting of a sequence of audio processors (effects) and a source. These chains are dynamically reconfigurable.
- **Processors:**
  Each processor is a modular audio effect (e.g., delay, chorus, reverb, drive) that can be inserted, bypassed, or removed from a chain. All processors are designed to operate on a configurable number of channels (typically stereo).
- **Chain Switching:**
  The performer can crossfade between the two chains, ensuring smooth transitions. Only one chain is audible at a time, except during deliberate crossfades.
- **Exclusivity:**
  The system enforces that only the ‚Äúcurrent‚Äù chain is audible, muting the ‚Äúnext‚Äù chain at its source except during crossfades.

### 2.2. Hierarchical Command Navigation

- **Command Tree:**
  All available commands (such as adding effects, switching chains, or changing sources) are organized in a hierarchical tree structure. Each node represents a command or a category of commands.
- **Navigation by Guitar:**
  The performer navigates the tree by playing specific frets on each string. Each string corresponds to a level in the tree; the fret number selects a branch at that level.
- **Command Queue:**
  As the performer navigates, the selected path is recorded as a sequence of tokens (e.g., `/audio/time-based/delay`). When navigation is complete (either at a leaf node or by explicit user action), the resulting command path is queued for execution.

### 2.3. Execution and Feedback

- **Command Execution:**
  When the performer triggers execution (e.g., by pressing a footswitch or reaching a leaf node), the queued command is sent to the audio engine for processing.
- **Partial Commands:**
  The system allows for both complete (leaf node) and partial (intermediate node) command paths to be executed, enabling both generic and specific actions.
- **User Feedback:**
  The system provides real-time feedback on the current navigation state, available choices, queued commands, and execution status via a display (console or GUI).

## 3. System Architecture

### 3.1. Audio Engine

- Maintains two independent signal chains (A/B), each as an ordered list of processors and a source.
- Supports dynamic mutation of chains: add, remove, swap, bypass processors; set sources.
- Enforces channel count and audio-rate consistency throughout the chain.
- Provides robust methods for resetting, rebuilding, and crossfading chains.

### 3.2. Command Navigation and Queue

- Maintains a hierarchical tree of commands, each node with a name, identifier, fret mapping, and optional payload.
- Navigation is performed by mapping incoming MIDI notes (from each guitar string/channel) to tree branches.
- Tracks the current navigation path and supports resetting or restarting navigation at any time.
- Maintains a queue of commands to be executed, supporting enqueue, dequeue, clear, and export operations.

### 3.3. MIDI and Device Management

- Detects and manages multiple MIDI input devices (guitar, foot controller, launchpad, etc.).
- Binds specific handlers to each device, mapping incoming MIDI messages to navigation, mode switching, or command execution.
- Supports flexible mode switching (e.g., navigation, queueing, sending, play, record) via foot controller or other devices.

### 3.4. Display and Feedback

- Provides a user interface (console or GUI) that displays:
  - Current navigation mode and state
  - Available choices at each navigation step
  - Current command queue
  - Last executed command
  - Status messages and errors
- Updates the display in real time as navigation and execution progress.

## 3.5 Command Tree Path Resolution (Runtime)

When no explicit path is provided to `LivePedalboardSystem.new(path)`, the JSON path is resolved with this precedence:

1. `Platform.userExtensionDir/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json`
2. `Platform.userExtensionDir/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json` _(repo default)_
3. _(Legacy, deprecated; warning emitted)_ `Platform.userExtensionDir/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json`

If none exist, the repo default path is returned and the import warns.

### 3.6 Acceptance & Demo Constraints
- **Audio**: generated sources only (no `SoundIn`).
- **Exclusivity (Option A)**: NEXT is silenced at source except during crossfades.
- **A/B XOR**: at any time exactly one sink (A or B) is audible; demos verify this.
- **GUI**: single MagicDisplayGUI window; UI updates via `AppClock` only.


## 4. Operational Workflow

1. **System Initialization**
   - Audio engine initializes both signal chains with default processors and sources.
   - Command tree is loaded from a configuration file or built programmatically.
   - MIDI devices are detected and handlers are bound.

2. **Navigation**
   - Performer enters navigation mode (e.g., via foot controller).
   - Each string/fret played advances one level in the command tree.
   - At each step, available choices are displayed.
   - Navigation can be completed by reaching a leaf node or by explicit user action.

3. **Queueing and Execution**
   - Upon completion, the selected command path is added to the command queue.
   - Performer can review, modify, or clear the queue.
   - When ready, the performer triggers execution (e.g., via foot controller).
   - The queued command is sent to the audio engine for processing.

4. **Audio Processing**
   - The audio engine interprets the command path and mutates the signal chain(s) accordingly.
   - If a chain switch is requested, a crossfade is performed.
   - Exclusivity is enforced: only the current chain is audible.

5. **Feedback**
   - The display updates to reflect the new state, available commands, and any errors or status changes.

## 5. Design Principles

- **Modularity:**
  All components (audio processors, command nodes, device handlers) are modular and extensible.
- **Robustness:**
  The system is designed to recover gracefully from errors, with clear state management and reset capabilities.
- **Real-Time Safety:**
  All time-sensitive operations (audio, MIDI) are handled in a thread-safe manner, with UI updates deferred as needed.
- **User-Centric Feedback:**
  The performer receives immediate, clear feedback at every step, supporting both novice and expert workflows.
- **Testability:**
  The system supports headless (non-GUI) operation and automated acceptance tests using generated audio only.

## 6. Extensibility and Future Directions

- **Additional Processors:**
  New audio effects can be added by registering new processor modules.
- **Custom Command Trees:**
  The command hierarchy can be reconfigured or extended to support new workflows.
- **Advanced Displays:**
  The user interface can be enhanced with richer visualizations, touch support, or remote control.
- **Integration with Other Instruments:**
  The navigation and command system can be adapted for other MIDI controllers or input devices.

## 7. Example Use Case

1. Performer powers on the system; both audio chains are initialized with default settings.
2. Performer enters navigation mode and plays a sequence of frets on the guitar, selecting a path such as ‚Äúaudio ‚Üí time-based ‚Üí delay‚Äù.
3. The system displays available sub-commands (e.g., ‚Äúmulti-tap‚Äù, ‚Äúping-pong‚Äù) or allows execution of the generic delay command.
4. Performer confirms the selection; the command is queued.
5. Performer triggers execution; the delay effect is added to the next chain, and a crossfade is performed to make it active.
6. The display updates to show the new chain configuration and confirms successful execution.

## 8. Summary

This system enables expressive, hands-free control of a modular audio pedalboard using a guitar as a navigation device. Its hierarchical command structure, robust audio engine, and real-time feedback make it suitable for live performance, experimentation, and further extension.

v0.9
===== test 31tp8ve.scd =====
// test 31tp8ve.scd
//

(
var baseFreq = 220.0; // A3
var stepsPerOctave = 31;
var numSteps = 62; // two octaves
var dur = 0.2;
var gap = 0.05;

Routine({
    numSteps.do { |step|
        var freq = baseFreq * (2 ** (step / stepsPerOctave));
        Synth(\play31tone, [\freq, freq]);
        dur.wait;
        gap.wait;
    };
}).play;

SynthDef(\play31tone, { |freq=220|
    var env = EnvGen.kr(Env.perc(0.01, 0.19), doneAction:2);
    var sig = SinOsc.ar(freq) * 0.2 * env;
    Out.ar(0, sig!2);
}).add;
)
===== Test_MagicDisplayGUI_BootAndScenarios.scd =====
// Test_MagicDisplayGUI_BootAndScenarios.scd
// v0.1.6
// MD 2025-09-26 11:58 BST

/* Purpose / Style
   One-click system bring-up using the PerfHUD v0.5.4 integration:
   - LivePedalboardSystem.new(nil).bringUpAll() -> your PerfHUD window (v0.5.4).
   - Install queue->MPB adapter bridge (if present) and inline AutoMeters taps.
   - AppClock-only; var-first in EVERY block; no server.sync; generated audio only.
   - Final expression returns -> a Window.
*/

(
var systemRef, pickedWindow, wins;

// Fresh system
systemRef = LivePedalboardSystem.new(nil);
~system = systemRef;  // convenience handle at top level (allowed per your style)
systemRef.bringUpAll;

// Optional: adapter and inline meter taps
if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
if(systemRef.respondsTo(\enableAutoMeters))     { systemRef.enableAutoMeters(18, 0.35) };

// Find MagicDisplay window produced by PerfHUD v0.5.4
wins = Window.allWindows;
pickedWindow = wins.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

// Final expression -> a Window
pickedWindow ? { wins.last }
)

===== Tests/Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd =====
// Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd
// v0.1.1
// MD 2025-09-26 16:35 BST

/* Purpose / Style
   Purpose: One-file, sectioned run-sheet for the 5pm demo. Brings up the system, ensures a single
            ‚ÄúMagicDisplayGUI ‚Ä¶‚Äù window, installs the adapter bridge and robust meter taps, and provides
            simulated footcontroller + hex guitar. Applies canonical commands via the adapter to avoid
            the known queue/display crash path today.
   Style:   SC only; known-good syntax; var-first everywhere; no non-local returns; no try/protect;
            no server.sync; GUI on AppClock; the bring-up section returns ‚Üí a Window.
*/

// [0] BRING-UP (build once; returns ‚Üí a Window)
(
var needNew, winList, pickedWindow;

needNew = ~system.isNil;
if(needNew) {
    var treePath;  // nil ‚Üí LivePedalboardSuite resolver precedence
    treePath = nil;
    ~system = LivePedalboardSystem.new(treePath);                     // resolver inside class
    ~system.bringUpAll;                                               // GUI+MPB+CommandManager+meters staged
} {
    // Refresh GUI only (avoid double full bring-up)
    ~system.closeExistingMagicDisplayWindows;
    ~system.bringUpMagicDisplayGUI;                                   // sets statusDisplay and re-binds if commandManager exists
};

// Return the single MagicDisplayGUI window and front it
winList = Window.allWindows;
pickedWindow = winList.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});
if(pickedWindow.notNil) { pickedWindow.front };
pickedWindow
)

// [1] ADAPTER BRIDGE + STABLE TAPS + INLINE OVERLAY METERS (self-contained)
/* Reason:
   - Your GUI shows the /md/levels OSC listener is installed, but the overlay meters weren't attached in your run.
   - We install stable taps (A=2001, B=2002) and a minimal overlay here so you see movement immediately.  */
(
var ensureBridge, ensureStableTaps, installLevelsListener, attachOverlay;

ensureBridge = {
    ~system.installAdapterBridge;  // routes canonical queue strings through adapter; also toggles active-chain HUD
    nil
};

ensureStableTaps = {
    // Sanitised + smoothed visual taps to /md/levels with IDs 2001 (A) / 2002 (B)
    ~system.installStableMeters;
    nil
};

installLevelsListener = {
    // Minimal HUD-side listener (independent of any external file)
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    if(OSCdef.all.at(\md_levels_inline).notNil) { OSCdef.all.at(\md_levels_inline).free };
    OSCdef(\md_levels_inline, { arg msg;
        var id, l, r, L, R;
        if(msg.size >= 5) {
            id = msg[2];
            l  = msg[3].asFloat; r = msg[4].asFloat;
            L  = l.isFinite.if({ l.clip(0,1) }, { 0.0 });
            R  = r.isFinite.if({ r.clip(0,1) }, { 0.0 });
            ~md_levelsById.put(id, [L, R]);
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    nil
};

attachOverlay = {
    var hudWindow, overlayView, pad, w, h, tick;
    hudWindow = Window.allWindows.detect({ arg ww;
        var n = ww.tryPerform(\name);
        n.notNil and: { n.asString.beginsWith("MagicDisplayGUI") }
    });
    if(hudWindow.isNil) { "‚ö†Ô∏è No MagicDisplayGUI window yet; run [0] first.".warn; ^nil };

    pad = 8; w = 22; h = 86;
    overlayView = UserView(hudWindow, Rect(pad, pad, w, h));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var pairA, pairB, aL, aR, bL, bR, halfH, halfW;
        pairA = ~md_levelsById.at(2001) ? [0, 0];       // A (replyID 2001)
        pairB = ~md_levelsById.at(2002) ? [0, 0];       // B (replyID 2002)
        aL = pairA[0]; aR = pairA[1];
        bL = pairB[0]; bR = pairB[1];
        halfH = v.bounds.height/2; halfW = v.bounds.width/2;

        // A (bottom half): left=green, right=blue
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, halfH - (halfH * aL), halfW, (halfH * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, halfH - (halfH * aR), halfW, (halfH * aR))); Pen.fill;

        // B (top half): lighter tint
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, v.bounds.height - (halfH * bL), halfW, (halfH * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, v.bounds.height - (halfH * bR), halfW, (halfH * bR))); Pen.fill;
    });

    // Refresh loop (AppClock only)
    tick = Routine({
        var keep;
        keep = true;
        while({ keep and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "‚úÖ Inline overlay meters attached (top-left)".postln;
    overlayView
};

// Apply fixes
ensureBridge.();
ensureStableTaps.();
installLevelsListener.();
attachOverlay.();
nil
)

// [2] SIMULATED CONTROLLERS (foot + hex guitar ‚Üí nav); AVOID queue/send crash today
(
var ensure, bases;

// Guard
ensure = {
    var ok;
    ok = ~system.notNil
      and: { ~system.commandManager.notNil }
      and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run section [0] first.".warn };
    ok
};

// Channel‚Üístring base pitches (E A D G B E) as per GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

// FOOT: emulate a foot button press (note number)
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);  // 36 idle, 38 prog, 40 queue, 41 send
};

// Shortcuts
~toIdle  = { var n; n = 36; ~fc.(n) };
~toProg  = { var n; n = 38; ~fc.(n) };

// GUITAR: emulate ‚Äústring s @ fret f‚Äù
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "‚ö†Ô∏è Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Helper: print current and canonical path
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);         // "/add/delay", "/switch", etc.
    ("‚Ä¢ long=" ++ long ++ "  canonical=" ++ short).postln;
    short
};
nil
)

// [3] DEMO SCENARIOS (canonical applied via adapter to avoid queue/display crash path)

// Scenario A ‚Äî Add delay to NEXT via guitar nav, then apply canonical via adapter (no queue/send today)
(
var path;
~toProg.();      // enter navigation mode
~gm.(6, 1);      // "audio"    (string 6 fret 1)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(5, 5);      // "timebased"(string 5 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(4, 3);      // "delay"    (string 4 fret 3)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // should be "/add/delay"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // apply via adapter
} {
    "‚ö†Ô∏è Adapter not loaded.".warn;
};
"‚úÖ Scenario A applied (add delay to NEXT).".postln;
nil
)

// Scenario B ‚Äî Navigate to top-level ‚Äúswitch‚Äù and apply canonical via adapter
(
var path;
~toProg.();
~gm.(6, 5);      // "switch" (string 6 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // "/switch"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // guarded crossfade + post-audit
} {
    "‚ö†Ô∏è Adapter not loaded.".warn;
};
"‚úÖ Scenario B applied (switch).".postln;
nil
)

===== troubleshooting/00_Reset_KnownClean_State.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)

===== troubleshooting/00A_HUD_Sanity_Check.scd =====
//////////////////////////////////////////////////////////////
// 00A_HUD_Sanity_Check.scd
// v0.1.0
// MD 20250929-13:02

/* Purpose
   - Print which window(s) are open and what ~gui is.
Style
   - var-first; no server.sync; safe .tryPerform.
*/
(
var windowNames, guiClass, isWindow;

windowNames = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
guiClass = ~gui.tryPerform(\class);
isWindow = ~gui.notNil and: { ~gui.isKindOf(Window) };

"‚Äî HUD Sanity ‚Äî".postln;
("Windows: " ++ windowNames).postln;
("~gui: " ++ (~gui ? "nil").asString).postln;
("~gui.class: " ++ (guiClass ? "nil").asString).postln;
("~gui is a Window? " ++ isWindow.asString).postln;
if(~gui.notNil) {
    ("GridDemo methods: highlight=" ++ ~gui.respondsTo(\highlightCurrentColumn)
      ++ " setOps=" ++ ~gui.respondsTo(\setOperations)).postln;
};
)

===== troubleshooting/00B_HUD_Force_GridDemo_Now.scd =====
//////////////////////////////////////////////////////////////
// 00B_HUD_Force_GridDemo_Now.scd
// v0.1.0
// MD 20250929-13:02
/* Purpose
   - Close PerfHUD/GridDemo windows and bring up GridDemo (non-pulsing).
   - Assign ~gui to the GridDemo controller and bring it to front.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/
(
var closeWindows, bringGrid, front;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller, not a Window
};

front = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (static A/B; no pulse)", 0);
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { front.value; nil }); nil });
)

===== troubleshooting/01_StartHere_LivePedalboardSuite.scd =====
// 01_StartHere_LivePedalboardSuite.scd
// v0.6.2
// MD 20250928-1935

(
// Purpose
// - Bring up LivePedalboardSuite from a clean state (server reboot, GUI, MPB, CommandTree).
// - Enable GUI taps for overlay; HUD meters will be driven by ‚Äú02_ForceMeters_FromBuses.scd‚Äù.
// Style
// - var-first; no server.sync; use s.waitForBoot; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var rebootServer, ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

rebootServer = {
    if(s.serverRunning) { s.reboot } { s.boot };
    s.waitForBoot({
        s.initTree;
        Server.default.bind({ s.defaultGroup.freeAll });
        "üîÅ Server booted & tree initialized.".postln;
    });
};

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };  // GUI taps for overlay
    frontWindow.(findMagicDisplayWindow.());
};

rebootServer.value;
ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_1_HUD_Adapter.scd =====
// 01b_1_HUD_Adapter.scd
// v0.1.0
// MD 2025-09-29 13:05

/* Purpose
   - Provide a stable HUD API regardless of which GUI is up:
        ~hud_highlightCurrent.(\chainA | \chainB)
        ~hud_showExpectation.("text", seconds=0)
        ~hud_setOperations.(["line1", "line2", ...])
   - If GridDemo is up, forward to its native methods.
   - If PerfHUD is up (meters!), create lightweight overlays on top of the window:
       ‚Ä¢ a solid A/B highlight (masks the pulsing)
       ‚Ä¢ a small text panel for status + choices
Style
   - var-first; AppClock for UI; no server.sync; nil-safe; idempotent.
*/

(
var findHudWindow, isGridDemo, adoptGridDemo, adoptPerfHUD, ensureOverlayBag;
var mkOrGetView, setSolidHighlight, setStatusText, setChoicesText;

findHudWindow = {
    Window.allWindows.detect { |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    }
};

isGridDemo = {
    // If ~gui is a GridDemo controller, prefer it
    (~gui.notNil)
    and: { ~gui.class.asString == "MagicDisplayGUI_GridDemo" }
    and: { ~gui.respondsTo(\highlightCurrentColumn) }
};

// ---- GridDemo path: forwarders to class methods -----------------------------
adoptGridDemo = {
    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            ~gui.highlightCurrentColumn(which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation(text, secs ? 0) };
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\setOperations)) { ~gui.setOperations(lines ? []) };
            nil
        })
    };
    "HUD adapter: GridDemo forwarders installed.".postln;
};

// ---- PerfHUD path: overlays on top of the window ----------------------------
ensureOverlayBag = { |win|
    var dict;
    dict = Library.at(\HUD_Overlay, win.identityHash);
    if(dict.isNil) {
        dict = IdentityDictionary.new;
        Library.put(\HUD_Overlay, win.identityHash, dict);
    };
    dict
};

mkOrGetView = { |win, key, makeFunc|
    var bag, v;
    bag = ensureOverlayBag.(win);
    v = bag[key];
    if(v.isNil or: { v.wasRemoved ? false }) {
        v = makeFunc.value(win.view);
        bag[key] = v;
    };
    v
};

setSolidHighlight = { |win, which|
    var host, w, h, half, rect, color, key;
    host = win.view;
    w = host.bounds.width; h = host.bounds.height;
    half = (w * 0.5).round(1);
    rect = (which == \chainA)
        .if({ Rect(0, 0, half, h) }, { Rect(half, 0, w - half, h) });
    color = Color(0.85, 1.0, 0.85, 0.90);   // same tint as GridDemo "active"
    key = \highlightView;

    mkOrGetView.(win, key, { |parent|
        var v = CompositeView(parent);
        v.background = color;
        v
    }).bounds = rect;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).background = color;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).front;
};

setStatusText = { |win, string|
    var host, rect, key;
    host = win.view;
    rect = Rect(8, 6, (host.bounds.width - 16).max(120), 22);
    key = \statusText;

    mkOrGetView.(win, key, { |parent|
        var tv = StaticText(parent);
        tv.stringColor = Color.black;
        tv.background = Color(1, 1, 0.6, 0.8);
        tv.align = \left;
        tv
    }).bounds = rect;

    mkOrGetView.(win, key, { |parent| StaticText(parent) }).string = string.asString;
    mkOrGetView.(win, key, { |parent| StaticText(parent) }).front;
};

setChoicesText = { |win, lines|
    var host, x, y, w, h, key, text;
    host = win.view;
    x = (host.bounds.width - 360).clip(8, host.bounds.width - 120);
    y = 40;
    w = 352;
    h = 220;
    text = (lines ? []).collect(_.asString).join("\n");
    key = \choicesText;

    mkOrGetView.(win, key, { |parent|
        var box = TextView(parent);
        box.string = text.size > 0.if({ text }, { "‚Äî" });
        box.background = Color(0.95, 0.98, 1.0, 0.85);
        box.editable = false;
        box.hasVerticalScroller = true;
        box
    }).bounds = Rect(x, y, w, h);

    mkOrGetView.(win, key, { |parent| TextView(parent) }).string = text.size > 0.if({ text }, { "‚Äî" });
    mkOrGetView.(win, key, { |parent| TextView(parent) }).front;
};

adoptPerfHUD = {
    var win;
    win = findHudWindow.();
    if(win.isNil) {
        "HUD adapter: no MagicDisplayGUI window found (PerfHUD expected).".warn;
        ^nil
    };

    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            setSolidHighlight.(win, which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            setStatusText.(win, text.asString);
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            setChoicesText.(win, lines ? []);
            nil
        })
    };
    "HUD adapter: PerfHUD overlays installed (solid A/B, status, choices).".postln;
};

// ---- Install adapter ---------------------------------------------------------
AppClock.sched(0.00, {
    var win;
    win = findHudWindow.();

    // Prefer GridDemo if controller is present and methods exist
    if(isGridDemo.()) {
        adoptGridDemo.();
    }{
        // Otherwise, adopt PerfHUD (overlays) if its window exists
        if(win.notNil) {
            adoptPerfHUD.();
        }{
            "HUD adapter: no GUI found yet; will try again shortly.".warn;
            AppClock.sched(0.10, {
                var win2 = findHudWindow.();
                if(isGridDemo.()) { adoptGridDemo.() } { if(win2.notNil) { adoptPerfHUD.() } };
                nil
            });
        };
    };
    nil
});
)

===== troubleshooting/01b_StartHere_NoReboot copy.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.2
// MD 20250929-0918

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

//new
~gui = Window.allWindows.detect { |w| w.name.asString.beginsWith("MagicDisplayGUI") };

ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_StartHere_NoReboot.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)

===== troubleshooting/01b_StartHere_NoRebootBROKEN.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-11:46

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoid reboot races; opens the single GUI window; enables GUI taps.
// - Force GridDemo for these tests (PerfHUD pulses and lacks setOperations).
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef, pedalboardRef, guiRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, closeMagicDisplayWindows;
var installGridDemo, bindDisplay, afterBringUp;

// ---------- helpers ----------

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0).source.isNil)    { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, { // neutral; 02D will replace with centered pulses
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, 0.0)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

closeMagicDisplayWindows = {
    var wins = Window.allWindows.select({ |w|
        var nm = w.tryPerform(\name) ? "";
        nm.asString.beginsWith("MagicDisplayGUI")
    });
    AppClock.sched(0.00, { wins.do(_.close); nil });
};

installGridDemo = {
    // Create GridDemo and publish it
    AppClock.sched(0.05, {
        guiRef = MagicDisplayGUI_GridDemo.new;        // <- concrete GUI
        ~gui   = guiRef;                               // publish for step scripts
        // if LPS carries the variable, update it too (it‚Äôs a <> ivar, settable)
        if(systemRef.notNil and: { systemRef.respondsTo(\statusDisplay_) }) {
            systemRef.statusDisplay_(guiRef);
        };
        // bind display to pedalboard if possible
        bindDisplay.value;
        // meters off->on to ensure responders
        if(guiRef.respondsTo(\enableMeters)) { guiRef.enableMeters(false); guiRef.enableMeters(true) };
        guiRef.showExpectation("System ready.", 0);
        guiRef.window.front.alwaysOnTop_(true);
        nil
    });
};

bindDisplay = {
    pedalboardRef = systemRef.pedalboard;
    if(pedalboardRef.notNil and: { pedalboardRef.respondsTo(\setDisplay) } and: { guiRef.notNil }) {
        pedalboardRef.setDisplay(guiRef);
    };
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll;            // this may load PerfHUD if present
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    // Note: when PerfHUD is used, statusDisplay stays nil; we‚Äôll force GridDemo next.
};

afterBringUp = { |lps|
    // Route short canonicals via adapter + post-switch meter re-arm
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };

    // If PerfHUD window was created, close it and switch to GridDemo
    AppClock.sched(0.05, {
        var win = findMagicDisplayWindow.();
        // If bringUpAll used PerfHUD, LivePedalboardSystem.statusDisplay is nil.
        if(lps.statusDisplay.isNil) {
            // Close the PerfHUD window (title contains "Performance HUD")
            if(win.notNil and: { win.name.asString.contains("Performance HUD") }) { win.close };
            installGridDemo.value; // create GridDemo, publish ~gui, bind to pedalboard
        } {
            // We already have a GUI object (GridDemo path)
            guiRef = lps.statusDisplay; ~gui = guiRef; bindDisplay.value;
            guiRef.window.front.alwaysOnTop_(true);
        };
        nil
    });
};

// ---------- run ----------

ensureAudioProxies.value;
startSystem.value;       // creates LPS + MPB; may open PerfHUD
closeMagicDisplayWindows.value;  // ensure only one window survives (we‚Äôll reinstall)
afterBringUp.(systemRef);
)

===== troubleshooting/01b.1_HUD_Ensure_GridDemo.scd =====
// 01b.1_HUD_Ensure_GridDemo.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Close any existing MagicDisplayGUI windows (including PerfHUD) and bring up GridDemo
   so highlighting is NON-PULSING.
 - Set ~gui to the GridDemo controller and front the window.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeWindows, bringGrid, frontIt;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller object (not a Window)
};

frontIt = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA); // make it obvious we‚Äôre on A
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo_v0.1.0.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemoREJECTED.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01c_PerfHUD_CompatAdapter.scd =====
//////////////////////////////////////////////////////////////
// 01c_PerfHUD_CompatAdapter.scd
// v0.9.0  MD 2025-09-29 12:35
//
// Purpose
// - Add a minimal, GridDemo-compatible layer on top of the existing
//   PerfHUD window (meters/layout unchanged).
// - Provide these helpers for test scripts:
//     ~hud_highlightCurrentColumn.(\chainA | \chainB)  // solid, no pulse
//     ~hud_showExpectation.("text", secs?)             // top status line
//     ~hud_updateTextField.(\state, "text")            // compat alias
//     ~hud_setOperations.([ "fret 3 ‚Üí add", "fret 5 ‚Üí ‚Ä¶" ])
//
// Style
// - var-first; descriptive names; AppClock-only for UI; no server.sync.
// - Nil-safe: aborts cleanly if no PerfHUD window is found.
// - Does NOT modify PerfHUD's own ticker; simply draws opaque overlays.
//
(
var win, host, hasWindow, ensureOverlays, relayoutOverlays;
var overlayLeft, overlayRight, statusLabel, choicesText;
var drawSolidA, drawSolidB, setStatus, setChoices, attachResize;

////////////////////////////////////////////////////////////
// 0) Find the PerfHUD window synchronously
win = ~gui;   // you already set this in 01b; it prints as a Window
hasWindow = win.notNil and: { win.isKindOf(Window) };
if(hasWindow.not) {
    "PerfHUD_CompatAdapter: ~gui is not a Window; aborting adapter.".warn;
    ^nil;
};

// Root view of the window
host = win.tryPerform(\view);
if(host.isNil) {
    "PerfHUD_CompatAdapter: window has no .view; aborting adapter.".warn;
    ^nil;
};

////////////////////////////////////////////////////////////
// 1) Create overlays (idempotent)
ensureOverlays = {
    var b, halfW, pad, topY, colH, rightX, rightW;
    b = host.bounds;  // Rect in UI coords (origin at top-left in View)
    pad = 8;
    halfW = (b.width / 2).asInteger;

    // reserve a small top bar for status
    topY = pad;
    // columns height = full minus top/status area and a small bottom pad
    colH = (b.height - (pad*3) - 180).max(40);

    // LEFT column overlay (Chain A)
    overlayLeft = overlayLeft ?? { CompositeView(host) };
    overlayLeft.bounds = Rect(pad, topY + 28, halfW - (pad*1.5), colH);
    overlayLeft.background = Color(0.85, 1.0, 0.85, 1.0);  // ACTIVE-green
    overlayLeft.visible = false; // default off; we turn it on in highlight
    overlayLeft.front;

    // RIGHT column overlay (Chain B)
    rightX = halfW + (pad * 0.5);
    rightW = b.width - rightX - pad;
    overlayRight = overlayRight ?? { CompositeView(host) };
    overlayRight.bounds = Rect(rightX, topY + 28, rightW, colH);
    overlayRight.background = Color(0.85, 1.0, 0.85, 1.0);
    overlayRight.visible = false;
    overlayRight.front;

    // STATUS label at very top (compatible with showExpectation / updateTextField(\state))
    statusLabel = statusLabel ?? { StaticText(host) };
    statusLabel.bounds = Rect(pad, pad, b.width - (pad*2), 22);
    statusLabel.align = \center;
    statusLabel.stringColor = Color.black;
    statusLabel.string = "Ready";
    statusLabel.front;

    // CHOICES text (right side, under the status bar)
    choicesText = choicesText ?? { TextView(host) };
    choicesText.bounds = Rect(halfW + (pad * 0.5), overlayRight.bounds.top - 22, rightW, 160);
    choicesText.editable = false;
    choicesText.hasVerticalScroller = true;
    choicesText.background = Color(0.97, 0.97, 0.97);
    choicesText.string = ""; // empty until setOperations call
    choicesText.front;
};

relayoutOverlays = {
    AppClock.sched(0.0, { ensureOverlays.value; nil });
};

////////////////////////////////////////////////////////////
// 2) Small helpers used by the tests (GridDemo-compatible)

drawSolidA = { // solid ACTIVE on A
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = true;
        overlayRight.visible = false;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

drawSolidB = { // solid ACTIVE on B
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = false;
        overlayRight.visible = true;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

setStatus = { |textString = "Ready", seconds = 0|
    AppClock.sched(0.0, {
        ensureOverlays.value;
        statusLabel.string = textString.asString;
        nil
    });
};

setChoices = { |itemsArray|
    var s;
    s = (itemsArray ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        ensureOverlays.value;
        choicesText.string = (s.size > 0).if({ s }, { "‚Äî" });
        choicesText.scrollToTop;
        nil
    });
};

////////////////////////////////////////////////////////////
// 3) Public tilde helpers (what your 02B / 02F will call if ~gui lacks methods)

~hud_highlightCurrentColumn = { |which|
    var w = (which ? \chainA).asSymbol;
    if(w == \chainA) { drawSolidA.value } { drawSolidB.value };
};

~hud_showExpectation = { |text, secs = 0| setStatus.value(text, secs) };

~hud_updateTextField = { |keySym, valueText|
    var k = keySym.asSymbol;
    if(k == \state) { setStatus.value(valueText.asString, 0) }
    { /* ignore other keys for now; extend later if needed */ };
};

~hud_setOperations = { |itemsArray| setChoices.value(itemsArray) };

////////////////////////////////////////////////////////////
// 4) Keep overlays in place on window resize
attachResize = {
    var resizeFunc;
    resizeFunc = {
        relayoutOverlays.value;
        nil
    };
    win.onResize = { resizeFunc.value };
};

////////////////////////////////////////////////////////////
// 5) Go
ensureOverlays.value;
attachResize.value;
"PerfHUD_CompatAdapter installed: uses ~hud_* helpers (solid A/B + status + choices).".postln;
)

===== troubleshooting/01c_PerfHUD_CompatAdapter.scd_v0.1.1 =====
//////////////////////////////////////////////////////////////
// 01c_PerfHUD_CompatAdapter.scd  (patch: resize + layout guard)
// v0.1.1  MD 2025-09-29

(
var win, host, ensureOverlays, relayoutOverlays;

// 1) Find the PerfHUD window by its title prefix (unchanged)
win = Window.allWindows.detect({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
});

if (win.isNil) {
    "01c: PerfHUD window not found; compat overlay skipped.".warn;
    ^nil;
};

// 2) Always work off the TopView, not the Window
host = win.view;

// 3) Your existing overlay builders go here (unchanged)
ensureOverlays = {
    // create or fetch CompositeView/TextView/StaticText children under `host`
    // ‚Ä¶ your current code ‚Ä¶
};

// 4) Relayout uses host.bounds (view coords)
relayoutOverlays = {
    var b = host.bounds, w = b.width, h = b.height;
    ensureOverlays.value;
    // recompute bounds for your overlay views using w/h
    // ‚Ä¶ your current code ‚Ä¶
};

// 5) Do an initial layout on AppClock
AppClock.sched(0.00, { relayoutOverlays.value; nil });

// 6) Hook resize on the **view**, not the window
if (host.respondsTo(\onResize_)) {
    host.onResize_{ relayoutOverlays.value };
};
)

===== troubleshooting/02_ForceMeters_FromBuses.scd =====
// 02_ForceMeters_FromBuses.scd
// v0.1.1
// MD 20250928-1935

(
// Purpose
// - Bypass older meter paths. Tap Ndef buses directly and send on "/md/levels_bus".
// - Correct parsing: SendReply => msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R.
// Style
// - var-first; no server.sync; server ops in Server.default.bind.

var makeTapDefOnce, installBusTaps, installHudReceiver, aBus, bBus, tBus;

makeTapDefOnce = {
    SynthDef(\md_busTap2, { |inBus=0, rate=24, replyID=2001|
        var sig, aL, aR;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).clip(0, 1);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [aL, aR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap2 installed.".postln;
};

installBusTaps = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, aBus, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, bBus, \rate, 24, \replyID, 2002]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, tBus, \rate, 24, \replyID, 1001]);
        "üì° Bus taps active (A=2001 / B=2002 / Test=1001).".postln;
    });
};

installHudReceiver = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        var id, l, r;
        if(msg.size < 5) { nil } {
            id = msg[2].asInteger;         // 2001 / 2002 / 1001
            l  = msg[3].asFloat.clip(0,1); // left
            r  = msg[4].asFloat.clip(0,1); // right
            ~md_levelsById.put(id, [l, r]);
            ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] listening /md/levels_bus (key=md_levels_hud; ids 2001/2002/1001)".postln;
};

makeTapDefOnce.value;
installBusTaps.value;
installHudReceiver.value;
"‚úÖ Forced bus meters installed; HUD bridged to dict.".postln;
)

===== troubleshooting/02A_Sanity_Wire_ChainA.scd =====
// 02A_Sanity_Wire_ChainA.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Ensure a real, steady signal reaches Chain A‚Äôs bus; keep Chain B silent.
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainA) <<> Ndef(\testmelody);  // Chain A <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainA).play;   // run A
        Ndef(\chainB).stop;   // keep B off for clarity
    });
    "üîó Wired: testmelody -> chainA; chainA is playing (B is stopped).".postln;
};

link.value;
start.value;
)

===== troubleshooting/02A_Sanity_Wire_ChainB.scd =====
// 02A_Sanity_Wire_ChainB.scd
// v0.1.0
// MD 20250929-1010

(
// Purpose
// - Route the same centered pulse source to chainB and play B (A can remain on).
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainB) <<> Ndef(\testmelody);   // Chain B <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainB).play;                // run B
        // (leave A as-is; you can stop it if you want: Ndef(\chainA).stop)
    });
    "üîó Wired: testmelody -> chainB; chainB is playing.".postln;
};

link.value;
start.value;
)

===== troubleshooting/02B_ForceMeters_FromBuses_dB.scd =====
// 02B_ForceMeters_FromBuses_dB.scd
// v0.1.2
// MD 20250929-0838

(
// Purpose
// - Replace bus taps with server-side dB-mapped meters (‚àí60 dB -> 0.0, 0 dB -> 1.0).
// - Keep using the existing /md/levels_bus receiver (ids: 2001=A, 2002=B, 1001=test).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, replaceBusTaps_dB, aBus, bBus, tBus;

minDB = -60;  // raise to -48 or -42 if you want hotter bars

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);  // avoid -inf
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046;                           // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);                            // clamp to floor
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);              // map -60..0 -> 0..1
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);           // gentle smoothing
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

replaceBusTaps_dB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, tBus, \rate, 24, \replyID, 1001, \floorDB, minDB]);
    });
    ("üì° Bus taps replaced with dB mapping (floor = " ++ minDB.asString ++ " dB).").postln;
};

makeTapDefOnce.value;
replaceBusTaps_dB.value;
"‚úÖ 02B dB taps active; HUD continues on /md/levels_bus (md_levels_hud).".postln;
)

===== troubleshooting/02B_HUD_AB_StrictAOnly copy.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.3
// MD 20250929-1153

(
var gui, applySolidA;

gui = ~gui;

applySolidA = {
    // Prefer GridDemo API if present
    if(gui.notNil and: { gui.respondsTo(\highlightCurrentColumn) }) {
        gui.highlightCurrentColumn(\chainA);
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_highlightCurrentColumn.notNil) {
            ~hud_highlightCurrentColumn.(\chainA);
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0);
            };
        } {
            "02B: No HUD adapter (~hud_*) and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid highlight.
 - Optional: stop demo overlays/meters if those extensions are loaded.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, setSolidA;

gui = ~gui; // provided earlier in your run (01b_StartHere_NoReboot / HUD bring-up)

// do nothing if HUD missing
if(gui.isNil) { "02B_HUD_AB_StrictAOnly: ~gui is nil (skipping).".warn; ^nil; };

setSolidA = {
    // 1) Solid highlight on Chain A (GridDemo API)
    if(gui.respondsTo(\highlightCurrentColumn)) {
        gui.highlightCurrentColumn(\chainA);
    };

    // 2) Optional: stop demo visual drivers if present (extensions)
    if(gui.respondsTo(\testMeter_stop)) { gui.testMeter_stop };
    if(gui.respondsTo(\testMarker_clear)) { gui.testMarker_clear };

    // 3) Small confirmation in the status line
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
    };
};

// Schedule on AppClock to be safe for UI operations
AppClock.sched(0.0, { setSolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd =====
//02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd
//v0.2.0
//MD 20250929-13:05

/* Purpose
   - Show Chain A as ACTIVE with a solid highlight in the current HUD.
   - Works with either GridDemo controller (~gui respondsTo \highlightCurrentColumn)
     or the PerfHUD window (~gui is a Window) by drawing an overlay.
Style
   - var-first; AppClock-only UI; no server.sync; idempotent; single-window policy.
*/

(
var ensureGui, useGridDemo, usePerfHUD, makeOverlay, drawSolidA, win;

ensureGui = {
    if(~gui.isNil) {
        // Grab whichever MagicDisplayGUI window exists (likely PerfHUD)
        ~gui = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
    };
    if(~gui.isNil) { "02B: No MagicDisplayGUI window found.".warn; };
    win = if(~gui.isKindOf(Window)) { ~gui } { ~gui.tryPerform(\window) };
    if(win.notNil) { AppClock.sched(0.00, { win.front.alwaysOnTop_(true); nil }) };
};

useGridDemo = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
        if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };   // stop any demo meter overlay if present
        if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
        if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        ^true
    };
    ^false
};

// Draws/updates a translucent overlay on left or right half of the window.
makeOverlay = { |w|
    var root, ov, aTint, bTint;
    root = w.tryPerform(\view);
    if(root.isNil) { ^nil };

    ov = w.getProperty(\md_overlay);
    if(ov.isNil) {
        ov = CompositeView(root);
        ov.name_("MD_OVERLAY");
        ov.resize = 5; // eLeft + eTop + eRight + eBottom
        w.setProperty(\md_overlay, ov);
    };

    // two half-width child views: left = A, right = B
    aTint = w.getProperty(\md_overlay_A);
    if(aTint.isNil) {
        aTint = CompositeView(ov); aTint.name_("MD_OVERLAY_A");
        w.setProperty(\md_overlay_A, aTint);
    };
    bTint = w.getProperty(\md_overlay_B);
    if(bTint.isNil) {
        bTint = CompositeView(ov); bTint.name_("MD_OVERLAY_B");
        w.setProperty(\md_overlay_B, bTint);
    };

    // lay out halves
    ov.bounds = root.bounds;
    aTint.bounds = Rect(0, 0, ov.bounds.width/2, ov.bounds.height);
    bTint.bounds = Rect(ov.bounds.width/2, 0, ov.bounds.width/2, ov.bounds.height);

    // gentle green & neutral tints
    aTint.background = Color(0.85, 1.0, 0.85, 0.50);
    bTint.background = Color(0.92, 0.92, 0.92, 0.00); // start hidden
    ov.front;

    // keep overlay aligned on resize
    if(w.onResize.isNil) {
        w.onResize = {
            var rb = root.bounds;
            ov.bounds = rb;
            aTint.bounds = Rect(0, 0, rb.width/2, rb.height);
            bTint.bounds = Rect(rb.width/2, 0, rb.width/2, rb.height);
        };
    };
    ^w
};

drawSolidA = { |w|
    var ov, aTint, bTint;
    ov = w.getProperty(\md_overlay);
    if(ov.isNil) { makeOverlay.(w) };
    aTint = w.getProperty(\md_overlay_A);
    bTint = w.getProperty(\md_overlay_B);
    if(aTint.notNil) { aTint.background = Color(0.85, 1.0, 0.85, 0.50) };
    if(bTint.notNil) { bTint.background = Color(0.92, 0.92, 0.92, 0.00) };
};

AppClock.sched(0.00, {
    ensureGui.value;
    if(~gui.isNil) { ^nil };
    if(useGridDemo.value.not) {
        // PerfHUD path
        if(win.notNil) {
            makeOverlay.(win);
            drawSolidA.(win);
        };
    };
    nil
});
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_v0.1.4.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:05

/* Purpose
   - Force Chain A to display as ACTIVE with a solid, non-pulsing highlight.
   - Uses the HUD adapter if available (~hud_highlightCurrent), else tries GridDemo.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/

(
var apply;

apply = {
    if(~hud_highlightCurrent.notNil) {
        ~hud_highlightCurrent.(\chainA);
        if(~hud_showExpectation.notNil) { ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0) };
    }{
        // Fallback for raw GridDemo controller if adapter missing
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        }{
            "02B: No HUD adapter and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { apply.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid (non‚Äëpulsing) highlight.
 - If ~gui is nil, bring up GridDemo and set ~gui first (single window).
Style
 - var-first; AppClock UI; no server.sync; nil-safe responders; idempotent.
*/

(
var ensureGui, applySolidA;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

applySolidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
    };
    // Shut off any optional demo overlays if present (nil-safe)
    if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };
    if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
};

AppClock.sched(0.00, { ensureGui.value; applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_Receiver_dB_Map.scd =====
// 02B_HUD_Receiver_dB_Map.scd
// v0.1.1
// MD 20250928-2050

(
// Purpose
// - Reinstall the HUD OSCdef to read the *linear* bus taps from "/md/levels_bus"
//   and convert them to a log/decibel-like visual scale on the *language* side.
// - No UGens here; only language methods (known-good): .ampdb, .max, arithmetic.
// - Mapping: floor = -60 dB -> 0.0, 0 dB -> 1.0 (adjust floor as needed).
// Style
// - var-first; no server.sync; UI/OSC on language side; no non-local returns.

var key, minDB, mapToMeter;

// ---- settings ----
key   = \md_levels_hud;  // the same key PerfHUD expects
minDB = -60.0;           // raise to -48 or -42 if you want hotter-looking bars

// ---- mapping function (language side) ----
mapToMeter = { |amp|
    var db, v;
    // guard tiny values to avoid -inf
    db = amp.max(1e-9).ampdb;    // amp -> dB (language method)
    db = db.max(minDB);          // clamp floor
    // map -60..0 dB -> 0..1
    v = (db - minDB) / (0 - minDB);
    v.clip(0, 1)
};

// ---- reinstall the OSCdef safely ----
if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
~md_lastMsgStamp = SystemClock.seconds.asFloat;

OSCdef(key, { |msg|
    // SendReply -> msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R
    var id, lAmp, rAmp, l, r;
    if(msg.size >= 5) {
        id   = msg[2].asInteger;
        lAmp = msg[3].asFloat;
        rAmp = msg[4].asFloat;
        l = mapToMeter.(lAmp);
        r = mapToMeter.(rAmp);
        ~md_levelsById.put(id, [l, r]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);

("[HUD] md_levels_hud reinstalled (dB map; floor = " ++ minDB.asString ++ " dB)").postln;
)

===== troubleshooting/02B_Taps_dB_NoTest_and_HUD.scd =====
// 02B_Taps_dB_NoTest_and_HUD.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose
// - Install server-side dB-mapped taps for Chain A and Chain B only (no "test").
// - Reinstall the HUD receiver to read "/md/levels_bus" and update dict keys:
//   2001 (A) and 2002 (B).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, installBusTaps_dB_AB, installHudReceiver_AB, aBus, bBus;
minDB = -60;  // try -48 for hotter visuals

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046; // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "üîß SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

installBusTaps_dB_AB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        "üì° Bus taps (dB) active for A/B only (floor=" ++ minDB.asString ++ " dB).".postln;
    });
};

installHudReceiver_AB = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        // SendReply => [ path, nodeID, replyID, L, R ]
        var id, l, r;
        if(msg.size >= 5) {
            id = msg[2].asInteger;          // 2001 or 2002
            if((id == 2001) or: { id == 2002 }) {
                l = msg[3].asFloat.clip(0,1);
                r = msg[4].asFloat.clip(0,1);
                ~md_levelsById.put(id, [l, r]);
                ~md_lastMsgStamp = SystemClock.seconds.asFloat;
            };
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] md_levels_hud listening on /md/levels_bus (A/B only).".postln;
};

makeTapDefOnce.value;
installBusTaps_dB_AB.value;
installHudReceiver_AB.value;
"‚úÖ dB taps installed and HUD receiver set (A=2001, B=2002).".postln;
)

===== troubleshooting/02C_Testmelody_Level_Boost.scd =====
// 02C_Testmelody_Level_Boost.scd
// v0.1.0
// MD 20250928-2015
(
// Purpose: temporarily raise testmelody output so meters are clearly visible.
// Style: var-first; server ops in Server.default.bind.

var boost;
boost = {
    Server.default.bind({
        // Reinstall the same testmelody with a slightly higher amp (0.22 -> 0.40)
        Ndef(\testmelody, {
            var trig = Impulse.kr(2.4);
            var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
            var scale = [60, 62, 64, 67, 69];
            var f = Select.kr(sel, scale).midicps;
            var env = Decay2.kr(trig, 0.01, 0.35);
            var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
            Pan2.ar(SinOsc.ar(f) * env * 0.40, pan)  // <-- boosted
        });
    });
    "‚¨ÜÔ∏è testmelody amp boosted (0.40).".postln;
};
boost.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02E_Meter_Floor_Adjust.scd =====
// 02E_Meter_Floor_Adjust.scd
// v0.1.0
// MD 20250929-0912

(
// Purpose
// - Adjust the dB floor used by the md_busTap_db Synths on the fly.
// - Example sets floor to -48 dB (hotter visuals). Re-run with -60 to restore.
// Style
// - var-first; server ops in Server.default.bind.

var setFloorDB;

setFloorDB = { |floorDB = -48|
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.set(\floorDB, floorDB) };
        if(~md_busTapB.notNil) { ~md_busTapB.set(\floorDB, floorDB) };
        if(~md_busTapT.notNil) { ~md_busTapT.set(\floorDB, floorDB) };
    });
    ("üìè Meter floor set to " ++ floorDB.asString ++ " dB").postln;
};

// Try -48 for a start, or -42 if you want it hotter:
setFloorDB.(-48);
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming copy.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.0
// MD 20250929-1121

/* Purpose
   - Write demo "system state", "choices", and "incoming" text into the existing HUD window.
   - Use the GUI's public API if available:
       showExpectation(String, Int)
       updateTextField(\state | \choices | \lastCommand, String)
   - No server changes; AppClock-only for UI.
   - var-first; lowercase; no server.sync.
*/

(
var g, have, pushStatus, pushChoices, pushIncoming;

g = ~system.notNil.if({ ~system.statusDisplay }, { nil }); // prefer your system GUI if present
have = { |selector| g.notNil and: { g.respondsTo(selector) } };

pushStatus = {
    var text;
    text = "State: serverRunning=true, activeChain=A (demo)\nGroups=(true,true)";
    if(have.(\updateTextField)) { g.updateTextField(\state, text) };
    if(have.(\showExpectation)) { g.showExpectation("System ready ‚Äî demo text injected", 0) };
};

pushChoices = {
    var txt;
    txt = "Choices:\nFret 7: delay\nFret 9: chorus\nFret 11: reverb\nFret 13: drive";
    if(have.(\updateTextField)) { g.updateTextField(\choices, txt) };
};

pushIncoming = {
    var txt;
    txt = "Incoming: key:a ‚Ä¢ key:b ‚Ä¢ key:r (rebuild)";
    if(have.(\updateTextField)) { g.updateTextField(\lastCommand, txt) };
};

// Defer UI calls to AppClock
{
    pushStatus.();
    pushChoices.();
    pushIncoming.();
}.defer;

"[*] 02F: demo HUD text pushed (state/choices/incoming)".postln;
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Write demo text to the HUD (state / choices / incoming).
 - Uses the public GridDemo API: showExpectation/updateTextField/setOperations.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, pushStateAndChoices;

gui = ~gui; // should be set by your earlier HUD bring-up step

if(gui.isNil) { "02F_HUD: ~gui is nil (skipping).".warn; ^nil; };

pushStateAndChoices = {
    // 0) (Optional) ensure the Choices panel exists (extension is nil-safe)
    if(gui.respondsTo(\ensureChoicesPanel)) { gui.ensureChoicesPanel };

    // 1) Top status / state line
    if(gui.respondsTo(\updateTextField)) {
        gui.updateTextField(\state, "Mode: treeNav ¬∑ A=ACTIVE");
    } {
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("Mode: treeNav ¬∑ A=ACTIVE", 0);
        };
    };

    // 2) Choices list (each line = ‚Äúfret ‚Üí name‚Äù)
    if(gui.respondsTo(\setOperations)) {
        gui.setOperations([
            "fret 3 ‚Üí add",      // example entries; replace with your actual current node‚Äôs options
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ]);
    };

    // 3) ‚ÄúIncoming‚Äù (GridDemo doesn‚Äôt have a dedicated box; use status line)
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("Incoming: demo-key:a ¬∑ demo-key:r", 0);
    };
};

// Defer to AppClock for UI safety
AppClock.sched(0.0, { pushStateAndChoices.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.3.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.3
// MD 2025-09-29 12:35

(
var gui, pushHUD;

gui = ~gui;

pushHUD = {
    var choicesLines;
    choicesLines = [
        "fret 3 ‚Üí add",
        "fret 5 ‚Üí timebased",
        "fret 7 ‚Üí modulation",
        "fret 9 ‚Üí filter"
    ];

    // Prefer GridDemo API
    if(gui.notNil and: { gui.respondsTo(\updateTextField) or: { gui.respondsTo(\showExpectation) } }) {
        if(gui.respondsTo(\updateTextField)) {
            gui.updateTextField(\state, "Mode: treeNav ¬∑ A=ACTIVE");
        } {
            gui.showExpectation("Mode: treeNav ¬∑ A=ACTIVE", 0);
        };
        if(gui.respondsTo(\setOperations)) {
            gui.setOperations(choicesLines);
        } {
            // fallback to status if no choices panel in that class
            gui.showExpectation("Choices:\n" ++ choicesLines.join("\n"), 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_updateTextField.notNil) {
            ~hud_updateTextField.(\state, "Mode: treeNav ¬∑ A=ACTIVE");
        } { if(~hud_showExpectation.notNil) { ~hud_showExpectation.("Mode: treeNav ¬∑ A=ACTIVE", 0) } };
        if(~hud_setOperations.notNil) {
            ~hud_setOperations.(choicesLines);
        } {
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("Choices:\n" ++ choicesLines.join("\n"), 0);
            };
        };
    };
};

AppClock.sched(0.0, { pushHUD.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.4.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Write demo text to the HUD via the overlay helpers created by 02H:
   ‚Ä¢ STATE line
   ‚Ä¢ CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
 - Assumes 02H_GridDemo_MinHUD_Overlay.scd has already run in this session.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    // If overlay is missing for any reason, create it on the fly:
    if(~gui.isNil or: { ~gui.tryPerform(\window).isNil }) {
        // fall back to GridDemo and create overlay
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    // If helper funcs don‚Äôt exist yet, synthesize the minimal overlay now:
    if(~hud_setState.isNil or: { ~hud_setChoices.isNil }) {
        // create a tiny overlay inline (same as 02H but shorter)
        var host, r, panel, stateBox, choicesBox, pad = 8, width = 360, height = 220, titleH = 18;

        host = ~gui.tryPerform(\window).tryPerform(\view);
        r = host.bounds;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.30);
        panel.bounds = Rect(r.width - (width + 12), 12, width, height);

        StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
            .stringColor_(Color(1,1,1,0.8))
            .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color.white)
            .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
            .font_(Font("Monaco", 11))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color(0.95,0.95,0.95))
            .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ‚Äî‚Äî‚Äî Actual demo content push ‚Äî‚Äî‚Äî
    ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE");
    ~hud_setChoices.([
        "fret 3 ‚Üí add",
        "fret 5 ‚Üí timebased",
        "fret 7 ‚Üí modulation",
        "fret 9 ‚Üí filter"
    ]);
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.5
// MD 2025-09-29 13:28 BST

/* Purpose
 - Write demo text to the HUD via overlay helpers created by 02H/02M:
   ‚Ä¢ STATE line
   ‚Ä¢ CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    var host, overlay;

    // Ensure ~gui and overlay exist
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });

    if(overlay.isNil) {
        // run 02H inline if needed (minimal version)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;
        r = host.bounds; width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ‚Äî‚Äî‚Äî Actual content push ‚Äî‚Äî‚Äî
    (~hud_setState !? { ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 ‚Üí add",
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ])
    });
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.0.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.0
// MD 20250929-1310

/* Purpose
   - Add a small overlay HUD panel (STATE + CHOICES) on top of GridDemo,
     without using GridDemo's internal ivars/methods (which are erroring in your build).
   - Export two helpers: ~hud_setState.(textString), ~hud_setChoices.([lines]).
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

// 1) Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

// 2) Remove any previous overlay if re-running
killOld = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

// 3) Create a small overlay panel at top-right
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds; // Rect
    width  = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30); // transparent dark
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    // 3a) Export helpers
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

// 4) Front and banner
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.1.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Add a small overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs ivars or buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.2.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs private ivars or its buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

/* Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller */
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

/* Remove any previous overlay if re-running */
killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

/* Create overlay at top-right (compact; draws above other widgets) */
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox;
    var pad, width, height, titleH, stateH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 320;          // narrower to avoid covering A/B headers
    height = 170;         // shorter; room for 5‚Äì7 lines
    pad = 8;
    titleH = 16;
    stateH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.28);         // translucent dark
    panel.decorator = FlowLayout(panel.bounds, 0@0, 0@0); // keeps children stable
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front; // ensure on top
    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.82))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 10))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.93,0.93,0.93))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + pad)
        ));

    // Export helpers:
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };

    positionTopRight = { arg margin = 10;
        var rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

/* Re-anchor overlay on window resize */
hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = {
            (~hud_moveTopRight !? { ~hud_moveTopRight.(10) });
        };
    };
};

/* Bring to front and seed banner */
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.3
// MD 2025-09-29 13:42 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo‚Äôs privates. Uses StaticText for guaranteed visibility.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

mkOverlay = {
    var host, r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360;                       // room for multi-line CHOICES
    height = 190;                      // compact but readable
    pad = 8;
    titleH = 16;
    stateH = 18;
    lineH = 14;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front;

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateLabel = StaticText(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.95))
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesLabel = StaticText(panel)
        .string_("CHOICES:")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH));

    choicesBox = StaticText(panel)
        .string_("(choices)")
        .align_(\topLeft)
        .font_(Font("Monaco", 10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6 + lineH + 2,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
        ));

    // ‚Äî‚Äî‚Äî Helpers (exported) ‚Äî‚Äî‚Äî
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, {
            stateLabel.string = textString.asString;
            nil
        });
    };

    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, {
            choicesBox.string = s.size > 0 ? s : "‚Äî";
            nil
        });
    };

    positionTopRight = { arg margin = 10;
        var rb;
        rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = { (~hud_moveTopRight !? { ~hud_moveTopRight.(10) }) };
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
    (~hud_setChoices !? { ~hud_setChoices.(["(no choices yet)"]) });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar_v0.1.0.scd =====
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.0
// MD 20250929-1258

/* Purpose
   - Attach tiny A/B bus meters to your existing taps (A=2001, B=2002)
     so GridDemo can display a moving meter bar via its TestMeter extension.
   - Then show a small horizontal "debug meter" inside the right panel, driven by /ampA.
Style
   - var-first; AppClock UI; Server.default.bind for server ops; no server.sync; idempotent.
*/

(
var aBus, bBus, mkMeters, showBar, killOld, ensureGui;

aBus = 2001;  // from your tap step (see console)
bBus = 2002;  // from your tap step (see console)

/* 0) Ensure we have a GridDemo GUI controller (non-pulsing)
      If you prefer PerfHUD for this run, skip this ensure block.
*/
ensureGui = {
    if(~gui.isNil) {
        // keep only one MagicDisplayGUI window
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

/* 1) Clean previous meter synths if we re-run */
killOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

/* 2) Create meter synths that publish /ampA and /ampB
      MagicDisplay already defines SynthDefs \busMeterA / \busMeterB (class init).
      We just need to instantiate them on our tap busses.
*/
mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // ‚Üí sends /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // ‚Üí sends /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

/* 3) Show a small moving meter bar in GridDemo (right panel, near 'eff:')
      Uses GridDemo‚Äôs TestMeter extension (if present). Safe if absent.
*/
showBar = {
    if(~gui.notNil and: { ~gui.respondsTo(\testMeter_attach) }) {
        // show chain A level; change to \B to view next chain
        ~gui.testMeter_attach(\A);
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensureGui.value;
killOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar.scd =====
//////////////////////////////////////////////////////////////
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.1
// MD 20250929-13:02
/* Purpose
   - Attach meter Synths to tap busses (A=2001, B=2002), emitting /ampA,/ampB.
//  - Display a small moving bar inside GridDemo (right panel) via TestMeter ext.
Style
   - var-first; Server.default.bind for synths; AppClock for UI; no server.sync.
*/

(
var aBus, bBus, mkMeters, stopOld, showBar, ensure;

aBus = 2001;  bBus = 2002;

ensure = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

stopOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // ‚Üí /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // ‚Üí /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

showBar = {
    if(~gui.respondsTo(\testMeter_attach)) {
        ~gui.testMeter_attach(\A);   // or \B to view NEXT
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensure.value;
stopOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.0.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.0
// MD 20250929-13:10

/* Purpose
   - Show a simple horizontal meter bar driven by your existing taps (A=2001, B=2002).
   - Avoid GridDemo TestMeter extension (which warns and OOC-returns in your build).
   - Instantiates \busMeterA / \busMeterB Synths if needed and listens to /ampA or /ampB.
Style
   - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, ensureSynths, killOld, mkBar, ampKey, oscKey;

aBus = 2001;  bBus = 2002;
whichChain = \A; // change to \B if you want to view NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        if(host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).not) {
            // bring up overlay if missing
            "02M: Overlay missing; creating‚Ä¶".postln;
            thisProcess.interpreter.executeFile(
                Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd"
            )
        };
    };
};

killOld = {
    // free previous synths + OSCdefs + view if re-running
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        // Define/instantiate lightweight bus meters (MagicDisplay provides the SynthDefs)
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };

    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    // OSC driver (choose /ampA or /ampB)
    ampKey = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey = ("mdg_simple_" ++ ampKey.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampKey);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.1.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Display a simple horizontal meter bar in the overlay, driven by your existing taps.
 - Uses MagicDisplay‚Äôs \busMeterA/\busMeterB SynthDefs (SendReply ‚Üí /ampA,/ampB).
 - Avoids GridDemo‚Äôs TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, ampPath, oscKey;

aBus = 2001;  // your tap buses (confirmed by console)
bBus = 2002;
whichChain = \A; // change to \B if you prefer watching NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, hasOverlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    hasOverlay = host.notNil and: { host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }) };
    if(hasOverlay.not) {
        // create overlay on the spot
        (
            var r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
            r = host.bounds; width = 360; height = 220; pad = 8; titleH = 18;
            panel = CompositeView(host).name_("MDG_MINHUD");
            panel.background = Color(0,0,0,0.30);
            panel.bounds = Rect(r.width - (width + 12), 12, width, height);
            title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
                   .stringColor_(Color(1,1,1,0.8)).bounds_(Rect(pad, pad, width - 2*pad, titleH));
            stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
                       .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                       .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));
            choicesBox = TextView(panel).string_("(choices)").editable_(false)
                         .font_(Font("Monaco", 11)).background_(Color(0,0,0,0.10))
                         .stringColor_(Color(0.95,0.95,0.95))
                         .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));
            ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
            ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                                AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        );
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Display a simple horizontal meter bar in the MIN-HUD overlay, driven by your taps.
 - Uses MagicDisplay‚Äôs \busMeterA/\busMeterB SynthDefs (SendReply ‚Üí /ampA,/ampB).
 - Avoids GridDemo‚Äôs TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain;
var ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, startOsc;

aBus = 2001;            // confirmed by your taps step
bBus = 2002;
whichChain = \A;        // set to \B to watch NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        // Create overlay quickly (same geometry as 02H)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;

        r = host.bounds;
        width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        ~hud_moveTopRight = { arg margin = 10;
            AppClock.sched(0.0, { panel.bounds = Rect(r.width - (width + margin), margin, width, height); panel.front; nil })
        };
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

startOsc = {
    var ampPath, oscKey;
    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; startOsc.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleMeters_FromOSC.scd =====
// 02M_GridDemo_SimpleMeters_FromOSC.scd
// v0.2.0
// MD 2025-09-29 13:42 BST

/* Purpose
 - Show a simple horizontal meter bar in the MIN-HUD overlay, driven directly by existing OSC taps.
 - Listens to any of these (whichever arrives first will drive the bar): /md/levels_gui, /md/levels, /ampA, /ampB.
 - Defaults to CURRENT (A). Set whichChain = \B to monitor NEXT instead.
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var whichChain, ensureGui, ensureOverlay, killOld, mkBar, startListeners, parseMsg, pickVal;

whichChain = \A;   // change to \B if you want NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        "02M: creating overlay (02H inline)".postln;
        thisProcess.interpreter.executeFile(Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd");
    };
};

killOld = {
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free; ~mdg_meterOSC_A = nil };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free; ~mdg_meterOSC_B = nil };
    if(~mdg_meterView.notNil)  { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 16;  // thicker bar

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

// Extract a normalized 0..1 value from a variety of message shapes
pickVal = { arg msg, wantB = false;
    var floats, vL, vR, v;
    // Common shapes:
    //  - ['/ampA', node, l, r] or ['/ampB', node, l, r]
    //  - ['/md/levels_gui', ..., lA, rA, lB, rB] (varies by sender)
    //  - ['/md/levels', ..., numbers...]         (varies by sender)
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        // Heuristic: last 4 floats are usually [lA, rA, lB, rB] (sanitised)
        if(floats.size >= 4) {
            if(wantB.not) {
                vL = floats.at(floats.size - 4);
                vR = floats.at(floats.size - 3);
            }{
                vL = floats.at(floats.size - 2);
                vR = floats.at(floats.size - 1);
            };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            // Fallback: mean of all floats
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startListeners = {
    var wantB, pathA1, pathA2, pathB1, pathB2, chainLabel;
    wantB = (whichChain == \B);
    chainLabel = (wantB.not).if({ "A" }, { "B" });

    pathA1 = (wantB.not).if({ '/ampA' }, { '/ampB' });
    pathA2 = (wantB.not).if({ '/md/levels_gui' }, { '/md/levels_gui' }); // we filter in pickVal
    pathB1 = (wantB.not).if({ '/ampA' }, { '/ampB' });  // both defs update same var
    pathB2 = (wantB.not).if({ '/md/levels' }, { '/md/levels' });

    // Free any previous listeners
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free };

    // Listener 1: /ampA or /ampB
    ~mdg_meterOSC_A = OSCdef(("mdg_meter_" ++ pathA1.asString).asSymbol, { |msg|
        var raw, sm;
        raw = pickVal.(msg, wantB);
        sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        ~mdg_meterVal = sm;
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, pathA1);

    // Listener 2: /md/levels_gui and /md/levels
    ~mdg_meterOSC_B = OSCdef(("mdg_meter_mix").asSymbol, { |msg|
        var raw, sm;
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            raw = pickVal.(msg, wantB);
            sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            ~mdg_meterVal = sm;
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // nil path: catch-all, we'll filter inside
    // Note: if the catch-all is too broad, change to two OSCdef with explicit paths.
    ("02M: meter listening for chain " ++ chainLabel ++ " on /ampA/B + /md/levels(_gui)").postln;
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    mkBar.value;
    startListeners.value;
    nil
});
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd =====
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap.scd =====
// 02S_AssertStereo_ChainAB_and_Retap.scd
// v0.1.0
// MD 20250929-0948

(
// Purpose
// - Force chainA/chainB to allocate *stereo* busses, then rewire A and reattach dB taps.
// - Clears stale 1001 (‚Äútest‚Äù) dict entry so HUD only shows A/B.
// Style
// - var-first; server ops in Server.default.bind.

var makeStereoBusses, rewireA, restartTaps, clearOldTestDict;

makeStereoBusses = {
    Server.default.bind({
        // Force stereo allocation by setting explicit stereo sources first
        Ndef(\chainA, { Silent.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { Silent.ar(2) }); Ndef(\chainB).ar(2);
        // Materialize bus width
        Ndef(\chainA).play;
        Ndef(\chainB).stop;
    });
    "üõ†Ô∏è Stereo busses asserted for chainA/chainB.".postln;
};

rewireA = {
    // Keep your exact operator
    Ndef(\chainA) <<> Ndef(\testmelody);
    "üîó Rewired: testmelody -> chainA.".postln;
};

restartTaps = {
    // Reinstall dB taps using existing SynthDef \md_busTap_db
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainA).bus.index, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainB).bus.index, \rate, 24, \replyID, 2002]);
    });
    "üì° dB taps restarted on asserted stereo busses (A/B).".postln;
};

clearOldTestDict = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_levelsById.removeAt(1001);  // remove ‚Äútest‚Äù so HUD can‚Äôt mirror it
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
};

makeStereoBusses.value;
rewireA.value;
restartTaps.value;
clearOldTestDict.value;

"‚úÖ Stereo confirmed, taps reattached. Expect both A bars moving, B near zero.".postln;
)

===== troubleshooting/03_Sanity_Beep.scd =====
// 03_Sanity_Beep.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose: Prove server + audio device are OK (audible 1-second beep).
// Style: var-first; no server.sync.

var playBeep;

playBeep = {
    if(s.serverRunning.not) { s.boot; s.waitForBoot({ "üîÅ Server booted for beep.".postln; }) };
    {
        var env = Env.perc(0.005, 0.9).ar(doneAction:2);
        var sig = SinOsc.ar(880) * 0.1 * env;
        Out.ar(0, sig.dup);
    }.play;
    "üîä Beep should be audible for ~1s.".postln;
};

playBeep.();
)

===== troubleshooting/04_Probes.scd =====
// 04_Probes.scd
// v0.1.0
// MD 20250928-1948

(
// A ‚Äî Dict snapshot used by the HUD (expect values < 1.0, changing)
var d = ~md_levelsById ? IdentityDictionary.new;
[1001, 2001, 2002].collect({ |k| [k, d[k]] }).postln;
)

(
// B ‚Äî Log a few /md/levels_bus messages (expect id, then two floats < 1.0)
~probeCount = 0;
if(OSCdef.all.at(\probe_levels_bus).notNil) { OSCdef(\probe_levels_bus).free };
OSCdef(\probe_levels_bus, { |msg|
    var id=msg[2], l=msg[3].asFloat, r=msg[4].asFloat;
    ("[bus] id=" ++ id.asString ++ " l=" ++ l.round(0.003) ++ " r=" ++ r.round(0.003)).postln;
    ~probeCount = (~probeCount ? 0) + 1;
    if(~probeCount >= 12) { OSCdef(\probe_levels_bus).free; "~probe done".postln; };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);
"probe armed /md/levels_bus".postln;
)

===== troubleshooting/98_PerfHUD_Triage_UIOnly.scd =====
// 98_PerfHUD_Triage_UIOnly.scd
// v0.1.0
// MD 2025-09-29 15:30 BST

/* Purpose
 - ZERO-OSC triage: prove we can paint + animate inside the PerfHUD window.
 - Draws a top RED banner, two wide bars near bottom; animates bars via AppClock.
 - Helpers:
     ~ui_wiggle_start.(\A or \B)   // start animation, tint active half
     ~ui_wiggle_stop.()            // stop + remove our overlays
Style
 - var-first; AppClock-only; idempotent; no server.sync; known-good SC API only.
*/

(
var findHudWin, findHost, debugPrintWindows, removeOverlays, makeBanner, makeBars, makeTint, startAnim, stopAnim;

// 0) enumerate windows for sanity
debugPrintWindows = {
    var names;
    names = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
    ("[triage] Windows: " ++ names).postln;
};

// 1) find the MagicDisplayGUI window and its host view
findHudWin = {
    var win;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    win
};

findHost = {
    var win, host, r;
    win = findHudWin.();
    if(win.isNil) { "[triage] MagicDisplayGUI window not found.".warn; ^nil };
    host = win.tryPerform(\view);
    r = host.tryPerform(\bounds);
    ("[triage] Host bounds: " ++ (r ? "<nil>")).postln;
    host
};

// 2) remove our overlays if present
removeOverlays = {
    var host;
    host = findHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["TRI_BANNER","TRI_BAR_A","TRI_BAR_B","TRI_TINT_A","TRI_TINT_B"].includes(n)
        }).do(_.remove);
    };
    if(~tri_task.notNil) { ~tri_task.stop; ~tri_task = nil };
    ~tri_valA = 0.0;
    ~tri_valB = 0.0;
};

// 3) big red banner at top (instant visual proof)
makeBanner = {
    var host, r, banner;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds;
    banner = UserView(host);
    banner.name = "TRI_BANNER";
    banner.bounds = Rect(0, 0, r.width, 18);
    banner.background = Color(1.0, 0.2, 0.2, 0.75); // red translucent
    banner.front;
    host.window.onResize = {
        var r2 = host.bounds;
        banner.bounds = Rect(0, 0, r2.width, 18);
        banner.refresh;
    };
    "[triage] Banner shown (top).".postln;
};

// 4) two wide bars near bottom (A green, B blue)
makeBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 12; h = 16; gap = 10;
    w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(30);
    yA = (yB - h - gap).max(10);

    barA = UserView(host);
    barA.name = "TRI_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.12);
    barA.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    barB = UserView(host);
    barB.name = "TRI_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.12);
    barB.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    host.window.onResize = {
        var r2, w2, yA2, yB2;
        r2 = host.bounds;
        w2 = (r2.width - (2*pad)).max(50);
        yB2 = (r2.height - pad - h).max(30);
        yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
    "[triage] Bars created (bottom).".postln;
};

// 5) translucent tint on left or right half to mark ACTIVE
makeTint = { arg which = \A;
    var host, r, midX, tintA, tintB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old
    host.children.select({ |v|
        var n = v.tryPerform(\name) ? "";
        ["TRI_TINT_A","TRI_TINT_B"].includes(n)
    }).do(_.remove);

    tintA = UserView(host);
    tintA.name = "TRI_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18);

    tintB = UserView(host);
    tintB.name = "TRI_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    host.window.onResize = {
        var r2 = host.bounds, mx = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx, r2.height);
        tintB.bounds = Rect(mx, 0, r2.width - mx, r2.height);
        tintA.refresh; tintB.refresh;
    };
    ("[triage] Active tint ‚Üí " ++ which.asString).postln;
};

// 6) animation (triangle wave) ‚Äî no OSC, UI-only
startAnim = { arg which = \A;
    var host, dt, t;
    host = findHost.(); if(host.isNil) { ^nil };

    removeOverlays.();
    makeBanner.();
    makeBars.();
    makeTint.(which);

    dt = 1/30; t = 0.0;
    ~tri_task = Task({
        loop {
            var a = (t % 1.0);   // 0..1 triangle
            var b = 1.0 - a;
            ~tri_valA = a;
            ~tri_valB = b;
            // refresh our bars only
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if((n == "TRI_BAR_A") or: { n == "TRI_BAR_B" }) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.6);
        }
    }).play(AppClock);

    "[triage] UI-only animation started.".postln;
};

stopAnim = {
    removeOverlays.();
    "[triage] UI-only animation stopped.".postln;
};

// Export helpers
~ui_wiggle_start = { arg which = \A; AppClock.sched(0.0, { debugPrintWindows.value; startAnim.(which); nil }) };
~ui_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };

"[triage] Ready: use ~ui_wiggle_start.(\\A) / ~ui_wiggle_stop.()".postln;
)

===== troubleshooting/99_HUD_GridDemo_OneShot.scd =====
// 99_HUD_GridDemo_OneShot.scd
// v0.1.1
// MD 2025-09-29 14:05 BST

/* Purpose
 - One-shot HUD bring-up for GridDemo (non-pulsing), replacing multiple files:
   ‚Ä¢ close old MagicDisplayGUI windows, bring up GridDemo, set ~gui
   ‚Ä¢ solid A highlight
   ‚Ä¢ overlay at top-right with STATE + CHOICES (StaticText only; guaranteed visible)
   ‚Ä¢ thicker moving meter bar driven by OSC taps (/ampA, /ampB, /md/levels_gui, /md/levels)
   ‚Ä¢ push demo STATE/CHOICES text
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns in closures.
Run
 - Run after audio/tap steps (e.g., after 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd).
 - To monitor NEXT (B) instead of CURRENT (A), set wantB = true below.
*/

(
var wantB;
var closeWindows, makeGridDemo, ensureReady, solidA, buildOverlay, pushDemoText;
var addMeterBar, startOscDefs, stopOldOscDefs, parseVal, retry;

// ===== CONFIG =====
wantB = false;  // false = monitor CURRENT (A); true = monitor NEXT (B)

// ===== HELPERS =====

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

makeGridDemo = {
    ~gui = MagicDisplayGUI_GridDemo.new;         // controller (not a Window)
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
};

ensureReady = { arg triesLeft = 20, thenDo = { } ;
    // Wait until ~gui.window.view is non-nil and has a Rect bounds
    AppClock.sched(0.03, {
        var win, host, ok;
        win = ~gui.tryPerform(\window);
        host = win.tryPerform(\view);
        ok = host.notNil and: { host.bounds.notNil };
        if(ok) { thenDo.value(host); nil } {
            if(triesLeft <= 0) { "99: window/view not ready; giving up.".warn; nil } {
                ensureReady.value(triesLeft - 1, thenDo);
            }
        }
    });
};

solidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) { ~gui.highlightCurrentColumn(\chainA) };
};

buildOverlay = { arg host;
    var r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    // Kill any old overlay
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);

    // Layout numbers (kept simple & safe)
    r = host.bounds;
    width = 360; height = 190;
    pad = 8; titleH = 16; stateH = 18; lineH = 14;

    panel = CompositeView(host);
    panel.name = "MDG_MINHUD";
    panel.background = Color(0,0,0,0.30);
    // no .border or decorators (avoids internal draw quirks)
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.front;

    title = StaticText(panel);
    title.string = "MIN-HUD";
    title.font   = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.85);
    title.bounds = Rect(pad, pad, width - 2*pad, titleH);

    stateLabel = StaticText(panel);
    stateLabel.string = "(state)";
    stateLabel.font   = Font("Monaco", 11);
    stateLabel.stringColor = Color(1,1,1,0.95);
    stateLabel.bounds = Rect(pad, pad + titleH + 4, width - 2*pad, stateH);

    choicesLabel = StaticText(panel);
    choicesLabel.string = "CHOICES:";
    choicesLabel.font   = Font("Monaco", 11);
    choicesLabel.stringColor = Color(1,1,1,0.85);
    choicesLabel.bounds = Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH);

    choicesBox = StaticText(panel);
    choicesBox.string = "(choices)";
    choicesBox.font   = Font("Monaco", 10);
    choicesBox.stringColor = Color(0.95,0.95,0.95);
    choicesBox.bounds = Rect(
        pad,
        pad + titleH + 4 + stateH + 6 + lineH + 2,
        width - 2*pad,
        height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
    );

    // Export helpers
    ~hud_setState = { arg s;
        AppClock.sched(0.0, { stateLabel.string = s.asString; nil });
    };
    ~hud_setChoices = { arg lines;
        var txt;
        txt = (lines ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = (txt.size > 0).if({ txt }, { "‚Äî" }); nil });
    };

    // Re-anchor after any resize
    if(~gui.respondsTo(\window)) {
        ~gui.window.onResize = {
            var rb = host.bounds;
            panel.bounds = Rect(rb.width - (width + 12), 10, width, height);
            panel.front;
        };
    };

    // Create thicker meter bar at bottom of the overlay
    addMeterBar.value(panel);
};

addMeterBar = { arg overlay;
    var bnds, pad, h, bar;

    bnds = overlay.bounds; pad = 8; h = 16;

    // Remove any previous bar if re-running
    overlay.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_SIMPLE_METER" }).do(_.remove);

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
    ~mdg_meterVal  = 0.0;
};

stopOldOscDefs = {
    if(~mdg_meterOSC_amp.notNil) { ~mdg_meterOSC_amp.free; ~mdg_meterOSC_amp = nil };
    if(~mdg_meterOSC_lvl.notNil) { ~mdg_meterOSC_lvl.free; ~mdg_meterOSC_lvl = nil };
};

parseVal = { arg msg, wantNext;
    var floats, vL, vR, v;
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        if(floats.size >= 4) {
            if(wantNext.not) { vL = floats.at(floats.size - 4); vR = floats.at(floats.size - 3) }
            { vL = floats.at(floats.size - 2); vR = floats.at(floats.size - 1) };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startOscDefs = {
    var wantNext, ampPath;
    wantNext = wantB;

    stopOldOscDefs.value;

    // 1) Prefer /ampA or /ampB if present (bus meters)
    ampPath = (wantNext.not).if({ '/ampA' }, { '/ampB' });
    ~mdg_meterOSC_amp = OSCdef(("mdg_meter_" ++ ampPath.asString).asSymbol, { |msg|
        var raw = parseVal.(msg, wantNext);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);

    // 2) Also listen to /md/levels_gui and /md/levels explicitly
    ~mdg_meterOSC_lvl = OSCdef(\mdg_meter_levels_mux, { |msg|
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            var raw = parseVal.(msg, wantNext);
            ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // catch all; we filter inside
    ("99: meter listening for chain " ++ (wantNext.if({ "B" }, { "A" })) ++ " on /ampA/B + /md/levels(_gui)").postln;
};

pushDemoText = {
    (~hud_setState !? { ~hud_setState.("Mode: treeNav ¬∑ A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 ‚Üí add",
            "fret 5 ‚Üí timebased",
            "fret 7 ‚Üí modulation",
            "fret 9 ‚Üí filter"
        ])
    });
};

// ===== RUN (guarded sequence) =====

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.08, {
    makeGridDemo.value;
    solidA.value;
    ensureReady.value(20, { arg host;
        buildOverlay.value(host);
        // Give layout a breath, then meters + text
        AppClock.sched(0.06, {
            addMeterBar.value(host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }));
            startOscDefs.value;
            pushDemoText.value;
            nil
        });
        nil
    });
    nil
});
)

===== troubleshooting/99_PerfHUD_BringUp_OneShot.scd =====
// 99_PerfHUD_BringUp_OneShot.scd
// v0.1.0
// MD 2025-09-29 14:25 BST

/* Purpose
 - Bring up (or focus) the PerfHUD window reliably with minimal moving parts.
 - Verify that meter data is arriving via OSC for a couple of seconds.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
   (so taps are armed and /md/levels(_gui)/ampA/ampB are flowing).
*/

(
var perfHudPath, ensurePerfHUD, waitForWindow, startProbe, stopProbe;

// Path as seen in your logs
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// 1) Ensure PerfHUD is loaded; DO NOT close existing windows (avoid flicker/races)
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD‚Ä¶".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing‚Ä¶".postln;
    };
};

// 2) Wait for the MagicDisplayGUI window, bring to front + always-on-top
waitForWindow = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        if(win.notNil) {
            win.front.alwaysOnTop_(true);
            ~perfHUDWin = win; // publish for convenience
            thenDo.value(win);
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not found; giving up.".warn; nil }{
                waitForWindow.value(triesLeft - 1, thenDo);
            }
        }
    });
};

// 3) Brief OSC probe: confirm meter messages are arriving; auto-stops
startProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\perfHUD_probe, { |msg|
        var path = msg[0];
        if(
            path == '/md/levels'
            or: { path == '/md/levels_gui' }
            or: { path == '/ampA' }
            or: { path == '/ampB' }
        ) {
            ("[levels] " ++ path ++ " ¬∑ size=" ++ msg.size).postln;
        };
    }, nil);
    "99: Probing /md/levels(_gui) & /ampA/B for 2 seconds‚Ä¶".postln;
    AppClock.sched(2.0, { stopProbe.value; nil });
};

stopProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: Probe stopped.".postln;
};

// ‚Äî‚Äî RUN ‚Äî‚Äî //
AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, { waitForWindow.value(40, { startProbe.value }); nil });
)

===== troubleshooting/99_PerfHUD_FixAndVerify_OneShot.scd =====
// 99_PerfHUD_FixAndVerify_OneShot.scd
// v0.2.0
// MD 2025-09-29 14:32 BST

/* Purpose
 - One-shot: make the existing PerfHUD window show MOVING METERS, highlight ACTIVE chain,
   and prove pane text updates, without closing windows or touching audio routing.
 - Bridges /md/levels ‚Üí also emit /md/levels_gui + /ampA + /ampB on the language port,
   so PerfHUD will update regardless of which path it is listening to internally.
 - Writes demo text via common GUI hooks (if exposed by PerfHUD‚Äôs compat shim).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd (taps armed).
Flip
 - Set wantB=true to highlight NEXT (B) instead of CURRENT (A).
*/

(
var wantB;
var perfHudPath, ensurePerfHUD, waitForGui, setHighlight, pushDemoText;
var installBridges, freeBridges, bridgeLevelsToGuiAndAmp, mkLocalSender, probeStart, probeStop;

// ===== CONFIG =====
wantB = false; // false = highlight A; true = highlight B

// ===== PATH to PerfHUD script (from your logs) =====
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// ===== HELPERS =====

mkLocalSender = {
    var addr;
    addr = NetAddr("127.0.0.1", NetAddr.langPort);
    ^addr
};

// 1) Ensure PerfHUD exists; DO NOT close existing GUI (avoid flicker/race).
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD‚Ä¶".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing‚Ä¶".postln;
        existing.front.alwaysOnTop_(true);
    };
};

// 2) Wait until a GUI handle is usable.
//    PerfHUD usually installs a ~gui compat shim; if not, we still proceed with window only.
waitForGui = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win, ok;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        // Accept either ~gui controller (preferable) or at least the window
        ok = (win.notNil) and: { (~gui.notNil) or: { true } };
        if(ok) {
            if(~gui.isNil) {
                // Try to capture a compat controller if PerfHUD exposed one (harmless if not)
                ~gui = ~gui ?? { nil };
            };
            win.front.alwaysOnTop_(true);
            thenDo.value;
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not ready; giving up.".warn; nil }
            { waitForGui.value(triesLeft - 1, thenDo) }
        }
    });
};

// 3) Highlight ACTIVE chain (default A). If compat shim exposes highlightCurrentColumn, use it.
setHighlight = {
    var targetSym;
    targetSym = (wantB.not).if({ \chainA }, { \chainB });
    if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
        ~gui.highlightCurrentColumn(targetSym);
        ("99: highlight set via GUI method ‚Üí " ++ targetSym.asString).postln;
    }{
        // fallback: post only; we avoid direct view hacking in PerfHUD for safety
        ("99: highlight method not found (GUI compat shim missing?) ‚Äî expected " ++ targetSym.asString).warn;
    };
};

// 4) Push DEMO TEXT: try showExpectation ‚Üí updateTextField ‚Üí setOperations (if present).
pushDemoText = {
    var stateText, lines;
    stateText = (wantB.not).if({ "Mode: test ¬∑ ACTIVE=A" }, { "Mode: test ¬∑ ACTIVE=B" });
    lines = ["fret 3 ‚Üí add", "fret 5 ‚Üí timebased", "fret 7 ‚Üí modulation", "fret 9 ‚Üí filter"];

    if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
        ~gui.showExpectation(stateText, 0);
        "99: showExpectation OK".postln;
    }{
        if(~gui.notNil and: { ~gui.respondsTo(\updateTextField) }) {
            ~gui.updateTextField(\state, stateText);
            "99: updateTextField(:state) OK".postln;
        }{
            "99: No text API found on GUI (skipping)".warn;
        };
    };
    if(~gui.notNil and: { ~gui.respondsTo(\setOperations) }) {
        ~gui.setOperations(lines);
        "99: setOperations OK".postln;
    }{
        "99: setOperations not available (skipping choices text)".postln;
    };
};

// 5) Bridge /md/levels ‚Üí also emit /md/levels_gui and /ampA/B so PerfHUD meters move.
freeBridges = {
    if(~osc_bridge_levels.notNil) { ~osc_bridge_levels.free; ~osc_bridge_levels = nil };
    if(~osc_bridge_gui.notNil)    { ~osc_bridge_gui.free; ~osc_bridge_gui    = nil };
};
bridgeLevelsToGuiAndAmp = {
    var out, lastPrint;
    var routeA, routeB;

    out = mkLocalSender.value;
    lastPrint = 0.0;

    // Helper to emit ampA/ampB from 4 floats [lA, rA, lB, rB]
    routeA = { arg lA = 0.0, rA = 0.0; out.sendMsg('/ampA', 0, lA, rA) };
    routeB = { arg lB = 0.0, rB = 0.0; out.sendMsg('/ampB', 0, lB, rB) };

    // Bridge from /md/levels ‚Üí duplicate as /md/levels_gui and /ampA/B
    ~osc_bridge_levels = OSCdef(\md_bridge_levels, { |msg, time, addr, recvPort|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // Emit a straight pass-through for GUI path (same payload except the path)
        out.sendMsg('/md/levels_gui', *floats);

        // Try to extract last 4 floats as [lA, rA, lB, rB]; fallback to mean pairs if shorter
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };
        routeA.value(lA.clip(0,1), rA.clip(0,1));
        routeB.value(lB.clip(0,1), rB.clip(0,1));

        // Throttled console confirmation
        if((SystemClock.seconds - lastPrint) > 0.50) {
            ("99: bridged levels ‚Üí GUI + ampA/B   A=(" ++ lA.round(0.01) ++ "," ++ rA.round(0.01)
              ++ ")  B=(" ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")").postln;
            lastPrint = SystemClock.seconds;
        };
    }, '/md/levels');

    // Also, if someone else sends /md/levels_gui only, mirror to ampA/B as well.
    ~osc_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            routeA.value(lA.clip(0,1), rA.clip(0,1));
            routeB.value(lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: bridges installed (levels ‚Üí gui + ampA/B)".postln;
};

// 6) Short probe: print any arriving meter messages for visibility (auto-stop)
probeStart = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\md_probe_any, { |msg|
        var p = msg[0];
        if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/ampA' } or: { p == '/ampB' }) {
            ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
        };
    }, nil);
    "99: probe: watching /md/levels(_gui) & /ampA/B for 2s‚Ä¶".postln;
    AppClock.sched(2.0, { probeStop.value; nil });
};
probeStop = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: probe stopped.".postln;
};

// 7) Uninstall bridges if you need to revert
~hud_fix_stop = {
    freeBridges.value;
    probeStop.value;
    "99: bridges and probe removed.".postln;
};

// ===== RUN (guarded) =====

AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, {
    waitForGui.value(40, {
        setHighlight.value;
        pushDemoText.value;
        freeBridges.value;
        installBridges.value;  // forward-declare call ‚Äî see below
        probeStart.value;
        nil
    });
    nil
});

// We bind the bridge installer late to avoid forward-ref warnings in some editors
installBridges = { bridgeLevelsToGuiAndAmp.value };
)

===== troubleshooting/99_PerfHUD_MetersFromBusses_v0.1.0.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.0
// MD 2025-09-29 15:18 BST

(
var aBus, bBus;
var mkDefs, startMeters, uiNudge;

aBus = 2001;  // your tap buses
bBus = 2002;

mkDefs = {
    Server.default.bind({
        SynthDef(\md_levels4_from_busses, { arg inA=2001, inB=2002, rate=24;
            var a, b, la, ra, lb, rb, t;
            a  = In.ar(inA, 2);
            b  = In.ar(inB, 2);
            la = Amplitude.ar(a[0], 0.01, 0.20).clip(0, 1);
            ra = Amplitude.ar(a[1], 0.01, 0.20).clip(0, 1);
            lb = Amplitude.ar(b[0], 0.01, 0.20).clip(0, 1);
            rb = Amplitude.ar(b[1], 0.01, 0.20).clip(0, 1);
            t  = Impulse.kr(rate);
            SendReply.kr(t, '/md/levels_gui', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/md/levels_bus', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/ampA', A2K.kr([la, ra]));
            SendReply.kr(t, '/ampB', A2K.kr([lb, rb]));
        }).add;
    });
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeters = {
    if(~md_levelsSynth.notNil) { ~md_levelsSynth.free; ~md_levelsSynth = nil };
    Server.default.bind({
        ~md_levelsSynth = Synth(\md_levels4_from_busses, [\inA, aBus, \inB, bBus, \rate, 24]);
    });
    ("99: Started md_levels4_from_busses on A=" ++ aBus ++ "  B=" ++ bBus).postln;
};

uiNudge = {
    AppClock.sched(0.10, {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B taps", 0);
        };
        nil
    });
};

mkDefs.value;
AppClock.sched(0.05, { startMeters.value; uiNudge.value; nil });
)

===== troubleshooting/99_PerfHUD_MetersFromBusses.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.1
// MD 2025-09-29 15:22 BST
(
/* Purpose
   - Bridge two 2-ch AUDIO buses (A and B) into the PerfHUD UI via OSC:
       ‚Ä¢ '/md/levels_gui'  ‚Üí linear amplitudes (0..1)  [A L, A R, B L, B R]
       ‚Ä¢ '/md/levels_db'   ‚Üí dBFS values (‚âà -inf..0)   [A L, A R, B L, B R]
       ‚Ä¢ '/ampA', '/ampB'  ‚Üí linear pairs for legacy listeners
   - Provide optional test pattern (fixed values) to prove the UI is controllable.
   - Optionally print a few lines of dB to the console to validate input sanity.

Style
   - var-first everywhere; descriptive lowercase names; no single-letter locals.
   - Server.default.bind for server ops; AppClock for UI; no server.sync; no non-local returns.
*/

var busIndexA, busIndexB;
var attackSeconds, releaseSeconds, updateRateHz;
var useTestPattern, testValueAL, testValueAR, testValueBL, testValueBR;
var printDbLinesCount;

var installSynthDefinitions, startMeterBridge, nudgeHudOnce, installDbConsolePrinter;

// --- Configuration (edit these if needed) ------------------------------------
busIndexA        = 2001;        // your A-tap bus index (2 channels expected)
busIndexB        = 2002;        // your B-tap bus index (2 channels expected)
attackSeconds    = 0.01;        // Amplitude.kr attack time
releaseSeconds   = 0.20;        // Amplitude.kr release time
updateRateHz     = 24;          // OSC update rate for GUI

useTestPattern   = false;       // set true to drive meters with fixed values
testValueAL      = 0.25;        // A left (linear 0..1)
testValueAR      = 0.50;        // A right
testValueBL      = 0.75;        // B left
testValueBR      = 0.50;        // B right

printDbLinesCount = 6;          // number of dB lines to print to console (0 disables)

// --- Definitions --------------------------------------------------------------
installSynthDefinitions = {
    var synthAdder;

    synthAdder = {
        // Two-bus (stereo+stereo) ‚Üí linear + dB, with optional test pattern
        SynthDef(\md_levels4_from_busses, {
            arg inBusA = 2001, inBusB = 2002, updatesPerSecond = 24,
                ampAttack = 0.01, ampRelease = 0.20,
                enableTestPattern = 0,
                patternAL = 0.25, patternAR = 0.50, patternBL = 0.75, patternBR = 0.50;

            var inputStereoA, inputStereoB;
            var ampLinearAL, ampLinearAR, ampLinearBL, ampLinearBR;
            var linearAL, linearAR, linearBL, linearBR;
            var dbAL, dbAR, dbBL, dbBR;
            var updateTrigger;
            var minLinearFloor;

            // Read 2 channels from each bus
            inputStereoA = In.ar(inBusA, 2);
            inputStereoB = In.ar(inBusB, 2);

            // Measure linear amplitude at control rate
            ampLinearAL = Amplitude.kr(inputStereoA[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearAR = Amplitude.kr(inputStereoA[1], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBL = Amplitude.kr(inputStereoB[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBR = Amplitude.kr(inputStereoB[1], ampAttack, ampRelease).clip(0.0, 1.0);

            // Select measured vs. test pattern
            linearAL = Select.kr(enableTestPattern, [ampLinearAL, patternAL]);
            linearAR = Select.kr(enableTestPattern, [ampLinearAR, patternAR]);
            linearBL = Select.kr(enableTestPattern, [ampLinearBL, patternBL]);
            linearBR = Select.kr(enableTestPattern, [ampLinearBR, patternBR]);

            // Convert to dB (guard the floor to avoid -inf)
            minLinearFloor = 1e-7;
            dbAL = (max(linearAL, minLinearFloor)).log10 * 20.0;
            dbAR = (max(linearAR, minLinearFloor)).log10 * 20.0;
            dbBL = (max(linearBL, minLinearFloor)).log10 * 20.0;
            dbBR = (max(linearBR, minLinearFloor)).log10 * 20.0;

            // Tick and send
            updateTrigger = Impulse.kr(updatesPerSecond);

            // Linear for GUI
            SendReply.kr(updateTrigger, '/md/levels_gui', [linearAL, linearAR, linearBL, linearBR]);

            // dB for console or dB-aware GUIs
            SendReply.kr(updateTrigger, '/md/levels_db',  [dbAL, dbAR, dbBL, dbBR]);

            // Legacy: per-chain linear pairs
            SendReply.kr(updateTrigger, '/ampA', [linearAL, linearAR]);
            SendReply.kr(updateTrigger, '/ampB', [linearBL, linearBR]);
        }).add;
    };

    Server.default.bind(synthAdder);
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeterBridge = {
    var freeOld, startNew;

    freeOld = {
        if(~md_levelsSynth.notNil) {
            ~md_levelsSynth.free;
            ~md_levelsSynth = nil;
        };
    };

    startNew = {
        Server.default.bind({
            ~md_levelsSynth = Synth(
                \md_levels4_from_busses,
                [
                    \inBusA,          busIndexA,
                    \inBusB,          busIndexB,
                    \updatesPerSecond, updateRateHz,
                    \ampAttack,        attackSeconds,
                    \ampRelease,       releaseSeconds,
                    \enableTestPattern, (useTestPattern.if({ 1 }, { 0 })),
                    \patternAL,        testValueAL,
                    \patternAR,        testValueAR,
                    \patternBL,        testValueBL,
                    \patternBR,        testValueBR
                ]
            );
        });
        ("99: Started md_levels4_from_busses on A=" ++ busIndexA
            ++ "  B=" ++ busIndexB
            ++ "  testPattern=" ++ useTestPattern).postln;
    };

    freeOld.();
    startNew.();
};

nudgeHudOnce = {
    var doIt;

    doIt = {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B buses", 0);
        };
        nil
    };

    AppClock.sched(0.10, doIt);
};

installDbConsolePrinter = {
    var oscKeyName, linesRemaining;

    oscKeyName     = \md_levels_db_console_printer;
    linesRemaining = printDbLinesCount.max(0).asInteger;

    // Optional: print a few dB lines then auto-stop
    if(linesRemaining > 0) {
        OSCdef(oscKeyName, { arg message;
            var dbLeftA, dbRightA, dbLeftB, dbRightB, lineText;

            if(message.size >= 5) {
                // ['/md/levels_db', nodeID, replyID, dB_AL, dB_AR, dB_BL, dB_BR] (nodeID/replyID vary by build)
                dbLeftA   = message[3].round(0.1);
                dbRightA  = message[4].round(0.1);
                dbLeftB   = message[5].round(0.1);
                dbRightB  = message[6].round(0.1);

                lineText = "[dB]  A: L=" ++ dbLeftA  ++ " dB  R=" ++ dbRightA
                         ++ "   |   B: L=" ++ dbLeftB ++ " dB  R=" ++ dbRightB;
                lineText.postln;

                linesRemaining = linesRemaining - 1;
                if(linesRemaining <= 0) {
                    OSCdef(oscKeyName).free;
                    "[dB] console printer finished.".postln;
                };
            };
        }, '/md/levels_db');
    };
};

// --- Run sequence -------------------------------------------------------------
installSynthDefinitions.();
installDbConsolePrinter.();               // prints a few lines if printDbLinesCount > 0
AppClock.sched(0.05, {
    startMeterBridge.();
    nudgeHudOnce.();
    nil
});
)

===== troubleshooting/99_PerfHUD_MetersNow_v2.scd =====
// 99_PerfHUD_MetersNow_v2.scd
// v0.2.1
// MD 2025-09-29 14:55 BST

/* Purpose
 - Make PerfHUD meters MOVE by bridging your real level messages to the paths PerfHUD reads,
   after SANITIZING payloads (strip bus IDs / counters; normalize to 0..1).
 - Listens on: /md/levels AND /md/levels_gui
 - Emits to : /md/levels_bus  (and mirrors to /ampA, /ampB)
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe; verbose console for verification.
*/

(
var out, freeAll, startBridge, stopBridge, extract4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean previous bridges
freeAll = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
};

// 2) dB ‚Üí 0..1 using a floor (default -48 dB mapped to 0)
normDb = { arg dbVal, floorDb = -48.0;
    var x = dbVal ? floorDb;
    x = x.clip(floorDb, 0.0);
    ^((x - floorDb) / (0.0 - floorDb))  // 0..1
};

// 3) Extract the last 4 meaningful floats [lA,rA,lB,rB] from a float list.
//    - Prefer values already in 0..1
//    - Else accept dB-ish (-120..+6) and convert via normDb
//    - Ignore obvious bus IDs / counters (>= 2.0 and not dB-range)
extract4 = { arg floatsIn;
    var f, tail4, useDb, vA1, vA2, vB1, vB2, floats01, floatsDbRange;

    f = (floatsIn ? []).collect(_.asFloat);

    // 3a) Try to find a **last** window of 4 floats already within 0..1
    floats01 = f.select({ |x| x.isNumber and: { (x >= 0.0) and: (x <= 1.0) } });
    if(floats01.size >= 4) {
        tail4 = floats01.keepLast(4);
        ^tail4; // already 0..1
    };

    // 3b) Else try dB-like values (e.g., -48..0 or up to +6)
    floatsDbRange = f.select({ |x| x.isNumber and: { (x >= -120.0) and: (x <= 6.0) } });
    if(floatsDbRange.size >= 4) {
        tail4 = floatsDbRange.keepLast(4);
        vA1 = normDb.(tail4[0]); vA2 = normDb.(tail4[1]);
        vB1 = normDb.(tail4[2]); vB2 = normDb.(tail4[3]);
        ^[vA1, vA2, vB1, vB2];
    };

    // 3c) Last resort: take **any** floats, drop obviously huge values (>= 2.0),
    //     then if still not enough, pad with zeros.
    tail4 = f.reject({ |x| x >= 2.0 }).keepLast(4);
    tail4 = (tail4 ++ Array.fill((4 - tail4.size).max(0), { 0.0 })).keepLast(4);
    // clip to 0..1 to be safe
    ^tail4.collect({ |x| x.clip(0.0, 1.0) });
};

// 4) Start the sanitizing bridge
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v2 = OSCdef(\md_bridge_levels_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);  // [lA,rA,lB,rB] normalized 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        // Emit to PerfHUD-friendly paths
        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui_v2 = OSCdef(\md_bridge_gui_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels_gui ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels_gui');

    "99v2: BRIDGE active (sanitized ‚Üí levels_bus + ampA/B)".postln;
};

stopBridge = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
    "99v2: BRIDGE stopped.".postln;
};

// Run
freeAll.value;
startBridge.value;
)

===== troubleshooting/99_PerfHUD_MetersNow_v3.scd =====
// 99_PerfHUD_MetersNow_v3.scd
// v0.3.0
// MD 2025-09-29 15:05 BST

/* Purpose
 - Make PerfHUD meters move by sanitizing level messages before forwarding:
   ‚Ä¢ Listen:  /md/levels   and  /md/levels_gui
   ‚Ä¢ Emit  :  /md/levels_bus   (and mirror to /ampA, /ampB)
 - Sanitizer rules (known-good SC only, no non-existent methods):
   1) Prefer the last 4 floats in 0..1
   2) Else prefer the last 4 floats in dB-ish range [-120..+6], map to 0..1 (floor = -48 dB)
   3) Else drop floats >= 2.0 (IDs/counters), take last 4, clip to 0..1
Style
 - var-first; AppClock-only scheduling; no server.sync; idempotent; nil-safe; conservative logging.
*/

(
var out, freeBridges, startBridges, stopBridges, sanitize4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean any previous bridges
freeBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
};

// 2) dB ‚Üí 0..1 with floor
normDb = { arg dbVal, floorDb = -48.0;
    var x;
    x = (dbVal ? floorDb);
    x = x.clip(floorDb, 0.0);
    // linear from floorDb..0 dB ‚Üí 0..1
    ((x - floorDb) / (0.0 - floorDb))
};

// 3) Get the **last** 4 usable floats
sanitize4 = { arg floatsIn;
    var f, i, count, res, v, dbCand, last4FromDb, raw, startIndex, endIndex;

    // Defensive copy of floats
    f = (floatsIn ? []).collect(_.asFloat);

    // (A) Prefer the last 4 in 0..1
    res = Array.new;
    i = f.size - 1;
    while({ i >= 0 and: { res.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= 0.0) and: (v <= 1.0) }) {
            res = res.add(v);
        };
        i = i - 1;
    });
    if(res.size >= 4) {
        res = res.reverse; // we collected backwards
        ^res;
    };

    // (B) Else, try last 4 in dB-ish range [-120..+6] ‚Üí map to 0..1
    dbCand = Array.new; i = f.size - 1;
    while({ i >= 0 and: { dbCand.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= -120.0) and: (v <= 6.0) }) {
            dbCand = dbCand.add(v);
        };
        i = i - 1;
    });
    if(dbCand.size >= 4) {
        dbCand = dbCand.reverse;
        last4FromDb = dbCand.collect({ arg x; normDb.(x) });
        ^last4FromDb;
    };

    // (C) Last resort: drop obvious IDs/counters (>= 2.0), take last 4, clip 0..1
    raw = f.select({ arg x; x.isNumber and: { x < 2.0 } });
    if(raw.size >= 4) {
        startIndex = (raw.size - 4).max(0);
        endIndex   = raw.size - 1;
        res = raw.copyRange(startIndex, endIndex).collect({ arg x; x.clip(0.0, 1.0) });
        ^res;
    }{
        // Not enough candidates: pad with zeros
        res = raw.collect({ arg x; x.clip(0.0, 1.0) });
        while({ res.size < 4 }, { res = res.add(0.0) });
        ^res;
    };
};

// 4) Bridges: listen ‚Üí sanitize ‚Üí forward
startBridges = {
    var throttle;

    throttle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.60) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v3 = OSCdef(\md_bridge_levels_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);

        // for visibility, show the numeric tail we saw (up to last 6 floats)
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats); // [lA,rA,lB,rB] in 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels tail=" ++ rawTail
            ++ "  ‚Üí bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels');

    ~md_bridge_gui_v3 = OSCdef(\md_bridge_gui_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels_gui tail=" ++ rawTail
            ++ "  ‚Üí bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels_gui');

    "99v3: BRIDGE active (sanitized ‚Üí /md/levels_bus + /ampA/B)".postln;
};

stopBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
    "99v3: BRIDGE stopped.".postln;
};

// Run
freeBridges.value;
startBridges.value;
)

===== troubleshooting/99_PerfHUD_MetersNow.scd =====
// 99_PerfHUD_MetersNow.scd
// v0.1.0
// MD 2025-09-29 14:40 BST

/* Purpose
 - Make PerfHUD meters MOVE immediately without touching the GUI or audio routing.
 - Step 1 (2s): emit a visible ramp to /md/levels_bus and /ampA/B (proof meters react).
 - Step 2 (continuous): bridge your real /md/levels & /md/levels_gui to /md/levels_bus (+ /ampA/B).
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe.
*/

(
var out, freeAll, startProof, stopProof, startBridge, stopBridge, lastPost;

// 0) local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean up any previous helpers
freeAll = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    if(~md_probe_perf.notNil)    { ~md_probe_perf.free;    ~md_probe_perf    = nil };
    if(~md_proof_task.notNil)    { ~md_proof_task.stop;    ~md_proof_task    = nil };
};

// 2) SHORT PROOF: drive a ramp so you SEE the meters move now
startProof = {
    var t = 0.0, dt = 1/24, secs = 2.0, steps = (secs / dt).round(1);
    var stepCount = 0, ramp;
    ramp = {
        // 0..1 triangle for A, inverse for B (obvious visual motion)
        var a = ( (stepCount % 24) / 24 );
        var b = 1.0 - a;
        out.sendMsg('/md/levels_bus', a, a, b, b);  // [lA, rA, lB, rB]
        out.sendMsg('/ampA', 0, a, a);
        out.sendMsg('/ampB', 0, b, b);
        stepCount = stepCount + 1;
    };
    ~md_proof_task = Task({
        steps.do({
            ramp.value;
            dt.wait;
        });
    }).play(AppClock);
    "99: PROOF running for 2s ‚Üí watch meters MOVE now‚Ä¶".postln;
};

stopProof = {
    if(~md_proof_task.notNil) { ~md_proof_task.stop; ~md_proof_task = nil };
    "99: PROOF stopped.".postln;
};

// 3) BRIDGE real levels ‚Üí /md/levels_bus (+ mirror to /ampA/B)
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels = OSCdef(\md_bridge_levels, { |msg|
        var floats, lA, rA, lB, rB;

        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // heuristics: last 4 floats are [lA,rA,lB,rB]; fallback if fewer
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };

        // forward to paths PerfHUD commonly consumes
        out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
        out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
        out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));

        postThrottle.value("99: bridged ‚Üí levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
            out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
            out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: BRIDGE active (levels ‚Üí levels_bus + ampA/B).".postln;
};

stopBridge = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    "99: BRIDGE stopped.".postln;
};

// 4) Optional: tiny probe (prints any level/amp paths for 2s)
~md_probe_perf = OSCdef(\md_probe_perf, { |msg|
    var p = msg[0];
    if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/md/levels_bus' } or: { p == '/ampA' } or: { p == '/ampB' }) {
        ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
    };
}, nil);

// RUN
freeAll.value;
startProof.value;
AppClock.sched(2.05, { stopProof.value; startBridge.value; nil });
)

===== troubleshooting/99_PerfHUD_UIOnly_Wiggle_Toggle.scd =====
// 99_PerfHUD_UIOnly_Wiggle_Toggle.scd
// v0.1.0
// MD 2025-09-29 15:22 BST

/* Purpose
 - Pure GUI-side diagnostic: animate two meter bars (A/B) inside the PerfHUD window
   WITHOUT OSC, to prove the window can update; also tint ACTIVE column and show test text.
 - Provides helpers:
     ~hud_wiggle_start.(\A or \B)   // start animation, choose active column
     ~hud_wiggle_stop.()            // stop & remove overlays
     ~hud_text.("state text", ["choice1", "choice2"])  // show sample texts
Style
 - var-first; AppClock-only; idempotent; nil-safe; no server.sync; no caret-returns in closures.
*/

(
var findHudHost, removeOverlays, mkBars, mkTint, mkText, startAnim, stopAnim;

// --- find the MagicDisplayGUI host view (PerfHUD window) ---
findHudHost = {
    var win, host;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    host = win.tryPerform(\view);
    ^host
};

// --- remove our overlays if present (safe to call anytime) ---
removeOverlays = {
    var host = findHudHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["WGL_BAR_A", "WGL_BAR_B", "WGL_TINT_A", "WGL_TINT_B", "WGL_TEXT"].includes(n)
        }).do(_.remove);
    };
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
};

// --- create two bars near the bottom of the window ---
mkBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD host not found.".warn; ^nil };
    r = host.bounds; pad = 12; h = 14; gap = 8; w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(10);
    yA = (yB - h - gap).max(10);

    // A
    barA = UserView(host);
    barA.name = "WGL_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.10);
    barA.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    // B
    barB = UserView(host);
    barB.name = "WGL_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.10);
    barB.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    // keep re-anchored on resize
    host.window.onResize = {
        var r2 = host.bounds;
        var w2 = (r2.width - (2*pad)).max(50);
        var yB2 = (r2.height - pad - h).max(10);
        var yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
};

// --- tint ACTIVE column (large translucent rect on left or right half) ---
mkTint = { arg which = \A;
    var host, r, leftRect, rightRect, tintA, tintB, midX;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old tints
    host.children.select({ |v| ["WGL_TINT_A","WGL_TINT_B"].includes(v.tryPerform(\name) ? "") }).do(_.remove);

    tintA = UserView(host); tintA.name = "WGL_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18); // soft green

    tintB = UserView(host); tintB.name = "WGL_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    // show only the chosen one
    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    // keep on resize
    host.window.onResize = {
        var r2 = host.bounds, mx2 = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx2, r2.height);
        tintB.bounds = Rect(mx2, 0, r2.width - mx2, r2.height);
        tintA.refresh; tintB.refresh;
    };
};

// --- small text block (state + choices) in top-right as a demo ---
mkText = { arg stateStr = "HUD UI-test", choices = #["choice A","choice B"];
    var host, r, pad, w, h, title, body, panel, s;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 8; w = 280; h = 120;

    // clear previous
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "WGL_TEXT" }).do(_.remove);

    panel = CompositeView(host).name_("WGL_TEXT");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (w + 12), 12, w, h);
    panel.front;

    title = StaticText(panel);
    title.string = stateStr.asString;
    title.font = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.9);
    title.bounds = Rect(pad, pad, w - 2*pad, 18);

    s = choices.collect(_.asString).join("\n");
    body = StaticText(panel);
    body.string = (s.size > 0).if({ s }, { "‚Äî" });
    body.font = Font("Monaco", 10);
    body.stringColor = Color(0.95,0.95,0.95);
    body.align = \topLeft;
    body.bounds = Rect(pad, pad + 22, w - 2*pad, h - (pad + 22 + pad));

    // keep anchored
    host.window.onResize = {
        var r2 = host.bounds;
        panel.bounds = Rect(r2.width - (w + 12), 12, w, h);
        panel.front;
    };
};

// --- animation task (no OSC; just wiggle locally) ---
startAnim = { arg active = \A;
    var host, barA, barB, t = 0.0, dt = 1/30;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD not found".warn; ^nil };

    // build overlays
    mkBars.();
    mkTint.(active);

    // drive values
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
    ~wgl_task = Task({
        loop {
            // simple triangle ‚Üí obvious motion
            var a = (t % 1.0);
            var b = 1.0 - a;
            ~wgl_valA = a;
            ~wgl_valB = b;
            // refresh our bars
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if(["WGL_BAR_A","WGL_BAR_B"].includes(n)) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.5); // slow-ish
        }
    }).play(AppClock);
};

stopAnim = {
    removeOverlays.();
};

// export helpers
~hud_wiggle_start = { arg which = \A; AppClock.sched(0.0, { startAnim.(which); nil }) };
~hud_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };
~hud_text = { arg state="HUD UI-test", choices = #[]; AppClock.sched(0.0, { mkText.(state, choices); nil }) };

"PerfHUD UI-only wiggle helpers ready: ~hud_wiggle_start.(\\A or \\B), ~hud_wiggle_stop.(), ~hud_text.(state, choices)".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck_GUI.scd =====
// Accept_Meters_QuickCheck_GUI.scd
// v0.1.0  MD 2025-09-26 16:10 BST

(
var key, counts, lastGA, lastGB, lastGT;
counts = IdentityDictionary[ 32001 -> 0, 32002 -> 0, 31001 -> 0 ];
lastGA = [0.0, 0.0]; lastGB = [0.0, 0.0]; lastGT = [0.0, 0.0];

key = \md_levels_gui_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };

OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 32001) { counts.put(32001, counts[32001] + 1); lastGA = [l, r] };
    if(id == 32002) { counts.put(32002, counts[32002] + 1); lastGB = [l, r] };
    if(id == 31001) { counts.put(31001, counts[31001] + 1); lastGT = [l, r] };
    nil
}, "/md/levels_gui", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), line;
    if(d.notNil) { d.free };
    line = "[ACCEPT_GUI] GA=" ++ counts[32001].asString ++ " " ++ lastGA.asString
        ++ "  GB=" ++ counts[32002].asString ++ " " ++ lastGB.asString
        ++ "  GT=" ++ counts[31001].asString ++ " " ++ lastGT.asString;
    line.postln;
    nil
});

"[ACCEPT_GUI] counting /md/levels_gui for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck.scd =====
// Accept_Meters_QuickCheck.scd
// v0.1.0  MD 2025-09-26 15:58 BST

/* Purpose
   Lightweight acceptance: count /md/levels for 0.5 s and print one line.
*/

(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), okLine;
    if(d.notNil) { d.free };
    okLine = "[ACCEPT] A=" ++ counts[2001].asString ++ " " ++ lastA.asString
           ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
           ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString;
    okLine.postln;
    nil
});
"[ACCEPT] counting /md/levels for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Bridge_mdlevels_to_ampAB.scd =====
// Bridge_mdlevels_to_ampAB.scd
// v0.1.0
// MD 2025-09-26 12:43 BST

/* Purpose
   Bridge /md/levels to /ampA and /ampB so the HUD meters animate regardless of
   which responder is currently active in the window code.
   - replyID 2001 -> /ampA
   - replyID 2002 -> /ampB
*/

(
var senderAddr, installBridge;

senderAddr = NetAddr("127.0.0.1", NetAddr.langPort);

installBridge = {
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };  // idempotent

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };  // guard

        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // Relay to whichever responders the HUD already has
        if(replyId == 2001) { senderAddr.sendMsg("/ampA", 0, -1, leftVal, rightVal) };
        if(replyId == 2002) { senderAddr.sendMsg("/ampB", 0, -1, leftVal, rightVal) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installBridge.();
"[/md/levels] -> [/ampA,/ampB] bridge installed.".postln;
)

===== troubleshooting/Bridge_Meters_Universal.scd =====
// Bridge_Meters_Universal.scd
// v0.1.0
// MD 2025-09-26 12:58 BST

/* Purpose / Style
   Make HUD meters move regardless of whether it listens to /md/levels or /ampA,/ampB.
   - Auto-discovers receiver ports for /ampA,/ampB responders and relays /md/levels to them.
   - Also updates the language-side model (~md_levelsById) from /ampA,/ampB (reverse path).
   - Idempotent: re-running replaces previous bridge.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
var allDefs, ampPorts, collectAmpPorts, installMdToAmp, installAmpToModel, postSummary;

allDefs = OSCdef.all;

collectAmpPorts = {
    var ports;
    ports = IdentitySet.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == "/ampA" or: { pathValue == "/ampB" }) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            ports.add(portValue);
        };
    });
    // Always include langPort as a fallback
    ports.add(NetAddr.langPort);
    ports.asArray
};

installMdToAmp = { arg portArray;
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        var sendAddrs;

        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // multicast to every port the HUD is listening on
        sendAddrs = portArray.collect({ arg portNum; NetAddr("127.0.0.1", portNum) });

        if(replyId == 2001) { sendAddrs.do({ arg na; na.sendMsg("/ampA", 0, -1, leftVal, rightVal) }) };
        if(replyId == 2002) { sendAddrs.do({ arg na; na.sendMsg("/ampB", 0, -1, leftVal, rightVal) }) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installAmpToModel = {
    var ensureDict;
    ensureDict = { ~md_levelsById = ~md_levelsById ? IdentityDictionary.new };

    // /ampA -> model[2001]
    if(OSCdef.all.at(\ampA_to_model).notNil) { OSCdef.all.at(\ampA_to_model).free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1); // guard
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    if(OSCdef.all.at(\ampB_to_model).notNil) { OSCdef.all.at(\ampB_to_model).free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        nil
    }, "/ampB", recvPort: NetAddr.langPort);
};

postSummary = { arg portsArray;
    var msg;
    msg = "Universal meter bridge active. ampA/ampB multicast ports: " ++ portsArray.asString;
    msg.postln;
};

// Main
ampPorts = collectAmpPorts.();
installMdToAmp.(ampPorts);
installAmpToModel.();
postSummary.(ampPorts);
)

===== troubleshooting/Diag_0G_ALT_CreateGridGuiAndBind.scd =====
// Diag_0G_ALT_CreateGridGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:25 BST
/* Purpose / Style
   Purpose: Avoid the PerfHUD 'base_' crash by bringing up the GridDemo GUI instead.
            Bind CommandManager.display to the created GUI object and return ‚Üí a Window.
   Style:   var-first; descriptive lowercase variable names; no server.sync; single MagicDisplayGUI window.
*/

(
var system_ref, cmd_mgr, gui_obj, window_list, gui_window;

system_ref = ~system;
if(system_ref.isNil) {
    // Construct LivePedalboardSystem with default path resolver (nil) and do the standard bring-up
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;  // server + pedalboard + command system (GUI may still be nil if PerfHUD crashed earlier)
};

// Close any existing MagicDisplayGUI windows to avoid duplicates
~system.closeExistingMagicDisplayWindows;

// Explicitly create the safe GridDemo GUI (bypass PerfHUD file loading)
gui_obj = MagicDisplayGUI_GridDemo.new;  // known-good fallback window class in your codebase

// Bind CommandManager.display if needed
cmd_mgr = ~system.commandManager;
if(cmd_mgr.notNil and: { cmd_mgr.display.isNil }) {
    cmd_mgr.display = gui_obj;
    "MD0G_ALT: bound CommandManager.display to GridDemo".postln;
};

// Bring the MagicDisplayGUI window to front and RETURN it
window_list = Window.allWindows;
gui_window = window_list.detect({ arg w;
    var title_string;
    title_string = w.tryPerform(\name);
    title_string.notNil and: { title_string.asString.beginsWith("MagicDisplayGUI") }
});
if(gui_window.notNil) { gui_window.front };
gui_window  // ‚Üí a Window (final expression)
)

===== troubleshooting/Diag_0G_CreateGuiAndBind.scd =====
// Diag_0G_CreateGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:05 BST

/* Purpose / Style
   Purpose: Ensure a single MagicDisplayGUI window exists, bind it to CommandManager.display,
            and return ‚Üí a Window (final expression).
   Style:   var-first; descriptive lowercase variable names (‚â•3 chars); no server.sync; AppClock implied.
*/

(
var systemRef, guiWindow, cmdMgr;

systemRef = ~system;
if(systemRef.isNil) {
    // If system doesn‚Äôt exist yet, construct with default path resolver.
    ~system = LivePedalboardSystem.new(nil);         // uses your resolveTreePath  (known-good)
    ~system.bringUpAll;
};

// Bring up (or refresh) the single GUI window
~system.closeExistingMagicDisplayWindows;
guiWindow = ~system.bringUpMagicDisplayGUI;          // sets statusDisplay inside LivePedalboardSystem

// Bind CommandManager.display to the GUI object if needed
cmdMgr = ~system.commandManager;
if(cmdMgr.notNil and: { cmdMgr.display.isNil } and: { ~system.statusDisplay.notNil }) {
    cmdMgr.display = ~system.statusDisplay;
    "MD0G: bound CommandManager.display to statusDisplay".postln;
};

// Final expression ‚Üí a Window (per your rule)
guiWindow
)

===== troubleshooting/Diag_1_CheckDisplayBinding.scd =====
// Diag_1_CheckDisplayBinding.scd
// v0.1.0
// MD 2025-09-26 16:55 BST
/* Purpose / Style
   Purpose: Check that CommandManager.display points to the current MagicDisplayGUI object.
            If not, bind it safely (no GUI calls are made here).
   Style:   var-first; descriptive lowercase variable names (>=3 chars); no server.sync.
*/

(
var systemRef, cmdMgr, guiRef, displayBefore, didBind;

systemRef = ~system;
if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; run your bring-up first.".warn; ^nil };

cmdMgr = systemRef.commandManager;
guiRef = systemRef.statusDisplay;

displayBefore = if(cmdMgr.notNil) { cmdMgr.display } { nil };
"MDSTEP1: before ‚Üí display.isNil=%  gui.isNil=%".format(displayBefore.isNil, guiRef.isNil).postln;

// Bind only if we have both objects and display is nil
didBind = false;
if(cmdMgr.notNil and: { guiRef.notNil } and: { displayBefore.isNil }) {
    cmdMgr.display = guiRef;
    didBind = true;
    "MDSTEP1: bound CommandManager.display to system.statusDisplay".postln;
};

"MDSTEP1: after  ‚Üí display.isNil=%  didBind=%".format(cmdMgr.display.isNil, didBind).postln;
nil
)

===== troubleshooting/Diag_2_LevelsSniffer.scd =====
// Diag_2_LevelsSniffer_FIXED.scd
// v0.1.2
// MD 2025-09-26 17:25 BST

/* Purpose / Style
   Purpose: Confirm that /md/levels messages arrive from stable taps (A=2001, B=2002).
            Prints compact values every second.
   Style:   var-first; descriptive lowercase names; AppClock; no server.sync; no single-letter variable names.
*/

(
var ensure_stable_taps, install_listener, start_reporter;
var values_by_id, last_stamp_seconds, reporter_routine;

// Share dictionary with any overlays; create if missing
values_by_id = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = values_by_id;
last_stamp_seconds = SystemClock.seconds.asFloat;

// Reinstall sanitised/smoothed taps to /md/levels with IDs 2001/2002
ensure_stable_taps = {
    if(~system.notNil) {
        ~system.installStableMeters;   // known-good installer in your codebase
        "MD2: stable taps reinstalled (IDs 2001/2002).".postln;
    } {
        "MD2: ~system is nil; cannot reinstall taps.".warn;
    };
};

// Listener updating ~md_levelsById (guard NaN and non-numbers; clip to [0,1])
install_listener = {
    var osc_key;
    osc_key = \md_levels_sniffer_fixed;
    if(OSCdef.all.at(osc_key).notNil) { OSCdef.all.at(osc_key).free };
    OSCdef(osc_key, { arg osc_message;
        var reply_id, left_value, right_value, safe_left, safe_right, now_seconds;
        var left_is_bad, right_is_bad;

        if(osc_message.size >= 5) {
            reply_id   = osc_message[2];
            left_value  = osc_message[3];
            right_value = osc_message[4];

            left_is_bad  = (left_value.isNumber.not)  or: { left_value.isNaN };
            right_is_bad = (right_value.isNumber.not) or: { right_value.isNaN };

            safe_left  = left_is_bad.if({ 0.0 }, { left_value.clip(0, 1) });
            safe_right = right_is_bad.if({ 0.0 }, { right_value.clip(0, 1) });

            values_by_id.put(reply_id, [safe_left, safe_right]);
            now_seconds = SystemClock.seconds.asFloat;
            last_stamp_seconds = now_seconds;
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "MD2: /md/levels sniffer installed.".postln;
};

// 1 Hz reporter
start_reporter = {
    if(reporter_routine.notNil) { reporter_routine.stop };
    reporter_routine = Routine({
        var keep_running;
        keep_running = true;
        while({ keep_running }, {
            var pair_a, pair_b, text_a, text_b;
            pair_a = values_by_id.at(2001) ? [0, 0];
            pair_b = values_by_id.at(2002) ? [0, 0];
            text_a = "A(L,R)=(" ++ pair_a[0].round(0.01) ++ "," ++ pair_a[1].round(0.01) ++ ")";
            text_b = "B(L,R)=(" ++ pair_b[0].round(0.01) ++ "," ++ pair_b[1].round(0.01) ++ ")";
            ("MD2: " ++ text_a ++ "  " ++ text_b).postln;
            1.0.wait;
        });
    }).play(AppClock);
};

ensure_stable_taps.();
install_listener.();
start_reporter.();
nil
)

===== troubleshooting/Diag_3_AttachInlineOverlay.scd =====
// Diag_3_AttachInlineOverlay.scd
// v0.1.0
// MD 2025-09-26 16:55 BST

/* Purpose / Style
   Purpose: Attach a small overlay view inside the existing MagicDisplayGUI window that visualises
            /md/levels (A=2001 bottom half; B=2002 top half). Uses the sniffer‚Äôs dictionary.
   Style:   var-first; descriptive lowercase variable names; AppClock; no server.sync.
*/

(
var hudWindow, overlayView, leftPadPixels, viewWidthPixels, viewHeightPixels, refreshRoutine;

hudWindow = Window.allWindows.detect({ arg winRef;
    var titleString;
    titleString = winRef.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

if(hudWindow.isNil) { "‚ö†Ô∏è MDSTEP3: No MagicDisplayGUI window; run your bring-up.".warn; ^nil };

leftPadPixels    = 8;
viewWidthPixels  = 22;
viewHeightPixels = 86;

overlayView = UserView(hudWindow, Rect(leftPadPixels, leftPadPixels, viewWidthPixels, viewHeightPixels));
overlayView.background_(Color.clear);

overlayView.drawFunc_({ arg viewRef;
    var valuesA, valuesB, aLeft, aRight, bLeft, bRight, halfHeight, halfWidth;
    valuesA = ~md_levelsById.at(2001) ? [0, 0];
    valuesB = ~md_levelsById.at(2002) ? [0, 0];

    aLeft  = valuesA[0]; aRight = valuesA[1];
    bLeft  = valuesB[0]; bRight = valuesB[1];

    halfHeight = viewRef.bounds.height / 2;
    halfWidth  = viewRef.bounds.width  / 2;

    // A (bottom half) ‚Äî green left, blue right
    Pen.fillColor = Color(0.35, 0.9, 0.35);
    Pen.addRect(Rect(0,        halfHeight - (halfHeight * aLeft),  halfWidth, halfHeight * aLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95);
    Pen.addRect(Rect(halfWidth, halfHeight - (halfHeight * aRight), halfWidth, halfHeight * aRight)); Pen.fill;

    // B (top half) ‚Äî subtle tint
    Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
    Pen.addRect(Rect(0,        viewRef.bounds.height - (halfHeight * bLeft),  halfWidth, halfHeight * bLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
    Pen.addRect(Rect(halfWidth, viewRef.bounds.height - (halfHeight * bRight), halfWidth, halfHeight * bRight)); Pen.fill;
});

// refresh on AppClock
refreshRoutine = Routine({
    var keepRunning;
    keepRunning = true;
    while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
        overlayView.refresh;
        0.15.wait;
    });
}).play(AppClock);

"MDSTEP3: inline overlay attached (top-left)".postln;
overlayView
)

===== troubleshooting/Diag_B_DebugTaps_AmplitudeVsVisual.scd =====
// Diag_B_DebugTaps_AmplitudeVsVisual.scd
// v0.1.0
// MD 2025-09-26 17:45 BST

/* Purpose / Style
   Purpose: Add debug taps (non-intrusive) on chainA/chainB that SendReply both the raw amplitude and
            the mapped visual value to /md/levels_dbg with reply IDs 42001 (A) and 42002 (B).
            Then print one line/second with (ampLeft, ampRight) and (visLeft, visRight), so we can
            see if unity (1.0) appears at the Amplitude stage or in the mapping/transport.
   Style:   var-first; descriptive lowercase variable names (>=3 chars); Server.default.bind; no server.sync.
*/

(
// ---- 1) Install debug taps (server side, pass-through audio intact)
var install_debug_taps;

install_debug_taps = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // chainA ‚Üí replyID 42001
        Ndef(\chainA).filter(\mdDebugTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // DO NOT overwrite vis_left/vis_right with CheckBadValues result;
            // we only call it for side-effect logging.
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            // Send both raw amplitude and final visual as 4 floats
            // payload: [ampLeft, ampRight, visLeft, visRight]
            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42001);

            in_sig
        });

        // chainB ‚Üí replyID 42002
        Ndef(\chainB).filter(\mdDebugTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42002);

            in_sig
        });
    });
    "MDDBG: debug taps installed (/md/levels_dbg; A=42001, B=42002).".postln;
};

install_debug_taps.();
nil
)

// ---- 2) Install compact, 1 Hz debug listener (language side; prints one line per second)
(
// Shared dictionary so we can read and format values
var dbg_values_by_id, dbg_listener_key, dbg_reporter_routine;

dbg_values_by_id = ~md_levels_dbg ? IdentityDictionary.new;
~md_levels_dbg = dbg_values_by_id;

// Listener
dbg_listener_key = \md_levels_dbg_sniffer;
if(OSCdef.all.at(dbg_listener_key).notNil) { OSCdef.all.at(dbg_listener_key).free };
OSCdef(dbg_listener_key, { arg osc_message;
    var reply_id, amp_left, amp_right, vis_left, vis_right;
    var valid_payload;

    valid_payload = (osc_message.size >= 7); // addr, timeTag, id, v0, v1, v2, v3 ‚Üí size >= 7
    if(valid_payload) {
        reply_id  = osc_message[2];
        amp_left  = osc_message[3];
        amp_right = osc_message[4];
        vis_left  = osc_message[5];
        vis_right = osc_message[6];

        // Minimal guards
        amp_left  = (amp_left.isNumber  and: { amp_left .isNaN.not })  .if({ amp_left  .clip(0,1) }, { 0.0 });
        amp_right = (amp_right.isNumber and: { amp_right.isNaN.not })  .if({ amp_right .clip(0,1) }, { 0.0 });
        vis_left  = (vis_left.isNumber  and: { vis_left .isNaN.not })  .if({ vis_left  .clip(0,1) }, { 0.0 });
        vis_right = (vis_right.isNumber and: { vis_right.isNaN.not })  .if({ vis_right .clip(0,1) }, { 0.0 });

        dbg_values_by_id.put(reply_id, [amp_left, amp_right, vis_left, vis_right]);
    };
    nil
}, "/md/levels_dbg", recvPort: NetAddr.langPort);
"MDDBG: /md/levels_dbg sniffer installed.".postln;

// Reporter
if(~md_levels_dbg_reporter.notNil) { ~md_levels_dbg_reporter.stop };
~md_levels_dbg_reporter = Routine({
    var keep_running;
    keep_running = true;
    while({ keep_running }, {
        var a_vals, b_vals, text_a, text_b;
        a_vals = dbg_values_by_id.at(42001) ? [0,0,0,0];
        b_vals = dbg_values_by_id.at(42002) ? [0,0,0,0];

        text_a = "A amp=("
            ++ a_vals[0].round(0.01) ++ "," ++ a_vals[1].round(0.01)
            ++ ") vis=("
            ++ a_vals[2].round(0.01) ++ "," ++ a_vals[3].round(0.01) ++ ")";

        text_b = "B amp=("
            ++ b_vals[0].round(0.01) ++ "," ++ b_vals[1].round(0.01)
            ++ ") vis=("
            ++ b_vals[2].round(0.01) ++ "," ++ b_vals[3].round(0.01) ++ ")";

        ("MDDBG: " ++ text_a ++ "   " ++ text_b).postln;
        1.0.wait;
    });
}).play(AppClock);

nil
)

===== troubleshooting/Diag_Meters_BringUp_And_Verify.scd =====
// Diag_Meters_BringUp_And_Verify.scd
// v0.1.2
// MD 2025-09-26 14:31 BST

/* Purpose / Style
   Re-install inline taps (A/B + testmelody), then verify /md/levels traffic
   with a short counter. Prints a concise PASS/FAIL line with counts + last values.
   - var-first, descriptive lowercase, AppClock-only, no server.sync.
   - Pass-through taps (return 'in'); generated audio only.
*/

(
var ensureSources, installTapsOnce, installTapsRobust, verifyTraffic, postSummary;
var packetCounts, lastAPair, lastBPair, lastTPair, verifySeconds;

verifySeconds = 0.6;

packetCounts = IdentityDictionary[
    2001 -> 0,   // A
    2002 -> 0,   // B
    1001 -> 0    // testmelody probe
];

lastAPair = [0.0, 0.0];
lastBPair = [0.0, 0.0];
lastTPair = [0.0, 0.0];

ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // keep sinks alive
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
    });
};

installTapsOnce = { arg rateHz = 18;
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A
        Ndef(\chainA).filter(\mdTapA, nil);
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B
        Ndef(\chainB).filter(\mdTapB, nil);
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (always present for diagnostics)
        Ndef(\testmelody).filter(\mdTapT, nil);
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
};

installTapsRobust = {
    var passIndex, passCount;
    passIndex = 0; passCount = 3;
    AppClock.sched(0.0, {
        installTapsOnce.(18);
        passIndex = passIndex + 1;
        if(passIndex < passCount) { 0.20 } { nil }  // re-run every 200ms, 3 passes
    });
    "[Diag] Inline taps installed (A=2001, B=2002, T=1001) with 3-pass rearm.".postln;
};

verifyTraffic = {
    var defKey;
    defKey = \md_levels_diag_count;

    if(OSCdef.all.at(defKey).notNil) { OSCdef.all.at(defKey).free };

    OSCdef(defKey, { arg msg;
        var replyId, leftVal, rightVal, currentCount;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat;
        rightVal = msg[4].asFloat;

        if(replyId == 2001) {
            currentCount = packetCounts[2001] ? 0;
            packetCounts.put(2001, currentCount + 1);
            lastAPair = [leftVal, rightVal];
        };
        if(replyId == 2002) {
            currentCount = packetCounts[2002] ? 0;
            packetCounts.put(2002, currentCount + 1);
            lastBPair = [leftVal, rightVal];
        };
        if(replyId == 1001) {
            currentCount = packetCounts[1001] ? 0;
            packetCounts.put(1001, currentCount + 1);
            lastTPair = [leftVal, rightVal];
        };

        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    AppClock.sched(verifySeconds, {
        var defObj;
        defObj = OSCdef.all.at(defKey);
        if(defObj.notNil) { defObj.free };
        postSummary.();
        nil
    });

    ("[Diag] Counting /md/levels for " ++ verifySeconds.asString ++ " s‚Ä¶").postln;
};

postSummary = {
    var aCount, bCount, tCount, message;
    aCount = packetCounts[2001] ? 0;
    bCount = packetCounts[2002] ? 0;
    tCount = packetCounts[1001] ? 0;

    message = "RESULT /md/levels  A=" ++ aCount.asString
        ++ "  B=" ++ bCount.asString
        ++ "  T=" ++ tCount.asString
        ++ "  lastA=" ++ lastAPair.asString
        ++ "  lastB=" ++ lastBPair.asString
        ++ "  lastT=" ++ lastTPair.asString;

    message.postln;
};

// run
ensureSources.();
installTapsRobust.();
verifyTraffic.();
)

===== troubleshooting/Diag_Meters_QuickProbe_A_B_T.scd =====
// Diag_Meters_QuickProbe_A_B_T.scd
// v0.1.0  MD 2025-09-26
(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_probe_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key);
    if(d.notNil) { d.free };
    ("RESULT A=" ++ counts[2001].asString ++ " " ++ lastA.asString
     ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
     ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString).postln;
    nil
});
"[Probe] counting /md/levels for 0.5 s‚Ä¶".postln;
)

===== troubleshooting/Diag_MeterWiring_Inspector.scd =====
// Diag_MeterWiring_Inspector.scd
(
var wantedPaths, allDefs, summary, listForPath, printEntry;
wantedPaths = ["/md/levels", "/ampA", "/ampB"];
allDefs = OSCdef.all;
listForPath = { arg pathString;
    var matches;
    matches = List.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == pathString) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            matches.add([keySym, portValue])
        };
    });
    matches
};
printEntry = { arg pathString, entries;
    (pathString ++ ": " ++ entries.size.asString ++ " listener(s)").postln;
    entries.do({ arg one;
        var keySym, portValue;
        keySym = one[0]; portValue = one[1];
        ("  key=" ++ keySym.asString ++ " port=" ++ portValue.asString).postln;
    });
};
"=== Meter Wiring Inspector ===".postln;
summary = wantedPaths.collect({ arg p; [p, listForPath.(p)] });
summary.do({ arg pair;
    var pathString, entries;
    pathString = pair[0]; entries = pair[1];
    printEntry.(pathString, entries);
});
)

===== troubleshooting/Feed_ChainA_TestTone_PlayChainA.scd =====
// Feed_ChainA_TestTone_PlayChainA.scd
// v0.1.0
// MD timestamp: 2025-09-26 19:40 GMT+1

/*
Purpose
- Generate a gentle test tone and feed it into Ndef(\chainA) using <<>.
- Also calls Ndef(\chainA).play so you can hear it through the default output.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var freq, amp, msg;

freq = 220;      // adjust if you prefer
amp  = 0.10;     // safe level

Server.default.bind({
    // signal generator
    Ndef(\testmelody, { var sig;
        sig = SinOsc.ar(freq ! 2) * amp;
        sig
    });

    // connect strictly per your rule (left <<> right)
    Ndef(\chainA) <<> Ndef(\testmelody);

    // make it audible (optional but useful for sanity)
    Ndef(\chainA).play;
});

msg = "[FEED] Ndef(\\chainA) <<> Ndef(\\testmelody), playing @ " ++ freq ++ " Hz, amp=" ++ amp;
msg.postln;
msg
)

===== troubleshooting/Fix_Meters_KnownGood.scd =====
// Fix_Meters_KnownGood.scd
// v0.1.0
// MD 2025-09-26 14:45 BST

/* Purpose / Style
   Minimal, known‚Äëgood meter bring‚Äëup:
   1) Install a /md/levels receiver (-> ~md_levelsById, ~md_lastMsgStamp).
   2) Re-arm inline taps on chainA (2001), chainB (2002), testmelody (1001) via Ndef.filter.
   3) Heartbeat prints "last /md/levels: X s" every ~2s so we know it's alive.
   - var-first; descriptive lowercase names; AppClock-only; no server.sync; no '?:'.
   - Pass-through taps (return 'in'); *generated audio only*.
*/

(
var installReceiver, ensureSources, installTaps, startHeartbeat;
var rateHz, receiverKey, heartbeatRoutine;

rateHz = 18;
receiverKey = \md_levels_hud;

// ---------- 1) /md/levels receiver ----------
installReceiver = {
    var existing;
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;

    existing = OSCdef.all.at(receiverKey);
    if(existing.notNil) { existing.free };

    OSCdef(receiverKey, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    ("[HUD] /md/levels listener installed (key=" ++ receiverKey.asString ++ ")").postln;
};

// ---------- 2) Sources / sinks kept alive (no server.sync) ----------
ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks "awake" at audio rate (no audible change)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    "[Meters] sources/sinks ensured.".postln;
};

// ---------- 3) Inline taps via known-good Ndef.filter ----------
installTaps = {
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A (replyID 2001)
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B (replyID 2002)
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (replyID 1001)
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
    "[Meters] inline taps armed (A=2001, B=2002, T=1001).".postln;
};

// ---------- 4) Heartbeat (light) ----------
startHeartbeat = {
    var beatInterval, routine;
    beatInterval = 2.0;
    routine = Routine({
        var keepRunning, now, lastAge;
        keepRunning = true;
        while({ keepRunning }, {
            now = SystemClock.seconds.asFloat;
            lastAge = (now - (~md_lastMsgStamp ? now)).round(0.01);
            ("[Meters] last /md/levels: " ++ lastAge.asString ++ " s").postln;
            beatInterval.wait;
        });
    }).play(AppClock);
    routine
};

// Run steps
installReceiver.();
ensureSources.();
installTaps.();

// (Optional) start/refresh overlay drawing here if you added one earlier.

// Heartbeat so we know packets are arriving
heartbeatRoutine = startHeartbeat.();
)

===== troubleshooting/Fix_Taps_CheckBadValues_SideEffect.scd =====
// Fix_Taps_CheckBadValues_SideEffect.scd
// v0.1.0
// MD 2025-09-26 17:35 BST

/* Purpose / Style
   Purpose: Reinstall /md/levels taps for A/B so that CheckBadValues.kr is side-effect only
            (do not overwrite the visual signals). This should remove the constant 1.0 issue.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync.
*/

(
var reinstallOnce;

reinstallOnce = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // ---- CHAIN A ‚Üí replyID 2001
        Ndef(\chainA).filter(\mdVisTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            // Log-like visual map then gentle smoothing; keep 0..1
            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // Side-effect diagnostics only (do NOT assign result)
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2001);
            in_sig  // pass-through audio
        });

        // ---- CHAIN B ‚Üí replyID 2002
        Ndef(\chainB).filter(\mdVisTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2002);
            in_sig
        });
    });
    "MDTAPS: reinstalled /md/levels taps (A=2001, B=2002) with side-effect checks only.".postln;
};

reinstallOnce.();
nil
)

===== troubleshooting/INSTALL_AmpA_AmpB_Responders_Min.scd =====
// INSTALL_AmpA_AmpB_Responders_Min.scd
// v0.1.0
// MD 2025-09-29

(
var ensureModelReady, installAmpResponders, updatesToLog, logKeyA, logKeyB;

updatesToLog = 6;
logKeyA = \ampA_to_model_log_once;
logKeyB = \ampB_to_model_log_once;

ensureModelReady = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installAmpResponders = {
    var existingA, existingB;

    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };

    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };

    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear, logText;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;

        if(updatesToLog > 0) {
            logText = "[ampA_to_model] A: L=" ++ leftLinear.round(0.01)
                ++ "  R=" ++ rightLinear.round(0.01);
            logText.postln;
            updatesToLog = updatesToLog - 1;
            if(updatesToLog <= 0) { "ampA/B model logging done.".postln };
        };
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
};

ensureModelReady.();
installAmpResponders.();
)

===== troubleshooting/justMartin/MD_Test_OneDrive_RoundTrip.scd =====
// MD_Test_OneDrive_RoundTrip.scd
// v0.1.1
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose: Detect a OneDrive root, create a test folder, write a file, read it back, and print results.
            Works with ~/Library/CloudStorage/OneDrive-* and legacy ~/OneDrive* names.
   Style:   Single () block; VAR-FIRST in every closure; descriptive lowercase names; no server.sync; finite print.
*/

(
var postBanner, expandPath, listFolders, findOneDriveRoot, writeThenRead;
var cloudRoot, homeRoot, foundRoot, testFolderPath, testFilePath, timeStampText, resultPath;

// Header
postBanner = {
    var headerText;
    headerText = "=== MD_TEST_ONEDRIVE_ROUND_TRIP ===";
    headerText.postln;
};

// Expand helper
expandPath = { arg pathString;
    var pn;
    pn = PathName(pathString.standardizePath);
    pn.fullPath
};

// Folder list helper
listFolders = { arg directoryPath;
    var pn, entries, indexCount, indexLimit, outList, item;
    pn = PathName(directoryPath);
    if(pn.isFolder.not) { [] } {
        entries = pn.entries;
        indexCount = 0; indexLimit = entries.size; outList = [];
        while({ indexCount < indexLimit }, {
            item = entries[indexCount];
            if(item.isFolder) { outList = outList.add(item.fullPath) };
            indexCount = indexCount + 1;
        });
        outList
    }
};

// Root finder
findOneDriveRoot = {
    var roots, candidates, indexCount, indexLimit, pathItem, baseOk;
    roots = [];

    cloudRoot = expandPath.("~/Library/CloudStorage");
    candidates = listFolders.(cloudRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    homeRoot = expandPath.("~");
    candidates = listFolders.(homeRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    if(roots.size > 0) { roots[0] } { nil }
};

// Writer/reader
writeThenRead = { arg folderPath;
    var okFolder, outFileName, outPath, readBackText;

    okFolder = PathName(folderPath).isFolder;
    if(okFolder.not) { File.mkdir(folderPath) };

    timeStampText = Date.getDate.stamp;
    outFileName = "sc_roundtrip_" ++ timeStampText ++ ".txt";
    outPath = folderPath ++ "/" ++ outFileName;

    File.use(outPath, "w", { arg fileRef; fileRef.write("Hello from SuperCollider at " ++ timeStampText) });
    readBackText = "";
    File.use(outPath, "r", { arg fileRef; readBackText = fileRef.readAllString });

    ("ODTEST: wrote " ++ outPath).postln;
    ("ODTEST: read  " ++ readBackText).postln;
    outPath
};

// ‚Äî‚Äî run ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner.();

foundRoot = findOneDriveRoot.();
if(foundRoot.isNil) {
    "‚ö†Ô∏è ODTEST: OneDrive root not found. Edit script to supply your OneDrive path explicitly.".warn;
    "   Example: set foundRoot = \"/Users/yourname/Library/CloudStorage/OneDrive-YourOrg\";".postln;
    resultPath = nil;
} {
    ("ODTEST: root = " ++ foundRoot).postln;
    testFolderPath = foundRoot ++ "/SC_MPB_Test";
    ("ODTEST: folder = " ++ testFolderPath).postln;
    resultPath = writeThenRead.(testFolderPath);
    "ODTEST: done.".postln;
};

// Final expression (so the block returns a value but uses no ^)
resultPath
)

===== troubleshooting/MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd =====
// MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd
// v0.1.0
// MD 2025-09-26 19:12 BST

/* Purpose / Style
   Purpose:
     ‚Ä¢ Loud console headers; clean-boot bring-up.
     ‚Ä¢ Single MagicDisplayGUI GridDemo window; bind CommandManager.display if present.
     ‚Ä¢ Generated-audio test source Ndef(\testmelody) at modest level.
     ‚Ä¢ Feed chain A from testmelody using Ndef(left) <<> Ndef(right).
     ‚Ä¢ Raw amplitude taps on A/B ‚Üí /md/levels (A=2001, B=2002).
     ‚Ä¢ Finite sniffer: print 6 lines (1 Hz) AND append to OneDrive log; auto-free listener.
     ‚Ä¢ Tiny overlay meters on the existing GUI (top-left) for ~4.5 s; auto-stop.
     ‚Ä¢ Final expression returns ‚Üí a Window.
   Style:
     ‚Ä¢ Single () block; VAR-FIRST in EVERY block/closure; ‚â•3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock for GUI; known-good SC syntax only.
*/

(
var postBanner, findWindowByPrefix, ensureGridDemoWindow, freeOscIfPresent, stopRoutineIfPresent;
var serverRef, guiWindow, systemRef, commandManagerRef;
var oneDriveRoot, sessionFolderPath, logFilePath, timeStampText;
var oscKeyLevels, linesRemaining, overlayView, overlayTicksRemaining, overlayRoutine;
var valuesById;

// ‚Äî‚Äî‚Äî loud header ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner = {
    var headerText;
    headerText = "=== MD_BRINGUP_GRIDDEMO_FEEDA_SAVEMETERS_ONEDRIVE ===";
    headerText.postln;
};

// ‚Äî‚Äî‚Äî helpers (VAR-FIRST in closures) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, nameString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        nameString = windowRef.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var priorWin, guiObj, newWin;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)‚Ä¶".postln;
    priorWin = findWindowByPrefix.("MagicDisplayGUI");
    if(priorWin.notNil) {
        priorWin.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };
    guiObj = MagicDisplayGUI_GridDemo.new;
    systemRef = ~system;
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };
    newWin = findWindowByPrefix.("Magic
===== troubleshooting/MD_Check_Suite_Symlink.scd =====
// MD_Check_Suite_Symlink.scd
// v0.1.0
// MD 2025-09-26 19:55 BST

/* Purpose / Style
   Purpose: Report whether Extensions/LivePedalboardSuite is a symlink and, if so, where it points.
            This block is read-only (no filesystem changes).
   Style:   Single () block; VAR-FIRST in every closure; ‚â•3-char lowercase descriptive names;
            no single-letter locals; no server.sync; finite output; no non-local ^ in .scd.
*/

(
var postBanner, quotePath, extensionsDir, suiteExtPath, testCmd, isLinkExit, isSymlinkFlag;
var readCmd, pipeRef, linkTargetPath, expectedTargetPrefix, looksCorrectFlag;

postBanner = {
    var headerText;
    headerText = "=== MD_CHECK_SUITE_SYMLINK ===";
    headerText.postln;
};

quotePath = { arg rawPathString;
    var q;
    q = "\"" ++ rawPathString.asString ++ "\"";
    q
};

postBanner.();

// 1) Paths
extensionsDir = Platform.userExtensionDir.standardizePath;
suiteExtPath  = extensionsDir +/+ "LivePedalboardSuite";
("EXT: suite path = " ++ suiteExtPath).postln;

// 2) Is it a symlink? (exit=0 means yes)
testCmd = "[ -L " ++ quotePath.(suiteExtPath) ++ " ]";
isLinkExit = testCmd.unixCmd;
isSymlinkFlag = (isLinkExit == 0);
("EXT: is symlink? " ++ isSymlinkFlag.asString).postln;

// 3) If a symlink, read its target
linkTargetPath = "(not a symlink)";
if(isSymlinkFlag) {
    readCmd = "readlink " ++ quotePath.(suiteExtPath);
    pipeRef = Pipe.new(readCmd, "r");
    linkTargetPath = if(pipeRef.notNil) { pipeRef.getLine } { "(unavailable)" };
    if(pipeRef.notNil) { pipeRef.close };
};
("EXT: link target = " ++ linkTargetPath).postln;

// 4) Does the link target appear to live under OneDrive?
expectedTargetPrefix = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
looksCorrectFlag = isSymlinkFlag and: { linkTargetPath.asString.beginsWith(expectedTargetPrefix) };
("OD : target under OneDrive? " ++ looksCorrectFlag.asString).postln;

// Final note
if(isSymlinkFlag.not) {
    "NOTE: Extensions/LivePedalboardSuite is a real folder, not a link. We can convert it to a symlink safely.".postln;
} {
    "NOTE: Good ‚Äî Extensions/LivePedalboardSuite is a symlink.".postln;
};

nil
)

===== troubleshooting/MD_MeterDiagnostics_Proof_Min.scd =====
// MD_MeterDiagnostics_Proof_Min.scd
// v0.1.1 (var-first everywhere; correct /md/levels format)
// MD timestamp: 2025-09-27 19:52 GMT+1

/*
Purpose (first principles)
- \const: set A to exact values (no audio), prove GUI path.
- \ramp: animate A deterministically (no audio), prove timing.
- \audio: feed a sine into chainA, compute expected RMS, print measured levels,
  send live values to /md/levels (A=2001, B=2002) and correlate with what you hear.

Style / Guard Rails
- Single () block; VAR-FIRST in all blocks/closures; no non-local returns; no server.sync.
- AppClock only for finite drivers; loud banners.
*/

(
var phase, server, sendToLang, banner, postLine, hz, secs, startWhen, endWhen, tickTask;
var constAL, constAR;
var testFreq, testAmp, expectedRMS;
var ensureProxy, attachTap, makeTaps;
var sendPair;

// ===== PHASE SELECTOR =====
phase = \const;  // change to \ramp or \audio and re-run the SAME block

// ===== COMMON UTILS (statements OK after var decls) =====
server     = Server.default;
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);
banner     = { arg text; ("[MDPROOF] " ++ text).postln; };
postLine   = { arg text; text.postln; };
hz         = 12;
secs       = 4.0;
startWhen  = thisThread.seconds;
endWhen    = startWhen + secs;

// We send messages matching your GUI/meter path:
// ['/md/levels', nodeID, replyID, L, R]  (replyIDs: A=2001, B=2002)
sendPair = { arg aLR, bLR;
    var aL, aR, bL, bR;
    aL = aLR[0]; aR = aLR[1]; bL = bLR[0]; bR = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

// ===== PHASE A params =====
constAL = 0.25;  // set any values 0..1 to prove exactness
constAR = 0.75;

// ===== PHASE C params =====
testFreq    = 220;
testAmp     = 0.20;                       // gentle
expectedRMS = (testAmp / (2.sqrt));       // RMS(sin) = A/‚àö2

// ===== TAPS for PHASE C (server-side; var-first in closures) =====
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);

        // Correct: replyID is 4th arg; values are ONLY [L, R]
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// ===== DRIVER =====
(phase == \const).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE A: set A=(" ++ constAL ++ "," ++ constAR ++ "), B=(0,0) for " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now;
        now = thisThread.seconds;
        (now < taskEnd).if({
            sendPair.([constAL, constAR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE A done.");
            nil
        });
    });
});

(phase == \ramp).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE B: ramp A L:0‚Üí0.9, R:0.9‚Üí0 over " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < taskEnd).if({
            t  = (now - taskStart) / secs;         // 0..1
            aL = (0.9 * t).clip(0.0, 0.9);         // rise
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);   // fall
            sendPair.([aL, aR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE B done.");
            nil
        });
    });
});

(phase == \audio).if({
    var spyStopAt;
    banner.("PHASE C: audio freq=" ++ testFreq ++ " Hz, amp=" ++ testAmp
        ++ "  (expected RMS‚âà" ++ expectedRMS.round(0.0001) ++ ")");

    Server.default.bind({
        var sig;
        sig = SinOsc.ar(testFreq ! 2) * testAmp;
        Ndef(\testmelody, { sig });
        Ndef(\chainA) <<> Ndef(\testmelody);
        Ndef(\chainA).play;
    });

    makeTaps.();

    spyStopAt = thisThread.seconds + 5.0;
    OSCdef(\mdSpyA, { arg msg, time, addr, port;
        var isA, l, r, line;
        isA = (msg.size >= 5) and: { msg[2] == 2001 };
        isA.if({
            l = msg[3].asFloat; r = msg[4].asFloat;
            line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
                ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.001);
            line.postln;
        });
    }, '/md/levels');

    AppClock.sched(5.0, {
        OSCdef(\mdSpyA).free;
        banner.("PHASE C done. Use Cleanup_ChainA_Unfeed later to stop audio.");
        nil
    });
});

"-> MD_MeterDiagnostics_Proof_Min scheduled.".postln;
)

===== troubleshooting/MD_Meters_D1_SpyAndRamp.scd =====
// MD_Meters_D1_SpyAndRamp.scd
// v0.1.0
// MD timestamp: 2025-09-28 09:55 GMT+1

/*
Purpose
- First principles: prove the sclang process receives /md/levels.
- Spy counts A (2001) and B (2002) messages for 3 s while we send a ramp.
- If counts > 0, OSC is fine and PerfHUD isn't listening to /md/levels.
- If counts == 0, messages aren't arriving (wrong port/shape).

Style / Guard Rails
- Single () block; VAR-FIRST everywhere; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendRamp, aCount, bCount, total, spy, startAt, endAt, banner;

hz         = 12;
secs       = 3.0;
aCount     = 0;
bCount     = 0;
total      = 0;
banner     = { arg text; ("[MD_D1] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// ---- Spy: capture ANY /md/levels messages and count A/B by replyID position ----
OSCdef(\md_levels_spy).free;
spy = OSCdef(\md_levels_spy, { arg msg, time, addr, port;
    var isA, isB;
    // Expect S1 standard: ['/md/levels', nodeID, replyID, L, R]
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isB = (msg.size >= 5) and: { msg[2] == 2002 };
    isA.if({ aCount = aCount + 1; });
    isB.if({ bCount = bCount + 1; });
    total = total + 1;
}, '/md/levels');

// ---- Known-good sender: S1 standard shape [0, replyID, L, R] ----
sendRamp = {
    var t, aL, aR, now, endSend;
    now = thisThread.seconds;
    endSend = now + secs;
    AppClock.sched(0.0, {
        var cur;
        cur = thisThread.seconds;
        (cur < endSend).if({
            t  = (cur - now) / secs;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
            sendToLang.sendMsg('/md/levels', 0, 2002, 0.0, 0.0); // B held at 0
            (1.0 / hz)
        }, {
            nil
        });
    });
};

banner.("Starting spy + ramp for " ++ secs ++ " s‚Ä¶");
startAt = thisThread.seconds;
endAt   = startAt + secs;

sendRamp.();

AppClock.sched(secs + 0.1, {
    OSCdef(\md_levels_spy).free;
    banner.("Spy summary: total=" ++ total
        ++ "  A(2001)=" ++ aCount
        ++ "  B(2002)=" ++ bCount);
    "-> MD_Meters_D1_SpyAndRamp done.".postln;
    nil
});
"-> MD_Meters_D1_SpyAndRamp scheduled."
)

===== troubleshooting/MD_Meters_D2_ListOSCdefs_ByPath.scd =====
// MD_Meters_D2_ListOSCdefs_ByPath.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:05 GMT+1

/*
Purpose
- Print all OSCdef listeners whose path mentions md/levels/meter.
- Confirms whether the PerfHUD window registered a listener and how it matches.
*/

(
var items, printOne;

items = List.new;

printOne = { arg keySym, def;
    var p, t, ps;
    p  = def.path;
    t  = def.argTemplate;
    ps = p ? "";
    ((ps.contains("md") or: { ps.contains("levels") or: { ps.contains("meter") } })).if({
        ("OSCdef " ++ keySym.asString
            ++ " : path=" ++ ps
            ++ "  template=" ++ (t ? nil).asString).postln;
        items.add(keySym);
    });
};

OSCdef.all.keysValuesDo { arg k, d; printOne.(k, d) };

("Found " ++ items.size ++ " OSCdef(s) matching 'md|levels|meter'").postln;
)

===== troubleshooting/MD_Meters_PhaseB_CompatProbe.scd =====
// MD_Meters_PhaseB_CompatProbe.scd
// v0.1.0
// MD timestamp: 2025-09-27 20:12 GMT+1

/*
Purpose
- Determine which /md/levels message shape your PerfHUD v0.5.4 consumes.
- Sends the same ramp in three 2s segments:
  A) S1 standard: ['/md/levels', nodeID=0, replyID=2001/2002, L, R]
  B) S0 legacy:  ['/md/levels', replyID=2001/2002, L, R]            // first arg after path is replyID
  C) S2 variant: ['/md/levels', nodeID=0, 0, replyID, L, R]         // mimics old SendReply misuse

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var hz, secsEach, sendToLang, banner, sendS1, sendS0, sendS2, startAt, segmentDur, schedSeg;

// Params
hz       = 12;      // updates per second
secsEach = 2.0;     // duration per segment (A/B/C)

// Utils
banner     = { arg text; ("[MD_COMPAT] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// --- Three message shapes ---
sendS1 = { arg aL, aR, bL, bR;
    // S1 standard: ['/md/levels', 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

sendS0 = { arg aL, aR, bL, bR;
    // S0 legacy: ['/md/levels', 2001, L, R]
    sendToLang.sendMsg('/md/levels', 2001, aL, aR);     // A
    sendToLang.sendMsg('/md/levels', 2002, bL, bR);     // B
};

sendS2 = { arg aL, aR, bL, bR;
    // S2 variant: ['/md/levels', 0, 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 0, 2002, bL, bR);  // B
};

// --- Scheduler for one segment with the given sender ---
schedSeg = { arg label, senderFunc;
    var segStart, segEnd;
    segStart = thisThread.seconds;
    segEnd   = segStart + secsEach;
    banner.("SEG " ++ label ++ " ‚Äî ramp A: L 0‚Üí0.9, R 0.9‚Üí0 (" ++ secsEach ++ " s)");
    AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < segEnd).if({
            t  = (now - segStart) / secsEach;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            senderFunc.value(aL, aR, 0.0, 0.0);  // B kept at 0
            (1.0 / hz)
        }, {
            banner.("SEG " ++ label ++ " done.");
            nil
        });
    });
};

// --- Run the three segments back-to-back ---
AppClock.sched(0.0, { schedSeg.("A (S1 standard: [0,replyID,L,R])", sendS1); secsEach });
AppClock.sched(secsEach, { schedSeg.("B (S0 legacy: [replyID,L,R])",   sendS0); secsEach });
AppClock.sched(secsEach*2, { schedSeg.("C (S2 variant: [0,0,replyID,L,R])", sendS2); nil });

"-> MD_Meters_PhaseB_CompatProbe scheduled (6 s total).".postln;
)

===== troubleshooting/MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd =====
// MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:27 GMT+1

/*
Purpose
- Audio proof with the tap attached to Ndef(\testmelody) (the generator),
  so measured levels are guaranteed non-zero and derived from the actual test signal.
- Sends /md/levels A=2001 from the tap; B stays untouched.

Style / Guard Rails
- Single () block; VAR-FIRST throughout; no non-local returns; no server.sync.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTapOnTest;

// params
hz = 12;
testFreq = 220;
testAmp  = 0.20;                       // gentle, audible
expectedRMS = (testAmp / (2.sqrt));    // ‚âà 0.1414

banner = { arg text; ("[MD_A_AUDIO_FIX] " ++ text).postln; };

// ensure Ndefs exist (not strictly needed for \testmelody, kept for consistency)
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

// attach tap directly on \testmelody (NOT \chainA)
attachTapOnTest = { arg replyID;
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID); // replyID=2001
        inSig
    });
};

// generate tone, feed chainA, and play (so you hear it)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    ensureProxy.(\chainA, 2);
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

attachTapOnTest.(2001);

// finite console monitor for correlation (5 s)
OSCdef(\mdSpyA_fix).free;
OSCdef(\mdSpyA_fix, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
        ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA_fix).free;
    banner.("done (audio keeps playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS‚âà" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio_FIX_TapOnTest scheduled."
)

===== troubleshooting/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd =====
// MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd
// v0.1.2
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose:
     ‚Ä¢ Loud console header + step banners so you can see it ran.
     ‚Ä¢ Clean-boot bring-up: server, single MagicDisplayGUI GridDemo window, modest-level test source.
     ‚Ä¢ Feed chain A from testmelody using your operator: Ndef(left) <<> Ndef(right).
     ‚Ä¢ Install simple raw Amplitude taps to /md/levels (A=2001, B=2002).
     ‚Ä¢ Print exactly 6 lines (1 Hz) and auto-stop; no console spam.
     ‚Ä¢ Final expression returns ‚Üí a Window.
   Style:
     ‚Ä¢ Single () block; VAR-FIRST in every block/closure; ‚â•3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock-only for GUI; known-good SC syntax.
*/

(
var postBanner, freeOscIfPresent, stopRoutineIfPresent, findWindowByPrefix, ensureGridDemoWindow;
var serverRef, oscKeyLevels, reporterRoutine, linesRemaining, guiWindow, systemRef, commandManagerRef;

// ‚Äî‚Äî header ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner = {
    var headerText;
    headerText = "=== MD_MIN_BRINGUP_FEEDA_SIMPLEMETERS_GRIDDEMO ===";
    headerText.postln;
};

// ‚Äî‚Äî helpers (VAR-FIRST inside closures) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MD: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineRef, labelString;
    var canStopRoutine;
    canStopRoutine = routineRef.notNil and: { routineRef.respondsTo(\stop) };
    if(canStopRoutine) { routineRef.stop; (labelString ++ ": stopped").postln };
};

findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, titleString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        titleString = windowRef.tryPerform(\name);
        if(titleString.notNil and: { titleString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            // do not use ^ ; just set foundWindow and let the closure return last expression
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var oldWindow, guiObj, newWindow;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)‚Ä¶".postln;

    oldWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(oldWindow.notNil) {
        oldWindow.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };

    guiObj = MagicDisplayGUI_GridDemo.new; // safe fallback GUI

    systemRef = ~system; // if user has a system object, bind display
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };

    newWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(newWindow.isNil) { "‚ö†Ô∏è GUI: no MagicDisplayGUI window found after creation".warn };
    newWindow
};

// ‚Äî‚Äî run ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
postBanner.();

// Server bring-up (allowed here)
serverRef = Server.default;
"STEP S: booting server‚Ä¶".postln;
serverRef.waitForBoot;
"STEP S: server booted".postln;

// GUI
guiWindow = ensureGridDemoWindow.();

// Source: testmelody (modest level; generated audio only)
"STEP SRC: defining Ndef(\\testmelody)‚Ä¶".postln;
Server.default.bind({
    Ndef(\testmelody, {
        var triggerCtl, freqCtl, envCtl, panCtl, midiScale, indexCtl, pairSig;
        triggerCtl = Impulse.kr(2.0);
        midiScale  = [60, 62, 64, 67, 69];
        indexCtl   = Demand.kr(triggerCtl, 0, Dwhite(0, midiScale.size, inf));
        freqCtl    = Select.kr(indexCtl, midiScale).midicps;
        envCtl     = Decay2.kr(triggerCtl, 0.01, 0.40);
        panCtl     = LFNoise1.kr(0.25).range(-0.6, 0.6);
        pairSig    = Pan2.ar(SinOsc.ar(freqCtl) * envCtl * 0.18, panCtl); // modest level
        pairSig
    });
    Ndef(\testmelody).ar(2);
});

// Feed chain A from testmelody (your operator)
"STEP FEED: using Ndef(left) <<> Ndef(right): A <<> testmelody".postln;
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
    Ndef(\chainA) <<> Ndef(\testmelody);
});

// Simple raw amplitude taps to /md/levels
"STEP TAPS: install raw amplitude taps (/md/levels A=2001, B=2002)‚Ä¶".postln;
oscKeyLevels = \md_levels_sniffer_finite;
freeOscIfPresent.(oscKeyLevels);

Server.default.bind({
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
        inSig
    });

    Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
        inSig
    });
});

// Finite 6-line sniffer (auto-free)
"STEP MTR: printing 6 lines (1 Hz) then auto-stop‚Ä¶".postln;
linesRemaining = 6;
OSCdef(oscKeyLevels, { arg oscMessage;
    var replyId, leftVal, rightVal, meterLabel, linesDone;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        meterLabel = if(replyId == 2001) { "A" } { if(replyId == 2002) { "B" } { replyId.asString } };
        ("MDMTR: " ++ meterLabel ++ " (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")").postln;

        linesRemaining = linesRemaining - 1;
        linesDone = linesRemaining <= 0;
        if(linesDone) {
            var oscRef2;
            oscRef2 = OSCdef.all.at(oscKeyLevels);
            if(oscRef2.notNil) { oscRef2.free; "MDMTR: listener freed.".postln };
        };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Bring GUI front and return ‚Üí a Window
if(guiWindow.notNil) { guiWindow.front };
guiWindow  // ‚Üí a Window
)

===== troubleshooting/MD_PerfHUD_LevelSubscriber.scd =====
// MD_PerfHUD_LevelSubscriber.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:15 GMT+1

/*
Purpose
- Populate ~md_levelsById (IdentityDictionary) from /md/levels messages so
  MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd can render meters.
- Also updates ~md_lastMsgStamp for the "last /md/levels age" display.

Message shapes handled
- Standard: ['/md/levels', nodeID, replyID, L, R]   (preferred)
- Legacy:   ['/md/levels', replyID, L, R]           (fallback)

Reply IDs used by the GUI (per file comments):
- A = 2001, B = 2002, test = 1001
*/

(
var ensureDict, putPair, banner, oscAny;

banner = { arg text; ("[MD_SUB] " ++ text).postln; };

// Ensure the shared dictionary exists (the GUI reads this)
ensureDict = {
    (~md_levelsById.isKindOf(IdentityDictionary)).if({
        // already OK
    }, {
        ~md_levelsById = IdentityDictionary.new;
        banner.("created ~md_levelsById");
    });
    ~md_lastMsgStamp = ~md_lastMsgStamp ? thisThread.seconds;
};

putPair = { arg id, l, r;
    var pair;
    pair = [ (l ? 0.0).asFloat, (r ? 0.0).asFloat ];
    ~md_levelsById[id] = pair;
    ~md_lastMsgStamp = thisThread.seconds;
};

// Clean prior instance (idempotent)
OSCdef(\md_levels_any).free;

ensureDict.();

// One listener that accepts both shapes and writes into ~md_levelsById
oscAny = OSCdef(\md_levels_any, { arg msg, time, addr, port;
    var id, l, r, sz;
    sz = msg.size;
    // Standard
    (sz >= 5).if({
        id = msg[2];
        l  = msg[3];
        r  = msg[4];
        putPair.(id, l, r);
    }, {
        // Legacy
        (sz == 4).if({
            id = msg[1];
            l  = msg[2];
            r  = msg[3];
            putPair.(id, l, r);
        }, {
            // ignore
        });
    });
}, '/md/levels');

banner.("listening on /md/levels ‚Üí ~md_levelsById (A=2001, B=2002, test=1001)");
"-> MD_PerfHUD_LevelSubscriber ready"
)

===== troubleshooting/MD_PhaseC_Smoke_PlayTest_TapTest.scd =====
// MD_PhaseC_Smoke_PlayTest_TapTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:58 GMT+1

/*
Purpose
1) Force Ndef(\testmelody) to run by playing it directly.
2) Prove the tap executes by sending a constant 0.5 for 2s (meters must move).
3) Switch the tap to real Amplitude.kr for 3s and print measured vs expected RMS.
All updates go to /md/levels A=2001 (B untouched).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync; finite.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, now,
    installConstantTap, installAmplitudeTap, removeTap, spy, stopSpyAt;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ‚âà0.1414

banner = { arg text; ("[MD_SMOKE] " ++ text).postln; };

// 0) Ensure a fresh, running generator (play directly so the proxy surely runs)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\testmelody).play; // <-- force run; independent of \chainA
});
banner.("testmelody playing @ " ++ testFreq ++ " Hz, amp=" ++ testAmp);

// helper: remove our tap cleanly
removeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig; inSig });
};

// 1) Tap variant A: constant 0.5 for 2s (meters must move)
installConstantTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var trig, l, r;
        trig = Impulse.kr(hz);
        l = 0.5; r = 0.5;
        SendReply.kr(trig, '/md/levels', [l, r], 2001);
        inSig
    });
    banner.("tap A: CONSTANT 0.5 for 2s (A should show ~0.5)");
};

// 2) Tap variant B: real amplitude for 3s (print measured vs expected)
installAmplitudeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], 2001);
        inSig
    });
    banner.("tap B: Amplitude.kr for 3s (console prints A_meas vs expected RMS)");
};

// Spy: show arriving values for A=2001 only
OSCdef(\mdSmokeSpy).free;
spy = OSCdef(\mdSmokeSpy, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
            ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

// Schedule: 0..2s constant 0.5, 2..5s amplitude, stop spy
now = thisThread.seconds;

AppClock.sched(0.0, { installConstantTap.(); 2.0 });
AppClock.sched(2.0, { installAmplitudeTap.(); 3.0 });
stopSpyAt = now + 5.0;
AppClock.sched(5.0, {
    removeTap.();
    OSCdef(\mdSmokeSpy).free;
    banner.("done (testmelody still playing; stop with MD_Cleanup_ChainA_Unfeed if needed).");
    nil
});

"-> MD_PhaseC_Smoke_PlayTest_TapTest scheduled."
)

===== troubleshooting/MD_Probe_Sources_Chain_RawAmp_AutoStop.scd =====
// MD_Probe_Sources_Chain_RawAmp_AutoStop.scd
// v0.1.0
// MD 2025-09-26 18:22 BST

/* Purpose / Style
   Purpose: Measure raw amplitudes directly at the source Ndef(\testmelody) and at the sink Ndef(\chainA)
            by creating two temporary probe Ndefs that read those proxies and SendReply their raw
            Amplitude.kr values to "/md/probe". A finite OSCdef prints exactly 6 lines and then removes
            itself and frees the probes. No GUI changes, no server.sync, single block.
   Style:   single () block; var-first in every closure; descriptive lowercase variable names (>=3 chars);
            AppClock-safe; returns nil.
*/

(
var ensureProbes, installSpy, startReporterAndCleanup;
var probeKeySource, probeKeyChain, spyKey, reporterRoutine, printCountRemaining;

// ---- configuration
printCountRemaining = 6;
probeKeySource = \md_probe_tm;    // probe for testmelody
probeKeyChain  = \md_probe_chain; // probe for chainA
spyKey         = \md_probe_spy;   // OSCdef key

// ---- 1) Create probes (server-side) that read from existing Ndefs and SendReply raw amplitudes
ensureProbes = {
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Server.default.bind({
        // Probe source: reads Ndef(\testmelody).ar(2)
        Ndef(probeKeySource, {
            var srcSig, ampLeft, ampRight;
            srcSig   = Ndef(\testmelody).ar(2);  // read directly from the source proxy
            ampLeft  = Amplitude.kr(srcSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(srcSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51001);
            Silent.ar(2) // silent synth (no audio output)
        }).play;  // ensure it runs on the server

        // Probe chainA: reads Ndef(\chainA).ar(2)
        Ndef(probeKeyChain, {
            var chainSig, ampLeft, ampRight;
            chainSig = Ndef(\chainA).ar(2);  // read directly from the sink proxy
            ampLeft  = Amplitude.kr(chainSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(chainSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51002);
            Silent.ar(2)
        }).play;
    });

    "MDPROBE: probes created (tm=51001, chainA=51002) ‚Üí /md/probe".postln;
};

// ---- 2) Spy listener (finite) that prints exactly 6 lines then frees itself and the probes
installSpy = {
    if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

    OSCdef(spyKey, { arg oscMessage;
        var msgSize, replyId, leftVal, rightVal, lineText;

        msgSize = oscMessage.size;
        if(msgSize >= 5) {
            replyId = oscMessage[2];
            leftVal  = oscMessage[3];
            rightVal = oscMessage[4];

            // guard + clip to [0,1]
            leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
            rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

            lineText = case
            { replyId == 51001 } { "SRC \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { replyId == 51002 } { "A   \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { "ID " ++ replyId.asString ++ " \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" };

            ("MDPROBE: " ++ lineText).postln;

            printCountRemaining = printCountRemaining - 1;
            if(printCountRemaining <= 0) {
                var spyObj;
                spyObj = OSCdef.all.at(spyKey);
                if(spyObj.notNil) { spyObj.free; "MDPROBE: spy freed".postln };

                // free probes (server-side)
                Server.default.bind({
                    if(Ndef(probeKeySource).isPlaying) { Ndef(probeKeySource).free };
                    if(Ndef(probeKeyChain ).isPlaying) { Ndef(probeKeyChain ).free };
                });
                "MDPROBE: probes freed".postln;
            };
        };
        nil
    }, "/md/probe", recvPort: NetAddr.langPort);
    "MDPROBE: spy armed (6 lines)‚Ä¶".postln;
};

// ---- 3) Go
ensureProbes.();
installSpy.();
nil
)

===== troubleshooting/MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd =====
// MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd
// v0.1.0
// MD 2025-09-26 17:55 BST

/* Purpose / Style
   Purpose: Replace current /md/levels taps with a *simple* version that sends raw Amplitude.kr values
            (no LinExp, no LagUD) for A/B sinks. Then install a finite sniffer that prints exactly
            6 lines (one per second) and auto-stops.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync; AppClock.
*/

(
// ---- reinstall simple taps (server-side), replyIDs: A=2001, B=2002
var reinstallSimpleTaps;

reinstallSimpleTaps = {
    Server.default.bind({
        var rateHertz, attackSec, releaseSec, floorAmp;

        rateHertz  = 24;
        attackSec  = 0.01;
        releaseSec = 0.20;
        floorAmp   = 1e-5;

        // CHAIN A
        Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            // Send raw amplitudes (0..1)
            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
            inSig
        });

        // CHAIN B
        Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
            inSig
        });
    });
    "MDSIMPLE: raw amplitude taps installed (/md/levels; A=2001 B=2002).".postln;
};

reinstallSimpleTaps.();
nil
);

// ---- finite sniffer: prints exactly 6 lines and auto-stops
(
var valuesById, oscKey, remainingLines, reporterRoutine;

// Shared store
valuesById = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = valuesById;

// Finite cycles to print
remainingLines = 6;

// Clean previous finite sniffer (if any)
oscKey = \md_levels_sniffer_fixed;
if(OSCdef.all.at(oscKey).notNil) { OSCdef.all.at(oscKey).free };

// Listener: only update the dict; no console spam here
OSCdef(oscKey, { arg oscMessage;
    var replyId, leftVal, rightVal;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        // Guards + clip 0..1
        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        valuesById.put(replyId, [leftVal, rightVal]);
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Reporter: 1 Hz; prints 6 lines then stops and frees listener
reporterRoutine = Routine({
    var keepRunning;
    keepRunning = true;

    while({ keepRunning and: { remainingLines > 0 } }, {
        var pairA, pairB, textA, textB;

        pairA = valuesById.at(2001) ? [0, 0];
        pairB = valuesById.at(2002) ? [0, 0];

        textA = "A(L,R)=(" ++ pairA[0].round(0.01) ++ "," ++ pairA[1].round(0.01) ++ ")";
        textB = "B(L,R)=(" ++ pairB[0].round(0.01) ++ "," ++ pairB[1].round(0.01) ++ ")";

        ("MDSIMPLE: " ++ textA ++ "  " ++ textB).postln;

        remainingLines = remainingLines - 1;
        1.0.wait;
    });

    // Auto-clean: free listener and stop routine
    var oscObj;
    oscObj = OSCdef.all.at(oscKey);
    if(oscObj.notNil) { oscObj.free; "MDSIMPLE: listener freed.".postln };

    "MDSIMPLE: reporter finished.".postln;
}).play(AppClock);

nil
)

===== troubleshooting/MD_Spy_md_levels_RawAutoStop.scd =====
// MD_Spy_md_levels_RawAutoStop.scd
// v0.1.0
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Print the next 4 OSC messages received on "/md/levels" verbatim (with indices),
            then auto-free the listener so the console stays clean.
   Style:   single () block; var-first everywhere; descriptive lowercase names; no server.sync; returns nil.
*/

(
var spyKey, remainingCount, printOneMessage;

spyKey = \md_levels_spy_once;
remainingCount = 4;

// ensure previous spy is gone
if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

// print helper (var-first inside closure)
printOneMessage = { arg messageArray;
    var sizeCount, indexPos, indexLimit, lineText;
    sizeCount = messageArray.size;
    ("MDSPY: size=" ++ sizeCount.asString).postln;
    indexPos = 0; indexLimit = sizeCount;
    while({ indexPos < indexLimit }, {
        lineText = ("  [" ++ indexPos.asString ++ "] = " ++ messageArray[indexPos].asString);
        lineText.postln;
        indexPos = indexPos + 1;
    });
};

OSCdef(spyKey, { arg oscMessage;
    var localCount, doneNow;
    localCount = remainingCount;
    printOneMessage.(oscMessage);
    remainingCount = remainingCount - 1;
    doneNow = remainingCount <= 0;
    if(doneNow) {
        var spyObj;
        spyObj = OSCdef.all.at(spyKey);
        if(spyObj.notNil) { spyObj.free; "MDSPY: freed".postln };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

"MDSPY: armed for 4 messages‚Ä¶".postln;
nil
)

===== troubleshooting/MD_Taps_Clear_All_FIXED.scd =====
// MD_Taps_Clear_All_FIXED.scd
// v0.1.1 (clear proxies instead of filter(..., nil))
// MD timestamp: 2025-09-28 10:52 GMT+1

/*
Purpose
- Remove all taps/filters by clearing proxies and recreating chainA as a 2‚Äëch audio proxy.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var msg;

Server.default.bind({
    // stop and clear any existing sources/filters/taps
    Ndef(\chainA).stop; Ndef(\chainA).clear; Ndef(\chainA).ar(2);
    Ndef(\chainB).stop; Ndef(\chainB).clear; Ndef(\chainB).ar(2);
    Ndef(\testmelody).stop; Ndef(\testmelody).clear;
});

msg = "[TAPS] cleared: chainA, chainB, testmelody ‚Äî chainA re-created as 2ch.";
msg.postln;
msg
)

===== troubleshooting/MD_Taps_Clear_All.scd =====
// MD_Taps_Clear_All.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:45 GMT+1

/*
Purpose
- Remove any previously attached /md/levels taps on chainA/chainB/testmelody
  so only one producer drives A=2001 / B=2002.

Style
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var cleared;

Server.default.bind({
    // Remove known tap filter keys if present
    Ndef(\chainA).filter(\eodTapA, nil);
    Ndef(\chainB).filter(\eodTapB, nil);
    Ndef(\testmelody).filter(\proofTap, nil);
});

cleared = "[TAPS] cleared filters: chainA(\\eodTapA), chainB(\\eodTapB), testmelody(\\proofTap)";
cleared.postln;
cleared
)

===== troubleshooting/MODEL_Print_Amp_Model_Values.scd =====
// MODEL_Print_Amp_Model_Values.scd
// v0.1.1
// MD 2025-09-29

(
var linesRemaining, printOnce;

linesRemaining = 6;

printOnce = {
    var levelsA, levelsB, reportText;
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });
    reportText = "model A=" ++ levelsA ++ "   B=" ++ levelsB;
    reportText.postln;

    linesRemaining = linesRemaining - 1;
    if(linesRemaining > 0) {
        AppClock.sched(0.5, { printOnce.(); nil });
    }{
        nil
    };
};

AppClock.sched(0.0, { printOnce.(); nil });
)

===== troubleshooting/Notes_Meters_2025-09-26.txt =====
Notes_Meters_2025-09-26
MD 2025-09-26

Summary
- NEW HUD (PerfHUD v0.5.4) is the correct window.
- Root cause of ‚Äúmeters not moving‚Äù: no OSC responders active in HUD (0 listeners for /md/levels, /ampA, /ampB).
- Secondary nuisance: occasional Window.flipY(nil) ‚Äì not from PerfHUD file; handled during dev by a guard.

What works now
1) /md/levels receiver (language-side) installed with key md_levels_hud:
   - Updates ~md_levelsById, ~md_lastMsgStamp.
   - Known-good: OSCdef(\md_levels_hud, { ... }, "/md/levels", recvPort: NetAddr.langPort).

2) Inline taps (pass-through) armed on server via Ndef.filter(name, func):
   - A ‚Üí replyID 2001, B ‚Üí 2002, testmelody probe ‚Üí 1001.
   - No 'removeFilter'; use filter(\name, nil) only if needed (we avoid it).

3) Heartbeat shows last /md/levels age ~0‚Äì1 s during normal operation.

4) LPS bring-up now performs, in order:
   - Close existing MagicDisplay windows.
   - Load PerfHUD v0.5.4.
   - Re-enable FilterMeters / Attach Probes / Reset Receiver (troubleshooting scripts).
   - Install /md/levels HUD listener (md_levels_hud).
   - Arm inline taps at ~18 Hz (A/B/testmelody).

Why meters looked "quiet"
- Taps were sending linear amplitude 0..1 (Amplitude.kr).
- GUI was drawing linearly, so normal musical levels looked small.
- Fix: map to dB in GUI (amp ‚Üí dB ‚Üí normalized 0..1). No DSP change.

Active highlight rule
- Previously: energy-based heuristic (pulsed).
- Now: chain flag ~md_currentChain = \A|\B ‚Äì stays green while active.
- Setter: ~md_setCurrentChain.(\A) or .(\B). To be called from switch path.

Dev guards
- A temporary Window.flipY guard extension prevented nil-rect crashes during bring-up.
- Repo search shows no flipY or Window.bounds in our sources; final call-site TBD.

Keep it working (policy)
- LPS bring-up installs HUD listener and taps every time.
- Taps use only Ndef.filter ‚Äì known-good API.
- No 'removeFilter', no '++' on Associations, no '? :' ternary.

===== troubleshooting/obsolete/turnintooneplease copy.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/PerfHUD_Adhoc_MeterFix_Overlay.scd =====
// PerfHUD_Adhoc_MeterFix_Overlay.scd
// v0.1.0
// MD 2025-09-26 13:42 BST

/* Purpose / Style
   - Install a /md/levels listener (HUD-side) so meters have data.
   - Add a small overlay meter (top-left) to prove live updates right now.
   - var-first; descriptive lowercase vars; AppClock-only; no server.sync.
*/

(
var ensureModel, installHudResponder, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installHudResponder = {
    var existing;
    existing = OSCdef.all.at(\md_levels_hud);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_hud, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[HUD] /md/levels listener installed (key=md_levels_hud)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 84;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half, slightly lighter)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15; lastBeatTime = SystemClock.seconds.asFloat;
    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[HUD] meters tick; last /md/levels "
                    ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            0.15.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installHudResponder.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) { attachOverlay.(hudWindow); startRefresh.() } {
    "‚ö†Ô∏è No MagicDisplayGUI window found; bring up PerfHUD first.".warn;
};
)

===== troubleshooting/PERFHUD_Bus_Indices_Inspect.scd =====
// PERFHUD_Bus_Indices_Inspect.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, summaryText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

summaryText =
    "[bus indices] A=" ++ (hasBusA.if({ ~busA.index }, { "nil" })) ++
    "  B=" ++ (hasBusB.if({ ~busB.index }, { "nil" }));

summaryText.postln;
)

===== troubleshooting/PerfHUD_Diag_OverlayMeters.scd =====
// PerfHUD_Diag_OverlayMeters.scd
// v0.1.0
// MD 2025-09-26 13:12 BST

/* Purpose
   - Prove the meter data path & UI repaint with a non-intrusive overlay.
   - Installs a /md/levels receiver -> ~md_levelsById.
   - Adds a tiny overlay UserView that animates A/B bars (top-left).
   - Very light diagnostics: heartbeat every ~2 seconds.
*/

(
var ensureModel, installReceiver, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installReceiver = {
    var existing;
    existing = OSCdef.all.at(\md_levels_diag);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_diag, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[Diag] /md/levels receiver installed (key=md_levels_diag)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 80;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        var aEnergy, bEnergy, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;

        // A on bottom half, B on top half (thin overlay)
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[Diag] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15;
    lastBeatTime = SystemClock.seconds.asFloat;

    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[Diag] meters tick; last /md/levels " ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            beatInterval.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installReceiver.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) {
    attachOverlay.(hudWindow);
    startRefresh.();
} {
    "‚ö†Ô∏è No MagicDisplayGUI window found; run the HUD first.".warn;
};
)

===== troubleshooting/PERFHUD_InlineTaps_On_ChainAB.scd =====
// PERFHUD_InlineTaps_On_ChainAB.scd
// v0.1.0
// MD 2025-09-29 15:26 BST

(
/* Purpose
   - Replace bus-based bridge (silent because no buses exist) with inline taps on Ndef(\chainA/\chainB).
   - Send linear amplitudes for PerfHUD via '/ampA' and '/ampB' (2 values each, L/R).
   - Also send dB readings via '/md/levels_db' with replyIDs A=2001, B=2002 for console sanity.
Style
   - var-first; descriptive lowercase variable names; Server.default.bind for server ops; AppClock for UI only.
   - No server.sync; no non-local returns; idempotent (re-running replaces the taps).
*/

var freeBusBridgeIfPresent, installInlineTaps, installDbSniffer, printLinesRemaining;
var attackSeconds, releaseSeconds, updateRateHz, minLinearFloor;
var oscKeyDb;

attackSeconds   = 0.01;
releaseSeconds  = 0.20;
updateRateHz    = 24;
minLinearFloor  = 1e-7;
printLinesRemaining = 6;
oscKeyDb = \perfHud_db_sniff;

// 1) Free the bus-bridge synth (if any), to avoid double feeds
freeBusBridgeIfPresent = {
    if(~md_levelsSynth.notNil) {
        ~md_levelsSynth.free;
        ~md_levelsSynth = nil;
        "99: Freed md_levels4_from_busses (bus bridge) ‚Äî switching to inline taps.".postln;
    };
};

// 2) Install inline taps on chainA and chainB
installInlineTaps = {
    Server.default.bind({
        // chainA ‚Üí '/ampA' (linear pair) and '/md/levels_db' (dB; replyID=2001)
        Ndef(\chainA).filter(\perfHudTapA, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            // normalize to a stereo pair (duplicate if mono)
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampA', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2001);

            // return audio unchanged
            localSignal
        });

        // chainB ‚Üí '/ampB' (linear pair) and '/md/levels_db' (dB; replyID=2002)
        Ndef(\chainB).filter(\perfHudTapB, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampB', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2002);

            // return audio unchanged
            localSignal
        });
    });

    "99: Inline taps installed on chainA/chainB ‚Üí '/ampA' & '/ampB' (+ dB on '/md/levels_db').".postln;
};

// 3) Short-lived dB console sniffer (6 lines total), then auto-free
installDbSniffer = {
    // clean any previous instance
    if(OSCdef(oscKeyDb).notNil) { OSCdef(oscKeyDb).free };

    OSCdef(oscKeyDb, { arg message;
        var replyId, dbLeft, dbRight, labelText;
        if(message.size >= 5) {
            replyId = message[2];
            dbLeft  = message[3].round(0.1);
            dbRight = message[4].round(0.1);
            labelText = "[dB inline " ++ replyId.asString ++ "] L=" ++ dbLeft ++ " dB  R=" ++ dbRight ++ " dB";
            labelText.postln;

            printLinesRemaining = printLinesRemaining - 1;
            if(printLinesRemaining <= 0) {
                OSCdef(oscKeyDb).free;
                "[dB inline] sniff done.".postln;
            };
        };
    }, '/md/levels_db');
};

// Execute
freeBusBridgeIfPresent.();
installInlineTaps.();
installDbSniffer.();
)

===== troubleshooting/PERFHUD_Repoint_MeterSynth_To_Buses.scd =====
// PERFHUD_Repoint_MeterSynth_To_Buses.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, repointedText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

if(~md_levelsSynth.notNil) {
    if(hasBusA) { ~md_levelsSynth.set(\inBusA, ~busA.index) };
    if(hasBusB) { ~md_levelsSynth.set(\inBusB, ~busB.index) };
    repointedText = "99: md_levels4_from_busses repointed to inBusA=" ++
        (hasBusA.if({ ~busA.index }, { "unchanged" })) ++
        "  inBusB=" ++ (hasBusB.if({ ~busB.index }, { "unchanged" }));
    repointedText.postln;
}{
    "‚ö†Ô∏è  md_levelsSynth not running; run 99_PerfHUD_MetersFromBusses.scd first.".warn;
}
)

===== troubleshooting/RMS_IsolatedHUD_BringUp.scd =====
// RMS_IsolatedHUD_BringUp.scd
//_v0.1.2
// MD 2025-09-29 19:10 BST

/* Purpose
   Show RMS (dB) at the *ends* of chainA and chainB in a NEW isolated window.
   - Reads Ndef(\chainA/\chainB) output busses directly: In.ar(bus, 2)
   - RMS per channel via RMS.ar(sig, 500)   // your spec
   - Convert to dBFS and map dB‚Üí0..1 for bar height (adjustable floor/top)
   - No shared OSC paths; no writes into existing HUD => zero interference

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops;
     no server.sync; no non-local returns. Returns '-> a Window'.
*/

(
var // calibration (live‚Äëtweakable via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra headroom)
updateRateHz   =  15;

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no VLayout/HLayout pitfalls) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aL, aR, bL, bR;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aL = sigA[0];
            aR = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bL = sigB[0];
            bR = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (your spec)
            rmsAL = RMS.ar(aL, 500);
            rmsAR = RMS.ar(aR, 500);
            rmsBL = RMS.ar(bL, 500);
            rmsBR = RMS.ar(bR, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);
            // Private OSC: 4 dB values [A_L, A_R, B_L, B_R]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busA, busB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busA, \inBusB, busB, \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busA ++ "  B=" ++ busB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait briefly until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START**
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this block.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window
rmsWindow;
)

===== troubleshooting/RMS_IsolatedHUD.scd =====
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/Run_All_PerfHUD_RMS_Isolated.scd =====
// Run_All_PerfHUD_RMS_Isolated.scd
// v0.1.0
// MD 2025-09-29 19:40 BST

/* Purpose
   One-shot bring-up from a clean SC restart:
     1) 00_Reset_KnownClean_State.scd
     2) 01b_StartHere_NoReboot.scd
     3) 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
     4) 02D_TestSource_CenteredStereo_Pulsed.scd
     5) RMS_IsolatedHUD (new window): reads ends of chainA/chainB, RMS.ar(sig,500) ‚Üí dB ‚Üí meters

Style
   - var-first; descriptive lowercase names; AppClock for sequencing/GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. Returns '-> a Window' (the RMS window) at the end.
*/

(
var // config (paths and small timings)
    baseDir, fReset, fStartHere, fAssertStereo, fTestSource,
    smallPause, mediumPause, longPause,

    // helpers
    ensureBaseDir, executeFileOnce, scheduleSequence,

    // rms window block (self-contained)
    buildRmsIsolatedHud, // returns a Window
    finalWindow;

// --- configuration (adjust only if your file names differ) -------------------
smallPause  = 0.25;   // seconds between immediate steps
mediumPause = 0.60;   // seconds to allow bring-up to tick
longPause   = 1.00;   // seconds for heavier steps

// Derive the troubleshooting/ folder by default (assumes this file is saved there)
ensureBaseDir = {
    // If this script is saved as a file, we can use nowExecutingPath; otherwise ask user to set.
    var fromFile = thisProcess.nowExecutingPath;
    if(fromFile.notNil) {
        baseDir = PathName(fromFile).parentPath;  // should end with '/'
    }{
        // Fallback: try to guess a 'troubleshooting' folder relative to current documents dir.
        // If this fails on your setup, please SAVE this file in the 'troubleshooting/' folder
        // and re-run so nowExecutingPath is available.
        baseDir = PathName(thisProcess.platform.userAppSupportDir).parentPath ++ "troubleshooting";
        "[RunAll] Warning: nowExecutingPath is nil; guessing baseDir: ".post; baseDir.postln;
    };

    // File names expected to be in baseDir
    fReset       = baseDir ++ "00_Reset_KnownClean_State.scd";
    fStartHere   = baseDir ++ "01b_StartHere_NoReboot.scd";
    fAssertStereo= baseDir ++ "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd";
    fTestSource  = baseDir ++ "02D_TestSource_CenteredStereo_Pulsed.scd";
};

// Execute a file if it exists; prints a readable status line
executeFileOnce = { arg absolutePathString, labelString;
    var pathOk;
    pathOk = File.exists(absolutePathString);
    if(pathOk.not) {
        ("[RunAll] ‚ö†Ô∏è Missing file: " ++ absolutePathString).warn;
    }{
        ("[RunAll] === " ++ labelString ++ " ===").postln;
        thisProcess.interpreter.executeFile(absolutePathString);
    };
    pathOk
};

// Self-contained RMS window that reads ends of chainA/chainB, computes RMS.dB, displays 4 meters
buildRmsIsolatedHud = {
    var defaultFloorDb, defaultTopDb, updateRateHz;
    var rmsWindow, labelTitle, labelDbA, labelDbB;
    var meterAL, meterAR, meterBL, meterBR, updateRoutine;
    var currentDbAL, currentDbAR, currentDbBL, currentDbBR;
    var installSynthDef, startRmsSynthAtTail, stopRmsSynth;
    var oscKeyName, installRmsListener;
    var discoverBussesAndStart, getProxyBusInfo;
    var chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

    defaultFloorDb = -72.0;
    defaultTopDb   =   0.0;   // set to +3.0 for extra visual headroom at full scale
    updateRateHz   =  15;

    // allow live tuning (optional)
    ~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
    ~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

    rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

    labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
        .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
        .font_(Font("Helvetica", 13));

    meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

    StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
    StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
    StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
    StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

    labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
    labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

    currentDbAL = -140.0; currentDbAR = -140.0;
    currentDbBL = -140.0; currentDbBR = -140.0;

    installSynthDef = {
        Server.default.bind({
            SynthDef(\md_rms_isolated_from_busses, {
                arg inBusA = 0, inBusB = 0, fps = 15;
                var sigA, sigB, aLeft, aRight, bLeft, bRight;
                var rmsAL, rmsAR, rmsBL, rmsBR;
                var dbAL, dbAR, dbBL, dbBR;
                var tick, minLinear;

                sigA = In.ar(inBusA, 2);
                sigB = In.ar(inBusB, 2);

                aLeft  = sigA[0];
                aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
                bLeft  = sigB[0];
                bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

                // RMS per channel with 500 Hz smoothing (requested)
                rmsAL = RMS.ar(aLeft,  500);
                rmsAR = RMS.ar(aRight, 500);
                rmsBL = RMS.ar(bLeft,  500);
                rmsBR = RMS.ar(bRight, 500);

                // dBFS with guard
                minLinear = 1e-9;
                dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
                dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
                dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
                dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

                tick = Impulse.kr(fps);
                SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);  // private path for this window
            }).add;
        });
        "[RunAll/RMS] SynthDef \\md_rms_isolated_from_busses installed.".postln;
    };

    stopRmsSynth = {
        if(~rms_isolated_synth.notNil) {
            ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
            "[RunAll/RMS] previous synth stopped.".postln;
        };
    };

    // IMPORTANT: start at TAIL so we read busses *after* chains write to them
    startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
        AppClock.sched(0.20, {
            Server.default.bind({
                ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                    \inBusA, busIndexForA,
                    \inBusB, busIndexForB,
                    \fps, updateRateHz
                ]);
            });
            ("[RunAll/RMS] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
            nil
        });
    };

    // Listener to receive dB payload and update UI model
    oscKeyName = \md_rms_isolated_listener;
    installRmsListener = {
        var existing;
        existing = OSCdef.all.at(oscKeyName);
        if(existing.notNil) { existing.free };

        OSCdef(oscKeyName, { arg msg;
            if(msg.size >= 7) {
                currentDbAL = msg[3].asFloat;
                currentDbAR = msg[4].asFloat;
                currentDbBL = msg[5].asFloat;
                currentDbBR = msg[6].asFloat;
            };
            nil
        }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

        "[RunAll/RMS] listener installed (/md/rms_isolated_dB)".postln;
    };

    // AppClock ticker: dB ‚Üí 0..1 mapping and UI updates
    updateRoutine = Routine({
        var waitSeconds, mapDbToUi, floorDbLive, topDbLive;
        waitSeconds = 1.0 / updateRateHz;
        mapDbToUi = { arg dbValue, floorDb, topDb; ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0) };

        while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
            floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
            topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

            meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
            meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
            meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
            meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

            labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
            labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

            waitSeconds.yield;
        };
    }).play(AppClock);

    // Discover Ndef(\chainA/\chainB) busses and start synth
    getProxyBusInfo = { arg chainSymbol;
        var proxy, busObject, info;
        proxy = Ndef(chainSymbol);
        busObject = proxy.bus;
        info = (
            symbol: chainSymbol,
            playing: proxy.isPlaying,
            numChannels: proxy.numChannels,
            busIndex: busObject.notNil.if({ busObject.index }, { nil })
        );
        info
    };

    discoverBussesAndStart = {
        triesLeft = 20;
        Routine({
            var resolved;
            resolved = false;
            while({ triesLeft > 0 and: { resolved.not } }) {
                chainAInfo = getProxyBusInfo.(\chainA);
                chainBInfo = getProxyBusInfo.(\chainB);
                busIndexA  = chainAInfo[\busIndex];
                busIndexB  = chainBInfo[\busIndex];

                if(busIndexA.notNil and: { busIndexB.notNil }) {
                    ("[RunAll/RMS] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                        ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                    installRmsListener.();
                    installSynthDef.();
                    stopRmsSynth.();
                    startRmsSynthAtTail.(busIndexA, busIndexB);
                    resolved = true;
                }{
                    if(triesLeft == 20) { "[RunAll/RMS] waiting for chainA/chainB busses...".postln };
                    0.25.wait; triesLeft = triesLeft - 1;
                };
            };

            if(resolved.not) {
                "‚ö†Ô∏è [RunAll/RMS] could not resolve busses (chains not playing?). Start a source and re-run this file.".warn;
            };
        }).play(AppClock);
    };

    // Cleanup when window closes
    rmsWindow.onClose_({
        if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
        if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
        if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
        "[RunAll/RMS] closed and cleaned up.".postln;
    });

    // Kick off discovery and return window
    discoverBussesAndStart.();
    rmsWindow
};

// Master sequence: execute your four scripts in order, then start the RMS window
scheduleSequence = {
    AppClock.sched(0.00, {
        ensureBaseDir.();
        executeFileOnce.(fReset, "00_Reset_KnownClean_State.scd");
        nil
    });

    AppClock.sched(longPause, {
        executeFileOnce.(fStartHere, "01b_StartHere_NoReboot.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause, {
        executeFileOnce.(fAssertStereo, "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause + smallPause, {
        executeFileOnce.(fTestSource, "02D_TestSource_CenteredStereo_Pulsed.scd");
        nil
    });

    // Start the isolated RMS HUD after bring-up + source have had a moment to run
    AppClock.sched(longPause + mediumPause + smallPause + longPause, {
        finalWindow = buildRmsIsolatedHud.();
        // Report and return
        "[RunAll] ‚úÖ RMS_IsolatedHUD started.".postln;
        finalWindow;
    });
};

// Kick off the sequence and return the window when ready
scheduleSequence.();

// Return something immediately; the RMS window will be returned by the scheduled step.
// To see '-> a Window' in the post window after completion, re-select and run only the last line:
// finalWindow;
)

===== troubleshooting/startheres/Finish_WriteStatus_SaveToOneDrive.scd =====
// Finish_WriteStatus_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Write an end-of-session status snapshot to OneDrive and return the file path.

What it records
- Timestamp, SC version, platform, sampleRate, server status, window count,
  suite path (under Extensions), and this file's location if available.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no non-local returns.
*/

(
var server, dirPath, pathName, stamp, filePath, writeLine, f, suitePath, windowCount, scVer, platformInfo;
var herePath;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";
dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
pathName = PathName(dirPath);
stamp = Date.getDate.stamp.replace($:, $_);
filePath = dirPath +/+ ("status_" ++ stamp ++ ".txt");
scVer = Main.scVersionString;
platformInfo = Platform.name.asString ++ " " ++ Platform.architecture.asString;
windowCount = Window.allWindows.size;
herePath = thisProcess.nowExecutingPath ? "<interactive>";

pathName.isFolder.if({ }, { pathName.mkdirAll; });

writeLine = { arg txt; f.write(txt ++ Char.nl); };

f = File(filePath, "w");
writeLine.("=== MPB EOD STATUS SNAPSHOT ===");
writeLine.("timestamp: " ++ stamp);
writeLine.("sc_version: " ++ scVer);
writeLine.("platform: " ++ platformInfo);
writeLine.("server_running: " ++ server.serverRunning);
writeLine.("server_sampleRate: " ++ server.sampleRate);
writeLine.("windows_open: " ++ windowCount);
writeLine.("suite_path: " ++ suitePath);
writeLine.("script_path: " ++ herePath);
f.close;

("[EOD] wrote " ++ filePath).postln;
filePath
)

===== troubleshooting/startheres/MD_Cleanup_ChainA_Unfeed.scd =====
// MD_Cleanup_ChainA_Unfeed.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Stop audio; clear and recreate Ndef(\chainA) so the pedalboard can drive it again.
*/

(
var done;
Server.default.bind({
    Ndef(\chainA).stop;
    Ndef(\chainA).clear;
    Ndef(\chainA).ar(2);
});
done = "Cleaned chainA‚Äîpedalboard can drive it again.";
done.postln;
done
)

===== troubleshooting/startheres/MD_Meters_PhaseA_Const.scd =====
// MD_Meters_PhaseA_Const.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Drive meters to exact values A=(0.25, 0.75), B=(0, 0) for 4s via /md/levels.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendPair, aL, aR, bL, bR, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_CONST] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);  // B
};

aL = 0.25; aR = 0.75; bL = 0.0; bR = 0.0;
startAt = thisThread.seconds; endAt = startAt + secs;

banner.("A=(" ++ aL ++ "," ++ aR ++ "), B=(0,0) for " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now;
    now = thisThread.seconds;
    (now < endAt).if({
        sendPair.([aL, aR], [bL, bR]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseA_Const scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseB_Ramp.scd =====
// MD_Meters_PhaseB_Ramp.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Animate A for 4s: L ramps 0‚Üí0.9, R ramps 0.9‚Üí0. B stays 0.
*/

(
var hz, secs, sendToLang, sendPair, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_RAMP] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);
};

startAt = thisThread.seconds; endAt = startAt + secs;

banner.("Ramp A L:0‚Üí0.9, R:0.9‚Üí0 over " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now, t, aL, aR;
    now = thisThread.seconds;
    (now < endAt).if({
        t = (now - startAt) / secs;          // 0..1
        aL = (0.9 * t).clip(0.0, 0.9);       // rise
        aR = (0.9 * (1 - t)).clip(0.0, 0.9); // fall
        sendPair.([aL, aR], [0.0, 0.0]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseB_Ramp scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseC_Audio.scd =====
// MD_Meters_PhaseC_Audio.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Feed a sine into Ndef(\chainA), attach taps that SendReply /md/levels (A=2001, B=2002).
- Print expected RMS (A/‚àö2) and measured A levels in console for 5s.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTap, makeTaps;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ‚âà0.1414 for 0.2

banner = { arg text; var t; t = text; ("[MD_A_AUDIO] " ++ t).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);  // replyID in 4th arg (correct)
        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// Feed test tone and play
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

makeTaps.();

OSCdef(\mdSpyA).free;  // ensure clean
OSCdef(\mdSpyA, { arg msg;
    var isA, l, r, line;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };  // replyID position
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
            ++ ")  vs expected_RMS‚âà" ++ expectedRMS.round(0.001);
        line.postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA).free;
    banner.("done (audio still playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS‚âà" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio scheduled."
)

===== troubleshooting/startheres/Meters_Sanity_6Lines_SaveToOneDrive.scd =====
// Meters_Sanity_6Lines_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Subscribe to /md/levels taps (A=2001, B=2002), sample 3 times, and print exactly 6 lines:
  "MDMTR: A (L,R)=(x.xx,y.yy)" then "MDMTR: B (L,R)=(x.xx,y.yy)" per sample.
- Save the 6 lines to OneDrive: ~/Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test/md_meters_<stamp>.txt
- Finite; auto-stops; cleans responders.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns.
- AppClock used for timing only; finite duration.
*/

(
var aLevels, bLevels, lines, sampleIndex, maxSamples, appTask, startTime;
var dirPath, pathName, filePath, stamp, makeDir;
var oscA, oscB, formatLine, writeFile, printLine;
var levelsUpdatedA, levelsUpdatedB;

aLevels = [0.0, 0.0];
bLevels = [0.0, 0.0];
levelsUpdatedA = false;
levelsUpdatedB = false;

lines = List.new;
sampleIndex = 0;
maxSamples = 3;
startTime = thisThread.seconds;

dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
stamp = Date.getDate.stamp.replace($:, $_); // safe for file names
pathName = PathName(dirPath);
filePath = dirPath +/+ ("md_meters_" ++ stamp ++ ".txt");

makeDir = {
    pathName.isFolder.if({ }, { pathName.mkdirAll; });
};

formatLine = { arg label, lr;
    var l, r;
    l = (lr[0] ? 0.0).asFloat.max(0.0);
    r = (lr[1] ? 0.0).asFloat.max(0.0);
    ("MDMTR: " ++ label ++ " (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001) ++ ")")
};

printLine = { arg text; text.postln; };

writeFile = {
    var f;
    makeDir.();
    f = File(filePath, "w");
    lines.do { arg ln; f.write(ln ++ Char.nl) };
    f.close;
    ("[MDMTR] wrote " ++ filePath).postln;
    filePath
};

// OSC responders: expect messages like /md/levels, id, ... , L, R.
// We match on reply id and pull the last two floats if present.
oscA = OSCdef(\mdLevelsA, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        aLevels = [l, r];
        levelsUpdatedA = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2001]);

oscB = OSCdef(\mdLevelsB, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        bLevels = [l, r];
        levelsUpdatedB = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2002]);

appTask = AppClock.sched(0.1, {
    var doOne;
    doOne = {
        var lineA, lineB;
        lineA = formatLine.("A", aLevels);
        lineB = formatLine.("B", bLevels);
        printLine.(lineA);
        printLine.(lineB);
        lines.add(lineA);
        lines.add(lineB);
        sampleIndex = sampleIndex + 1;
        levelsUpdatedA = false;
        levelsUpdatedB = false;
    };

    (sampleIndex < maxSamples).if({
        doOne.();
        0.6
    }, {
        OSCdef(\mdLevelsA).free;
        OSCdef(\mdLevelsB).free;
        writeFile.();
        nil
    })
});
"MDMTR: starting 3√ó sampling (A=2001, B=2002)‚Ä¶".postln;
filePath
)

===== troubleshooting/startheres/StartHere_CleanBoot_GridOrPerfHUD.scd =====
// StartHere_CleanBoot_GridOrPerfHUD.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Clean boot pathway that brings up PerfHUD (guarded) and, if it fails, falls back to GridDemo.
- Ensures taps are running via LivePedalboardSystem-Taps_Stable.sc.
- Returns -> a Window (PerfHUD if healthy, otherwise Grid).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock use is inside called files only; this wrapper remains finite.
- Loud console banners; prefer existing files; safe operations via Server.default.bind.
*/

(
var server, suitePath, stopDiagPath, perfhudPath, tapsPath, gridPath, gridMinPath;
var windowResult, banner, runFile, fallbackDone, fallbackWindow;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";

stopDiagPath = suitePath +/+ "utilities/MD_Stop_All_MeterDiagnostics.scd";
perfhudPath  = suitePath +/+ "MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
/*tapsPath     = suitePath +/+ "LivePedalboardSystem/LivePedalboardSystem-Taps_Stable.sc";*/
tapsPath = suitePath +/+ "troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd";

gridPath     = suitePath +/+ "MagicPedalboard/MagicDisplayGUI_GridDemo.sc";
gridMinPath  = suitePath +/+ "utilities/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd";

banner = { arg text; ("[MPB-START] " ++ text).postln; };

runFile = { arg filePath;
    var exists, result;
    exists = File.exists(filePath);
    exists.if({
        ("[RUN] " ++ filePath).postln;
        result = thisProcess.interpreter.executeFile(filePath);
        ("[OK ] " ++ filePath).postln;
    }, {
        ("[MISS] " ++ filePath).warn;
        result = nil;
    });
    result
};

banner.("Clean boot begin ‚Äî ensuring server and quiescent diagnostics‚Ä¶");

server.boot;
server.waitForBoot({
    Server.default.bind({
        server.initTree;
        server.defaultGroup.freeAll;
    });
});

runFile.(stopDiagPath);

banner.("PerfHUD bring-up (guarded) ‚Ä¶");
windowResult = runFile.(perfhudPath);

// Always start taps; if missing, we still continue to Grid fallback.
runFile.(tapsPath);

// If PerfHUD did not return a Window, fall back to Grid.
(windowResult.isKindOf(Window)).if({
    banner.("PerfHUD window active ‚Äî returning PerfHUD.");
    windowResult
}, {
    banner.("PerfHUD did not yield a Window ‚Äî falling back to Grid‚Ä¶");
    fallbackDone = false;
    fallbackWindow = runFile.(gridPath);
    (fallbackWindow.isKindOf(Window)).if({
        fallbackDone = true;
        banner.("GridDemo is active ‚Äî returning Grid window.");
        fallbackWindow
    }, {
        // Try minimal grid bring-up
        fallbackWindow = runFile.(gridMinPath);
        (fallbackWindow.isKindOf(Window)).if({
            fallbackDone = true;
            banner.("Minimal GridDemo is active ‚Äî returning Grid window.");
            fallbackWindow
        }, {
            // As a last resort, create a tiny placeholder window so we still return -> a Window.
            banner.("All bring-up files missing or failed ‚Äî creating placeholder window.");
            Window("MagicDisplayGUI (Placeholder)", Rect(120, 120, 480, 260)).front;
        });
    });
});
)

===== troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd =====

===== troubleshooting/Taps_Stable_Runtime_Shim.scd =====
// Taps_Stable_Runtime_Shim.scd
// v0.1.1 (fix SendReply replyID position)
// MD timestamp: 2025-09-27 19:35 GMT+1

/*
Purpose
- Publish /md/levels with replyID in proper slot (msg[2]) so listeners match A=2001 / B=2002.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var server, rateHz, attachTap, ensureProxy, banner;

server = Server.default;
rateHz = 12;

banner = { arg text; ("[TAPS] " ++ text).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var sig, chans, l, r, ampL, ampR, trig;
        sig = inSig;
        chans = sig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l }); // mono -> duplicate
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(rateHz);

        // *** Correct: replyID is the 4th arg, values exclude replyID
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        sig
    });
};

Server.default.bind({
    ensureProxy.(\chainA, 2);
    ensureProxy.(\chainB, 2);
    attachTap.(\chainA, \eodTapA, 2001);
    attachTap.(\chainB, \eodTapB, 2002);
});

banner.("Taps active (/md/levels) ‚Äî A=2001, B=2002 at " ++ rateHz ++ " Hz.");
"-> Taps_Stable_Runtime_Shim ready".postln;
Window.allWindows.detect({ |w| w.name.asString.beginsWith("MagicDisplayGUI") }) ? nil;
)

===== troubleshooting/turnintooneplease copy.scd.txt =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/turnintooneplease.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"‚úÖ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "‚ö†Ô∏è Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW ‚Äî ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD‚Äôs window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ‚Äî‚Äî‚Äî bring-up sequence ‚Äî‚Äî‚Äî

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your ‚Äú-> a Window‚Äù acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "üéõÔ∏è testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd ‚Üí -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB‚Üí0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS ‚Üí 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD ‚Äî chain ends (A/B) ‚Äî RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-‚àû  R=-‚àû");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-‚àû  R=-‚àû");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "‚ö†Ô∏è [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/WorkingSequence_20250929-1649.scd =====
// WorkingSequence_20250929-1649.scd

/*
We have proof of principle working with these:

00_Reset_KnownClean_State.scd
03_Sanity_Beep.scd
01b_StartHere_NoReboot.scd
02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
PERFHUD_InlineTaps_On_ChainAB.scd
INSTALL_AmpA_AmpB_Responders_Min.scd <-- key


*/
===== utilities/ControlLogVerbosity.scd =====
// ControlLogVerbosity.sc
// v1
// MD 20250923-0835

// error = 0
// warn = 1
// info = 2
// debug = 3
// trace = 4

MDMiniLogger.get.setverbosity(2);
===== utilities/DEMO20250923_FIXED.scd =====
// DEMO20250923_FIXED.scd
// v0.2.0
// MD 2025-09-23 10:46 BST

/* Purpose
 - Run the 2025-09-23 demo steps while updating MagicDisplayGUI at each step.
 - Uses ~nav_handleFret from the SimNav patch (Fix 1) so the GUI shows choices
   and "Apply ‚Üí ..." on leaf selections.
Style
 - var-first; AppClock-only; no server.sync; one MagicDisplayGUI window.
*/

(
var steps, gap, i, runStep, schedNext;

if(~system.isNil) { "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil };
if(~nav_handleFret.isNil) { "‚ö†Ô∏è Load SimNav_Bridge_ApplyLeafPayload_FIX.scd first".warn; ^nil };

// Your original script, now paced:
steps = [
    // Add delay ‚Üí /add/delay
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 1) }, // add
    { ~nav_handleFret.(4, 1) }, // delay (leaf ‚Üí applies)

    // Switch ‚Üí /switch
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 3) }, // switch (leaf ‚Üí applies)

    // Bypass delay ON
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 2) }, // bypass
    { ~nav_handleFret.(4, 1) }, // delay
    { ~nav_handleFret.(3, 2) }, // on (leaf)

    // Bypass delay OFF
    { ~nav_handleFret.(6,10) },
    { ~nav_handleFret.(5, 2) },
    { ~nav_handleFret.(4, 1) },
    { ~nav_handleFret.(3, 3) }, // off (leaf)

    // Set source testmelody ‚Üí /setSource/testmelody
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 4) }, // setSource
    { ~nav_handleFret.(4, 1) }  // testmelody (leaf)
];

// pacing
gap = 0.55;
i = 0;
runStep = { steps[i].value; i = i + 1; if(i < steps.size) { schedNext.() } };
schedNext = { AppClock.sched(gap, { runStep.(); nil }) };

// kick off and ensure GUI is showing something
~nav_reset.();
AppClock.sched(0.0, { runStep.(); nil });
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay ‚Üí /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf ‚Üí applies)


//Switch ‚Üí /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf ‚Üí applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody ‚Üí /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Editor_AddCommands_Branch_Canonical.scd =====
// Editor_AddCommands_Branch_Canonical.scd
// v0.1.7
// MD 20250923-0956

(
/*
Purpose
- Ensure a minimal 'commands' branch exists in the canonical CommandTree JSON used by LivePedalboardSystem.
- Set each leaf's payload under 'commands' to a canonical path string ("/verb/arg/...").
- Uses only known-good methods; no caret returns; var-first at top-level.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPath, tree, ok, proceed;
var findChildByName, ensureChildUnder, ensurePath;
var commandsNode, printSampleLeaves, showFirstN;
var setCanonicalPayloads, buildPathsDown, buildPathFromSegments, rootCmd, count;

// ‚îÄ‚îÄ entry banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
"Editor_AddCommands_Branch_Canonical: ENTER".postln;

// ‚îÄ‚îÄ canonical JSON path (LivePedalboardSuite) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
jsonPath = Platform.userExtensionDir
  ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
("JSON path ‚Üí " ++ jsonPath).postln;

// ‚îÄ‚îÄ load tree ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPath);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// ‚îÄ‚îÄ helpers (only stable fields/methods) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
findChildByName = { |parentNode, childName|
  var wanted, found;
  wanted = childName.asString;
  found = nil;
  parentNode.children.do({ |c|
    if(c.name.asString == wanted) { found = c };
  });
  found
};

ensureChildUnder = { |parentNode, childName, fretNumber|
  var existing, created, fret;
  fret = fretNumber ? 1;
  existing = findChildByName.(parentNode, childName);
  if(existing.notNil) {
    existing
  }{
    created = tree.addNode(parentNode.id, childName.asString, fret);
    if(created.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
    created
  }
};

ensurePath = { |names, frets|
  var node, i, count, name, fret;
  node = tree.root;
  i = 0; count = names.size;
  while({ i < count }, {
    name = names[i];
    fret = frets[i] ? 1;
    node = ensureChildUnder.(node, name, fret);
    i = i + 1;
  });
  node
};

showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new;
  i = 0;
  while({ i < lim }, {
    out.add(listIn[i]);
    i = i + 1;
  });
  out.asArray
};

// ‚îÄ‚îÄ do the work only if load succeeded ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if(proceed) {
  // 1) ensure 'commands' branch + minimal leaves (idempotent)
  ensurePath.( ["commands"], [10] );
  ensurePath.( ["commands","add","delay"],            [10,1,1] );
  ensurePath.( ["commands","bypass","delay","on"],    [10,2,1,2] );
  ensurePath.( ["commands","bypass","delay","off"],   [10,2,1,3] );
  ensurePath.( ["commands","switch"],                 [10,3] );
  ensurePath.( ["commands","setSource","testmelody"], [10,4,1] );

  // 2) normalize payloads and tag depths
  tree.assignPayloads;     // payload := name where missing
  tree.root.tagByDepth(0);

  // 2b) set canonical path strings for each 'commands' leaf ("/verb/arg/...")
  buildPathFromSegments = { |segs|
    var out, i, lim;
    out = "";
    i = 0; lim = segs.size;
    while({ i < lim }, {
      out = out ++ "/" ++ segs[i];
      i = i + 1;
    });
    out
  };

  setCanonicalPayloads = {
    rootCmd = findChildByName.(tree.root, "commands");
    if(rootCmd.isNil) {
      "‚ö†Ô∏è cannot set payloads: 'commands' missing.".postln;
    }{
      count = 0;
      buildPathsDown = { |node, segs|
        if(node.isLeaf) {
          node.payload = buildPathFromSegments.(segs);
          count = count + 1;
        }{
          node.children.do({ |child|
            var nextSegs;
            nextSegs = segs.copy;
            nextSegs.add(child.name.asString);
            buildPathsDown.(child, nextSegs);
          });
        }
      };
      // seed with immediate children of 'commands'
      rootCmd.children.do({ |child|
        buildPathsDown.(child, [child.name.asString]);
      });
      ("set canonical payloads on " ++ count ++ " leaf/leaves under 'commands'").postln;
    };
  };

  setCanonicalPayloads.();

  // 3) save back to the canonical file
  tree.exportJSONFile(jsonPath);
  ("‚úÖ Updated commands branch in ‚Üí " ++ jsonPath).postln;

  // 4) sample a few payloads under 'commands' (sanity)
  commandsNode = findChildByName.(tree.root, "commands");
  if(commandsNode.isNil) {
    "‚ö†Ô∏è 'commands' node not found after ensure-path (unexpected).".postln;
  }{
    printSampleLeaves = {
      var visit, payloads;
      payloads = List.new;
      visit = { |n|
        if(n.isLeaf) {
          payloads.add((n.payload ?? n.name).asString);
        }{
          n.children.do(visit);
        }
      };
      visit.(commandsNode);
      ("sample payloads: " ++ showFirstN.(payloads, 8).asString).postln;
    };
    printSampleLeaves.();
  };
}{
  ("‚ùå Failed to load " ++ jsonPath ++ " (no changes made)").postln;
};

// ‚îÄ‚îÄ exit banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"Editor_AddCommands_Branch_Canonical: EXIT".postln;
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
)

===== utilities/Fallback_Diag_OneShot.scd =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/Fallback_Diag_OneShot.scd.bak =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/FallbackDemo_ManualSequence.scd =====
// FallbackDemo_ManualSequence
// v0.1.3
// MD 20250923

// Purpose:
// - Apply a fixed sequence of canonical commands to MagicPedalboardNew.
// - Uses AppClock for scheduling; no Routine or Task.
// - Follows Martin's SC style: var-first, descriptive names, no server.sync, AppClock-only GUI ops.

(


var canonicalCommands, commandIndex, commandDelay;
var applyCommand, runNextCommand;
var pedalboardRef, bypassState;

canonicalCommands = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

commandIndex = 0;
commandDelay = 0.6;
pedalboardRef = if(~system.notNil) { ~system.pedalboard } { nil };

applyCommand = { |canonicalPath|
    ("[FallbackDemo] apply ‚Üí " ++ canonicalPath).postln;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, ~system.statusDisplay);
    } {
        if(pedalboardRef.isNil) {
            ("[FallbackDemo] pedalboard is nil; skipping " ++ canonicalPath).warn;
            nil;
        } {
            if(canonicalPath == "/add/delay") {
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(\delay);
                };
            } {
            if(canonicalPath == "/switch") {
                if(pedalboardRef.respondsTo(\switchChain)) {
                    pedalboardRef.switchChain(0.12);
                };
            } {
            if(canonicalPath == "/bypass/delay/on") {
                bypassState = true;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
            if(canonicalPath == "/bypass/delay/off") {
                bypassState = false;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
                ("[FallbackDemo] unhandled command: " ++ canonicalPath).warn;
            }}}};
        };
    };
};

runNextCommand = {
    if(commandIndex >= canonicalCommands.size) {
        ("[FallbackDemo] done.").postln;
        nil;
    } {
        applyCommand.(canonicalCommands[commandIndex]);
        commandIndex = commandIndex + 1;

        AppClock.sched(commandDelay, {
            runNextCommand.();
            nil;
        });
    };
};

runNextCommand.();
)

===== utilities/GUI_QuickFix_Choices_Contrast.scd =====
// GUI_QuickFix_Choices_Contrast.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   Improve legibility of the "Choices" panel immediately (runtime).
   Style: var-first; AppClock-only; no server.sync.
*/

(
var displayRef, choicesPanelView, choicesTitleView, choicesTextView, canDo;

displayRef = ~system ? nil;
if(displayRef.isNil or: { ~system.statusDisplay.isNil }) {
  "‚ö†Ô∏è No status display found; bring-up first.".warn; ^nil;
};
displayRef = ~system.statusDisplay;

displayRef.queueUi({
  choicesPanelView = displayRef.tryPerform(\choicesPanel);
  choicesTitleView = displayRef.tryPerform(\choicesTitle);
  choicesTextView  = displayRef.tryPerform(\choicesText);

  if(choicesPanelView.notNil and: { choicesPanelView.respondsTo(\background_) }) {
    choicesPanelView.background_(Color(0.12, 0.12, 0.12));
  };
  if(choicesTitleView.notNil and: { choicesTitleView.respondsTo(\stringColor_) }) {
    choicesTitleView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  if(choicesTextView.notNil and: { choicesTextView.respondsTo(\stringColor_) }) {
    choicesTextView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  nil
});
)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "‚ùå Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "‚ùå Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Inspect_CommandTree_Under_Chain.scd =====
// Inspect_CommandTree_Under_Chain.scd
// v0.1.0
// MD 20250923--1255

/* Purpose
   Print child names (with frets) under "chain"; also prints under "add" if present.
   Helps confirm the live tree route to "delay".
   Style
   - var-first; descriptive variable names; no server.sync.
*/

(
var environmentReady, commandManager, commandTree, chainNode, addNode;
var listChildren, findChildByName;

environmentReady = (~system.notNil) and: { ~system.commandManager.notNil };
if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn; ^nil };

commandManager = ~system.commandManager;
commandTree    = commandManager.tree;

listChildren = { |nodeRef, labelText|
  var childrenArray, childLines;
  if(nodeRef.isNil) { ("[INSPECT] " ++ labelText ++ ": <nil>").postln; ^nil };
  childrenArray = nodeRef.children ? [];
  if(childrenArray.isEmpty) {
    ("[INSPECT] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[INSPECT] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil
};

findChildByName = { |parentNode, childNameString|
  if(parentNode.isNil) { ^nil };
  ^parentNode.getChildByName(childNameString.asString);
};

// 1) under "chain"
chainNode = commandTree.root.getChildByName("chain");
listChildren.(chainNode, "Children under [chain]");

// 2) under "chain ‚Üí add" (if present)
addNode = findChildByName.(chainNode, "add");
if(addNode.notNil) { listChildren.(addNode, "Children under [chain ‚Üí add]") };
)

===== utilities/Install_LightweightMeterPrinters.scd =====
// Install_LightweightMeterPrinters.scd
// v0.1
// MD 20250923-1556

/* Purpose
   Quiet console printers for '/ampA' and '/ampB' that print only non-zero-ish values.
*/

(
var threshold, freeIfExists;

threshold = 0.02;

freeIfExists = { |defName|
  var existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

freeIfExists.(\_meterA_dbg);
freeIfExists.(\_meterB_dbg);

OSCdef(\_meterA_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterA] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampA');

OSCdef(\_meterB_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterB] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampB');

"‚úÖ Lightweight printers installed (non-zero only).".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd.bak =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QuietProxyMeters_Core.scd =====
// Install_QuietProxyMeters_Core.scd
// v0.1
// MD 20250923-1610

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) using .filter:
   - Low-rate sampling with Impulse.kr.
   - Threshold gate from UGens (no Boolean 'or:').
   - Sends '/ampA' '/ampB' only when above threshold.
   - No console prints by default.

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold;
var ensureProxyAudio, installOrReplaceTap, installForProxy;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyAudio = { |proxyName|
  Server.default.bind({
    Ndef(proxyName).ar(2); // ensure 2ch audio-rate proxy exists
  });
};

installOrReplaceTap = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampLeft, ampRight, ampMax, tick, gate;

      // robust channel fetch
      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0.0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // per-channel level followers
      ampLeft  = Amplitude.kr(leftIn, 0.01, 0.15);
      ampRight = Amplitude.kr(rightIn, 0.01, 0.15);
      ampMax   = ampLeft.max(ampRight);     // <- UGen-safe combine

      // low-rate tick and gate when above threshold (UGen compare)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (ampMax > postThreshold); // 0 or tick

      // emit values only when above threshold
      SendReply.kr(gate, oscPath, [ampLeft, ampRight]);

      // pass-through audio unchanged
      inSig
    });
  });
};

installForProxy = { |proxyName, oscPath|
  ensureProxyAudio.(proxyName);
  installOrReplaceTap.(proxyName, oscPath);
};

installForProxy.(\chainA, '/ampA');
installForProxy.(\chainB, '/ampB');

"‚úÖ Quiet proxy taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"‚úÖ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/MD_EOD_Status_Snapshot_FIXED.scd =====
// MD_EOD_Status_Snapshot_FIXED.scd
// v0.1.1
// MD 2025-09-26 16:56 BST

/* Purpose / Style
   Purpose: Record where SC is loading LivePedalboardSuite from and write a status file to OneDrive.
   Style:   Single () block; var-first in all closures; ‚â•3-char lowercase descriptive names;
            no single-letter locals; no non-local ^; finite output.
*/

(
var postBanner, writeStatus, isSymlink, readLinkTarget;
var extensionsDir, extSuitePath, odRootPath, statusFolderPath, outFilePath, linkTargetText, isLink, exitCode;

// ---- header ----
postBanner = {
    var headerText;
    headerText = "=== MD_EOD_STATUS_SNAPSHOT (FIXED) ===";
    headerText.postln;
};

// ---- helpers (var-first inside closures) ----
isSymlink = { arg pathString;
    var testCmd, code, flag;
    testCmd = "[ -L \"" ++ pathString ++ "\" ]";
    code = testCmd.unixCmd;        // 0 if symlink, non-zero otherwise
    flag = (code == 0);
    flag
};

readLinkTarget = { arg pathString;
    var pipeRef, cmd, line;
    cmd = "readlink \"" ++ pathString ++ "\"";
    pipeRef = Pipe.new(cmd, "r");
    if(pipeRef.isNil) { "(unavailable)" } {
        line = pipeRef.getLine ? "(unavailable)";
        pipeRef.close;
        line
    }
};

writeStatus = { arg folderPath, bodyText;
    var ensureFolderOk, fileName, fullPath;
    ensureFolderOk = PathName(folderPath).isFolder;
    if(ensureFolderOk.not) { File.mkdir(folderPath) };
    fileName = "sc_status_" ++ Date.getDate.stamp ++ ".txt";
    fullPath = folderPath +/+ fileName;
    File.use(fullPath, "w", { arg fileRef; fileRef.write(bodyText) });
    ("EOD: wrote " ++ fullPath).postln;
    fullPath
};

// ---- run ----
postBanner.();

extensionsDir  = Platform.userExtensionDir.standardizePath;
extSuitePath   = extensionsDir +/+ "LivePedalboardSuite";
("EXT: " ++ extSuitePath).postln;

isLink = isSymlink.(extSuitePath);
if(isLink) {
    linkTargetText = readLinkTarget.(extSuitePath);
} {
    linkTargetText = "(not a symlink)";
};
("EXT: target = " ++ linkTargetText).postln;

// OneDrive folder we‚Äôre using today
odRootPath = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
statusFolderPath = odRootPath +/+ "SC_MPB_Test";

outFilePath = writeStatus.(statusFolderPath,
    "EOD snapshot at " ++ Date.getDate.stamp
    ++ "\nExtensions dir         = " ++ extensionsDir
    ++ "\nSuite path             = " ++ extSuitePath
    ++ "\nSuite link target      = " ++ linkTargetText
    ++ "\n"
);

// final expression (implicit return; no ^ in .scd)
outFilePath
)

===== utilities/MD_Stop_All_MeterDiagnostics.scd =====
// MD_Stop_All_MeterDiagnostics.scd
// v0.1.1
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Quiet the console by freeing known OSCdef listeners and stopping any reporter routines
            we may have created during diagnostics. Safe to run multiple times. Auto-stops.
   Style:   single () block; var-first everywhere; descriptive lowercase names; AppClock-only where used;
            no server.sync; no single-letter locals; returns nil.
*/

(
var freeOscIfPresent, stopRoutineIfPresent, freedCount, oscKeys, indexCount, indexLimit;
var reporterStoppedCount, oscObj, routineRef;

// ‚Äî‚Äî helpers (var-first in closures)
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MDSTOP: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineVar, labelString;
    var canStop;
    canStop = routineVar.notNil and: { routineVar.respondsTo(\stop) };
    if(canStop) { routineVar.stop; (labelString ++ ": stopped").postln };
};

// ‚Äî‚Äî free known listeners (only if present)
freedCount = 0;
oscKeys = [
    \md_levels_sniffer_fixed,    // finite/continuous sniffers
    \md_levels_inline,           // overlay listener (if any)
    \md_levels_dbg_sniffer,      // debug taps listener
    \md_levels_gui_listener,     // if we created a GUI-only listener
    \md_levels_hud               // HUD listener (optional ‚Äì remove if you want it kept)
];
indexCount = 0; indexLimit = oscKeys.size;
while({ indexCount < indexLimit }, {
    var keySym, exists;
    keySym = oscKeys[indexCount];
    exists = OSCdef.all.at(keySym).notNil;
    if(exists) { freeOscIfPresent.(keySym); freedCount = freedCount + 1 };
    indexCount = indexCount + 1;
});

// ‚Äî‚Äî stop known reporter routines (only if present)
reporterStoppedCount = 0;
stopRoutineIfPresent.(~md_levels_dbg_reporter, "md_levels_dbg_reporter"); reporterStoppedCount = reporterStoppedCount + 1;
stopRoutineIfPresent.(~md_simple_reporter,     "md_simple_reporter");     reporterStoppedCount = reporterStoppedCount + 1;

// ‚Äî‚Äî clear diagnostic dictionaries (safe)
~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
~md_levels_dbg = ~md_levels_dbg ? IdentityDictionary.new;

("MDSTOP: freed=" ++ freedCount.asString
 ++ " stopped=" ++ reporterStoppedCount.asString).postln;
nil
)

===== utilities/Meters_Diagnostic_Bootstrap_FIX.scd =====
// Meters_Diagnostic_Bootstrap_FIX.scd
// v0.1.1
// MD 20250923-1543

/* Purpose
   - Ensure bus meter SynthDefs exist (defines them via MagicDisplay.ensureMeterDefs(2) if needed).
   - Instantiate meter readers on Ndef(\chainA) and Ndef(\chainB) buses.
   - Install console debug printers for '/ampA' and '/ampB' using correct OSCdef.free pattern.

   Style
   - var-first; Server.default.bind for server ops; AppClock-safe UI; no server.sync.
*/

(
var serverRef, statusDisplayRef, chainABusIndex, chainBBusIndex, metersGroupId;
var ensureMeterDefsExist, installDebugPrinters, freeIfExists;

serverRef        = Server.default;
statusDisplayRef = (~system ? nil).notNil.if({ ~system.statusDisplay }, { nil });

ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ÑπÔ∏è Defining meter synths (busMeterA/busMeterB).".postln;
    MagicDisplay.ensureMeterDefs(2); // should be idempotent in your codebase
  };
};

freeIfExists = { |defName|
  var existingDef;
  existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

installDebugPrinters = {
  // Avoid duplicates by
===== utilities/Meters_QuickCheck_And_Enable.scd =====
// Meters_QuickCheck_And_Enable.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - Ensure meter SynthDefs exist (busMeterA/B).
   - Attach meter readers to Ndef(\chainA/\chainB) buses.
   - Print incoming values to console (quick sanity).
   - Re-enable GUI meters if the display supports it.

   Style
   - var-first; Server.default.bind for server ops; no server.sync.
*/

(
var serverRef, displayRef, chainABusIndex, chainBBusIndex, metersGroup;
var ensureMeterDefsExist, installConsolePrinters;

serverRef  = Server.default;
displayRef = ~system ? nil;

// --- helpers ---
ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ö†Ô∏è Meter SynthDefs missing ‚Äî defining now via MagicDisplay.ensureMeterDefs(2)".postln;
  };
  MagicDisplay.ensureMeterDefs(2); // idempotent
};

installConsolePrinters = {
  // avoid duplicates
  OSCdef.remove(\_meterA_dbg);
  OSCdef.remove(\_meterB_dbg);
  OSCdef(\_meterA_dbg, { |oscMessage| ("[meterA] " ++ oscMessage[3..].asString).postln }, '/ampA');
  OSCdef(\_meterB_dbg, { |oscMessage| ("[meterB] " ++ oscMessage[3..].asString).postln }, '/ampB');
};

// --- server work ---
Server.default.bind({
  ensureMeterDefsExist.value;

  // ensure both chain proxies are realized at audio-rate
  Ndef(\chainA).ar(2);
  Ndef(\chainB).ar(2);
  chainABusIndex = Ndef(\chainA).bus.index;
  chainBBusIndex = Ndef(\chainB).bus.index;

  metersGroup = Group.head(serverRef.defaultGroup);

  // spawn readers (safe to re
===== utilities/MIDI_Input_Tests_20250922.scd =====
// MIDI_Input_Tests_20250922.scd
// Run these step by step

// STEP A ‚Äî canonical bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);   // nil -> class default tree path
    ~system.bringUpAll;
}.defer;
)


// STEP B ‚Äî Refresh and connect MIDI at the SC level (safe anytime)
(
MIDIClient.restart;     // re-scan devices (good after hot-plug)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)



// STEP C ‚Äî Inspect manager + the symbol names you can bind
(
var mi;

mi = ~system.commandManager.midiManager;

"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;   // prints "Symbol: \NAME  ‚Üí UID: 1234..."

"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;         // prints the connected devices it sees
)


// STEP D ‚Äî Bind nanoKEY2 and IAC "to SC" to handlers
(
var mi = ~system.commandManager.midiManager;

// nanoKEY2 -> FootController (so notes 36/38/40/41 switch idle/prog/queue/send)
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);

// IAC "to SC" -> Guitar handler (so notes become frets during PROG mode)
mi.bindDevice(\MD_IAC_to_SC, mi.guitarHandler);

// Show current bindings (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect { |k| mi.deviceUIDs[k] == srcID } ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)


// Option 1
MIDIdef.trace(true);   // start tracing all MIDI events
// Press a nanoKEY2 key (or send a note to IAC "to SC") ‚Äî you should see noteOn/off
// When done:
MIDIdef.trace(false);

// Option 2:
// Install once; re-evaluate if you hot-plug (it rebuilds the map)
(
var buildMap;
~midiLog_srcFilter = nil;  // e.g. set to \nanoKEY2_KEYBOARD to filter (optional)
~midiLog_chanFilter = nil; // e.g. set to 1 to filter (optional)
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name)
            .replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%"
                .format(sym, chan, num, val)).postln;
        };
    };
});

// quick refresh if you hot-plug:
~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

// stop logger if needed:
~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k| MIDIdef(k).free };
    "[MIDI-LOG] stopped".postln;
};

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)


===== utilities/MIDI_Input_Tests2_20250922.scd =====
//MIDI_Input_Tests2_20250922.scd

// 0) Bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
}.defer;
)


// 1) Refresh MIDI in SC and connect all sources
(
MIDIClient.restart;     // re-scan devices (safe after hot-plugging)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)


// 2) See the symbols your app uses and their UIDs
(
var mi = ~system.commandManager.midiManager;
"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;
"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;
)


// 3) Bind nanoKEY2 -> FootController; IAC 'to SC' -> Guitar
(
var mi = ~system.commandManager.midiManager;
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);
mi.bindDevice(\MD_IAC_to_SC,      mi.guitarHandler);

// Print bound table (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect({ |k| mi.deviceUIDs[k] == srcID }) ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)

MIDIdef.trace(true);   // enable global trace
// press keys on nanoKEY2 or send notes to IAC "to SC"
MIDIdef.trace(false);

// 4B) Install raw taps (noteOn/noteOff/cc)
(
var mkLabel, fns;

mkLabel = { |src|
    var ep = MIDIClient.sources.detect({ |e| e.uid == src });
    if(ep.notNil) { (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_") } { "uid:" ++ src }
};

~midiTap_remove.(); // remove any previous tap safely (defined below)

// keep references so we can remove cleanly
~midiTap_fns = IdentityDictionary[
    \noteOn  -> MIDIIn.addFuncTo(\noteOn,  { |src, chan, num, vel| ("[RAW] noteOn  src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \noteOff -> MIDIIn.addFuncTo(\noteOff, { |src, chan, num, vel| ("[RAW] noteOff src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \control -> MIDIIn.addFuncTo(\control, { |src, chan, num, val| ("[RAW] cc     src=%  ch=%  num=%  val=%".format(mkLabel.(src), chan, num, val)).postln; })
];

~midiTap_remove = {
    if(~midiTap_fns.notNil) {
        ~midiTap_fns.keysValuesDo { |k, fn| if(fn.notNil) { MIDIIn.removeFuncFrom(k, fn) } };
        ~midiTap_fns = nil;
        "[RAW] taps removed".postln;
    } {
        // noop
    };
};

"[RAW] taps installed ‚Äî press nanoKEY2 or send to IAC".postln;
)


// 4C) Minimal logger (noteOn/off & CC), with map refresh helper
(
var buildMap;
~midiLog_srcFilter = nil;
~midiLog_chanFilter = nil;
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k|
        var def = MIDIdef(k);
        if(def.notNil) { def.free };
    };
    "[MIDI-LOG] stopped".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%".format(sym, chan, num, val)).postln;
        };
    };
});

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "üîé [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"‚úÖ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "üõë [MIDI-LOG] stopped.".postln;
};
)

===== utilities/MIDI_Log_RefreshAndConnect.scd =====
// MIDI_Log_RefreshAndConnect.scd
// v0.1.0
// MD 20250922-1422

/*
Purpose
- If you plugged devices while SC was running, restart the MIDI client,
  reconnect all inputs, and refresh the logger's source map.
- Also clears any logger filters so you see everything.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

(
var announce;

announce = { |title| ("[MIDI-LOG] " ++ title).postln };

MIDIClient.restart;           // re-scan devices (idempotent & safe)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

~midiLog_srcFilter = nil;     // show all sources
~midiLog_chanFilter = nil;    // show all channels

if(~midiLog_refresh.isKindOf(Function)) {
    ~midiLog_refresh.();      // rebuild the uid->label map used by the logger
    announce.("sources remapped.");
} {
    announce.("note: logger not installed yet; run MIDI_Log_Console.scd first.");
};

// quick device listing
"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };
"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ [MIDI-LOG] refresh complete ‚Äî play/send something to see messages.".postln;
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "üßπ Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("üì• Command added: " ++ canonicalPathString).postln;
("üì¶ Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Quick_SetSource_Testmelody.scd =====
// Quick_SetSource_Testmelody.scd
// v0.1.0  MD 2025-09-26
(
var systemRef, cmRef, cb;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
cmRef = systemRef.commandManager; if(cmRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
cb = cmRef.queueExportCallback;
if(cb.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    cb = cmRef.queueExportCallback;
};
if(cb.isKindOf(Function)) {
    cb.value("/commands/setSource/testmelody");  // from your tree: commands ‚Üí setSource ‚Üí testmelody
    "[SetSource] '/commands/setSource/testmelody' sent.".postln;
} {
    "‚ö†Ô∏è queueExportCallback missing.".warn;
};
)

===== utilities/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "‚ö†Ô∏è ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "‚ö†Ô∏è CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "‚ö†Ô∏è queueExportCallback missing.".warn };
)

===== utilities/Rearm_Attach_Probes_AfterBringUp.scd =====
// Rearm_Attach_Probes_AfterBringUp.scd
// v0.1.0  MD 2025-09-26
(
var baseTrouble, runIfExists;
baseTrouble = Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting";
runIfExists = { arg leaf;
    var p = (baseTrouble ++ "/" ++ leaf).standardizePath;
    if(File.exists(p)) { p.load } { ("‚ö†Ô∏è missing " ++ leaf).warn };
};

AppClock.sched(0.10, { runIfExists.("MagicDisplayGUI_Reenable_FilterMeters_V0.3.12.scd"); nil });
AppClock.sched(0.20, { runIfExists.("MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd"); nil });
AppClock.sched(0.30, { runIfExists.("MagicDisplayGUI_ResetReceiver_v0.3.11.scd"); nil });
"[Rearm] bus/probe helpers scheduled.".postln;
)

===== utilities/Report_ChainPlayFlags.scd =====
// Report_ChainPlayFlags.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Print whether Ndef(\chainA) and Ndef(\chainB) are playing.
   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var isChainAPlaying, isChainBPlaying;

isChainAPlaying = Ndef(\chainA).isPlaying;
isChainBPlaying = Ndef(\chainB).isPlaying;

("[PLAY] chainA=" ++ isChainAPlaying ++ "  chainB=" ++ isChainBPlaying).postln;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd.bak =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager‚Äôs builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X ‚Üí Name" lines for the GUI‚Äôs Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI‚Äôs expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager‚Äôs builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply ‚Üí " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready ‚Äî use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd.bak =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/Magicpedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long ‚Üí short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long ‚Üí short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain ‚Üí add ‚Üí delay        (preferred if present)
       (b) chain ‚Üí add ‚Üí timebased ‚Üí delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> ‚Üí /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> ‚Üí /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path‚Üí " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) ‚Üí still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

===== utilities/Test_MagicPedalboard_MIDI_Simulation.scd =====
// Test_MagicPedalboard_MIDI_Simulation.scd
// v0.1.1
// MD 20250922-18-15

/*
Purpose
- Simulate MIDI input sequences for MagicPedalboard system testing.
- Each test step is labeled and commented with expected GUI/behavior.
- Allows repeatable, device-free testing and can be bundled with the suite.

Style
- var-first; lowercase; AppClock-only; no server.sync; clear comments.
*/

// --- Device UIDs: update these to match your system ---
var nanoUID = 302172822;    // nanoKEY2_KEYBOARD
var iacUID  = 1339807908;   // MD_IAC_to_SC

// --- Helper: fire a sequence of steps ---
~fireMidiSequence = { |steps|
    Routine({
        steps.do { |step|
            var src, chan, note, vel, dur, comment;
            src = step[0]; chan = step[1]; note = step[2];
            vel = step[3]; dur = step[4]; comment = step[5];
            ("[TEST] " ++ comment).postln;
            MIDIIn.doNoteOnAction(src, chan, note, vel);
            (dur ? 0.5).wait;
            MIDIIn.doNoteOffAction(src, chan, note, 0);
            0.1.wait;
        }
    }).play(AppClock);
};

// --- Test Sequence 1: Add Delay and Send ---
~test_add_delay = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 41, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /add"],
    [iacUID,  1, 45, 100, 0.5, "Step 3: IAC string 5 ‚Üí select /delay"],
    [nanoUID, 0, 40, 100, 0.5, "Step 4: nanoKEY2 E2 ‚Üí queue path"],
    [nanoUID, 0, 41, 100, 0.5, "Step 5: nanoKEY2 F2 ‚Üí send path"]
];

// --- Test Sequence 2: Switch Chain ---
/*~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 48, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"],
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]
];*/
~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"], // enter prog mode
    [iacUID,  0, 43, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"], // pitch 43 = base 40 + fret 3
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],   // queue
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]     // send
];



// --- To run a test sequence ---
~fireMidiSequence.(~test_add_delay);
// ~fireMidiSequence.(~test_switch_chain); // ‚Üê uncomment to run this one

// --- Add more sequences below as needed ---

===== utilities/Verify_Baseline_CurrentAudible_NextSilent.scd =====
// Verify_Baseline_CurrentAudible_NextSilent.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Verify that CURRENT‚Äôs sink is the audible one and NEXT‚Äôs sink is silent (Option A).
   - Posts a clear PASS/FAIL with details.

   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var systemReady, pedalboardRef;
var currentSinkSymbol, nextSinkSymbol;
var isChainAPlaying, isChainBPlaying;
var currentIsAudible, nextIsSilent;
var summaryText;

// guards
systemReady = ~system.notNil;
if(systemReady.not) {
    "‚ö†Ô∏è ~system is nil. Run Start_LivePedalboardSystem.scd (Option B) first.".postln;
};

// proceed only if ready
if(systemReady) {
    pedalboardRef = ~system.pedalboard;

    // sink symbols at the heads of CURRENT/NEXT
    currentSinkSymbol = pedalboardRef.effectiveCurrent[0];  // \chainA or \chainB
    nextSinkSymbol    = pedalboardRef.effectiveNext[0];     // \chainB or \chainA

    // live flags (do not change any routing)
    isChainAPlaying = Ndef(\chainA).isPlaying;
    isChainBPlaying = Ndef(\chainB).isPlaying;

    // interpret flags relative to CURRENT/NEXT
    currentIsAudible =
        ((currentSinkSymbol == \chainA) and: { isChainAPlaying })
        or: { (currentSinkSymbol == \chainB) and: { isChainBPlaying } };

    nextIsSilent =
        ((nextSinkSymbol == \chainA) and: { isChainAPlaying.not })
        or: { (nextSinkSymbol == \chainB) and: { isChainBPlaying.not } };

    if(currentIsAudible and: { nextIsSilent }) {
        "‚úÖ Baseline OK: CURRENT is audible; NEXT is silent.".postln;
    }{
        summaryText =
            "‚ö†Ô∏è Baseline mismatch ‚Äî "
            ++ "CURRENT=" ++ currentSinkSymbol.asString
            ++ " NEXT=" ++ nextSinkSymbol.asString
            ++ " | chainA=" ++ isChainAPlaying
            ++ " chainB=" ++ isChainBPlaying;
        summaryText.postln;
    };
};
)

