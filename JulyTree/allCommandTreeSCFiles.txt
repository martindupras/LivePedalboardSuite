// circularSaves.sc
// MD 20250819

// This allows me to save the last ten trees in a folder, and keep track of the last one. Versions are named after date/time.


CircularFileSave {
    var <>prefix, <>folderPath, <>maxVersions, <fileList;

    *new { |prefix = "myTree", folderPath = "~/TreeSaves", maxVersions = 10|
        ^super.new.init(prefix, folderPath, maxVersions);
    }

    init { |prefix, folderPath, maxVersions|
        this.prefix = prefix;
        this.folderPath = folderPath.standardizePath;
        this.maxVersions = maxVersions;
        this.ensureFolderExists;
        this.refreshFileList;
    }

    ensureFolderExists {
        File.mkdir(folderPath);
    }

    refreshFileList {
        fileList = PathName(folderPath).entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
    }

    saveVersion { |content|
        var timestamp = Date.getDate.stamp;
        var filename = "%-%".format(prefix, timestamp) ++ ".json";
        var path = folderPath +/+ filename;

        File.use(path, "w", { |f| f.write(content) });

        fileList.addFirst(PathName(path));

        if(fileList.size > maxVersions) {
            var toDelete = fileList.copyRange(maxVersions, fileList.size - 1);
            toDelete.do(_.delete);
            fileList = fileList.copyRange(0, maxVersions - 1);
        };

        path.postln;
    }

    listVersions {
        fileList.collect(_.fileName).do(_.postln);
    }

    loadVersion { |index|
        var file, content;

        if(index >= fileList.size or: { index < 0 }) {
            "Invalid index: % (available: 0 to %)".format(index, fileList.size - 1).warn;
            ^nil;
        };

        file = fileList[index];
        if(file.isNil) {
            "No file found at index %".format(index).warn;
            ^nil;
        };

        File.use(file.fullPath, "r", { |f|
            content = f.readAllString;
        });
        ^content;
    }

    latestVersion {
        ^this.loadVersion(0);
    }
}

// CommandManager.sc
// Refactored from MDCommandMC.sc
// MD 20250817-1927

//previously known as MDCommandMC
CommandManager {
	//var something, octave, pitchclass, gString; // no longer used
	//var states;
	var <> currentState; // getter and setters for outside

	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver; // for circularSaver


	var launchpadHandler, footControllerHandler, guitarHandler;
	var <>launchpadID, <>footControllerID, <>guitarID;

	*new {
		^super.new.init;
	}


	init {
		//DEBUG
		if (true) { "CommandManager created".postln };

		currentState = \idle;

		saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);
		filePath = "~/CommandTreeSavefiles/myTree.json".standardizePath;


		this.createNewTree;
		this.createBuilder;
		this.createCommandQueue;

		display = UserDisplay.new;

		midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager.parentCommandManager = this;

		^this
	}


	createNewTree {
		tree = MDCommandTree.new("root");
		tree.importJSONFile(filePath);
		if (tree.notNil) {
			"üîÆ Tree created".postln;
			//DEBUG
			if (true) { tree.printTreePretty };
		} {
			"üîÆ Couldn't create tree".postln;
		}
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			//DEBUG
			if (true) {"üîÆ Builder created".postln};
		} {
			"üîÆ Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			//DEBUG
			if (true) {"üîÆ Queue created".postln};
		} {
			"üîÆ Couldn't create queue".postln;
		}
	}

	// previously only called "print"
	printMIDIInfo { |vel, num, chan|
		("vel: " + vel).postln;
		("num: " + num).postln;
		("chan: " + chan).postln;
		^this
	}

	updateDisplay {
		var modeText, nodeChoicesText, children;

		// Show current state
		modeText = "üß≠ Mode: " ++ currentState.asString;
		nodeChoicesText = "‚ö†Ô∏è No choices available.";

		if (currentState == \prog) {
			children = builder.currentNode.children;

			if (builder.isAtLeaf) {
				nodeChoicesText = nodeChoicesText ++ "\nüåø Leaf node reached.";
			};

			if (children.notEmpty) {
				children.do { |c|
					("üß™ Child: " ++ c.name ++ ", payload: " ++ c.payload).postln;
				};

				nodeChoicesText = "üéö Current Node: " ++ builder.currentNode.name ++ "\n\n" ++
				"üì¶ Available Choices:\n" ++
				children.collect { |c|
					"‚Ä¢ Fret " ++ c.fret ++ " ‚Üí " ++ c.name ++ " (payload: " ++ c.payload ++ ")"
				}.join("\n");
			} {
				nodeChoicesText = "üéö Current Node: " ++ builder.currentNode.name ++ "\n‚ö†Ô∏è No available choices.";
			};
		} {
			nodeChoicesText = "";
		};

		("üñ• Updating display...").postln;
		("State text: " ++ modeText).postln;
		("Choices text: " ++ nodeChoicesText).postln;

		// Update individual display fields
		{display.modeText.string = modeText;}.defer;
		{display.userChoicesText.string = nodeChoicesText;}.defer;
	}


	setStatus { |text|
		if (display.notNil) {
			display.updateStatus(text);
		} {
			("‚ö†Ô∏è Display not available. Status: " ++ text).postln;
		}
	}

	saveCurrentTreeVersion {
    if(tree.notNil) {
        var json = tree.asJSON;
        saver.saveVersion(json);
        this.setStatus("‚úÖ Tree saved to versioned file.");
    } {
        this.setStatus("‚ö†Ô∏è No tree to save.");
    };
}

	loadLatestTreeVersion {
    var json = saver.latestVersion;
    if(json.notNil) {
        tree = MDCommandTree.new("root");
        tree.importJSON(json);
        builder = MDCommandBuilder.new(tree);
        this.setStatus("‚úÖ Latest tree version loaded.");
    } {
        this.setStatus("‚ö†Ô∏è No saved version found.");
    };
}

	listSavedVersions {
    saver.listVersions;
}


}

// alias to old name
MDCommandMC : CommandManager {}// MDCommandBuilder.sc

// MD 20250818

MDCommandBuilder {
	var <>tree, <>currentNode, <>currentCommand, <>fretPath;
	var <>navigationComplete = false;

	*new { |argTree| ^super.new.init(argTree); }

	init { |argTree|
		tree = argTree;
		currentNode = tree.root;
		fretPath = List[0];
		"CommandBuilder initialized".postln;
		^this
	}

	printChildren {
		var childrenNames;
		if (currentNode.children.notEmpty) {
			currentNode.children.do { |item|
				("üéö Fret: " ++ item.fret ++ " ‚Üí " ++ item.name).postln;
			};
			childrenNames = currentNode.children.collect(_.name);
		} {
			"‚ö†Ô∏è No children".postln;
		};
		^childrenNames
	}

	navigateByFret { |stringLevel, fretNumber|
		var nextNode;
		("üé∏ Navigating by fret: " ++ fretNumber).postln;
		nextNode = currentNode.getChildByFret(fretNumber);
		if (nextNode.notNil) {
			currentNode = nextNode;
			fretPath.add(currentNode.fret);
			("Current node: " ++ currentNode.name).postln;
		} {
			("‚ö†Ô∏è No child found for fret: " ++ fretNumber).postln;
		};
		^currentNode
	}


	navigateByName { |stringLevel, childName|
		var nextNode = currentNode.getChildByName(childName);
		if (nextNode.notNil) {
			currentNode = nextNode;
			fretPath.add(currentNode.fret);
			("Current node: " ++ currentNode.name).postln;
			("Path: " ++ currentNode.getFullPathString).postln;
		} {
			("‚ö†Ô∏è Available children: " ++ currentNode.children.collect(_.name).join(", ")).postln;
		};
		^currentNode
	}

	printPathToRoot {
		currentNode.getPathToRoot.postln;
		^this
	}

	getCurrentName {
		currentNode.name.postln;
		^currentNode.name
	}

	getCurrentPayload {
		("Current payload: " ++ currentNode.payload).postln;
		//currentNode.payload.postln;
		^currentNode.payload
	}
	isAtLeaf {
		^currentNode.children.isEmpty;
	}

	resetNavigation {
		currentNode = tree.root;
		fretPath = List[0];
		navigationComplete = false;  // important; reset the flag!
		"üîÑ Navigation reset".postln;
		^this
	}

	printfretPath {
		("Fret path: " ++ fretPath).postln;
		^this
	}

}
// MDCommandNode.sc
// Refactored for clarity and correctness
// MD 20250813

MDCommandNode {
	var <>name, <>id, <>fret, <>parent, <>children;
	var <> payload; // the "command" that will be inserted in the tree


	*new { |name = "default", id = 1, fret = 1, parent = nil|
		^super.new.init(name, id, fret, parent);
	}

	init { |name, id, fret, parent = nil|
		this.name = name;
		this.id = id;
		this.fret = fret;
		this.parent = parent;
		//this.children = List.new; // updated to following:
		this.children = SortedList.new(nil, { |a, b| a.fret < b.fret });

		//if (children.isKindOf(List).not) updated to following:
		if (this.children.isKindOf(SortedList).not) {
			{
				("‚ö†Ô∏è Children is not a SortedList in node '" ++ name ++ "'! It is: " ++ children.class).postln;
			};

			^this
		}
	}

		// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Management ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		addChild { |child|
			if (child.isKindOf(MDCommandNode)) {
				child.parent = this;
				children.add(child);
			} {
				"‚ö†Ô∏è Attempted to add a non-node child.".warn;
			}
		}

		createChild { |name, id, fret|
			var child;
			if (name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
				("‚ùå Invalid arguments for createChild").warn;
				^nil;
			};

			child = this.getChildByName(name);
			if (child.isNil) {
				child = MDCommandNode.new(name, id, fret);
				this.addChild(child);
				("‚úÖ Created new child node: " ++ name ++ " (ID: " ++ id ++ ", Fret: " ++ fret ++ ")").postln;
			} {
				("‚ÑπÔ∏è Child node already exists: " ++ name).postln;
			};

			^child
		}

		removeChildByName { |nameToRemove|
			var index = children.findIndex { |c| c.name == nameToRemove };
			if (index.notNil) { children.removeAt(index); }
		}

		removeChildById { |idToRemove|
			var childToRemove = children.detect { |c| c.id == idToRemove };
			if (childToRemove.notNil) {
				children.remove(childToRemove);
				("üóë Child removed").postln;
			} {
				("‚ö†Ô∏è ID not found").postln;
			}
		}

		// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Child Lookup ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		getChildByName { |name|
			if (name.isKindOf(String).not) {
				("‚ùå getChildByName error: name must be a String").warn;
				^nil;
			};
			^children.detect { |c| c.name == name }
		}

		getChildById { |id| ^children.detect { |c| c.id == id } }

		getChildByFret { |fret| ^children.detect { |c| c.fret == fret } }

		childNameExists { |name| ^children.any { |c| c.name == name } }

		// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Navigation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		getPathToRoot {
			var path = List.new;
			var current = this;
			while { current.notNil } {
				path.addFirst(current.name);
				current = current.parent;
			};
			^path
		}

		printPathToRoot {
			("üìç Path: " ++ this.getPathToRoot.join(" ‚Üí ")).postln;
		}

		getNodeByNamePath { |nameList|
			var current = this;
			nameList.do { |name|
				current = current.getChildByName(name);
				if (current.isNil) {
					("‚ùå Node not found at path segment: " ++ name).postln;
					^nil;
				}
			};
			("‚úÖ Found node: " ++ current.name).postln;
			^current
		}

		getDepth {
			^this.parent.notNil.if({ this.parent.getDepth + 1 }, { 0 })
		}


		// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Analysis ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		isLeaf {
			^this.children.size == 0
		}

	// isDescendant replaced with hasChild; clearer
/*		isDescendant { |node|
			^this.children.any { |c| c === node }
		}*/

		hasChild { |node|
			^this.children.any { |c| c === node }
		}
		countDescendants {
			if (this.isLeaf) { ^1 } {
				^this.children.sum { |c| c.countDescendants }
			}
		}

		countLeavesOnly {
			^this.isLeaf.if({ 1 }, {
				this.children.sum { |c| c.countLeavesOnly }
			})
		}

		getFullPathString {
			^this.getPathToRoot.join(" ‚Üí ");
		}

		checkIntegrity {
			var failedChild;

			if (this.children.isKindOf(List).not) {
				("‚ùå Integrity check failed at node '" ++ this.name ++ "'").postln;
				^false;
			};

			failedChild = this.children.detect { |c| c.checkIntegrity.not };
			if (failedChild.notNil) {
				("‚ùå Integrity failed in child: " ++ failedChild.name).postln;
				^false;
			};

			^true
		}


	// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Tree Display ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
printTreePretty { |level = 0, isLast = true, prefix = ""|
    var sortedChildren, connector, newPrefix;

    // Print current node
    connector = if (level == 0) { "" } { if (isLast) { "‚îî‚îÄ‚îÄ " } { "‚îú‚îÄ‚îÄ " } };
    (prefix ++ connector ++ this.name ++
        " (fret: " ++ this.fret ++
        ", id: " ++ this.id ++
        ", payload: " ++ this.payload ++ ")").postln;

    // Prepare prefix for children
    newPrefix = if (level == 0) { "" } {
        prefix ++ if (isLast) { "    " } { "‚îÇ   " }
    };

    // Use existing sortedChildren logic
    sortedChildren = this.children;

    // Recursively print children
    sortedChildren.do { |child, i|
        var last = (i == (sortedChildren.size - 1));
        child.printTreePretty(level + 1, last, newPrefix);
    };
}

		// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Serialization for exporting ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

		asDictRecursively {
			^(
				id: this.id,
				name: this.name,
				fret: this.fret,
				children: this.children.collect { |c| c.asDictRecursively }
			)
		}
	}
	// MDCommandQueue.sc
// Refactored for clarity and consistency
// MD 20250818



MDCommandQueue {
    var <>commandList;

    *new { ^super.new.init(); }

    init {
        commandList = List.new(8);
        Verbosity.postIf(1, "‚úÖ CommandQueue initialized");
        ^this
    }

    enqueueCommand { |command|
        commandList.add(command);
        Verbosity.postIf(1, "üì• Command added: " ++ command);
        Verbosity.postIf(2, "üì¶ Current queue: " ++ commandList);
        ^commandList
    }

    dequeueLastCommand {
        if (commandList.notEmpty) {
            commandList.removeAt(commandList.size - 1);
            Verbosity.postIf(1, "üóë Last command removed");
        } {
            Verbosity.postIf(0, "‚ö† No command to remove");
        };
        ^commandList
    }

    clearQueue {
        commandList.clear;
        Verbosity.postIf(1, "üßπ Queue cleared");
        ^this
    }

    exportAsOSCPath {
        var oscPath;

        oscPath = "/" ++ commandList.collect { |cmd|
            cmd.asString;
        }.join("/");

        ~commandToSend = oscPath;
        Verbosity.postIf(2, "üöÄ Exported OSC path: " ++ oscPath);
        ^oscPath
    }
}

// MDCommandQueue {
// 	var <>commandList;
//
// 	*new { ^super.new.init(); }
//
// 	init {
// 		commandList = List.new(8);
// 		"CommandQueue initialized".postln;
// 		^this
// 	}
//
// 	enqueueCommand { |command|
// 		commandList.add(command);
// 		("Command added: " ++ command).postln;
// 		("Current queue: " ++ commandList).postln;
// 		^commandList
// 	}
//
// 	dequeueLastCommand {
// 		if (commandList.notEmpty) {
// 			commandList.removeAt(commandList.size - 1);
// 			"Last command removed".postln;
// 		} {
// 			"‚ö†No command to remove".postln;
// 		};
// 		^commandList
// 	}
//
// 	clearQueue {
// 		commandList.clear;
// 		"üßπ Queue cleared".postln;
// 		^this
// 	}
//
//
// 	exportAsOSCPath {
// 		var oscPath;
//
// 		oscPath = "/" ++ commandList.collect { |cmd|
// 			cmd.asString;
// 		}.join("/");
//
// 		~commandToSend = oscPath;
// 		("Exported OSC path: " ++ oscPath).postln;
// 		^oscPath
// 	}
// }MDCommandTree {
	var <>root, <>nodeLimit = 200, <>nodeCount = 0, <>nodeMap;
	var <>saver;

	*new { |rootName = "root", rootId = 0, nodeLimit|
		^super.new.init(rootName, rootId, nodeLimit);
	}


	*fromDict { |dict|
		var tree;

		// Use a default node limit, or extract from dict if available
		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ?? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				tree.rebuildTreeFromDict(childDict, tree.root);
			};
		};
		tree.root.payload = dict[\payload];

		^tree;
	}


	init { |rootName, rootId, limit|
		root = MDCommandNode.new(rootName, rootId);
		nodeLimit = limit;
		nodeCount = 1;

		nodeMap = IdentityDictionary.new(100);
		nodeMap.put(rootId, root);

		saver = CircularFileSave.new("myTree", "~/TreeSaves", 10); // this is what will manage saves

		^this
	}

	rebuildTreeFromDict { |dict, parent|
		var node;

		node = MDCommandNode.new(dict[\name], dict[\id], dict[\fret]);
		parent.addChild(node);

		nodeMap.put(node.id, node);
		nodeCount = node.id.max(nodeCount);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				this.rebuildTreeFromDict(childDict, node);
			};
		};

		node.payload = dict[\payload];

		^node;
	}

	printTreePretty {
		root.printTreePretty;
		^this;
	}

	tagDepths {
		root.tagByDepth(0);
		^this;
	}

	findNodeByName { |name|
		var found;
		found = nodeMap.values.detect { |node| node.name == name };
		if (found.notNil) {
			("üîç Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			^found
		} {
			"‚ö†Ô∏è Node not found".postln;
			^nil
		}
	}

	getNodeByNamePath { |nameList|
		var found;
		found = root.getNodeByNamePath(nameList);
		if (found.notNil) {
			^found
		} {
			("‚ö†Ô∏è Node not found at path: " ++ nameList.join(" ‚Üí ")).postln;
			^nil
		}
	}

	addNode { |parentId, name, fret|
		var newId, parentNode, newNode;

		newId = nodeCount + 1;
		parentNode = nodeMap.at(parentId);

		if (parentNode.notNil) {
			nodeCount = newId;
			newNode = MDCommandNode.new(name, newId, fret);
			newNode.parent = parentNode;
			parentNode.addChild(newNode);
			nodeMap.put(newId, newNode);
			^newNode
		} {
			("‚ö†Ô∏è Invalid parent ID: " ++ parentId).postln;
			^nil
		}
	}

	removeNode { |nodeId|
		var nodeToRemove, parentNode, found;

		nodeToRemove = nodeMap.at(nodeId);
		parentNode = nodeToRemove.parent;

		if (parentNode.notNil) {
			found = parentNode.children.detect { |c| c === nodeToRemove };
			if (found.notNil) {
				parentNode.removeChildById(found.id);
				nodeMap.removeAt(nodeId);
				("üóë Node " ++ nodeId ++ " removed.").postln;
				^nodeToRemove
			} {
				"‚ö†Ô∏è Node not found in parent's children".postln;
				^nil
			}
		} {
			"‚ö†Ô∏è Cannot remove root node".postln;
			^nil
		}
	}

	swapNodes { |nodeId1, nodeId2|
		var node1, node2, parent1, parent2;

		node1 = nodeMap.at(nodeId1);
		node2 = nodeMap.at(nodeId2);
		parent1 = node1.parent;
		parent2 = node2.parent;

		if (parent1.isNil or: { parent2.isNil }) {
			"‚ö†Ô∏è Both nodes must have parents to swap".postln;
			^nil
		};

		node1 = removeNode(nodeId1);
		node2 = removeNode(nodeId2);

		if (node1.isNil or: { node2.isNil }) {
			"‚ö†Ô∏è Failed to remove nodes for swapping".postln;
			^nil
		};

		parent1.addChild(node2);
		parent2.addChild(node1);

		"üîÑ Nodes swapped".postln;
		^nil
	}

	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("üì§ Tree exported to " ++ path).postln;
		} {
			"‚ö†Ô∏è Failed to open file for writing.".warn;
		}
	}

	importJSONFile { |path|
		var jsonString, dict, newTree;

		if (File.exists(path).not) {
			"‚ùå File does not exist: %".format(path).postln;
			^false;
		};

		jsonString = File(path, "r").readAllString;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"‚ö†Ô∏è File is empty or unreadable.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		("üì• Tree imported from " ++ path).postln;
		^true;
	}

	// NEW - added to manage circular saves
	saveVersioned {
		var json = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(json);
		"Tree saved to versioned file.".postln;
	}
	//---

	// NEW - added to manage circular saves
	loadLatestVersion {
		var json = saver.latestVersion;
		var dict, newTree;

		if(json.isNil or: { json.isEmpty }) {
			"‚ö†Ô∏è No saved version found.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(json);

		if(dict.isNil) {
			"‚ö†Ô∏è Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		"üì• Tree loaded from latest version.".postln;
		^true;
	}
	//---

	// NEW - added to manage circular saves
	listSavedVersions {
		saver.listVersions;
	}

	//---




	validateTree {
		var seenNames = Set.new;
		var valid = true;
		nodeMap.values.do { |node|
			if (seenNames.includes(node.name)) {
				("‚ö†Ô∏è Duplicate node name: " ++ node.name).postln;
				valid = false;
			};
			seenNames.add(node.name);
		};
		^valid;
	}


	// THIS IS NEW. This is so that (for now) we can copy the name of the node into the payload instance variable.
	assignPayloads {
		var assignRecursively;

		assignRecursively = { |node|
			node.payload = node.name;
			node.children.do { |child|
				assignRecursively.(child);
			};
		};

		assignRecursively.(this.root);
		"üß† Payloads assigned to all nodes in tree.".postln;
		^this;
	}

	printPayloads {
		var printRecursively;

		printRecursively = { |node, level = 0|
			var indent = "  " ! level;
			(indent.join ++ node.name ++ " ‚Üí Payload: " ++ node.payload).postln;
			node.children.do { |child|
				printRecursively.(child, level + 1);
			};
		};

		printRecursively.(this.root);
		^this;
	}


}
//MIDIHandlers.sc
// MD 20250818
// taken out of MIDIInputManager.sc to make smaller file and cleaner organisation.

MIDIInputHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}

LaunchpadHandler  {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
	}
}

LaunchpadDAWHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		// Intentionally left blank to ignore DAW messages
	}
}

FootControllerHandler {
	var <>inputManager;

	*new { |inputManager|
		if (inputManager.isNil) {
			Error("FootControllerHandler requires a inputManager").throw;
		};
		^super.new.init(inputManager);
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ FootControllerHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, value|
		("üß™ inputManager class is: " ++ inputManager.class).postln;


		if (type === \noteOn) {
			switch (value,
				36, { inputManager.setMode(inputManager.modes[\idle]) },
				38, { inputManager.setMode(inputManager.modes[\prog]) },
				40, { inputManager.setMode(inputManager.modes[\queue]) },
				41, { inputManager.setMode(inputManager.modes[\send]) },
				{ ("‚ö†Ô∏è No action for note: " ++ value).postln }
			);
		}
	}
}

GuitarMIDIHandler {
	var <>inputManager;

	*new { |inputManager|
		var instance = super.new;
		instance.init(inputManager);
		^instance
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("‚úÖ GuitarMIDIHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, pitch|
		var stringBasePitches, basePitch, fret, stringNumber;

		// ‚úÖ Confirm method is being called
		("üì• handleMessage called with channel: " ++ channel ++ ", type: " ++ type ++ ", pitch: " ++ pitch).postln;

		// ‚úÖ Check type
		if (type === \noteOn) {
			"‚úÖ type is noteOn".postln;
		} {
			"‚ùå type is not noteOn".postln;
		};

		// ‚úÖ Check current mode
		if (inputManager.currentMode == inputManager.modes[\prog]) {
			"‚úÖ currentMode is prog".postln;

			stringBasePitches = (
				0: 40, // E string (6th)
				1: 45, // A
				2: 50, // D
				3: 55, // G
				4: 59, // B
				5: 64  // E (1st)
			);

			basePitch = stringBasePitches[channel];
			if (basePitch.notNil) {
				fret = pitch - basePitch;
				stringNumber = 6 - channel;

				("üé∏ Received MIDI note: " ++ pitch ++
					" on channel: " ++ channel ++
					" ‚Üí string: " ++ stringNumber ++
					", base pitch: " ++ basePitch ++
					", calculated fret: " ++ fret).postln;

				// ‚úÖ Navigation logic
				if (inputManager.waitingForString == stringNumber) {
					inputManager.waitingForString = nil;
					inputManager.navigationCallback.value(fret);
				};
			} {
				("‚ö†Ô∏è Unrecognized channel: " ++ channel ++ ". No base pitch defined.").postln;
			}
		} {
			("‚ùå currentMode is: " ++ inputManager.currentMode).postln;
		};

		{ inputManager.parentCommandManager.updateDisplay; }.defer;
	}
}// MIDIInputManager.sc
// MD 20250817-1926

MIDIInputManager {
	var <>deviceUIDs;         // Dict: symbolic name -> srcID
	var <>deviceHandlers;     // Dict: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <> builder, <>queue;
	var <> parentCommandManager;
	var <> modes;
	var <>waitingForString, <>navigationCallback;
	var <>lastEnqueuedPayload;


	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|

		this.modes = IdentityDictionary[
			\idle -> \idle,
			\prog -> \prog,
			\queue -> \queue,
			\send -> \send,
			\play -> \play,
			\numeric -> \numeric,
			\capture -> \capture,
			\record -> \record
		];

		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		//DEBUG:
		("footControllerHandler manager is: " ++ footControllerHandler.inputManager).postln;

		this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;

		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getDeviceSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}

	setMode { |newMode|
		currentMode = newMode;
		parentCommandManager.currentState = newMode;
		this.handleModeChange(newMode);
		{ parentCommandManager.updateDisplay }.defer;
	}

	handleModeChange { |mode|
		switch(mode,
			modes[\idle], {
				queue.clear;
				builder.resetNavigation;
				"Tree navigation reset.".postln;
			},

			modes[\prog], {
				var root;

				builder.resetNavigation;

				root = builder.tree.root; // get the root
				if (root.notNil) {
					root.children.do { |child| ("‚Ä¢ " ++ child.name).postln };
				};

				this.startNavigationFromString(6);

				"Tree navigation started.".postln;
			},

			//---


			modes[\queue], {
				var queueText;
				var payload = builder.getCurrentPayload;

				if (payload != lastEnqueuedPayload) {
					("Current payload to queue: " ++ payload).postln;
					queue.enqueueCommand(payload);
					lastEnqueuedPayload = payload;

					if (builder.isAtLeaf) {
						parentCommandManager.setStatus("üåø Leaf node reached; payload: " ++ payload);
					} {
						parentCommandManager.setStatus("üì• Queued node: " ++ payload);
					};

					queueText = queue.commandList.collect { |cmd| "- " ++ cmd.asString }.join("\n");
					("Queue contents:\n" ++ queueText).postln;

					{
						/*parentCommandManager.display.display(\state, "Mode: queue");
						parentCommandManager.display.display(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.display(\lastCommand, "Last Added: " ++ payload);*/
						parentCommandManager.display.updateTextField(\state, "Mode: queue");
						parentCommandManager.display.updateTextField(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.updateTextField(\lastCommand, "Last Added: " ++ payload);

					}.defer;
				} {
					("‚ö†Ô∏è Duplicate payload ignored: " ++ payload).postln;
					parentCommandManager.setStatus("‚ö†Ô∏è Duplicate payload ignored");
				};

				builder.resetNavigation;
				"Added node to queue and restarted navigation.".postln;
				this.setMode(modes[\prog]);
			},

			//---

			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;

				("Sent queue as OSC: " ++ path).postln;
				queue.clear;
			},
			modes[\play], {
				"üé∏ Play mode: no interaction.".postln;
			},
			modes[\numeric], {
				"üî¢ Numeric input mode (not yet implemented).".postln;
			},
			modes[\capture], {
				"üéº Capture mode (not yet implemented).".postln;
			},
			modes[\record], {
				"üî¥ Record mode (not yet implemented).".postln;
			}
		);
	}
	startNavigationFromString { |stringNum|
		if (stringNum < 1) {
			builder.navigationComplete = true;
			"‚úÖ Navigation complete.".postln;
			^this;
		};

		this.listenForNoteFromString(stringNum, { |fret|
			builder.navigateByFret(stringNum, fret);
			this.startNavigationFromString(stringNum - 1);
		});
	}

	listenForNoteFromString { |stringNum, callback|
		waitingForString = stringNum;
		navigationCallback = callback;
		("üéß Waiting for note on string " ++ stringNum).postln;
	}

	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"üéõ Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getDeviceSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " ‚Üí UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getDeviceSrcID(keyOrID);
			symbol = keyOrID;
		}{
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("‚ö†Ô∏è Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("‚ö†Ô∏è No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("üîó Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}

	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("‚ö†Ô∏è No handler bound for srcID: " + srcID).postln;
			}
		});
	}

} // end of MIDIInputManager class


// Define the UserDisplay class
TESTUserDisplay {
    var <stateBox, <queueBox, <lastCommandBox, <choicesBox;
    var window;

    *new {
        ^super.new.init;
    }

    init {
        window = Window("User Display", Rect(100, 100, 400, 300)).front;

        stateBox = StaticText(window, Rect(10, 10, 380, 20))
            .string_("State: empty");

        queueBox = StaticText(window, Rect(10, 40, 380, 20))
            .string_("Queue: []");

        lastCommandBox = StaticText(window, Rect(10, 70, 380, 20))
            .string_("Last Command: none");

        choicesBox = StaticText(window, Rect(10, 100, 380, 180))
            .string_("Choices:\n1: oscil\n2: pinknoise\n3: whitenoise");

        window.onClose_({ this.free });
    }

    display { |boxSymbol, message|
        switch(boxSymbol,
            \state, { stateBox.string_("State: " ++ message); },
            \queue, { queueBox.string_("Queue: " ++ message); },
            \lastCommand, { lastCommandBox.string_("Last Command: " ++ message); },
            \choices, { choicesBox.string_("Choices:\n" ++ message); },
            { "Unknown box symbol: %".format(boxSymbol).postln }
        );
    }

    free {
        window.close;
    }
}


// userFeedbackSystem.sc
// MD 20250806

// Used to display states of the system and such.

UserDisplay {

	var <>window;
	var <>modeText;
	var <>queueText;
	var <>lastCommandText;
	var <>userChoicesText;
	var <>statusText;

	*new{
		^super.new.init
	}

	init{
		"userFeedback created".postln;

		// create window
		window = Window("user display", Rect(10, 400, 800, 600));

		// create the fields:
		modeText = StaticText(window).string_("modeText");
		queueText = StaticText(window).string_("queueText");
		lastCommandText = StaticText(window).string_("lastCommandText");
		userChoicesText = StaticText(window).string_("userChoicesText");
		statusText = StaticText(window).string_(""); // choose appropriate position and size


		// add layouts to the window
		window.layout =
		VLayout(
			modeText,
			queueText,
			lastCommandText,
			userChoicesText,
			statusText
		);

		// bring window to front:
		window.front;
		^this // return instance of UserDisplay
	}

	updateTextField{
		|box, msg|
		switch (box,
			\state, { modeText.string_(msg)},
			\queue, { queueText.string_(msg)},
			\lastCommand, { lastCommandText.string_(msg)},
			\choices, { userChoicesText.string_(msg)}
		);

		postln("box:" + box);
		postln("msg:" + msg);
	}

	updateStatus { |text|
    ("üñ• Status update: " ++ text).postln;
    { this.statusText.string = text; }.defer; // assuming you have a GUI element called statusText
}


} //end of class// Verbosity.sc
// MD 20250819

// used to manage verbosity levels of my debugging messages

// Verbosity Levels:
// 0 ‚Üí Errors only
// 1 ‚Üí Actions
// 2 ‚Üí Input/Output
// 3 ‚Üí Object and type reporting
// 4 ‚Üí Full debug (everything)






// Verbosity.sc
Verbosity {
    classvar <level = 2; // Default level

	*help {
    "Verbosity Levels:".postln;
    "0 ‚Üí Errors only".postln;
    "1 ‚Üí Actions".postln;
    "2 ‚Üí Input/Output".postln;
    "3 ‚Üí Object and type reporting".postln;
    "4 ‚Üí Full debug (everything)".postln;
}


    *setLevel { |newLevel|
        level = newLevel;
        ("üîß Verbosity level set to: " ++ level).postln;
    }

    *shouldPost { |requiredLevel|
        ^level >= requiredLevel;
    }

    *postIf { |requiredLevel, msg|
        if (level >= requiredLevel) {
            msg.postln;
        };
    }
}
