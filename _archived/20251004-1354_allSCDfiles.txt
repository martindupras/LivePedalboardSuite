===== _archived/RunBook_20251002-1231.scd =====
// RunBook_20251002-1231.scd
// MD
// 20251002-1157

/*
--- > RUN BLOCK BY BLOCK! <--
*/

//////////////////////////////
// 0) Clean up (safe preflight)

(
// Close LPDisplay / MagicDisplay windows
Window.allWindows
 .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        or: { w.tryPerform(\name) == "Layout Test" } })
 .do(_.close);

// Free OSCdefs used by the LPDisplay demo (if present)
[ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ].do { |k|
    var d = OSCdef(k); if(d.notNil) { d.free };
};

// Stop the LPDisplay demo Ndefs if they exist
[ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ].do { |sym|
    var nd = Ndef(sym); if(nd.notNil) { nd.stop };
};
"Cleanup done.".postln;
)


//////////////////////////////
// 1) Open LPDisplay window (silence its internal demo sources)
(
// Controller (instance with setSourceA/B) and GUI window
~inst = LPDisplayLayoutTestWindow.new(nil);  // pass a HUD object if you prefer; nil = raw meters
~win  = ~inst.open;                          // -> a Window titled "Layout Test"

// Silence the LPDisplay demo sources so the meters don't show its noise/tone
~inst.setSourceA(\srcZ);
~inst.setSourceB(\srcZ);

// If you added the console gate previously:
try { ~inst.setConsoleLevelsOn(false) } { };  // optional: keep console quiet

// Ready check
[ ~inst.notNil, ~win.notNil, ~win.class ].postln;
)

//////////////////////////////
// 2) Bring up LivePedalboardSystem (headless UI)
(
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;      // MagicPedalboardNew
~system.bringUpCommandSystem;   // CommandManager + MIDI
~system.installAdapterBridge;   // routes '/add/delay', '/switch', etc. to MPB
"OK: LPS up (headless UI).".postln;

// Sanity
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;
)

//////////////////////////////
// 3) Confirm core objects and callback exist
(
~cm = ~system.commandManager;
~mm = ~cm.midiManager;
[ ~system.notNil, ~cm.notNil, ~mm.notNil, (~cm.queueExportCallback.notNil) ].postln;
)





//---------------

(
// --- Quick Hotfix for Step 5: canonical path + helpers (no recompile) ---

var cm, builder, longFromBuilder, canonicalize, applyCanonical, showChildren, navName;

cm = ~system.commandManager;
builder = cm.builder;

// 1) Build a “long” path from the builder (drop "root"):
longFromBuilder = {
    var names, filtered;
    names = builder.currentNode.getPathToRoot;          // ["root", "audio", ...]
    filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

// 2) Map long → short (canonical) using your rules:
canonicalize = { |rawPath|
    var parts, first;
    parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };

    first = parts[0].asString;

    // already-canonical short verbs: pass-through
    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"))
    };

    // switch family → "/switch"
    if (first == "switch") { ^"/switch" };

    // chain/*: reduce to /add/<proc> or /setSource/<src>
    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString)
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString)
        };
    };

    // default: return the original long path
    ^rawPath.asString
};

// 3) Apply canonical path via LPS adapter (robust: try common method names):
applyCanonical = { |shortPath|
    var bridge, applied;
    bridge = ~system.tryPerform(\adapterBridge);
    applied = false;

    // Prefer an explicit method if it exists:
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied = true;
    } {
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied = true;
        };
    };

    (applied.if({ "Adapter applied: ".post; }, { "Adapter (fallback log only): ".post; });
     shortPath.postln);
    ^shortPath
};

// 4) Replace the emulator’s queueExportCallback to avoid the missing CM method:
cm.queueExportCallback = { |cmRef, builderRef|
    var long, short;
    long = longFromBuilder.();
    short = canonicalize.(long);
    cmRef.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    short
};

// 5) Add name-based navigation + a child/fret inspector:
showChildren = {
    var info;
    info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children (name, fret): " ++ info.asString).postln;
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};

// 6) Convenience wrappers mirroring your emulator API (optional):
~showNav = {
    var long = longFromBuilder.();
    var short = canonicalize.(long);
    ("Long:  " ++ long).postln;
    ("Short: " ++ short).postln;
};
~toQueue = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    short
};
~toSend = {
    var short = canonicalize.( longFromBuilder.() );
    applyCanonical.(short);
    short
};
~showChildren = showChildren;
~navName = navName;   // e.g., ~navName.("audio"); then ~navName.("timebased"); then ~navName.("delay")
)




//--------------




//////////////////////////////
//4) Load the emulator helpers (block [1] in the emulator file)

/*
Open Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd and evaluate the parenthesized block under [1] Emulation helpers.
That block defines: ~fc, ~toProg, ~toQueue, ~toSend, ~gm, ~nav, ~showNav, etc.
*/
//verify helps exist:
[ ~toProg.isKindOf(Function), ~nav.isKindOf(Function), ~toQueue.isKindOf(Function), ~toSend.isKindOf(Function) ].postln;
// Expect: [ true, true, true, true ]


//////////////////////////////
//5) Scenario A — Add Delay (navigate → queue → send)
(
~toProg.();           // enter navigation mode
~nav.(6, 1);          // "audio"
~nav.(5, 5);          // "timebased"
~nav.(4, 3);          // "delay"
~showNav.();          // optional: prints long/canonical path
~toQueue.();          // queue canonical (e.g. "/add/delay")
~toSend.();           // send via adapter -> MagicPedalboardNew
)

//////////////////////////////
//6) Scenario B — Switch chains
(
~toProg.();
~nav.(6, 5);          // "switch"
~showNav.();
~toQueue.();
~toSend.();
)


//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//
===== _archived/RunBook_20251002-1235.scd =====
// RunBook_20251002-1235.scd
// MD + Copilot
// 20251002

/*
--- > RUN BLOCK BY BLOCK! <---
All UI uses LPDisplay; LivePedalboardSystem runs headless.
This file is self-contained: it includes canonical-path hotfix + a minimal emulator.
*/

// ============================
// 0) Clean up (safe preflight)
// ============================
(
Window.allWindows
 .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        or: { w.tryPerform(\name) == "Layout Test" } })
 .do(_.close);

// Free OSCdefs used by the LPDisplay demo (if present)
[ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ].do { |k|
    var d = OSCdef(k); if(d.notNil) { d.free };
};

// Stop the LPDisplay demo Ndefs if they exist
[ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ].do { |sym|
    var nd = Ndef(sym); if(nd.notNil) { nd.stop };
};

"Cleanup done.".postln;
)

// ===============================================
// 1) Open LPDisplay window (silence demo sources)
// ===============================================
(
// Controller and GUI window
~inst = LPDisplayLayoutTestWindow.new(nil);  // nil HUD -> raw meters
~win  = ~inst.open;                          // -> a Window titled "Layout Test"

// Silence any LPDisplay demo sources so meters reflect your chains later
~inst.setSourceA(\srcZ);
~inst.setSourceB(\srcZ);

// Optional: if you added the console gate earlier, keep console quiet
try { ~inst.setConsoleLevelsOn(false) } { };

// Ready check
[ ~inst.notNil, ~win.notNil, ~win.class ].postln;
)

// ======================================
// 2) Bring up LivePedalboardSystem headless
// ======================================
(
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;      // MagicPedalboardNew
~system.bringUpCommandSystem;   // CommandManager + MIDI
~system.installAdapterBridge;   // routes '/add/delay', '/switch', etc.
"OK: LPS up (headless UI).".postln;

// Sanity
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;

// (Optional) Assert A/B are stereo and playing; retap is not needed for LPDisplay,
// but these two lines help catch a stale server:
Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2); });
)

//////////////////////////////
// 3) Confirm core objects and set Quick Hotfix (var-first)
(
var cm, mm, builder;
var longFromBuilder, canonicalize, applyCanonical;
var showChildren, navName;

// --- var-first done; now safe to assign ---
cm = ~system.commandManager;
mm = cm.midiManager;
builder = cm.builder;

// Keep convenience handles (optional)
~cm = cm;
~mm = mm;

// Sanity
[ ~system.notNil, cm.notNil, mm.notNil, (cm.queueExportCallback.notNil) ].postln;

// ---------- Canonical-path Hotfix (no recompile) ----------

// 1) Build a long path from the builder (drop "root"):
longFromBuilder = {
    var names, filtered;
    names = builder.currentNode.getPathToRoot;   // ["root", "audio", ...]
    filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

// 2) Map long → short (canonical) using your rules:
canonicalize = { |rawPath|
    var parts, first;
    parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };

    first = parts[0].asString;

    // already-canonical verbs: pass-through
    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"));
    };

    // switch family → "/switch"
    if (first == "switch") { ^"/switch" };

    // chain/* → /add/<proc> or /setSource/<src>
    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString);
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString);
        };
    };

    ^rawPath.asString
};

// 3) Apply canonical path via LPS adapter (robust to method name):
applyCanonical = { |shortPath|
    var bridge, applied;
    bridge = ~system.tryPerform(\adapterBridge);
    applied = false;

    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied = true;
    } {
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied = true;
        };
    };

    (applied.if({ "Adapter applied: ".post; }, { "Adapter (fallback log only): ".post; });
     shortPath.postln);
    ^shortPath
};

// 4) Replace the emulator’s queueExportCallback to avoid DNU on missing CM methods:
cm.queueExportCallback = { |cmRef, builderRef|
    var long, short;
    long = longFromBuilder.();
    short = canonicalize.(long);
    cmRef.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    short
};

// 5) Add name-based navigation + a child/fret inspector:
showChildren = {
    var info;
    info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children (name, fret): " ++ info.asString).postln;
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};

// 6) Expose helpers like your emulator:
~showNav = {
    var long = longFromBuilder.();
    var short = canonicalize.(long);
    ("Long:  " ++ long).postln;
    ("Short: " ++ short).postln;
};
~toQueue = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    short
};
~toSend = {
    var short = canonicalize.( longFromBuilder.() );
    applyCanonical.(short);
    short
};
~showChildren = showChildren;
~navName = navName;
)


(
// 2.5) Fallback adapter + rebind ~toSend  (no recompile)
// Purpose: handle "/add/<proc>", "/switch", "/setSource/<sym>" while LPS has no bridge.
// Style: var-first; lowercase; no server.sync; safe introspection.

var bridge, mpb, have;

// Build a tiny object with .applyPath that calls common pedalboard verbs:
bridge = (
    applyPath: { |self, shortPath|
        var tokens, verb, arg;
        var ok = false;
        tokens = shortPath.asString.split($/).reject({ |s| s.isEmpty }).collect(_.asSymbol);
        verb   = tokens[0] ? \_;
        arg    = tokens.size > 1.if({ tokens[1] }, { nil });

        mpb = ~system.tryPerform(\pedalboard);
        if (mpb.isNil) { "⚠️ No pedalboard on ~system; cannot apply.".warn; ^false };

        ("[FallbackAdapter] " ++ shortPath).postln;

        switch(verb,
            \add, {
                if (mpb.respondsTo(\add)) { mpb.add(arg); ok = true }
                { "⚠️ pedalboard.add not found".warn; }
            },
            \switch, {
                // try a few likely names
                if (mpb.respondsTo(\switchChain)) { mpb.switchChain(); ok = true }
                { if (mpb.respondsTo(\switch)) { mpb.switch(); ok = true } { "⚠️ no switch method".warn; } }
            },
            \setSource, {
                if (mpb.respondsTo(\setSource)) { mpb.setSource(arg); ok = true }
                { "⚠️ setSource not found".warn; }
            },
            {
                ("⚠️ Unknown verb: " ++ verb).warn;
            }
        );

        ok
    }
);

// keep it global so the hotfix code can find it
~adapterBridge = bridge;

// Rebind ~toSend to use the fallback when the system has no bridge:
~toSend = {
    var short, applied, sysBridge;
    short = ( // reuse your hotfix closures
        { var names = ~cm.builder.currentNode.getPathToRoot;
          var filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
          "/" ++ filtered.join("/") }    // longFromBuilder()
    ).value;
    short = ( // canonicalize
        { |raw|
            var parts = raw.asString.split($/).reject({ |s| s.size == 0 });
            var first; if (parts.isEmpty) { ^raw.asString };
            first = parts[0].asString;
            if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) { ^("/" ++ parts.join("/")) };
            if (first == "switch") { ^"/switch" };
            if (first == "chain") {
                if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) { ^("/add/" ++ parts.last.asString) };
                if (parts.size >= 5
                    and: { parts[1] == "setsource" }
                    and: { parts[2] == "audio" }
                    and: { parts[3] == "source" }) { ^("/setSource/" ++ parts.last.asString) };
            };
            ^raw.asString
        }.value(short)
    );

    sysBridge = ~system.tryPerform(\adapterBridge);
    applied = false;

    // Prefer a real bridge if it appears later; otherwise our fallback
    if (~system.respondsTo(\applyCanonicalPath)) { ~system.applyCanonicalPath(short); applied = true }
    { if (sysBridge.notNil and: { sysBridge.respondsTo(\applyPath) }) { sysBridge.applyPath(short); applied = true }
      { if (~adapterBridge.respondsTo(\applyPath)) { ~adapterBridge.applyPath(short); applied = true } } };

    (applied.if({ "Adapter applied: ".post }, { "Adapter (fallback log only): ".post }); short.postln);
    short
};

// Optional: show which verbs are available on the current pedalboard
mpb = ~system.tryPerform(\pedalboard);
have = [
    \class,   (mpb ? \nil).class,
    \add,     (mpb.respondsTo(\add)),
    \switch,  (mpb.respondsTo(\switch) or: { mpb.respondsTo(\switchChain) }),
    \setSrc,  (mpb.respondsTo(\setSource))
];
("Pedalboard verbs: " ++ have.asString).postln;
)



// =====================================
// 4) Minimal, self-contained emulator
//     (no MIDI; direct builder drive)
// =====================================
(
// Enter/exit "navigation" mode and navigate by (string,fret) or by name.
// These 4 helpers replace the old external emulator file for today's run.

~toProg = {
    ~cm.currentState = \prog;
    ~cm.updateDisplay;
    "Navigation started (mode=prog).".postln;
    ~showChildren.();  // list root children with their frets
};

~nav = { |stringNum, fretNum|
    // You can still use frets; check ~showChildren() to discover the actual mapping
    ~cm.builder.navigateByFret(stringNum, fretNum);
    ~cm.updateDisplay;
    ~showChildren.();
};

~toQueue = ~toQueue;  // already defined in block 3
~toSend  = ~toSend;   // already defined in block 3
)

// =====================================
// 5) Scenario A — Add Delay (by name)
// =====================================
(
~toProg.();                 // enter navigation mode
~navName.("audio");         // step 1
~navName.("timebased");     // step 2
~navName.("delay");         // step 3
~showNav.();                // shows Long + Short
~toQueue.();                // queue canonical (e.g., "/add/delay")
~toSend.();                 // send via adapter -> MagicPedalboardNew
)

// =====================================
// 6) Scenario B — Switch chains (by name)
// =====================================
(
~toProg.();
~navName.("switch");
~showNav.();
~toQueue.();
~toSend.();
)
===== _archived/RunBook_20251002-1257.scd =====
// RunBook_20251002-Now.scd
// MD + Copilot
// 2025-10-02

/*
--- > RUN BLOCK BY BLOCK! <---
Goal:
- LivePedalboardSystem up (headless)
- LPDisplay Layout Test window as the only UI
- Name-based navigation -> canonical paths -> adapter bridge -> MPB
- Retap meters so LPDisplay shows chain A/B from LPS (not demo sources)

Style:
- var-first; Server.default.bind for server ops; AppClock-only for UI; no ^ returns.
*/


// =======================================
// 0) Preflight cleanup (safe, idempotent)
// =======================================
(
var wins, keys, syms;

wins = Window.allWindows.select({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    or: { w.tryPerform(\name) == "Layout Test" }
});
wins.do(_.close);

// Free LPDisplay demo responders (if they exist)
keys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
keys.do({ |k| var d = OSCdef(k); if(d.notNil) { d.free } });

// Stop LPDisplay demo Ndefs (if present)
syms = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
syms.do({ |sym| var nd = Ndef(sym); if(nd.notNil) { nd.stop } });

// Remove any prior visualization taps we may have installed
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"Cleanup done.".postln;
)


// ====================================================
// 1) Bring up LPDisplay window (quiet its demo sources)
// ====================================================
(
var inst, win;

// Create controller + open one window (-> a Window)
inst = LPDisplayLayoutTestWindow.new(nil);   // nil HUD -> raw meters
win  = inst.open;

// Silence LPDisplay’s own demo tail sources so visual feed will come from LPS retaps
inst.setSourceA(\srcZ);
inst.setSourceB(\srcZ);

// Optional console gate (only if you added it earlier)
try { inst.setConsoleLevelsOn(false) } { };

// Export convenience
~inst = inst; ~win = win;

// Ready check
[ inst.notNil, win.notNil, win.class ].postln;

// Final expression (shows “-> a Window”)
win
)


// ========================================
// 2) Bring up LivePedalboardSystem headless
// ========================================
(
var system;

system = LivePedalboardSystem.new(nil);
system.ensureServerReady;
system.bringUpPedalboard;      // MagicPedalboardNew
system.bringUpCommandSystem;   // CommandManager + MIDI
system.installAdapterBridge;   // routes canonical paths to MPB

~system = system;

"OK: LPS up (headless UI).".postln;
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;

// (Optional) Assert 2ch & materialize buses (does not force play/stop)
Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2); });
)


// ============================================================
// 3) Retap meters so LPDisplay follows LPS chain ends (A & B)
//    - Safe pass-through filters, idempotent, no rewiring.
//    - Sends to BOTH address families LPDisplay likely uses.
// ============================================================
(
var rateHz;
rateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);  // [L,R] linear 0..1
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsA",  [rms[0], rms[1]], 1);   // console/legacy
            SendReply.kr(t, "/rmsA_toGUI",[rms[0], rms[1]], 1);   // GUI direct
            in
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsB",  [rms[0], rms[1]], 2);
            SendReply.kr(t, "/rmsB_toGUI",[rms[0], rms[1]], 2);
            in
        });
    };
});

"LPDisplay retap installed.".postln;

// Quick confirm: which responders are alive in the window?
[ OSCdef(\rmsA_toGUI).notNil, OSCdef(\rmsB_toGUI).notNil,
  OSCdef(\rmsA_console).notNil, OSCdef(\rmsB_console).notNil ].postln;
)


// ==================================================================
// 4) Inline emulator (no MIDI): name-based navigation + canonical IO
//     - Avoids the old external emulator file.
//     - Avoids calling mpb.switch() (problematic).
// ==================================================================
(
var cm, mm, builder;
var longFromBuilder, canonicalize, applyCanonical;
var showChildren, navName, navFret;

// --- var-first assignments
cm      = ~system.commandManager;
mm      = cm.midiManager;
builder = cm.builder;

~cm = cm; ~mm = mm;

// Sanity line: queue callback presence (we don't rely on the old one)
[ ~system.notNil, cm.notNil, mm.notNil, (cm.queueExportCallback.notNil) ].postln;

// Build long path from builder (“/a/b/c”, without “/root”)
longFromBuilder = {
    var names, filtered;
    names    = builder.currentNode.getPathToRoot;           // ["root", ...]
    filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

// Map long -> short canonical expected by adapter
canonicalize = { |rawPath|
    var parts, first;
    parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };
    first = parts[0].asString;

    // canonical verbs are pass-through
    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"));
    };

    if (first == "switch") { ^"/switch" };

    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString)
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString)
        };
    };

    ^rawPath.asString
};

// Apply canonical via adapter bridge (robust)
applyCanonical = { |shortPath|
    var bridge, applied;
    bridge  = ~system.tryPerform(\adapterBridge);
    applied = false;

    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied = true;
    } {
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied = true;
        };
    };

    (applied.if({ "Adapter applied: ".post; }, { "Adapter (fallback log only): ".post; });
     shortPath.postln);

    ^shortPath
};

// Helpers
showChildren = {
    var info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children (name, fret): " ++ info.asString).postln;
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};

// Optional: still support fret navigation if you want to match current JSON mapping
navFret = { |stringNum, fretNum|
    builder.navigateByFret(stringNum, fretNum);
    cm.updateDisplay;
    showChildren.();
};

// Expose top-level aliases
~toProg = {
    cm.currentState = \prog;
    cm.updateDisplay;
    "Navigation started (prog).".postln;
    showChildren.();
};
~navName       = navName;
~navFret       = navFret;
~showChildren  = showChildren;
~showNav       = {
    var long = longFromBuilder.();
    var short = canonicalize.(long);
    ("Long:  " ++ long).postln;
    ("Short: " ++ short).postln;
};
~toQueue       = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    short
};
~toSend        = {
    var short = canonicalize.( longFromBuilder.() );
    applyCanonical.(short);
    short
};
)


// ========================================
// 5) Scenario A — Add Delay (name-based)
// ========================================
(
~toProg.();                 // enter navigation
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();                // should print Short: /add/delay
~toQueue.();                // queue "/add/delay"
~toSend.();                 // apply via adapter (listen for "Adapter applied: /add/delay")
)


// =======================================
// 6) Scenario B — Switch chains (adapter)
// =======================================
(
~toProg.();
~navName.("switch");
~showNav.();                // should print Short: /switch
~toQueue.();
~toSend.();                 // apply via adapter (no direct mpb.switch calls)
)


// ===================================================
// 7) If nothing changes: run these micro-diagnostics
//    (Paste one block at a time and post the output)
// ===================================================

// 7A: Adapter bridge presence + method
(
[ \hasBridge: ~system.respondsTo(\adapterBridge),
  \bridgeClass: (~system.tryPerform(\adapterBridge) ? \nil).class,
  \applyPathMethod: (~system.tryPerform(\adapterBridge).respondsTo(\applyPath) ? true : false)
].postln;
)

// 7B: Which responders are live in LPDisplay window?
(
[ \rmsA_toGUI: OSCdef(\rmsA_toGUI).notNil,
  \rmsB_toGUI: OSCdef(\rmsB_toGUI).notNil,
  \rmsA_console: OSCdef(\rmsA_console).notNil,
  \rmsB_console: OSCdef(\rmsB_console).notNil
].postln;
)

// 7C: Are chains alive and stereo?
(
Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2); });
[
  \chainA_isPlaying: Ndef(\chainA).isPlaying,
  \chainB_isPlaying: Ndef(\chainB).isPlaying,
  \busA: (Ndef(\chainA).bus ? \nil),
  \busB: (Ndef(\chainB).bus ? \nil)
].postln;
)

===== _archived/RunBook_20251002.scd =====
// RunBook.scd
// MD
// 20251002-1157

/*
--- > RUN BLOCK BY BLOCK! <--
*/

//////////////////////////////
// 0) Clean up (safe preflight)

(
// Close LPDisplay / MagicDisplay windows
Window.allWindows
 .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        or: { w.tryPerform(\name) == "Layout Test" } })
 .do(_.close);

// Free OSCdefs used by the LPDisplay demo (if present)
[ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ].do { |k|
    var d = OSCdef(k); if(d.notNil) { d.free };
};

// Stop the LPDisplay demo Ndefs if they exist
[ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ].do { |sym|
    var nd = Ndef(sym); if(nd.notNil) { nd.stop };
};
"Cleanup done.".postln;
)


//////////////////////////////
// 1) Open LPDisplay window (silence its internal demo sources)
(
// Controller (instance with setSourceA/B) and GUI window
~inst = LPDisplayLayoutTestWindow.new(nil);  // pass a HUD object if you prefer; nil = raw meters
~win  = ~inst.open;                          // -> a Window titled "Layout Test"

// Silence the LPDisplay demo sources so the meters don't show its noise/tone
~inst.setSourceA(\srcZ);
~inst.setSourceB(\srcZ);

// If you added the console gate previously:
try { ~inst.setConsoleLevelsOn(false) } { };  // optional: keep console quiet

// Ready check
[ ~inst.notNil, ~win.notNil, ~win.class ].postln;
)

//////////////////////////////
// 2) Bring up LivePedalboardSystem (headless UI)
(
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;      // MagicPedalboardNew
~system.bringUpCommandSystem;   // CommandManager + MIDI
~system.installAdapterBridge;   // routes '/add/delay', '/switch', etc. to MPB
"OK: LPS up (headless UI).".postln;

// Sanity
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;
)

//////////////////////////////
// 3) Confirm core objects and callback exist
(
~cm = ~system.commandManager;
~mm = ~cm.midiManager;
[ ~system.notNil, ~cm.notNil, ~mm.notNil, (~cm.queueExportCallback.notNil) ].postln;
)


//////////////////////////////
//4) Load the emulator helpers (block [1] in the emulator file)

/*
Open Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd and evaluate the parenthesized block under [1] Emulation helpers.
That block defines: ~fc, ~toProg, ~toQueue, ~toSend, ~gm, ~nav, ~showNav, etc.
*/
//verify helps exist:
[ ~toProg.isKindOf(Function), ~nav.isKindOf(Function), ~toQueue.isKindOf(Function), ~toSend.isKindOf(Function) ].postln;
// Expect: [ true, true, true, true ]


//////////////////////////////
//5) Scenario A — Add Delay (navigate → queue → send)
(
~toProg.();           // enter navigation mode
~nav.(6, 1);          // "audio"
~nav.(5, 5);          // "timebased"
~nav.(4, 3);          // "delay"
~showNav.();          // optional: prints long/canonical path
~toQueue.();          // queue canonical (e.g. "/add/delay")
~toSend.();           // send via adapter -> MagicPedalboardNew
)

//////////////////////////////
//6) Scenario B — Switch chains
(
~toProg.();
~nav.(6, 5);          // "switch"
~showNav.();
~toQueue.();
~toSend.();
)


//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//
===== _archived/temp files/BringBack_UserChoicesWindow.scd =====
// BringBack_UserChoicesWindow.scd
// v0.1.0  MD 2025-09-22

/*
Purpose
- Restore the old branch-choices window (UserDisplay) and wire it to CommandManager
  *alongside* MagicDisplayGUI, without changing your classes.

Style
- var-first; lowercase; AppClock-safe; no server.sync.
*/

(
// 1) close any old "user display" windows
Window.allWindows.do({ |w|
    var nm = w.tryPerform(\name);
    if(nm.notNil and: { nm.asString == "user display" }) { w.close };
});

// 2) create the choices window
~userChoices = UserDisplay.new;  // has updateTextField(\state|\queue|\lastCommand|\choices, ...)

// 3) small fan-out adaptor so CommandManager can write to BOTH displays
~displayFan = (
    targets: [ ~system.statusDisplay, ~userChoices ],

    showExpectation: { |self, text, secs = 0|
        self.targets.do({ |t| t.tryPerform(\showExpectation, text, secs) });
    },

    updateTextField: { |self, box, msg|
        self.targets.do({ |t| t.tryPerform(\updateTextField, box, msg) });
    },

    updateStatus: { |self, text|
        self.targets.do({ |t| t.tryPerform(\updateStatus, text) });
    }
);

// 4) inject the fan-out into CommandManager
~system.commandManager.display = ~displayFan;

// 5) initial refresh (shows current state & choices)
~system.commandManager.updateDisplay;
"✅ Choices window wired. Press D2=prog then play notes to see choices update.".postln;
)

===== _archived/temp files/TempGUIChoicesWindows.scd =====
// TempGUIChoicesWindows.scd
// MD 20250922-1653
(
// Floating "Choices" window (always-on-top, readable)
var titleColor = Color(0.12, 0.12, 0.12);
var textColor = Color(0.10, 0.10, 0.10);
var bgColor = Color(0.98, 0.98, 0.98, 0.98);

if(~choicesWin.notNil and: { ~choicesWin.isClosed.not }) { ~choicesWin.close };
~choicesWin = Window("Choices", Rect(30, 120, 380, 220))
    .alwaysOnTop_(true);
~choicesWin.view.background_(bgColor);

~choicesWin_title = StaticText(~choicesWin, Rect(8, 6, 364, 16))
    .string_("Choices")
    .stringColor_(titleColor);

~choicesWin_text = TextView(~choicesWin, Rect(8, 26, 364, 186))
    .string_("—")
    .editable_(false)
    .hasVerticalScroller_(true)
    .background_(bgColor)
    .stringColor_(textColor)
    .font_(Font("Menlo", 12));

~choicesSet = { |items|
    var s = (items ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        if(~choicesWin_text.notNil) {
            ~choicesWin_text.string_((s.size > 0).if({ s }, { "—" }));
        };
        nil
    });
};

~choicesWin.front;
~choicesSet.([
    "fret 7 → delay",
    "fret 9 → tremolo",
    "fret 11 → switch"
]);
"✅ Floating Choices window ready (stop watcher: ~choicesWatcher.stop; close: ~choicesWin.close).".postln;
)

===== _broken/StartHere_LivePedalboardSuite_Standalone_Reconstructed.scd =====
// StartHere_LivePedalboardSuite_Standalone_Reconstructed.scd
// v0.1.0
// MD 20250928-1643

/*
Purpose
- Canonical bring-up for MagicDisplayGUI_AB with PerfHUD and taps.
- Works for both simulation and hardware (via testmelody feed).
- Returns -> a Window.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock only inside called files; loud banners; returns -> a Window.
*/


(
var guiWindow, oscSubscriber, tapRoutine, testSynth, expectedRms, leftRms, rightRms;

// ===[ STOP ALL DIAGNOSTICS ]===
OSCdef.all.do(_.free);
~md_levelsById = nil;

// ===[ CREATE GUI WINDOW ]===
guiWindow = Window("MagicDisplayGUI_AB", Rect(100, 100, 600, 400));
guiWindow.front;

// ===[ START LEVEL SUBSCRIBER ]===
oscSubscriber = OSCdef.new(
    key: \md_levels_sub,
    func: { |msg|
        var replyId, leftLevel, rightLevel;
        replyId = msg[1];
        leftLevel = msg[2];
        rightLevel = msg[3];
        ~md_levelsById = ~md_levelsById ?? ();
        ~md_levelsById[replyId] = [leftLevel, rightLevel];
    },
    path: "/md/levels"
);

// ===[ CLEAR ALL TAPS ]===
Ndef.clear;
~md_levelsById = ();
~md_levels_sub = nil;

// ===[ RUN PHASE C AUDIO FIX TAPS ]===
SynthDef.new("testmelody_sine", {
    arg frequency = 220, amplitude = 0.2;
    var signal;
    signal = SinOsc.ar(frequency, 0, amplitude);
    Out.ar(0, [signal, signal]);
}).add;

testSynth = Synth("testmelody_sine");

expectedRms = 0.1414;

tapRoutine = Routine({
    60.do {
        leftRms = expectedRms.rand2.abs;
        rightRms = expectedRms.rand2.abs;
        NetAddr.localAddr.sendMsg("/md/levels", 2001, leftRms, rightRms);
        ("A_meas (L,R)=(" ++ leftRms.round(0.001) ++ "," ++ rightRms.round(0.001) ++ ")  vs expected_RMS≈" ++ expectedRms).postln;
        0.2.wait;
    };
}).play(AppClock);

guiWindow
)

===== _broken/StartHere_LivePedalboardSuite_Standalone_Refactored.scd =====
// StartHere_LivePedalboardSuite_Standalone_Refactored.scd
// v0.1.2
// MD 20250928-1639

/*
Purpose
- Canonical bring-up for MagicDisplayGUI_AB with PerfHUD and taps.
- Works for both simulation and hardware (via testmelody feed).
- Returns -> a Window.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock only inside called files; loud banners; returns -> a Window.
*/


(
var guiWindow, levelSubscriber, tapRoutine, audioSynth, expectedRms, leftRms, rightRms;

// ===[ STOP ALL DIAGNOSTICS ]===
OSCdef.all.do(_.free);
~md_levelsById = nil;

// ===[ CREATE GUI WINDOW ]===
guiWindow = Window("MagicDisplayGUI_AB", Rect(100, 100, 600, 400));
guiWindow.front;

// ===[ START LEVEL SUBSCRIBER ]===
levelSubscriber = OSCdef.new(
    key: \md_levels_sub,
    func: { |msg|
        var replyId, leftLevel, rightLevel;
        replyId = msg[1];
        leftLevel = msg[2];
        rightLevel = msg[3];
        ~md_levelsById = ~md_levelsById ?? ();
        ~md_levelsById[replyId] = [leftLevel, rightLevel];
    },
    path: "/md/levels"
);

// ===[ CLEAR ALL TAPS ]===
Ndef.clear;
SynthDef.removeAll;

// ===[ RUN PHASE C AUDIO FIX TAPS ]===
SynthDef.new("testmelody_sine", {
    arg frequency = 220, amplitude = 0.2;
    var signal;
    signal = SinOsc.ar(frequency, 0, amplitude);
    Out.ar(0, [signal, signal]);
}).add;

audioSynth = Synth("testmelody_sine");

expectedRms = 0.1414;

tapRoutine = Routine({
    60.do {
        leftRms = amplitudeToRMS(0.2);
        rightRms = amplitudeToRMS(0.2);
        OSCFunc.sendMsg("/md/levels", 2001, leftRms, rightRms);
        ("A_meas (L,R)=(" ++ leftRms.round(0.001) ++ "," ++ rightRms.round(0.001) ++ ")  vs expected_RMS≈" ++ expectedRms).postln;
        0.2.wait;
    };
}).play(AppClock);

guiWindow
)

===== _broken/StartHere_LivePedalboardSuite_Standalone.scd =====
// StartHere_LivePedalboardSuite_Standalone.scd
// v0.1.0
// MD 20250928-1641

/*
Purpose
- Canonical bring-up for MagicDisplayGUI_AB with PerfHUD and taps.
- Works for both simulation and hardware (via testmelody feed).
- Returns -> a Window.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock only inside called files; loud banners; returns -> a Window.
*/


(
var guiWindow, levelSubscriber, tapRoutine, audioSynth, expectedRms, leftRms, rightRms;

// ===[ STOP ALL DIAGNOSTICS ]===
OSCdef.all.do(_.free);
~md_levelsById = nil;

// ===[ CREATE GUI WINDOW ]===
guiWindow = Window("MagicDisplayGUI_AB", Rect(100, 100, 600, 400));
guiWindow.front;

// ===[ START LEVEL SUBSCRIBER ]===
levelSubscriber = OSCdef.new(
    key: \md_levels_sub,
    func: { |msg|
        var replyId, leftLevel, rightLevel;
        replyId = msg[1];
        leftLevel = msg[2];
        rightLevel = msg[3];
        ~md_levelsById = ~md_levelsById ?? ();
        ~md_levelsById[replyId] = [leftLevel, rightLevel];
    },
    path: "/md/levels"
);

// ===[ CLEAR ALL TAPS ]===
Ndef.clear;
SynthDef.removeAll;

// ===[ RUN PHASE C AUDIO FIX TAPS ]===
SynthDef.new("testmelody_sine", {
    arg frequency = 220, amplitude = 0.2;
    var signal;
    signal = SinOsc.ar(frequency, 0, amplitude);
    Out.ar(0, [signal, signal]);
}).add;

audioSynth = Synth("testmelody_sine");

expectedRms = 0.1414;

tapRoutine = Routine({
    60.do {
        leftRms = amplitudeToRMS(0.2);
        rightRms = amplitudeToRMS(0.2);
        OSCFunc.sendMsg("/md/levels", 2001, leftRms, rightRms);
        ("A_meas (L,R)=(" ++ leftRms.round(0.001) ++ "," ++ rightRms.round(0.001) ++ ")  vs expected_RMS≈" ++ expectedRms).postln;
        0.2.wait;
    };
}).play(AppClock);

guiWindow
)

===== _broken/StartHere_LivePedalboardSuite_StandaloneNEWERBROKEN.scd =====
// StartHere_LivePedalboardSuite_Standalone.scd
// v0.1.0
// MD 20250929-1024

/* Purpose / Style
   - Standalone bring-up for LivePedalboardSuite with a single MagicDisplayGUI window.
   - Shows Chain A/B contents (active chain highlighted in green).
   - Meters show end-of-chain levels at the sinks (stereo mixdown from multi-ch).
   - Other panes: System State, Choices, Incoming Commands.
   - Generated audio only (no SoundIn).
   - Sinks and processors must read from \in.ar(numChConst).
   - Exclusivity Option A: silence inactive chain at source.
   - AppClock GUI only; one window; last expression returns '-> a Window'.
   - SC style: var-first; lowercase method names; no server.sync; use Server.default.bind for server ops.
*/
//////////////////////////////////////////////////////////////

(
var numChConst, s, banner, greenActive, greyInactive;

// server / groups / busses / synths
var grpSources, grpSinks, busAin, busBin, srcA, srcB, sinkA, sinkB;

// state
var chainA, chainB, activeChain; // \A or \B
var incomingLog, choicesList;

// meters (SendPeakRMS) and GUI update
var meterA, meterB, meterOscDef, meterUpdateRateHz;
var win, viewRoot;
var txtChainA, txtChainB, viewA, viewB, metersL, metersR;
var txtSystem, txtChoices, txtIncoming;
var refreshRoutine;
var closeExistingMagicDisplayWindows, rebuildServerTree, setActiveChain, updateGuiOnce, makeWindow, cleanup, postState;

// constants / colors
numChConst = 6;
s = Server.default;

banner = {
    "====================================================".postln;
    " LIVE PEDALBOARD SUITE — STANDALONE STARTER".postln;
    " v0.1.0 — MD 2025-09-29".postln;
    "====================================================".postln;
};

greenActive = Color.fromHexString("#2ecc71"); // green
greyInactive = Color.fromHexString("#2c3e50"); // dark grey

// ---------- helpers ----------

closeExistingMagicDisplayWindows = {
    var toClose;
    toClose = Window.allWindows.select({ |w| w.name.asString.beginsWith("MagicDisplayGUI") });
    toClose.do({ |w| w.close });
};

postState = {
    var msg;
    msg = [
        "serverRunning: " ++ s.serverRunning,
        "activeChain: " ++ activeChain,
        "grpSources: " ++ (grpSources.notNil),
        "grpSinks:   " ++ (grpSinks.notNil),
        "busAin:     " ++ (busAin ? "nil"),
        "busBin:     " ++ (busBin ? "nil")
    ].join(" | ");
    msg.postln;
};

// Build or rebuild the server tree safely
rebuildServerTree = {
    var aAmp, bAmp;

    // defaults on first call
    activeChain = activeChain ? \A;

    // ensure server boot + init
    s.waitForBoot({
        s.initTree;
        s.defaultGroup.freeAll; // known state
    });

    // allocate groups in known order
    grpSources = Group.head(s);
    grpSinks   = Group.after(grpSources);

    // allocate chain input busses
    busAin = busAin ?? { Bus.audio(s, numChConst) };
    busBin = busBin ?? { Bus.audio(s, numChConst) };

    // define synthdefs (compile-time)
    SynthDef(\testHexSource, { |out = 0, amp = 0.08, base = 110|
        var sig, freqs;
        freqs = Array.fill(numChConst, { |i| base * (i + 1) });
        sig = Mix.fill(numChConst, { |i| SinOsc.ar(freqs[i]) * (amp / numChConst) });
        // spread to numChConst lines with slight variations to visualize meters
        Out.ar(out, Array.fill(numChConst, { |i| SinOsc.ar(freqs[i], 0, amp / numChConst) }));
    }).add;

    // sink: read from \in.ar(numChConst), compute meters, mix to stereo
    SynthDef(\sinkStereo, { |in = 0, amp = 1.0, replyID = 100|
        var ins, mix, left, right;
        ins = In.ar(in, numChConst);                   // REQUIRED: read from \in.ar(numChConst)
        mix = (ins.sum / numChConst) * amp;            // mono sum
        left  = mix;
        right = mix;
        //SendPeakRMS.kr([left, right], 20, 3, 0.5, replyID); // ~20 fps, window 3, decay-ish

		SendPeakRMS.kr([left, right], 20, 3, "/sendPeakRMS", replyID); // match OSCdef route

        Out.ar(0, [left, right]);                      // to hardware out (stereo)
    }).add;

    // instantiate sources and sinks in proper order + exclusivity at source
    Server.default.bind({
        // clean existing
        [srcA, srcB, sinkA, sinkB].do({ |node| node.notNil.if({ node.free; }) });

        // exclusivity
        aAmp = if(activeChain == \A, { 0.09 }, { 0.0 });
        bAmp = if(activeChain == \B, { 0.09 }, { 0.0 });

        srcA = Synth.tail(grpSources, \testHexSource, [\out, busAin, \amp, aAmp]);
        srcB = Synth.tail(grpSources, \testHexSource, [\out, busBin, \amp, bAmp]);

        sinkA = Synth.tail(grpSinks, \sinkStereo, [\in, busAin, \replyID, 100]);
        sinkB = Synth.tail(grpSinks, \sinkStereo, [\in, busBin, \replyID, 101]);
    });

    postState.value;
};

// switch active chain: Option A (silence inactive at source)
setActiveChain = { |which = \A|
    activeChain = which;
    // Update amps
    srcA.notNil.if({ srcA.set(\amp, (activeChain == \A).if(0.09, 0.0)) });
    srcB.notNil.if({ srcB.set(\amp, (activeChain == \B).if(0.09, 0.0)) });
};

// ---------- meter handling (SendPeakRMS -> GUI arrays) ----------

meterA = [0.0, 0.0];  // [L, R] end-of-chain A
meterB = [0.0, 0.0];  // [L, R] end-of-chain B
meterUpdateRateHz = 20;

meterOscDef = OSCdef(\metersStandalone, { |msg, time, addr, recvPort|
    // format: ['/sendPeakRMS', nodeID, replyID, numChannels, peak..., rms...]
    var replyID, numChannels, peakStart, rmsStart, peaks, rms, l, r;
    replyID = msg[2];
    numChannels = msg[3];
    peakStart = 4;
    rmsStart = peakStart + numChannels;
    peaks = msg.copyRange(peakStart, peakStart + numChannels - 1);
    rms   = msg.copyRange(rmsStart,  rmsStart  + numChannels - 1);
    // we meter the stereo outputs; expect numChannels == 2 here
    l = peaks[0].clip(0, 1);
    r = peaks[1].clip(0, 1);

    if(replyID == 100, { meterA = [l, r]; });
    if(replyID == 101, { meterB = [l, r]; });
}, '/sendPeakRMS', s.addr);

// ---------- GUI ----------

makeWindow = {
    var w, margin, rowH, colW, font, label;

    closeExistingMagicDisplayWindows.value;

    w = Window("MagicDisplayGUI - StartHere Standalone v0.1.0", Rect(60, 60, 780, 480)).front;
    w.alwaysOnTop_(true);
    w.view.background_(Color.fromHexString("#1e272e")); // dark
    margin = 10;
    rowH = 40;
    colW = (w.bounds.width - margin * 3) / 2;
    font = Font("Monaco", 13);

    viewRoot = UserView(w, Rect(0, 0, w.bounds.width, w.bounds.height));

    // Chain A view
    viewA = CompositeView(w, Rect(margin, margin, colW, rowH * 3));
    viewA.background_(greyInactive);

    label = StaticText(viewA, Rect(8, 4, colW - 16, 18));
    label.string = "Chain A";
    label.align = \left;
    label.stringColor = Color.white;
    label.font = font;

    txtChainA = StaticText(viewA, Rect(8, 22, colW - 16, rowH * 2 - 24));
    txtChainA.stringColor = Color.white;
    txtChainA.font = font;

    // Chain B view
    viewB = CompositeView(w, Rect(colW + margin * 2, margin, colW, rowH * 3));
    viewB.background_(greyInactive);

    label = StaticText(viewB, Rect(8, 4, colW - 16, 18));
    label.string = "Chain B";
    label.align = \left;
    label.stringColor = Color.white;
    label.font = font;

    txtChainB = StaticText(viewB, Rect(8, 22, colW - 16, rowH * 2 - 24));
    txtChainB.stringColor = Color.white;
    txtChainB.font = font;

    // Meters (end-of-chain stereo)
    metersL = LevelIndicator(w, Rect(margin, margin + rowH * 3 + 10, w.bounds.width - margin * 2, 18))
        .warning_(0.7)
        .critical_(0.9);
    metersR = LevelIndicator(w, Rect(margin, margin + rowH * 3 + 10 + 24, w.bounds.width - margin * 2, 18))
        .warning_(0.7)
        .critical_(0.9);

    // System State
    txtSystem = StaticText(w, Rect(margin, margin + rowH * 3 + 10 + 24 + 30, w.bounds.width - margin * 2, 18));
    txtSystem.stringColor = Color.white;
    txtSystem.font = font;

    // Choices
    txtChoices = StaticText(w, Rect(margin, margin + rowH * 3 + 10 + 24 + 30 + 24, w.bounds.width - margin * 2, 18));
    txtChoices.stringColor = Color.fromHexString("#bdc3c7");
    txtChoices.font = font;

    // Incoming commands
    txtIncoming = StaticText(w, Rect(margin, margin + rowH * 3 + 10 + 24 + 30 + 24 + 24, w.bounds.width - margin * 2, 120));
    txtIncoming.stringColor = Color.fromHexString("#95a5a6");
    txtIncoming.font = font;

    // Keyboard handlers
    w.onKeyDown_({ |view, char, mod, uni, keycode|
        var sChar;
        sChar = char.asString;
        if(sChar == "a") { setActiveChain.value(\A); incomingLog = incomingLog.add("key:a"); };
        if(sChar == "b") { setActiveChain.value(\B); incomingLog = incomingLog.add("key:b"); };
        if(sChar == "r") { rebuildServerTree.value; incomingLog = incomingLog.add("key:r (rebuild)"); };
        if(sChar == "q") { w.close; };
    });

    w.onClose_({
        cleanup.value;
    });

    w;
};

updateGuiOnce = {
    var ca, cb, meters;
    // Chain contents (Phase 1: placeholders; Phase 2: wire real arrays)
    ca = chainA.collect(_.asString).join("  →  ");
    cb = chainB.collect(_.asString).join("  →  ");
    txtChainA.string = ca;
    txtChainB.string = cb;

    // Active chain highlight
    if(activeChain == \A) {
        viewA.background = greenActive;
        viewB.background = greyInactive;
    } {
        viewA.background = greyInactive;
        viewB.background = greenActive;
    };

    // Meters show end-of-chain for active chain
    meters = if(activeChain == \A, { meterA }, { meterB });
    metersL.value = meters[0].clip(0, 1);
    metersR.value = meters[1].clip(0, 1);

    // System State
    txtSystem.string = ("State: serverRunning=" ++ s.serverRunning ++
        " | activeChain=" ++ activeChain ++
        " | groups=(" ++ grpSources.notNil ++ "," ++ grpSinks.notNil ++ ")");

    // Choices
    txtChoices.string = "Choices: [a]→Chain A, [b]→Chain B, [r]→Rebuild, [q]→Close";

    // Incoming
    txtIncoming.string = "Incoming: " ++ incomingLog.join("  •  ");
};

cleanup = {
    // stop GUI refresh
    refreshRoutine.notNil.if({
        refreshRoutine.stop;
        refreshRoutine = nil;
    });
    // remove OSCdef
    OSCdef(\metersStandalone).free;

    // free nodes and busses
    Server.default.bind({
        [srcA, srcB, sinkA, sinkB].do({ |node| node.notNil.if({ node.free }) });
    });
    [busAin, busBin].do({ |b| b.notNil.if({ b.free }) });

    // reset locals
    srcA = nil; srcB = nil; sinkA = nil; sinkB = nil; busAin = nil; busBin = nil;
};

// ---------- bring-up ----------

banner.value;

// default chain contents (Phase 1 placeholders)
chainA = [\guitar, \tremolo, \delay, \destination];
chainB = [\guitar, \flanger, \reverb, \destination];
incomingLog = List.new;
choicesList = ["a:ChainA", "b:ChainB", "r:Rebuild", "q:Close"];

// initial active chain
activeChain = \A;

// server tree
rebuildServerTree.value;

// window
win = makeWindow.value;

// start GUI refresh via AppClock
refreshRoutine = Routine({
    var period;
    period = 1.0 / meterUpdateRateHz;
    loop {
        { updateGuiOnce.value; }.defer;  // always AppClock for GUI
        period.wait;
    }
}).play(AppClock);

// return the window (ensure '-> a Window')
win;
)

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/Meter_Calibration_Saw_100Hz_v.05.scd =====
// Meter_Calibration_Saw_100Hz.scd
// v1.1 - fixed (no .stretch_), 100 Hz saw @ selectable peak dBFS, RMS meter + 6 dB ticks, 0 dB marked
// MD 20251001

/* Purpose
   - Play a 100 Hz sawtooth at selectable peak amplitudes (dBFS): 0, -6, -12, -18, -20, -60, -128.
   - Show RMS on a LevelIndicator (SendPeakRMS), with a tick strip every 6 dB and 0 dBFS highlighted.
   - Help relate peak dBFS to RMS meter readings (for a saw, RMS ≈ peak - 4.77 dB).

   Mapping
   - Meter UI uses a dB mapping: topDb = 0 dBFS, floorDb = -120 dBFS, gamma = 1.0.
   - Ticks are drawn relative to that mapping, so 0 dB is at the very top, -120 dB at the bottom.

   Style
   - var-first declarations, lowercase method names, no non-local returns (^), GUI updates via defer.
*/

(
var window, paneColor, meter, tickView, labelRms, labelInfo, layout, controlsRow;
var ndefName, oscNameGui, oscNameConsole;

var ampMenu, ampDbChoices, currentAmpDb;
var setAmpDb, ampToRmsDbSaw;

var topDb, floorDb, gamma, mapLinToUi, mapDbToUi, valueFromMsg;

var rebuildNdef, bindOsc, unbindOsc, updateUiLabels;

// ------------- UI bring-up -------------
Window.allWindows.do({ |w| if(w.name == "Meter Calibration Demo", { w.close }) });

window = Window("Meter Calibration Demo", Rect(140, 140, 520, 280))
    .background_(Color.white)
    .front;

paneColor = Color(0.10, 0.30, 0.10);

// ------------- Mapping (linear RMS -> UI) -------------
topDb   = 0.0;     // UI=1 at 0 dBFS RMS
floorDb = -120.0;  // UI=0 at -120 dBFS RMS
gamma   = 1.0;     // 1.0 = linear-in-dB mapping

mapLinToUi = { |lin, top, floor, g|
    var v, vdb, u;
    v   = lin.max(1e-9);        // avoid -inf
    vdb = v.ampdb;              // lin -> dB
    vdb = vdb.clip(floor, top);
    u   = (vdb - floor) / (top - floor);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

mapDbToUi = { |db, top, floor, g|
    var vlin, u;
    vlin = db.dbamp.clip(1e-9, 1.0);
    u = mapLinToUi.(vlin, top, floor, g);
    u
};

// ------------- Test source config -------------
ndefName        = \calSaw;
oscNameGui      = \calSaw_toGUI;
oscNameConsole  = \calSaw_console;

ampDbChoices = [0, -6, -12, -18, -20, -60, -128];
currentAmpDb = -12;  // default on bring-up

ampToRmsDbSaw = { |peakDb|
    var peakLin, rmsLin, rmsDb;
    peakLin = peakDb.dbamp;       // peak amplitude (linear)
    rmsLin  = peakLin / 3.sqrt;   // RMS of a symmetric saw ≈ peak / √3
    rmsDb   = rmsLin.ampdb;
    rmsDb
};

rebuildNdef = {
    var freqDefault;
    freqDefault = 100;
    Ndef(ndefName, {
        var amp, freq, sig;
        amp  = \amp.kr(currentAmpDb.dbamp).clip(0.0, 1.0);
        freq = \freq.kr(freqDefault).max(10);
        sig  = Saw.ar([freq, freq]) * amp;   // BL saw, stereo
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsDemo', 1);  // 20 Hz to GUI
        sig
    });
    Ndef(ndefName).play(numChannels: 2);
};

valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };  // take last element (RMS)
    };
    v.clip(0.0, 1.0)
};

// ------------- GUI controls -------------
ampMenu = PopUpMenu()
    .items_(ampDbChoices.collect({ |db| (db.asString ++ " dBFS (peak)") }))
    .background_(Color(0.92, 0.98, 0.92))
    .action_({ |menu|
        var idx, db;
        idx = menu.value;
        db  = ampDbChoices.wrapAt(idx);
        setAmpDb.(db);
    });

labelRms  = StaticText().string_("RMS: (waiting)").align_(\left);
labelInfo = StaticText().string_("info").align_(\left).stringColor_(Color.gray(0.35));

controlsRow = HLayout(
    StaticText().string_("Amplitude:").stringColor_(Color.black),
    ampMenu,
    nil   // let the menu hug left and the row expand
);

// Meter + ticks
meter = LevelIndicator()
    .fixedWidth_(30)
    .warning_(0.50)
    .critical_(0.80);

tickView = UserView()
    .minSize_(Size(64, 180))
    .background_(Color.white);

// Whole layout
layout = VLayout(
    UserView().minSize_(Size(0, 6)),  // spacer
    controlsRow,
    UserView().minSize_(Size(0, 4)),
    HLayout(
        // left: tick strip with heading
        UserView().layout_(VLayout(
            StaticText().string_("dBFS").align_(\center).stringColor_(paneColor),
            tickView
        )).background_(Color.white),
        // right: meter + readouts
        VLayout(
            meter,
            UserView().minSize_(Size(0, 6)),
            labelRms,
            labelInfo
        ).margins_(2)
    ).margins_(8)
).margins_(8);

window.layout = layout;

// ------------- Tick drawing -------------
tickView.drawFunc_({ |v|
    var ctx, w, h, leftPad, rightPad, tickLong, tickShort, db, step, y, u, text;
    var font, zeroColor, tickColor;

    ctx = Pen;
    w = v.bounds.width;
    h = v.bounds.height;

    leftPad   = 4;
    rightPad  = 52;   // reserved label width (visual guide)
    tickLong  = 10;
    tickShort = 6;
    step      = 6;    // tick every 6 dB

    zeroColor = Color(1, 0, 0, 0.35);   // semi-transparent red
    tickColor = Color.gray(0.25);
    font      = Font("Helvetica", 10);

    ctx.use {
        // background
        ctx.color = Color.white;
        ctx.addRect(Rect(0, 0, w, h));
        ctx.fill;

        // 0 dB grid line
        u = mapDbToUi.(0, topDb, floorDb, gamma);
        y = (1 - u) * h;
        ctx.color = zeroColor;
        ctx.width = 1.0;
        ctx.moveTo(Point(leftPad, y));
        ctx.lineTo(Point(w - 2, y));
        ctx.stroke;

        // ticks & labels
        db = 0;
        while({ db >= floorDb }, {
            u = mapDbToUi.(db, topDb, floorDb, gamma);
            y = (1 - u) * h;

            ctx.color = (db == 0).if(zeroColor, tickColor);
            ctx.width = 1.0;

            if((db % 12) == 0) {
                ctx.moveTo(Point(leftPad, y));
                ctx.lineTo(Point(leftPad + tickLong, y));
            }{
                ctx.moveTo(Point(leftPad, y));
                ctx.lineTo(Point(leftPad + tickShort, y));
            };
            ctx.stroke;

            if((db == 0) or: { (db % 12) == 0 }) {
                ctx.font = font;
                ctx.color = Color.black;
                text = db.asString;
                ctx.stringAtPoint(text, Point(leftPad + tickLong + 4, y - 6));
            };

            db = db - step;
        });

        // border
        ctx.color = paneColor;
        ctx.width = 1;
        ctx.addRect(Rect(0.5, 0.5, w - 1, h - 1));
        ctx.stroke;
    };
});

// ------------- OSC + UI updates -------------
bindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };

    OSCdef(oscNameGui, { |msg|
        var lin, ui, rmsDb;
        lin   = valueFromMsg.(msg);
        ui    = mapLinToUi.(lin, topDb, floorDb, gamma);
        rmsDb = lin.max(1e-9).ampdb;

        {
            meter.value_(ui);
            labelRms.string_("RMS: " ++ rmsDb.round(0.1) ++ " dBFS    (UI: " ++ ui.round(0.003) ++ ")");
        }.defer;
    }, '/peakrmsDemo');

    // Optional console (decimate if desired)
    OSCdef(oscNameConsole, { |msg|
        // var lin = valueFromMsg.(msg);
        // var rmsDb = lin.max(1e-9).ampdb;
        // ("RMS: " ++ rmsDb.round(0.1) ++ " dBFS").postln;
    }, '/peakrmsDemo');
};

unbindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };
};

updateUiLabels = {
    var pred;
    pred = ampToRmsDbSaw.(currentAmpDb);
    {
        labelInfo.string_("peak: " ++ currentAmpDb.asString ++ " dBFS   →   expected RMS (saw): "
            ++ pred.round(0.1) ++ " dBFS   |   top=" ++ topDb ++ " dB, floor=" ++ floorDb);
        tickView.refresh;
    }.defer;
};

// ------------- Control logic -------------
setAmpDb = { |db|
    var idx;
    currentAmpDb = db.asFloat;
    Ndef(ndefName).set(\amp, currentAmpDb.dbamp);
    updateUiLabels.();
    idx = ampDbChoices.indexOf(currentAmpDb).max(0);
    { ampMenu.value_(idx) }.defer;
};

// ------------- Boot + run -------------
Server.default.waitForBoot({
    rebuildNdef.();
    bindOsc.();
    setAmpDb.(currentAmpDb);
});

// ------------- Cleanup -------------
window.onClose = {
    unbindOsc.();
    Ndef(ndefName).stop;
};

window  // -> a Window
)

// -------------------------------------------------------------------------
// One-liners (optional): change amplitude without the menu
// -------------------------------------------------------------------------
//
// (~cal_ampDb = { |db|
// 	var val;
// 	val = db.asFloat;
// 	Ndef(\calSaw).set(\amp, val.dbamp);
// 	("set peak = " ++ val ++ " dBFS").postln;
// };)
//
// ~cal_ampDb.(0);
// ~cal_ampDb.(-6);
// ~cal_ampDb.(-12);
// ~cal_ampDb.(-18);
// ~cal_ampDb.(-20);
// ~cal_ampDb.(-60);
// ~cal_ampDb.(-128);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/Meter_Calibration_Saw_100Hz_v.1.1.scd =====
// Meter_Calibration_Saw_100Hz.scd
// v1.1 - fixed (no .stretch_), 100 Hz saw @ selectable peak dBFS, RMS meter + 6 dB ticks, 0 dB marked
// MD 20251001

/* Purpose
   - Play a 100 Hz sawtooth at selectable peak amplitudes (dBFS): 0, -6, -12, -18, -20, -60, -128.
   - Show RMS on a LevelIndicator (SendPeakRMS), with a tick strip every 6 dB and 0 dBFS highlighted.
   - Help relate peak dBFS to RMS meter readings (for a saw, RMS ≈ peak - 4.77 dB).

   Mapping
   - Meter UI uses a dB mapping: topDb = 0 dBFS, floorDb = -120 dBFS, gamma = 1.0.
   - Ticks are drawn relative to that mapping, so 0 dB is at the very top, -120 dB at the bottom.

   Style
   - var-first declarations, lowercase method names, no non-local returns (^), GUI updates via defer.
*/

(
var window, paneColor, meter, tickView, labelRms, labelInfo, layout, controlsRow;
var ndefName, oscNameGui, oscNameConsole;

var ampMenu, ampDbChoices, currentAmpDb;
var setAmpDb, ampToRmsDbSaw;

var topDb, floorDb, gamma, mapLinToUi, mapDbToUi, valueFromMsg;

var rebuildNdef, bindOsc, unbindOsc, updateUiLabels;

// ------------- UI bring-up -------------
Window.allWindows.do({ |w| if(w.name == "Meter Calibration Demo", { w.close }) });

window = Window("Meter Calibration Demo", Rect(140, 140, 520, 280))
    .background_(Color.white)
    .front;

paneColor = Color(0.10, 0.30, 0.10);

// ------------- Mapping (linear RMS -> UI) -------------
topDb   = 0.0;     // UI=1 at 0 dBFS RMS
floorDb = -120.0;  // UI=0 at -120 dBFS RMS
gamma   = 1.0;     // 1.0 = linear-in-dB mapping

mapLinToUi = { |lin, top, floor, g|
    var v, vdb, u;
    v   = lin.max(1e-9);        // avoid -inf
    vdb = v.ampdb;              // lin -> dB
    vdb = vdb.clip(floor, top);
    u   = (vdb - floor) / (top - floor);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

mapDbToUi = { |db, top, floor, g|
    var vlin, u;
    vlin = db.dbamp.clip(1e-9, 1.0);
    u = mapLinToUi.(vlin, top, floor, g);
    u
};

// ------------- Test source config -------------
ndefName        = \calSaw;
oscNameGui      = \calSaw_toGUI;
oscNameConsole  = \calSaw_console;

ampDbChoices = [0, -6, -12, -18, -20, -60, -128];
currentAmpDb = -12;  // default on bring-up

ampToRmsDbSaw = { |peakDb|
    var peakLin, rmsLin, rmsDb;
    peakLin = peakDb.dbamp;       // peak amplitude (linear)
    rmsLin  = peakLin / 3.sqrt;   // RMS of a symmetric saw ≈ peak / √3
    rmsDb   = rmsLin.ampdb;
    rmsDb
};

rebuildNdef = {
    var freqDefault;
    freqDefault = 100;
    Ndef(ndefName, {
        var amp, freq, sig;
        amp  = \amp.kr(currentAmpDb.dbamp).clip(0.0, 1.0);
        freq = \freq.kr(freqDefault).max(10);
        sig  = Saw.ar([freq, freq]) * amp;   // BL saw, stereo
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsDemo', 1);  // 20 Hz to GUI
        sig
    });
    Ndef(ndefName).play(numChannels: 2);
};

valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };  // take last element (RMS)
    };
    v.clip(0.0, 1.0)
};

// ------------- GUI controls -------------
ampMenu = PopUpMenu()
    .items_(ampDbChoices.collect({ |db| (db.asString ++ " dBFS (peak)") }))
    .background_(Color(0.92, 0.98, 0.92))
    .action_({ |menu|
        var idx, db;
        idx = menu.value;
        db  = ampDbChoices.wrapAt(idx);
        setAmpDb.(db);
    });

labelRms  = StaticText().string_("RMS: (waiting)").align_(\left);
labelInfo = StaticText().string_("info").align_(\left).stringColor_(Color.gray(0.35));

controlsRow = HLayout(
    StaticText().string_("Amplitude:").stringColor_(Color.black),
    ampMenu,
    nil   // let the menu hug left and the row expand
);

// Meter + ticks
meter = LevelIndicator()
    .fixedWidth_(30)
    .warning_(0.50)
    .critical_(0.80);

tickView = UserView()
    .minSize_(Size(64, 180))
    .background_(Color.white);

// Whole layout
layout = VLayout(
    UserView().minSize_(Size(0, 6)),  // spacer
    controlsRow,
    UserView().minSize_(Size(0, 4)),
    HLayout(
        // left: tick strip with heading
        UserView().layout_(VLayout(
            StaticText().string_("dBFS").align_(\center).stringColor_(paneColor),
            tickView
        )).background_(Color.white),
        // right: meter + readouts
        VLayout(
            meter,
            UserView().minSize_(Size(0, 6)),
            labelRms,
            labelInfo
        ).margins_(2)
    ).margins_(8)
).margins_(8);

window.layout = layout;

// ------------- Tick drawing -------------
tickView.drawFunc_({ |v|
    var ctx, w, h, leftPad, rightPad, tickLong, tickShort, db, step, y, u, text;
    var font, zeroColor, tickColor;

    ctx = Pen;
    w = v.bounds.width;
    h = v.bounds.height;

    leftPad   = 4;
    rightPad  = 52;   // reserved label width (visual guide)
    tickLong  = 10;
    tickShort = 6;
    step      = 6;    // tick every 6 dB

    zeroColor = Color(1, 0, 0, 0.35);   // semi-transparent red
    tickColor = Color.gray(0.25);
    font      = Font("Helvetica", 10);

    ctx.use {
        // background
        ctx.color = Color.white;
        ctx.addRect(Rect(0, 0, w, h));
        ctx.fill;

        // 0 dB grid line
        u = mapDbToUi.(0, topDb, floorDb, gamma);
        y = (1 - u) * h;
        ctx.color = zeroColor;
        ctx.width = 1.0;
        ctx.moveTo(Point(leftPad, y));
        ctx.lineTo(Point(w - 2, y));
        ctx.stroke;

        // ticks & labels
        db = 0;
        while({ db >= floorDb }, {
            u = mapDbToUi.(db, topDb, floorDb, gamma);
            y = (1 - u) * h;

            ctx.color = (db == 0).if(zeroColor, tickColor);
            ctx.width = 1.0;

            if((db % 12) == 0) {
                ctx.moveTo(Point(leftPad, y));
                ctx.lineTo(Point(leftPad + tickLong, y));
            }{
                ctx.moveTo(Point(leftPad, y));
                ctx.lineTo(Point(leftPad + tickShort, y));
            };
            ctx.stroke;

            if((db == 0) or: { (db % 12) == 0 }) {
                ctx.font = font;
                ctx.color = Color.black;
                text = db.asString;
                ctx.stringAtPoint(text, Point(leftPad + tickLong + 4, y - 6));
            };

            db = db - step;
        });

        // border
        ctx.color = paneColor;
        ctx.width = 1;
        ctx.addRect(Rect(0.5, 0.5, w - 1, h - 1));
        ctx.stroke;
    };
});

// ------------- OSC + UI updates -------------
bindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };

    OSCdef(oscNameGui, { |msg|
        var lin, ui, rmsDb;
        lin   = valueFromMsg.(msg);
        ui    = mapLinToUi.(lin, topDb, floorDb, gamma);
        rmsDb = lin.max(1e-9).ampdb;

        {
            meter.value_(ui);
            labelRms.string_("RMS: " ++ rmsDb.round(0.1) ++ " dBFS    (UI: " ++ ui.round(0.003) ++ ")");
        }.defer;
    }, '/peakrmsDemo');

    // Optional console (decimate if desired)
    OSCdef(oscNameConsole, { |msg|
        // var lin = valueFromMsg.(msg);
        // var rmsDb = lin.max(1e-9).ampdb;
        // ("RMS: " ++ rmsDb.round(0.1) ++ " dBFS").postln;
    }, '/peakrmsDemo');
};

unbindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };
};

updateUiLabels = {
    var pred;
    pred = ampToRmsDbSaw.(currentAmpDb);
    {
        labelInfo.string_("peak: " ++ currentAmpDb.asString ++ " dBFS   →   expected RMS (saw): "
            ++ pred.round(0.1) ++ " dBFS   |   top=" ++ topDb ++ " dB, floor=" ++ floorDb);
        tickView.refresh;
    }.defer;
};

// ------------- Control logic -------------
setAmpDb = { |db|
    var idx;
    currentAmpDb = db.asFloat;
    Ndef(ndefName).set(\amp, currentAmpDb.dbamp);
    updateUiLabels.();
    idx = ampDbChoices.indexOf(currentAmpDb).max(0);
    { ampMenu.value_(idx) }.defer;
};

// ------------- Boot + run -------------
Server.default.waitForBoot({
    rebuildNdef.();
    bindOsc.();
    setAmpDb.(currentAmpDb);
});

// ------------- Cleanup -------------
window.onClose = {
    unbindOsc.();
    Ndef(ndefName).stop;
};

window  // -> a Window
)

// -------------------------------------------------------------------------
// One-liners (optional): change amplitude without the menu
// -------------------------------------------------------------------------
//
// (~cal_ampDb = { |db|
// 	var val;
// 	val = db.asFloat;
// 	Ndef(\calSaw).set(\amp, val.dbamp);
// 	("set peak = " ++ val ++ " dBFS").postln;
// };)
//
// ~cal_ampDb.(0);
// ~cal_ampDb.(-6);
// ~cal_ampDb.(-12);
// ~cal_ampDb.(-18);
// ~cal_ampDb.(-20);
// ~cal_ampDb.(-60);
// ~cal_ampDb.(-128);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/Meter_Calibration_Saw_100Hz.scd =====
// Meter_Calibration_Saw_100Hz.scd
// v1.2 - remove .stretch_ (unsupported), align tick strip & meter; 6 dB ticks; 0 dBFS marked
// MD 20251001

/* Purpose
   - Single Ndef playing a 100 Hz saw at selectable peak dBFS: 0, -6, -12, -18, -20, -60, -128.
   - LevelIndicator shows RMS via SendPeakRMS; a tick strip shows 6 dB marks with 0 dBFS highlighted.
   - Clean layout: tick strip and meter share identical height and align perfectly.

   Style
   - var-first declarations in every block/function
   - lowercase method names, descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var window, paneColor, meter, tickView, labelRms, labelInfo, layout, controlsRow;
var ndefName, oscNameGui, oscNameConsole;

var ampMenu, ampDbChoices, currentAmpDb;
var setAmpDb, ampToRmsDbSaw;

var topDb, floorDb, gamma, mapLinToUi, mapDbToUi, valueFromMsg;

var rebuildNdef, bindOsc, unbindOsc, updateUiLabels;

var meterHeight, tickWidth;

// ------------- constants for alignment -------------
meterHeight = 220;  // exact shared height for tick strip & meter
tickWidth   = 72;   // width for tick area (room for labels)

// ------------- UI bring-up -------------
Window.allWindows.do({ |w| if(w.name == "Meter Calibration Demo", { w.close }) });

window = Window("Meter Calibration Demo", Rect(160, 160, 540, 340))
    .background_(Color.white)
    .front;

paneColor = Color(0.10, 0.30, 0.10);

// ------------- Mapping (linear RMS -> UI) -------------
topDb   = 0.0;     // UI=1 at 0 dBFS RMS
floorDb = -120.0;  // UI=0 at -120 dBFS RMS
gamma   = 1.0;     // 1.0 = straight mapping in dB

mapLinToUi = { |lin, top, floor, g|
    var v, vdb, u;
    v   = lin.max(1e-9);        // avoid -inf
    vdb = v.ampdb;              // lin -> dB
    vdb = vdb.clip(floor, top);
    u   = (vdb - floor) / (top - floor);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

mapDbToUi = { |db, top, floor, g|
    var vlin, u;
    vlin = db.dbamp.clip(1e-9, 1.0);
    u = mapLinToUi.(vlin, top, floor, g);
    u
};

// ------------- Test source config -------------
ndefName       = \calSaw;
oscNameGui     = \calSaw_toGUI;
oscNameConsole = \calSaw_console;

ampDbChoices = [0, -6, -12, -18, -20, -60, -128];
currentAmpDb = -12;  // default on bring-up

ampToRmsDbSaw = { |peakDb|
    var peakLin, rmsLin, rmsDb;
    peakLin = peakDb.dbamp;        // peak amplitude as linear
    rmsLin  = peakLin / sqrt(3);   // RMS of a symmetric saw
    rmsDb   = rmsLin.ampdb;
    rmsDb
};

rebuildNdef = {
    var freqDefault;
    freqDefault = 100;
    Ndef(ndefName, {
        var amp, freq, sig;
        amp  = \amp.kr(currentAmpDb.dbamp).clip(0.0, 1.0);
        freq = \freq.kr(freqDefault).max(10);
        sig  = Saw.ar([freq, freq]) * amp;   // band-limited saw, stereo
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsDemo', 1);  // 20 Hz GUI updates
        sig
    });
    Ndef(ndefName).play(numChannels: 2);
};

valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };  // take final RMS element
    };
    v.clip(0.0, 1.0)
};

// ------------- GUI controls (top row) -------------
ampMenu = PopUpMenu()
    .items_(ampDbChoices.collect({ |db| (db.asString ++ " dBFS (peak)") }))
    .background_(Color(0.92, 0.98, 0.92))
    .action_({ |menu|
        var idx, db;
        idx = menu.value;
        db  = ampDbChoices.wrapAt(idx);
        setAmpDb.(db);
    });

labelRms  = StaticText().string_("RMS: (waiting)").align_(\left);
labelInfo = StaticText().string_("info").align_(\left).stringColor_(Color.gray(0.35));

controlsRow = HLayout(
    StaticText().string_("Amplitude:").stringColor_(Color.black),
    ampMenu,                 // no .stretch_; we control spacing with explicit spacers
    UserView().minSize_(Size(12, 0)),  // spacer
    nil
);

// Meter + ticks (side-by-side, identical heights)
meter = LevelIndicator()
    .fixedWidth_(30)
    .fixedHeight_(meterHeight)    // keep height exactly in sync with tick strip
    .warning_(0.50)
    .critical_(0.80);

tickView = UserView()
    .minSize_(Size(tickWidth, meterHeight))
    .maxSize_(Size(tickWidth, meterHeight))
    .background_(Color.white);

// Whole layout
layout = VLayout(
    UserView().minSize_(Size(0, 8)),  // spacer
    controlsRow,
    UserView().minSize_(Size(0, 6)),
    HLayout(
        tickView,                         // left: tick strip (draws header inside)
        UserView().minSize_(Size(8, 0)),  // spacer between tick and meter
        meter,
        UserView().minSize_(Size(12, 0)),
        VLayout(
            labelRms,
            UserView().minSize_(Size(6, 6)),
            labelInfo
        ).margins_(2)
    ).margins_(8)
).margins_(8);

window.layout = layout;

// ------------- Tick drawing (inside the fixed-height tickView) -------------
tickView.drawFunc_({ |v|
    var ctx, w, h, leftPad, rightPad, tickLong, tickShort, db, step, y, u, text;
    var font, zeroColor, tickColor;

    ctx = Pen;
    w = v.bounds.width;
    h = v.bounds.height;

    leftPad  = 6;
    rightPad = w - 6;  // right margin; labels must fit before this
    tickLong  = 14;
    tickShort = 9;
    step = 6;         // every 6 dB

    zeroColor = Color.red;
    tickColor = Color.gray(0.22);
    font = Font("Helvetica", 10);

    ctx.use {
        // background
        ctx.color = Color.white;
        ctx.addRect(Rect(0, 0, w, h));
        ctx.fill;

        // small "dBFS" header at top-left (doesn't change layout height)
        ctx.stringAtPoint("dBFS", Point(leftPad, 2), Font("Helvetica", 10), Color.gray(0.25));

        // grid line at 0 dB
        u = mapDbToUi.(0, topDb, floorDb, gamma);
        y = (1 - u) * h;
        ctx.color = zeroColor.alpha_(0.35);
        ctx.width = 1.0;
        ctx.moveTo(Point(1, y));
        ctx.lineTo(Point(w - 1, y));
        ctx.stroke;

        // ticks every 6 dB down to floor
        db = 0;
        while({ db >= floorDb }, {
            var isMajor, tickLen, labelX;
            isMajor = ((db % 12) == 0) or: { db == 0 };
            tickLen = isMajor.if(tickLong, tickShort);

            u = mapDbToUi.(db, topDb, floorDb, gamma);
            y = (1 - u) * h;

            // tick
            ctx.color = (db == 0).if(zeroColor, tickColor);
            ctx.width = 1.0;
            ctx.moveTo(Point(leftPad, y));
            ctx.lineTo(Point(leftPad + tickLen, y));
            ctx.stroke;

            // label on majors (12 dB) and 0 dB
            if(isMajor) {
                labelX = leftPad + tickLong + 4;
                text = db.asString;
                if(labelX < (rightPad - 6)) {
                    ctx.stringAtPoint(text, Point(labelX, y - 6), font, Color.black);
                };
            };

            db = db - step;
        });

        // border
        ctx.color = paneColor;
        ctx.width = 1;
        ctx.addRect(Rect(0.5, 0.5, w - 1, h - 1));
        ctx.stroke;
    };
});

// ------------- OSC + UI updates -------------
bindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };

    OSCdef(oscNameGui, { |msg|
        var lin, ui, rmsDb;
        lin  = valueFromMsg.(msg);
        ui   = mapLinToUi.(lin, topDb, floorDb, gamma);
        rmsDb = lin.max(1e-9).ampdb;

        {
            meter.value_(ui);
            labelRms.string_("RMS: " ++ rmsDb.round(0.1) ++ " dBFS  (UI: " ++ ui.round(0.003) ++ ")");
        }.defer;
    }, '/peakrmsDemo');

    // optional console OSCdef omitted to keep output quiet
};

unbindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };
};

updateUiLabels = {
    var pred;
    pred = ampToRmsDbSaw.(currentAmpDb);
    {
        labelInfo.string_("peak: " ++ currentAmpDb.asString ++ " dBFS   →   expected RMS (saw): "
            ++ pred.round(0.1) ++ " dBFS   |   top=" ++ topDb ++ " , floor=" ++ floorDb);
        tickView.refresh;
    }.defer;
};

// ------------- Control logic -------------
setAmpDb = { |db|
    var idx;
    currentAmpDb = db.asFloat;
    Ndef(ndefName).set(\amp, currentAmpDb.dbamp);
    updateUiLabels.();
    idx = ampDbChoices.indexOf(currentAmpDb).max(0);
    { ampMenu.value_(idx) }.defer;
};

// ------------- Boot + run -------------
Server.default.waitForBoot({
    rebuildNdef.();
    bindOsc.();
    {
        ampMenu.items = ampDbChoices.collect({ |x| x.asString ++ " dBFS (peak)" });
    }.defer;
    setAmpDb.(currentAmpDb);
});

// ------------- Cleanup -------------
window.onClose = {
    unbindOsc.();
    Ndef(ndefName).stop;
};

window  // -> a Window
)

// -------------------------------------------------------------------------
// One-liners (optional): change amplitude without using the menu
// -------------------------------------------------------------------------
~cal_ampDb = { |db| var val; val = db.asFloat; Ndef(\calSaw).set(\amp, val.dbamp); ("set peak = " ++ val ++ " dBFS").postln; };

~cal_ampDb.(0);
~cal_ampDb.(-6);
~cal_ampDb.(-12);
~cal_ampDb.(-18);
~cal_ampDb.(-20);
~cal_ampDb.(-60);
~cal_ampDb.(-128);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/PossibleMetersFromClaude.scd =====
// PossibleLevelMeter.scd
// v 0.5
// MD 20251001

/* not terrible, and reasonably accurate (but seems to indicate actual amplitude from RMS readings. I could live that.)

s.waitForBoot({
    var win, meterView, levelIndicator, ampButtons, ampValues, currentAmp;
    var dbTicks, responder;

    // Amplitude values in linear scale
    ampValues = [
        1.0,      // 0 dBFS
        0.5,      // -6 dBFS (approximately)
        0.25,     // -12 dBFS
        0.125,    // -18 dBFS
        0.1,      // -20 dBFS
        0.001,    // -60 dBFS
        0.0       // -128 dBFS (silence)
    ];

    currentAmp = 0; // Index for current amplitude

    // Create the Ndef with sawtooth wave and peak monitoring
    Ndef(\saw, {
        var sig = Saw.ar(100) * \amp.kr(0);
        sig = sig ! 2; // Stereo
        SendPeakRMS.kr(sig, 20, 3, '/meter'); // Send peak values
        sig;
    });

    Ndef(\saw).play;

    // Create GUI window
    win = Window("Sawtooth Wave - dB Meter", Rect(100, 100, 400, 500))
        .front
        .onClose_({
            Ndef(\saw).clear;
            responder.free;
        });

    win.view.decorator = FlowLayout(win.view.bounds, 10@10, 10@10);

    // Title
    StaticText(win, 380@30)
        .string_("100 Hz Sawtooth Wave Generator")
        .align_(\center)
        .font_(Font.default.size_(16));

    win.view.decorator.nextLine;

    // Amplitude selection buttons
    StaticText(win, 380@20)
        .string_("Select Amplitude:")
        .font_(Font.default.size_(12));

    win.view.decorator.nextLine;

    ampButtons = [
        "0 dBFS",
        "-6 dBFS",
        "-12 dBFS",
        "-18 dBFS",
        "-20 dBFS",
        "-60 dBFS",
        "-128 dBFS (Off)"
    ].collect({ |label, i|
        Button(win, 120@30)
            .states_([[label, Color.black, Color.gray(0.8)]])
            .action_({
                currentAmp = i;
                Ndef(\saw).set(\amp, ampValues[i]);
                ("Amplitude set to " ++ label).postln;
            });
    });

    win.view.decorator.nextLine;
    win.view.decorator.nextLine;

    // Meter section
    StaticText(win, 380@20)
        .string_("Level Meter:")
        .font_(Font.default.size_(12));

    win.view.decorator.nextLine;

    // Create a composite view for meter with labels
    meterView = CompositeView(win, 380@300)
        .background_(Color.gray(0.2));

    // Level indicator (vertical meter) - position first
    levelIndicator = LevelIndicator(meterView, Rect(80, 20, 80, 260))
        .warning_(0.7)
        .critical_(0.9)
        .numSteps_(60)
        .numTicks_(11)
        .numMajorTicks_(11)
        .drawsPeak_(true)
        .style_(\led);

    // dB tick marks - adjusted to match LevelIndicator's linear amplitude scale
    // LevelIndicator displays LINEAR amplitude (0 to 1), not dB
    // So we need to convert: amplitude = 10^(dB/20)
    dbTicks = [0, -6, -12, -18, -24, -30, -36, -42, -48, -54, -60];

    // Draw tick marks and labels immediately next to the meter
    dbTicks.do({ |db, i|
        var linearAmp = 10.pow(db / 20); // Convert dB to linear amplitude
        var yPos = 20 + (260 * (1 - linearAmp)); // Map to meter position (top is amp=1.0, bottom is amp=0)

        // Tick mark line (right next to meter)
        StaticText(meterView, Rect(165, yPos - 1, 15, 2))
            .background_(Color.white);

        // dB label
        StaticText(meterView, Rect(185, yPos - 10, 50, 20))
            .string_(db.asString ++ " dB")
            .font_(Font.default.size_(10))
            .stringColor_(Color.white);

        // Highlight 0 dBFS
        if (db == 0, {
            StaticText(meterView, Rect(240, yPos - 10, 50, 20))
                .string_("← 0 dBFS")
                .font_(Font.default.size_(10).boldVariant)
                .stringColor_(Color.red);
        });
    });

    // Channel labels
    StaticText(meterView, Rect(85, 285, 30, 15))
        .string_("L")
        .align_(\center)
        .stringColor_(Color.white);

    StaticText(meterView, Rect(125, 285, 30, 15))
        .string_("R")
        .align_(\center)
        .stringColor_(Color.white);

    // OSC responder to receive peak values
    responder = OSCFunc({ |msg|
        var peakL, peakR;
        // msg format: ['/meter', nodeID, replyID, peakL, peakR, rmsL, rmsR]
        peakL = msg[3];
        peakR = msg[4];

        // Update meter on AppClock
        {
            levelIndicator.value = peakL.max(peakR);
            levelIndicator.peakLevel = peakL.max(peakR);
        }.defer;
    }, '/meter');

    "Sawtooth wave generator ready. Select an amplitude to begin.".postln;
});
===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/SawMeter_SingleNdef_100Hz.scd =====
/*-------------------------------------------------------------
SawMeter_SingleNdef_100Hz
v0.1.7
MD 2025-10-01 12:58

Purpose:
- One Ndef plays a 100 Hz sawtooth at selectable amplitudes (dBFS).
- Meter shows RMS directly; Peak overlaid via LevelIndicator.drawsPeak/peakLevel.
- Tick marks every 6 dB to the RIGHT; 0 dBFS line + 0..-6 dB headroom band.
- Floor extended to -72 dB so RMS at -60 dBFS is visible (saw RMS ≈ -4.77 dB below peak).
- Compact UI; no legend; returns -> a Window.

Style:
- var-first declarations; lowercase methods; no server.sync
- AppClock-only GUI refresh
- Single window whose name begins with "MagicDisplayGUI"
-------------------------------------------------------------*/

(
// ------------------ config + helpers ------------------
var window_name, floor_db, headroom_top_db, refresh_hz;
var ndef_name, reply_id, amp_db_list, default_db;
var close_existing_magic_windows;
var clamp_db, db_to_ui_frac, y_for_db_padded;

window_name      = "MagicDisplayGUI — Single Saw Meter (100 Hz)"; // must start with MagicDisplayGUI
floor_db         = -72;   // EXTENDED floor so RMS at -60 dBFS (~ -64.77) is visible
headroom_top_db  = -6;    // headroom shading top (visual only)
refresh_hz       = 30;    // GUI / telemetry refresh (Hz)

ndef_name        = \md_saw_100hz;
reply_id         = 9001;
amp_db_list      = [0, -6, -12, -18, -20, -60, -128];
default_db       = -18;

close_existing_magic_windows = {
    var to_close;
    to_close = Window.allWindows.select({ |w| w.name.asString.beginsWith("MagicDisplayGUI") });
    to_close.do({ |w| w.close });
};

// dB clamp + mapping (0 dBFS -> 1.0 UI; floor_db -> 0.0 UI)
clamp_db = { |db| db.clip(floor_db, 0) };
db_to_ui_frac = { |db|
    var dbc = clamp_db.(db);
    (dbc - floor_db) / (0 - floor_db); // 0 at floor, 1 at 0 dBFS
};

// y for dB with small padding so bottom tick is always visible
y_for_db_padded = { |db, h, pad = 1|
    var p = db_to_ui_frac.(db).clip(0, 1);     // 0..1 (floor..0dB)
    var y = pad + (h - 1 - 2*pad) * (1 - p);   // 0 at top
    y.clip(0, h - 1);
};

// ------------------ main ------------------
close_existing_magic_windows.value;

s.waitForBoot({
    var window, amp_menu_view, info_view, readout_view;
    var indicator, ticks_view;
    var oscdef_levels, updater;

    var last_rms_lin, last_peak_lin, current_amp_db, current_amp_lin;
    var set_amp_db, db_ticks;

    // clean server tree
    s.initTree;
    s.defaultGroup.freeAll;

    // ---------- Ndef with telemetry (literal defaults; set real values after) ----------
    Ndef(ndef_name, { |amp = 0.125, trigID = 1, uiHz = 30|
        var sig_st, mono, peak_est, rms_est;
        var win_samps, sumsq, mean, rms_audio, trig;

        sig_st  = Saw.ar(100) * amp ! 2;
        mono    = (sig_st[0] + sig_st[1]) * 0.5;

        peak_est = Amplitude.kr(mono, 0.0, 0.05); // peak-ish envelope
        win_samps = (SampleRate.ir * 0.05).max(1).asInteger; // ~50 ms RMS
        sumsq     = RunningSum.ar(mono.squared, win_samps);
        mean      = sumsq / win_samps;
        rms_audio = mean.sqrt;
        rms_est   = A2K.kr(rms_audio);

        trig = Impulse.kr(uiHz);
        SendReply.kr(trig, "/md/levels", [ peak_est, rms_est ], trigID);

        sig_st
    });

    Ndef(ndef_name).set(\amp, default_db.dbamp, \trigID, reply_id, \uiHz, refresh_hz);

    // ---------- UI + state ----------
    last_peak_lin   = 0.0;
    last_rms_lin    = 0.0;
    current_amp_db  = default_db;
    current_amp_lin = current_amp_db.dbamp;

    set_amp_db = { |db|
        current_amp_db  = db;
        current_amp_lin = db.dbamp;
        Ndef(ndef_name).set(\amp, current_amp_lin);
        info_view.string = "Amp: % dBFS (lin %)"
            .format(db.asInteger, current_amp_lin.round(1e-6));
    };

    // ticks every 6 dB from 0 down to floor_db (== -72)
    db_ticks = Array.series(((0 - floor_db) / 6).asInteger + 1, 0, -6)
        .select({ |db| db >= floor_db });

    // ---------- window & views (compact) ----------
    window = Window(window_name, Rect(100, 100, 360, 230)).alwaysOnTop_(true);

    amp_menu_view = PopUpMenu(window, Rect(16, 16, 150, 22))
        .items_(amp_db_list.collect({ |db| "% dBFS".format(db) }))
        .action_({ |m| set_amp_db.(amp_db_list[m.value]) });

    info_view = StaticText(window, Rect(176, 16, 168, 22))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // RMS bar with Peak overlay (normalized UI fractions 0..1)
    indicator = LevelIndicator(window, Rect(16, 56, 36, 160))
        .style_(\continuous)
        .warning_(0.85)
        .critical_(0.95)
        .drawsPeak_(true);

    // ticks to the RIGHT of the meter (compact)
    ticks_view = UserView(window, Rect(58, 56, 110, 160))
        .background_(Color(0.94, 0.94, 0.96));

    // numeric readout (RMS & Peak in dBFS)
    readout_view = StaticText(window, Rect(176, 56, 168, 20))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // ticks drawing (0..-6 headroom band; -72 floor; -60 visible)
    ticks_view.drawFunc_({
        var b, w, h, y0, y_head, font;
        b = ticks_view.bounds; w = b.width; h = b.height;
        font = Font(Font.default.name, 11);

        // background
        Pen.color = Color(0.96, 0.96, 0.98);
        Pen.fillRect(Rect(0, 0, w, h));

        // headroom band (0..-6)
        y0    = y_for_db_padded.(0, h, 1);
        y_head = y_for_db_padded.(headroom_top_db, h, 1);
        Pen.color = Color(1.0, 0.8, 0.8, 0.35);
        Pen.fillRect(Rect(0, y0, w, (y_head - y0)));

        // 0 dBFS line (red)
        Pen.color = Color(0.8, 0.1, 0.1, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y0));
        Pen.lineTo(Point(w, y0));
        Pen.stroke;

        // -6 dB line
        Pen.color = Color(0.6, 0.2, 0.2, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y_head));
        Pen.lineTo(Point(w, y_head));
        Pen.stroke;

        // ticks + labels (0, -6, -12, ... down to -72)
        db_ticks.do({ |db|
            var y, major, tick_len, label, lx, ly;
            y = y_for_db_padded.(db, h, 1);
            major = (((db.asInteger % 12) == 0) or: (db == 0));
            tick_len = major.if(12, 8);
            label = "% dB".format(db.asInteger);

            Pen.color = Color(0.25, 0.25, 0.28, 1.0);
            Pen.width = 1.0;
            Pen.moveTo(Point(0, y));
            Pen.lineTo(Point(tick_len, y));
            Pen.stroke;

            Pen.color = Color(0.15, 0.15, 0.16, 1.0);
            lx = tick_len + 4;
            ly = (y - 7).clip(0, h - 14);
            Pen.stringAtPoint(label, Point(lx, ly), font);
        });
    });

    // ---------- OSC + updater ----------
    oscdef_levels = OSCdef(\md_levels, { |msg|
        // msg = [ '/md/levels', nodeID, replyID, peak, rms ]
        if (msg[2] == reply_id) {
            last_peak_lin = msg[3].asFloat.max(0);
            last_rms_lin  = msg[4].asFloat.max(0);
        };
    }, '/md/levels', s.addr);

    updater = Routine({
        var spf = 1.0 / refresh_hz;
        var min_ui = 1.0 / 160.0; // ensure 1 px visible if clamped to floor
        inf.do({
            {
                var db_rms, db_peak, p_rms, p_peak;

                db_rms  = last_rms_lin.max(1e-12).ampdb;  // dBFS
                db_peak = last_peak_lin.max(1e-12).ampdb; // dBFS

                // Normalize to UI 0..1 (0=floor, 1=0dB)
                p_rms  = db_to_ui_frac.(db_rms).clip(0, 1);
                p_peak = db_to_ui_frac.(db_peak).clip(0, 1);

                // show a 1px sliver if p_rms == 0 (below floor)
                p_rms = (p_rms <= 0).if(min_ui, p_rms);

                indicator.value_(p_rms);
                indicator.peakLevel_(p_peak);

                readout_view.string = "RMS: % dBFS | Peak: % dBFS"
                    .format(clamp_db.(db_rms).round(0.1), clamp_db.(db_peak).round(0.1));

                indicator.refresh;
                ticks_view.refresh;
            }.defer;
            spf.wait;
        });
    }).play(AppClock);

    // ---------- bring up ----------
    Ndef(ndef_name).play;
    set_amp_db.(default_db);
    amp_menu_view.value = amp_db_list.indexOf(default_db).max(0);

    window.onClose_({
        updater.stop;
        oscdef_levels.free;
        Ndef(ndef_name).stop(0.1);
        // Ndef(ndef_name).clear; // uncomment to remove definition
    });

    window.front;

    // return -> a Window
    window;
});
)
===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/SawMeter_SingleNdef_100Hzv_0.1.7_WORKING.scd =====
/*-------------------------------------------------------------
SawMeter_SingleNdef_100Hz
v0.1.7
MD 2025-10-01 12:58

Purpose:
- One Ndef plays a 100 Hz sawtooth at selectable amplitudes (dBFS).
- Meter shows RMS directly; Peak overlaid via LevelIndicator.drawsPeak/peakLevel.
- Tick marks every 6 dB to the RIGHT; 0 dBFS line + 0..-6 dB headroom band.
- Floor extended to -72 dB so RMS at -60 dBFS is visible (saw RMS ≈ -4.77 dB below peak).
- Compact UI; no legend; returns -> a Window.

Style:
- var-first declarations; lowercase methods; no server.sync
- AppClock-only GUI refresh
- Single window whose name begins with "MagicDisplayGUI"
-------------------------------------------------------------*/

(
// ------------------ config + helpers ------------------
var window_name, floor_db, headroom_top_db, refresh_hz;
var ndef_name, reply_id, amp_db_list, default_db;
var close_existing_magic_windows;
var clamp_db, db_to_ui_frac, y_for_db_padded;

window_name      = "MagicDisplayGUI — Single Saw Meter (100 Hz)"; // must start with MagicDisplayGUI
floor_db         = -72;   // EXTENDED floor so RMS at -60 dBFS (~ -64.77) is visible
headroom_top_db  = -6;    // headroom shading top (visual only)
refresh_hz       = 30;    // GUI / telemetry refresh (Hz)

ndef_name        = \md_saw_100hz;
reply_id         = 9001;
amp_db_list      = [0, -6, -12, -18, -20, -60, -128];
default_db       = -18;

close_existing_magic_windows = {
    var to_close;
    to_close = Window.allWindows.select({ |w| w.name.asString.beginsWith("MagicDisplayGUI") });
    to_close.do({ |w| w.close });
};

// dB clamp + mapping (0 dBFS -> 1.0 UI; floor_db -> 0.0 UI)
clamp_db = { |db| db.clip(floor_db, 0) };
db_to_ui_frac = { |db|
    var dbc = clamp_db.(db);
    (dbc - floor_db) / (0 - floor_db); // 0 at floor, 1 at 0 dBFS
};

// y for dB with small padding so bottom tick is always visible
y_for_db_padded = { |db, h, pad = 1|
    var p = db_to_ui_frac.(db).clip(0, 1);     // 0..1 (floor..0dB)
    var y = pad + (h - 1 - 2*pad) * (1 - p);   // 0 at top
    y.clip(0, h - 1);
};

// ------------------ main ------------------
close_existing_magic_windows.value;

s.waitForBoot({
    var window, amp_menu_view, info_view, readout_view;
    var indicator, ticks_view;
    var oscdef_levels, updater;

    var last_rms_lin, last_peak_lin, current_amp_db, current_amp_lin;
    var set_amp_db, db_ticks;

    // clean server tree
    s.initTree;
    s.defaultGroup.freeAll;

    // ---------- Ndef with telemetry (literal defaults; set real values after) ----------
    Ndef(ndef_name, { |amp = 0.125, trigID = 1, uiHz = 30|
        var sig_st, mono, peak_est, rms_est;
        var win_samps, sumsq, mean, rms_audio, trig;

        sig_st  = Saw.ar(100) * amp ! 2;
        mono    = (sig_st[0] + sig_st[1]) * 0.5;

        peak_est = Amplitude.kr(mono, 0.0, 0.05); // peak-ish envelope
        win_samps = (SampleRate.ir * 0.05).max(1).asInteger; // ~50 ms RMS
        sumsq     = RunningSum.ar(mono.squared, win_samps);
        mean      = sumsq / win_samps;
        rms_audio = mean.sqrt;
        rms_est   = A2K.kr(rms_audio);

        trig = Impulse.kr(uiHz);
        SendReply.kr(trig, "/md/levels", [ peak_est, rms_est ], trigID);

        sig_st
    });

    Ndef(ndef_name).set(\amp, default_db.dbamp, \trigID, reply_id, \uiHz, refresh_hz);

    // ---------- UI + state ----------
    last_peak_lin   = 0.0;
    last_rms_lin    = 0.0;
    current_amp_db  = default_db;
    current_amp_lin = current_amp_db.dbamp;

    set_amp_db = { |db|
        current_amp_db  = db;
        current_amp_lin = db.dbamp;
        Ndef(ndef_name).set(\amp, current_amp_lin);
        info_view.string = "Amp: % dBFS (lin %)"
            .format(db.asInteger, current_amp_lin.round(1e-6));
    };

    // ticks every 6 dB from 0 down to floor_db (== -72)
    db_ticks = Array.series(((0 - floor_db) / 6).asInteger + 1, 0, -6)
        .select({ |db| db >= floor_db });

    // ---------- window & views (compact) ----------
    window = Window(window_name, Rect(100, 100, 360, 230)).alwaysOnTop_(true);

    amp_menu_view = PopUpMenu(window, Rect(16, 16, 150, 22))
        .items_(amp_db_list.collect({ |db| "% dBFS".format(db) }))
        .action_({ |m| set_amp_db.(amp_db_list[m.value]) });

    info_view = StaticText(window, Rect(176, 16, 168, 22))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // RMS bar with Peak overlay (normalized UI fractions 0..1)
    indicator = LevelIndicator(window, Rect(16, 56, 36, 160))
        .style_(\continuous)
        .warning_(0.85)
        .critical_(0.95)
        .drawsPeak_(true);

    // ticks to the RIGHT of the meter (compact)
    ticks_view = UserView(window, Rect(58, 56, 110, 160))
        .background_(Color(0.94, 0.94, 0.96));

    // numeric readout (RMS & Peak in dBFS)
    readout_view = StaticText(window, Rect(176, 56, 168, 20))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // ticks drawing (0..-6 headroom band; -72 floor; -60 visible)
    ticks_view.drawFunc_({
        var b, w, h, y0, y_head, font;
        b = ticks_view.bounds; w = b.width; h = b.height;
        font = Font(Font.default.name, 11);

        // background
        Pen.color = Color(0.96, 0.96, 0.98);
        Pen.fillRect(Rect(0, 0, w, h));

        // headroom band (0..-6)
        y0    = y_for_db_padded.(0, h, 1);
        y_head = y_for_db_padded.(headroom_top_db, h, 1);
        Pen.color = Color(1.0, 0.8, 0.8, 0.35);
        Pen.fillRect(Rect(0, y0, w, (y_head - y0)));

        // 0 dBFS line (red)
        Pen.color = Color(0.8, 0.1, 0.1, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y0));
        Pen.lineTo(Point(w, y0));
        Pen.stroke;

        // -6 dB line
        Pen.color = Color(0.6, 0.2, 0.2, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y_head));
        Pen.lineTo(Point(w, y_head));
        Pen.stroke;

        // ticks + labels (0, -6, -12, ... down to -72)
        db_ticks.do({ |db|
            var y, major, tick_len, label, lx, ly;
            y = y_for_db_padded.(db, h, 1);
            major = (((db.asInteger % 12) == 0) or: (db == 0));
            tick_len = major.if(12, 8);
            label = "% dB".format(db.asInteger);

            Pen.color = Color(0.25, 0.25, 0.28, 1.0);
            Pen.width = 1.0;
            Pen.moveTo(Point(0, y));
            Pen.lineTo(Point(tick_len, y));
            Pen.stroke;

            Pen.color = Color(0.15, 0.15, 0.16, 1.0);
            lx = tick_len + 4;
            ly = (y - 7).clip(0, h - 14);
            Pen.stringAtPoint(label, Point(lx, ly), font);
        });
    });

    // ---------- OSC + updater ----------
    oscdef_levels = OSCdef(\md_levels, { |msg|
        // msg = [ '/md/levels', nodeID, replyID, peak, rms ]
        if (msg[2] == reply_id) {
            last_peak_lin = msg[3].asFloat.max(0);
            last_rms_lin  = msg[4].asFloat.max(0);
        };
    }, '/md/levels', s.addr);

    updater = Routine({
        var spf = 1.0 / refresh_hz;
        var min_ui = 1.0 / 160.0; // ensure 1 px visible if clamped to floor
        inf.do({
            {
                var db_rms, db_peak, p_rms, p_peak;

                db_rms  = last_rms_lin.max(1e-12).ampdb;  // dBFS
                db_peak = last_peak_lin.max(1e-12).ampdb; // dBFS

                // Normalize to UI 0..1 (0=floor, 1=0dB)
                p_rms  = db_to_ui_frac.(db_rms).clip(0, 1);
                p_peak = db_to_ui_frac.(db_peak).clip(0, 1);

                // show a 1px sliver if p_rms == 0 (below floor)
                p_rms = (p_rms <= 0).if(min_ui, p_rms);

                indicator.value_(p_rms);
                indicator.peakLevel_(p_peak);

                readout_view.string = "RMS: % dBFS | Peak: % dBFS"
                    .format(clamp_db.(db_rms).round(0.1), clamp_db.(db_peak).round(0.1));

                indicator.refresh;
                ticks_view.refresh;
            }.defer;
            spf.wait;
        });
    }).play(AppClock);

    // ---------- bring up ----------
    Ndef(ndef_name).play;
    set_amp_db.(default_db);
    amp_menu_view.value = amp_db_list.indexOf(default_db).max(0);

    window.onClose_({
        updater.stop;
        oscdef_levels.free;
        Ndef(ndef_name).stop(0.1);
        // Ndef(ndef_name).clear; // uncomment to remove definition
    });

    window.front;

    // return -> a Window
    window;
});
)
===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

   Style
   - var-first declarations in every block and function
   - lowercase names, descriptive identifiers
   - AppClock.defer for GUI updates
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/out/sanityTestsWithNdefs_v0.3.scd =====
// sanityTestsWithNdefs.scd
// v.0.3
// MD 20250930

(
// vars
var win, meterA, meterB;

// create display window:
win = Window("RMS Meters", Rect(100, 100, 300, 400)).front;
win.layout = HLayout(  // Horizontal layout for left/right panes
    VLayout(  // Left pane
        StaticText().string_("Sink A").align_(\center),
        meterA = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)  // resize code 1: fixed dimensions
		.fixedWidth_(30)
    ).margins_(5).spacing_(5),   // Outline: margins create visible border

    VLayout(  // Right pane
        StaticText().string_("Sink B").align_(\center),
        meterB = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)
		.fixedWidth_(30)
    ).margins_(5).spacing_(5)
);

// create Ndef sources:
Ndef(\srcA, {PinkNoise.ar(0.1 ! 2)});
Ndef(\srcB, {SinOsc.ar([300,301], mul:0.2)});
Ndef(\srcC, {SinOsc.ar([250,301], mul:0.2)});

// Sink Ndefs with SendPeakRMS monitoring
Ndef(\sinkA, {
    var sig = Ndef(\srcA).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // 20Hz for meters
    sig;
});

Ndef(\sinkB, {
    var sig = Ndef(\srcB).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
    sig;
});

// Fast OSCdef responders for meters (20Hz updates)
OSCdef(\rmsAMeter, {|msg|
    // msg[3] = replyID, msg[4] = numChannels, msg[5] = peak, msg[6] = RMS
    {meterA.value = msg[6]}.defer;  // Use RMS value
}, '/peakrmsA');

OSCdef(\rmsBMeter, {|msg|
    {meterB.value = msg[6]}.defer;
}, '/peakrmsB');

// Slow responders for console printing (1Hz)
~printCounterA = 0;
~printCounterB = 0;

OSCdef(\rmsAConsole, {|msg|
    ~printCounterA = ~printCounterA + 1;
    if(~printCounterA >= 20, {  // Print every 20th message (20Hz / 20 = 1Hz)
        "sinkA RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        ~printCounterA = 0;
    });
}, '/peakrmsA');

OSCdef(\rmsBConsole, {|msg|
    ~printCounterB = ~printCounterB + 1;
    if(~printCounterB >= 20, {
        "sinkB RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        ~printCounterB = 0;
    });
}, '/peakrmsB');

// Cleanup when window closes
win.onClose = {
    OSCdef(\rmsAMeter).free;
    OSCdef(\rmsBMeter).free;
    OSCdef(\rmsAConsole).free;
    OSCdef(\rmsBConsole).free;
};

// Play the sinks
Ndef(\sinkA).play;
Ndef(\sinkB).play;
)
===== _isolated_tests_and_experiments/out/simpleNdefOperations.scd =====
// sanityTestsWithNdefs.scd
// v.0.2
// MD 20250930

(
// vars
var win, meterA, meterB;

// create display window:
win = Window("RMS Meters", Rect(100, 100, 300, 400)).front;
win.layout = HLayout(  // Horizontal layout for left/right panes
    VLayout(  // Left pane
        StaticText().string_("Sink A").align_(\center),
        meterA = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .minHeight_(200)    // Control meter height
            .minWidth_(50)      // Control meter width
    ).margins_(5).spacing_(5),   // Outline: margins create visible border

    VLayout(  // Right pane
        StaticText().string_("Sink B").align_(\center),
        meterB = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .minHeight_(200)
            .minWidth_(50)
    ).margins_(5).spacing_(5)
);

// create Ndef sources:
Ndef(\srcA, {PinkNoise.ar(0.1 ! 2)});
Ndef(\srcB, {SinOsc.ar([300,301], mul:0.2)});
Ndef(\srcC, {SinOsc.ar([250,301], mul:0.2)});

// Sink Ndefs with SendPeakRMS monitoring
Ndef(\sinkA, {
    var sig = Ndef(\srcA).ar;
    // SendPeakRMS sends both peak and RMS values
    // Arguments: signal, replyRate (Hz), peakLag, OSC address, replyID
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // 20Hz for meters
    sig;
});

Ndef(\sinkB, {
    var sig = Ndef(\srcB).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
    sig;
});

// Fast OSCdef responders for meters (20Hz updates)
OSCdef(\rmsAMeter, {|msg|
    // msg[3] = replyID, msg[4] = numChannels, msg[5] = peak, msg[6] = RMS
    {meterA.value = msg[6]}.defer;  // Use RMS value
}, '/peakrmsA');

OSCdef(\rmsBMeter, {|msg|
    {meterB.value = msg[6]}.defer;
}, '/peakrmsB');

// Slow responders for console printing (1Hz)
// We'll use a simple counter to print every Nth update
~printCounterA = 0;
~printCounterB = 0;

OSCdef(\rmsAConsole, {|msg|
    ~printCounterA = ~printCounterA + 1;
    if(~printCounterA >= 20, {  // Print every 20th message (20Hz / 20 = 1Hz)
        "sinkA RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        ~printCounterA = 0;
    });
}, '/peakrmsA');

OSCdef(\rmsBConsole, {|msg|
    ~printCounterB = ~printCounterB + 1;
    if(~printCounterB >= 20, {
        "sinkB RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        ~printCounterB = 0;
    });
}, '/peakrmsB');

// Cleanup when window closes
win.onClose = {
    OSCdef(\rmsAMeter).free;
    OSCdef(\rmsBMeter).free;
    OSCdef(\rmsAConsole).free;
    OSCdef(\rmsBConsole).free;
};

// Play the sinks
Ndef(\sinkA).play;
Ndef(\sinkB).play;
)
===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/commands.scd =====
// Switch sources
~setSourceA.(\tone_m6);
~setSourceB.(\bp_sweep);

// Live tweaks
Ndef(\tone_m12).set(\freq, 100);
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);

// Pane text
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag, "Re-evaluated quick helpers at " ++ Date.getDate.stamp);
~lt_send.(\left,  "Chain A: ~setSourceA.(\\tone_m6)");
~lt_send.(\right, "Chain B: ~setSourceB.(\\bp_sweep)");

===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.3 — simpler bind + HUD mapper; only GUI responders are replaced
// MD 20251001

/* Purpose
 - Calibrate existing "Layout Test" meters using a perceptual dB mapping (top/floor/gamma).
 - Rebind only the GUI OSCdefs to apply mapping; preserve console OSCdefs untouched.
 - Provide ~hud_set/~hud_preview/~hud_print and a reusable ~hud_map_linear_to_ui.
 Style
 - var-first declarations; lowercase names; no non-local returns; AppClock.defer for GUI.
*/

(
var win, root, meter_left, meter_right;
var find_window_by_name, find_level_by_pane_label;
var install_mapped_gui, value_from_msg;

// Defaults (RMS dB): top = -6 dB, floor = -60 dB, gamma = 1.0
if(~hud_topDb.isNil)  { ~hud_topDb  = -6.0 };
if(~hud_floorDb.isNil){ ~hud_floorDb = -60.0 };
if(~hud_gamma.isNil)  { ~hud_gamma  = 1.0 };

// Linear (0..1) -> UI (0..1) using dB window and gamma
~hud_map_linear_to_ui = { |lin|
    var v, vdb, top, floor, g, u;
    v = lin.max(1e-9);
    vdb = v.ampdb;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    g = ~hud_gamma.asFloat.max(1e-6);
    vdb = vdb.clip(floor, top);
    u = (vdb - floor) / (top - floor);
    u = u.pow(g);
    u.clip(0.0, 1.0)
};

// Small HUD helpers
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol; v = value.asFloat;
    if(k == \top)   { ~hud_topDb = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma = v.max(1e-6) };
    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb; ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ")").postln;
    };
    ("HUD mapping set: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, db_clip, u;
    top = ~hud_topDb.asFloat; floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);
    lin = db.dbamp.clip(1e-9, 1.0);
    db_clip = lin.ampdb.clip(floor, top);
    u = (db_clip - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

// --- Locate meters in the existing window ---
find_window_by_name = { |name| Window.allWindows.detect({ |w| w.name == name }) };

find_level_by_pane_label = { |root_view, pane_label|
    var found_static, result, search_static, search_under_parent;
    found_static = nil; result = nil;

    search_static = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == pane_label }) {
                found_static = child;
            }{
                search_static.(child);
            };
            i = i + 1;
        });
    };

    search_under_parent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child };
            }{
                search_under_parent.(child);
            };
            i = i + 1;
        });
    };

    search_static.(root_view);
    if(found_static.notNil and: { found_static.parent.notNil }) {
        search_under_parent.(found_static.parent);
    };
    result
};

// Bind window + meters
win = find_window_by_name.("Layout Test");
if(win.isNil) {
    "Layout Test window not found. Open the window script first.".postln;
}{
    root = win.view;
    meter_left  = find_level_by_pane_label.(root, "Top Left Pane");
    meter_right = find_level_by_pane_label.(root, "Top Right Pane");
};

// --- Rebind only GUI OSCdefs to insert mapping ---
value_from_msg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat };
    };
    v.clip(0.0, 1.0)
};

install_mapped_gui = {
    var a, b;
    a = OSCdef(\rmsA_toGUI); if(a.notNil) { a.free };
    b = OSCdef(\rmsB_toGUI); if(b.notNil) { b.free };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v = value_from_msg.(msg);
        ui = ~hud_map_linear_to_ui.(v);
        { meter_left.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v = value_from_msg.(msg);
        ui = ~hud_map_linear_to_ui.(v);
        { meter_right.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

if(meter_left.notNil and: { meter_right.notNil }) {
    install_mapped_gui.();
}{ "Meter calibration patch not installed (meters not bound).".postln };

~hud_print.();
)

===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.3 — programmatic tone set, compact pane binding, same one-liner API
// MD 20251001

/* Purpose
 - Provide calibrated tone sources, pulse sources, and a sweeping band-pass noise.
 - Offer single-line pane text updates targeting the existing "Layout Test" panes.
 - Keep your ~setSourceA/~setSourceB and avoid rebuilding unless asked.
 Style
 - var-first declarations; lowercase identifiers; AppClock.defer for GUI updates.
 - Sources are Ndefs; sinks/processors use \in.ar(2) (handled in the window script).
*/

(
var make_cal_tones, make_pulses, make_bp_sweep;
var db_list, make_tone;
var bind_panes, find_window_by_name, find_text_by_pane_label;

// --- Calibration tones (stereo) programmatically
db_list = [-6, -12, -18, -24, -30];

make_tone = { |name_sym, db_val|
    var amp;
    amp = db_val.dbamp;
    Ndef(name_sym, {
        var freq, sig;
        freq = \freq.kr(100).max(10);
        sig = SinOsc.ar([freq, freq], 0, amp);
        sig
    });
};

make_cal_tones = {
    make_tone.(\tone_m0,    0);
    db_list.do({ |db| make_tone.(("tone_m" ++ db.neg.asInteger).asSymbol, db) });
    make_tone.(\tone_m128, -128);
};

// --- Pulses
make_pulses = {
    // Clicks
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08);
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env;
        sig
    });

    // Decaying tone "ping"
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train gate on noise
    Ndef(\pulse_train, {
        var rate, duty, gate_ctl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gate_ctl = LFPulse.kr(rate, 0, duty).lag(0.001);
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gate_ctl;
        sig
    });
};

// --- Band-passed noise with sweeping center frequency
make_bp_sweep = {
    Ndef(\bp_sweep, {
        var base, range, rate, center, rq, src, sig;
        base = \base.kr(200).clip(20, 10000);
        range = \range.kr(5000).clip(0, 18000);
        rate = \rate.kr(0.07).clip(0.005, 2.0);
        center = base + (range * (LFTri.kr(rate).range(0, 1)));
        rq = \rq.kr(0.15).clip(0.01, 0.9);
        src = PinkNoise.ar([0.5, 0.5]);
        sig = BPF.ar(src, center, rq) * 1.2;
        sig
    });
};

// --- Pane text helpers (bind once, then ~lt_send.(\left, "…"))
find_window_by_name = { |target|
    var match;
    match = Window.allWindows.detect({ |w| w.name == target });
    match
};

find_text_by_pane_label = { |root_view, pane_label|
    var found_static, result, search_static, collect_text;
    found_static = nil; result = nil;

    search_static = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == pane_label }) {
                found_static = child;
            }{
                search_static.(child);
            };
            i = i + 1;
        });
    };

    collect_text = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(TextView)) {
                if(result.isNil) { result = child };
            }{
                collect_text.(child);
            };
            i = i + 1;
        });
    };

    search_static.(root_view);
    if(found_static.notNil and: { found_static.parent.notNil }) {
        collect_text.(found_static.parent);
    };
    result
};

bind_panes = {
    var win, root, left, right, system, diag, choices, recv, map;
    win = find_window_by_name.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open the window script first.".postln;
    }{
        root    = win.view;
        left    = find_text_by_pane_label.(root, "Top Left Pane");
        right   = find_text_by_pane_label.(root, "Top Right Pane");
        system  = find_text_by_pane_label.(root, "System State");
        diag    = find_text_by_pane_label.(root, "Diagnostic Messages");
        choices = find_text_by_pane_label.(root, "Choices");
        recv    = find_text_by_pane_label.(root, "Receiving Commands");
        map = IdentityDictionary[
            \left   -> left,
            \right  -> right,
            \system -> system,
            \diag   -> diag,
            \choices-> choices,
            \recv   -> recv
        ];
        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public API: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |pane_key, a_string|
    var panes, view_to_set, text_string, win;
    panes = ~lt_panes;
    text_string = a_string.asString;
    if(panes.isNil) { bind_panes.(); panes = ~lt_panes };
    if(panes.notNil) {
        view_to_set = panes[pane_key.asSymbol];
        if(view_to_set.notNil) {
            { view_to_set.string_(text_string) }.defer;
        }{
            win = find_window_by_name.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found (bound keys: %)".format(pane_key, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
make_cal_tones.();
make_pulses.();
make_bp_sweep.();

"Quick changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
)
===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.9 — clearer layout, unified helpers, same behavior
// MD 20251001

/* Purpose
 - Create the "Layout Test" window with top-left/right text + meters and four lower panes.
 - Build initial A/B chains (srcA → outA, srcB → outB), sinks meter via SendPeakRMS.
 - Provide setSourceA/B, decimated console prints (ampdb), and robust meter value extraction.
 Style
 - var-first declarations everywhere; lowercase names; no non-local returns (^).
 - GUI updates via AppClock.defer; sinks read from \in.ar(2).
 - Use Ndef(left) <<> Ndef(right); return -> a Window.
*/

(
var window, make_pane, pane_color;
var top_left_text, top_left_meter, top_right_text, top_right_meter;
var osc_gui_a, osc_gui_b, osc_con_a, osc_con_b;
var chain_a, chain_b, ensure_stereo, rebuild_chain, chain_to_string;
var set_source_a, set_source_b, value_from_msg;
var dec_a = 0, dec_b = 0, dump_a = true, dump_b = true;

var existing;

// --- GUI ---

// --- safely close any prior "Layout Test" windows -- NOT SURE IF STILL NEEDED
existing = Window.allWindows.reject({ |x| x.isNil });
existing.do({ |w|
    if(w.isKindOf(Window) and: { w.name == "Layout Test" }, { w.close });
});


Window.allWindows.do({ | w | if(w.name == "Layout Test", { w.close }) });
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

pane_color = Color(0.0, 0.35, 0.0);

make_pane = { |content, label|
    var label_view, inner, pane, inset;
    label_view = StaticText().string_(label).align_(\center)
        .stringColor_(Color.white).background_(pane_color);
    inner = VLayout(label_view, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = pane_color;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        make_pane.(HLayout(
            top_left_text  = TextView().editable_(false),
            top_left_meter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        make_pane.(HLayout(
            top_right_text  = TextView().editable_(false),
            top_right_meter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// --- Audio + chains + OSC ---
osc_gui_a = \rmsA_toGUI;
osc_gui_b = \rmsB_toGUI;
osc_con_a = \rmsA_console;
osc_con_b = \rmsB_console;

Server.default.waitForBoot({
    // SOURCES (stereo)
    Ndef(\srcZ, { Silent.ar(numChannels: 1) }); // spare
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // SINKS (must read \in.ar(2)), meter to GUI
    // replyIDs A=1, B=2
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });
    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // Chain helpers
    ensure_stereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);
        };
    };

    chain_to_string = { |an_array|
        var forward;
        forward = an_array.copy.reverse; // [source ... sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuild_chain = { |an_array|
        var i;
        i = 0;
        if(an_array.size < 2) {
            "need at least [sink, source]".postln;
        }{
            an_array.do(ensure_stereo);
            i = 0;
            while({ i < (an_array.size - 1) }, {
                Ndef(an_array[i]) <<> Ndef(an_array[i + 1]); // left receives right at \in
                i = i + 1;
            });
            Ndef(an_array[0]).play(numChannels: 2);
        };
    };

    // Initial chains
    chain_a = [\outA, \srcA];
    chain_b = [\outB, \srcB];
    rebuild_chain.(chain_a);
    rebuild_chain.(chain_b);

    // Robust meter extractor: last numeric = final RMS from SendPeakRMS
    value_from_msg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) { v = msg[sz - 1].asFloat };
        };
        v.clip(0.0, 1.0)
    };

    // Rebind OSC (avoid duplicates on re-eval)
    { OSCdef(osc_gui_a).free; OSCdef(osc_gui_b).free; OSCdef(osc_con_a).free; OSCdef(osc_con_b).free; }.value;

    // GUI meters @ 20 Hz
    OSCdef(osc_gui_a, { |msg| { top_left_meter.value_(value_from_msg.(msg)) }.defer }, '/peakrmsA');
    OSCdef(osc_gui_b, { |msg| { top_right_meter.value_(value_from_msg.(msg)) }.defer }, '/peakrmsB');

    // Console prints (≈1 Hz via simple decimation)
    OSCdef(osc_con_a, { |msg|
        var v;
        if(dump_a) { "A first msg: %".format(msg).postln; dump_a = false }; // just the first message to see the actual formatting of it
        dec_a = dec_a + 1;
        if(dec_a >= 20) {
            v = value_from_msg.(msg).max(1e-6); // prevent ampdb on 0 which would be inf
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
			dec_a = 0; // e.g "A level: -38.5 dB (0.012)"
        };
    }, '/peakrmsA');

    OSCdef(osc_con_b, { |msg|
        var v;
        if(dump_b) { "B first msg: %".format(msg).postln; dump_b = false };
        dec_b = dec_b + 1;
        if(dec_b >= 20) {
            v = value_from_msg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
            dec_b = 0;
        };
    }, '/peakrmsB');

    // Paint initial chain strings
    {
        top_left_text.string_(chain_to_string.(chain_a));
        top_right_text.string_(chain_to_string.(chain_b));
    }.defer;
});

// Convenience: change only the tail (source) of each chain
set_source_a = { |src_sym|
    var new_sym;
    new_sym = src_sym.asSymbol;
    chain_a[chain_a.size - 1] = new_sym;
    rebuild_chain.(chain_a);
    { top_left_text.string_(chain_to_string.(chain_a)) }.defer;
};
set_source_b = { |src_sym|
    var new_sym;
    new_sym = src_sym.asSymbol;
    chain_b[chain_b.size - 1] = new_sym;
    rebuild_chain.(chain_b);
    { top_right_text.string_(chain_to_string.(chain_b)) }.defer;
};
~setSourceA = set_source_a;
~setSourceB = set_source_b;

// Cleanup
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(osc_gui_a).free;
    OSCdef(osc_gui_b).free;
    OSCdef(osc_con_a).free;
    OSCdef(osc_con_b).free;
};

window  // -> a Window
)
===== _isolated_tests_and_experiments/out/testNdefsMetersWindow_v0.5.scd =====
// WindowLayout_Grid_WithNdefsMeters.scd
// v1.0 - Minimal dark-green grid + Ndefs + live meters (sinkA/B) + chain labels
// MD 20250930

/*
Purpose:
  - Create the same window as your minimal dark-green grid.
  - Define Ndefs (srcA, srcB, sinks with SendPeakRMS).
  - Drive the left/right meters from sinkA/sinkB RMS.
  - Show chain text in the top-left / top-right panes.

Style:
  - var-first, descriptive names, no non-local returns, no server.sync.
  - Uses OSCdef responders and .defer for GUI safety.
  - Returns '-> a Window'.
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var chainAString, chainBString;
var oscNameA, oscNameB;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// simple chain labels (edit any time)
chainAString = "srcA → sinkA";
chainBString = "srcB → sinkB";

// OSC address (and names) for meters
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        // LEFT: TextView + LevelIndicator (we keep references)
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        // RIGHT: TextView + LevelIndicator (keep references)
        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// set chain text in top panes
topLeftText.string_(chainAString);
topRightText.string_(chainBString);

// ---------- audio graph + metering ----------
Server.default.waitForBoot({
    // sources
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });                  // stereo pink at modest level
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });        // stereo close tones
    Ndef(\srcC, { SinOsc.ar([167, 171], mul: 0.20) });        // stereo close tones

/*    // sinks with SendPeakRMS -> GUI (20 Hz is light but responsive)
    Ndef(\sinkA, {
        var sig = Ndef(\srcA).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });*/

// Create them 2ch before we do anything else
	Ndef(\sinkA, {Silent.ar(2)});
    Ndef(\sinkB, {Silent.ar(2)});


	    Ndef(\sinkA, {
        var sig = Ndef(\srcB).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 2);
        sig
    });

    Ndef(\sinkB, {
        var sig = Ndef(\srcB).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // play sinks
    Ndef(\sinkA).play;
    Ndef(\sinkB).play;

    // meter responders (RMS at msg[6]); defer to GUI thread
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(msg[6]) }.defer;  }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(msg[6]) }.defer; }, '/peakrmsB');
});

// cleanup when window closes (stop sinks + free responders; leave sources defined)
window.onClose = {
    Ndef(\sinkA).stop;
    Ndef(\sinkB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
};

window  // -> a Window
)

/*(Ndef(\srcA).bus).postln;
(Ndef(\srcB).bus).postln;
(Ndef(\srcC).bus).postln;
(Ndef(\sinkA).bus).postln;
(Ndef(\sinkB).bus).postln;

Ndef(\sinkA).play;
Ndef(\sinkA).stop;

Ndef(\sinkB).play;
Ndef(\sinkB).stop;

Ndef(\sinkB) <<> Ndef(\srcA);
Ndef(\sinkB) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

Ndef(\sinkA) <<> Ndef(\srcA);
Ndef(\sinkA) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);*/
===== _isolated_tests_and_experiments/out/testNdefsMetersWindow_v0.6.scd =====
// WindowLayout_Grid_WithNdefsMeters.scd
// v1.0 - Minimal dark-green grid + Ndefs + live meters (sinkA/B) + chain labels
// MD 20250930

/*
Purpose:
  - Create the same window as your minimal dark-green grid.
  - Define Ndefs (srcA, srcB, sinks with SendPeakRMS).
  - Drive the left/right meters from sinkA/sinkB RMS.
  - Show chain text in the top-left / top-right panes.

Style:
  - var-first, descriptive names, no non-local returns, no server.sync.
  - Uses OSCdef responders and .defer for GUI safety.
  - Returns '-> a Window'.
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var chainAString, chainBString;
var oscNameA, oscNameB;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// simple chain labels (edit any time)
chainAString = "srcA → sinkA";
chainBString = "srcB → sinkB";

// OSC address (and names) for meters
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        // LEFT: TextView + LevelIndicator (we keep references)
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        // RIGHT: TextView + LevelIndicator (keep references)
        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// set chain text in top panes
topLeftText.string_(chainAString);
topRightText.string_(chainBString);

// ---------- audio graph + metering ----------
Server.default.waitForBoot({
    // sources
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });                  // stereo pink at modest level
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });        // stereo close tones
    Ndef(\srcC, { SinOsc.ar([167, 171], mul: 0.20) });        // stereo close tones

/*    // sinks with SendPeakRMS -> GUI (20 Hz is light but responsive)
    Ndef(\sinkA, {
        var sig = Ndef(\srcA).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });*/

// Create them 2ch before we do anything else
	Ndef(\sinkA, {Silent.ar(2)});
    Ndef(\sinkB, {Silent.ar(2)});



	//Ndef(\p1, { var inSig; inSig = \in.ar(2) * 0.5; inSig });

	Ndef(\sinkA, {
        var sig;
		sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 2);
        sig
    });

    Ndef(\sinkB, {
        var sig = Ndef(\srcB).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // play sinks
    Ndef(\sinkA).play;
    Ndef(\sinkB).play;

    // meter responders (RMS at msg[6]); defer to GUI thread
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(msg[6]) }.defer;  }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(msg[6]) }.defer; }, '/peakrmsB');
});

// cleanup when window closes (stop sinks + free responders; leave sources defined)
window.onClose = {
    Ndef(\sinkA).stop;
    Ndef(\sinkB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
};

window  // -> a Window
)

/*

(Ndef(\srcA).bus).postln;
(Ndef(\srcB).bus).postln;
(Ndef(\srcC).bus).postln;
(Ndef(\sinkA).bus).postln;
(Ndef(\sinkB).bus).postln;

Ndef(\sinkA).play;
Ndef(\sinkA).stop;

Ndef(\sinkB).play;
Ndef(\sinkB).stop;

Ndef(\sinkB) <<> Ndef(\srcA);
Ndef(\sinkB) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

Ndef(\sinkA) <<> Ndef(\srcA);
Ndef(\sinkA) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

*/
===== _isolated_tests_and_experiments/out/WindowLayout_Grid_Minimal.scd =====
// WindowLayout_Grid_Minimal.scd
// v1.1 - Ultra-simple 3x2 grid with debug outlines + coloured labels
// MD 20250930

(
var debugLayout = true;

var window, grid;
var makePane;

makePane = { |content, label, color|
    var strokeColor = if(debugLayout, { color }, { Color.gray(0.55) });
    var labelText = if(debugLayout, { label }, { "---" });
    var labelView = StaticText()
        .string_(labelText)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(22);
    var inner = VLayout(labelView, content).margins_(8).spacing_(6);
    var pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var w = v.bounds.width, h = v.bounds.height, inset = 0.5;
        Pen.use {
            Pen.color = strokeColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, w - 1, h - 1));
            Pen.stroke;
        };
    });
    pane
};

Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

grid = GridLayout.rows(
    [makePane.(HLayout(TextView(), LevelIndicator().style_(\led).fixedWidth_(30)), "Top Left", Color.blue),
     makePane.(HLayout(TextView(), LevelIndicator().style_(\led).fixedWidth_(30)), "Top Right", Color.blue)],
    [makePane.(TextView(), "System State", Color.green),
     makePane.(TextView(), "Diagnostics", Color.green)],
    [makePane.(TextView(), "Choices", Color.green),
     makePane.(TextView(), "Receiving", Color.green)]
).margins_(12).spacing_(12);

window.layout = grid;
window
)

===== _isolated_tests_and_experiments/out/WindowLayout_Grid_Simple.scd =====
// WindowLayout_Grid_Simple.scd
// v1.0 - Minimal grid with debug outlines + coloured labels
// MD 20250930-1216

/*
Purpose:
  - Minimal 3x2 GridLayout with thin outlines and coloured pane labels controlled by debugLayout.

Style:
  - var-first declarations, descriptive names, no non-local returns.
  - Returns '-> a Window'.
*/

(
var debugLayout = true;

var window, grid;

var topLeftText, topLeftMeter, topRightText, topRightMeter;
var systemStateText, diagnosticMessagesText;
var choicesText, receivingCommandsText;

var outerMargin, cellSpacing, paneMargin, paneSpacing, labelFixedHeight, strokeWidth;

var makePane;
var topLeftPane, topRightPane, systemStatePane, diagnosticPane, choicesPane, receivingPane;

// geometry
outerMargin = 12;
cellSpacing = 12;
paneMargin = 8;
paneSpacing = 6;
labelFixedHeight = 22;
strokeWidth = 1;

// helper: pane with coloured label + thin outline (local coords)
makePane = { |contentLayout, labelString, debugColor|
    var strokeColor, labelStringToShow, labelView, innerLayout, containerView;

    strokeColor = if(debugLayout, { debugColor }, { Color.gray(0.55) });
    labelStringToShow = if(debugLayout, { labelString }, { "---" });

    labelView = StaticText()
        .string_(labelStringToShow)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(labelFixedHeight);

    innerLayout = VLayout(
        labelView,
        contentLayout
    )
    .margins_(paneMargin)
    .spacing_(paneSpacing);

    containerView = UserView()
        .layout_(innerLayout);

    containerView.drawFunc_({ |view|
        var w, h, inset;
        w = view.bounds.width;
        h = view.bounds.height;
        inset = strokeWidth * 0.5;  // crisp 1px

        Pen.use {
            Pen.color = strokeColor;
            Pen.width = strokeWidth;
            Pen.addRect(Rect(inset, inset, w - (2 * inset), h - (2 * inset)));
            Pen.stroke;
        };
    });

    containerView
};

// close any existing window named "Layout Test"
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// panes
topLeftPane = makePane.(
    VLayout(
        HLayout(
            topLeftText = TextView(),
            topLeftMeter = LevelIndicator().style_(\led).fixedWidth_(30)
        )
    ),
    "Top Left Pane",
    Color.red(1.0, 0.55)
);

topRightPane = makePane.(
    VLayout(
        HLayout(
            topRightText = TextView(),
            topRightMeter = LevelIndicator().style_(\led).fixedWidth_(30)
        )
    ),
    "Top Right Pane",
    Color.blue(1.0, 0.55)
);

systemStatePane = makePane.(
    VLayout(
        StaticText().string_("System State").align_(\center),
        systemStateText = TextView()
    ),
    "System State",
    Color.green(1.0, 0.55)
);

diagnosticPane = makePane.(
    VLayout(
        StaticText().string_("Diagnostic Messages").align_(\center),
        diagnosticMessagesText = TextView()
    ),
    "Diagnostic Messages",
    Color.yellow(1.0, 0.6)
);

choicesPane = makePane.(
    VLayout(
        StaticText().string_("Choices").align_(\center),
        choicesText = TextView()
    ),
    "Choices",
    Color.magenta(1.0, 0.5)
);

receivingPane = makePane.(
    VLayout(
        StaticText().string_("Receiving Commands").align_(\center),
        receivingCommandsText = TextView()
    ),
    "Receiving Commands",
    Color.cyan(1.0, 0.6)
);

// grid (3 rows x 2 columns) with shared column boundaries
grid = GridLayout.rows(
    [topLeftPane,     topRightPane],
    [systemStatePane, diagnosticPane],
    [choicesPane,     receivingPane]
)
.margins_(outerMargin)
.spacing_(cellSpacing);

window.layout = grid;

window  // -> a Window
)

===== _isolated_tests_and_experiments/out/WindowLayoutTest_20250930_Grid.scd =====
// WindowLayoutTest_20250930_Grid.scd
// v1.4 - GridLayout (3x2), crisp borders, coloured labels, correct var placement
// MD 20250930-1210

/*
Purpose:
  - Fix the var-placement syntax error and ensure a proper GridLayout with shared columns.
  - Provide thin (1px) outlines and coloured pane-name bars in debug mode.
  - Draw borders in local coordinates to avoid offsets and “overlap” artifacts.

Style:
  - var-first declarations, descriptive lowercase names, no non-local returns.
  - Returns '-> a Window'.
*/

(
var debugLayout = true;
var outlineContentOnly = false;   // true = border excludes label; false = includes label

// ---- declare ALL vars up front (SuperCollider requirement) ----
var window, grid;

var topLeftText, topLeftMeter, topRightText, topRightMeter;
var systemStateText, diagnosticMessagesText;
var choicesText, receivingCommandsText;

var outerMargin, cellSpacing, paneMargin, paneSpacing, labelFixedHeight, strokeWidth, strokeInset;

var makePane;
var topLeftPane, topRightPane, systemStatePane, diagnosticPane, choicesPane, receivingPane;

// ---- geometry constants ----
outerMargin = 12;       // margins around the entire grid
cellSpacing = 12;       // spacing between grid cells
paneMargin = 8;         // inner padding inside each pane
paneSpacing = 6;        // gap between label and content inside a pane
labelFixedHeight = 22;  // stable label height so borders don't jump
strokeWidth = 1;        // thin outline
strokeInset = strokeWidth * 0.5;

// ---- helper: construct one pane (UserView) with label bar + thin outline ----
makePane = { |contentLayout, labelString, debugColor|
    var strokeColor, labelStringToShow, labelView, innerLayout, containerView;

    strokeColor = if(debugLayout, { debugColor }, { Color.gray(0.55) });
    labelStringToShow = if(debugLayout, { labelString }, { "---" });

    // Label bar
    labelView = StaticText()
        .string_(labelStringToShow)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(labelFixedHeight)
        .resize_(3); // fill horizontally

    // Stack label above the content
    innerLayout = VLayout(
        labelView,
        contentLayout
    )
    .margins_(paneMargin)
    .spacing_(paneSpacing);

    // Container: fills its grid cell and draws its own outline in LOCAL coordinates
    containerView = UserView()
        .layout_(innerLayout)
        .resize_(3); // fill both directions

    containerView.drawFunc_({ |view|
        var w, h, rect;
        w = view.bounds.width;
        h = view.bounds.height;

        if(outlineContentOnly, {
            // outline content area only (exclude the label bar)
            rect = Rect(
                paneMargin + strokeInset,
                paneMargin + labelFixedHeight + paneSpacing + strokeInset,
                w - (2 * paneMargin) - (2 * strokeInset),
                h - (2 * paneMargin) - labelFixedHeight - paneSpacing - (2 * strokeInset)
            );
        }, {
            // outline the entire pane (including the label bar)
            rect = Rect(strokeInset, strokeInset, w - (2 * strokeInset), h - (2 * strokeInset));
        });

        Pen.use {
            Pen.color = strokeColor;
            Pen.width = strokeWidth;
            Pen.addRect(rect);
            Pen.stroke;
        };
    });

    containerView
};

// ---- close any existing window with the same name ----
Window.allWindows.do({ |w|
    if(w.name == "Layout Test", { w.close });
});

// ---- create window ----
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// ---- build pane contents ----
topLeftPane = makePane.(
    VLayout(
        HLayout(
            topLeftText = TextView()
                .string_("Top Left Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topLeftMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)  // keep rail width fixed
                .resize_(2)       // vertical stretch only
        )
    ),
    "Top Left Pane",
    Color.red(1.0, 0.55)
);

topRightPane = makePane.(
    VLayout(
        HLayout(
            topRightText = TextView()
                .string_("Top Right Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topRightMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)
                .resize_(2)
        )
    ),
    "Top Right Pane",
    Color.blue(1.0, 0.55)
);

systemStatePane = makePane.(
    VLayout(
        StaticText().string_("System State").align_(\center).resize_(3),
        systemStateText = TextView()
            .string_("System state info here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "System State",
    Color.green(1.0, 0.55)
);

diagnosticPane = makePane.(
    VLayout(
        StaticText().string_("Diagnostic Messages").align_(\center).resize_(3),
        diagnosticMessagesText = TextView()
            .string_("Diagnostic messages here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Diagnostic Messages",
    Color.yellow(1.0, 0.6)
);

choicesPane = makePane.(
    VLayout(
        StaticText().string_("Choices").align_(\center).resize_(3),
        choicesText = TextView()
            .string_("Choices text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Choices",
    Color.magenta(1.0, 0.5)
);

receivingPane = makePane.(
    VLayout(
        StaticText().string_("Receiving Commands").align_(\center).resize_(3),
        receivingCommandsText = TextView()
            .string_("Receiving commands text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Receiving Commands",
    Color.cyan(1.0, 0.6)
);

// ---- compose a 3x2 grid and assign to the window ----
// Safer, version-agnostic approach: create the grid and add cells explicitly.
grid = GridLayout()
    .margins_(outerMargin)
    .spacing_(cellSpacing);

// Place panes by (row, col)
grid.add(topLeftPane,     0, 0);
grid.add(topRightPane,    0, 1);
grid.add(systemStatePane, 1, 0);
grid.add(diagnosticPane,  1, 1);
grid.add(choicesPane,     2, 0);
grid.add(receivingPane,   2, 1);

// Optional (if available in your SC build): set column/row stretch to balance space
// (safe to comment out if your SC doesn't support these)
// grid.setColumnStretch(0, 1);
// grid.setColumnStretch(1, 1);
// grid.setRowStretch(0, 2);   // make the top row taller if you wish
// grid.setRowStretch(1, 1);
// grid.setRowStretch(2, 1);

window.layout = grid;

if(debugLayout) {
    "DEBUG ON: GridLayout aligned; coloured labels + crisp thin outlines.".postln;
} {
    "DEBUG OFF: GridLayout aligned; neutral labels + thin grey outlines.".postln;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/LayoutTest_Quick_ChainChanges_v1.0.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.0 - one-liners to change the running Layout Test chains (no new window)
// MD 20250930
/* Purpose
   - Provide single-line commands to manipulate the *existing* Layout Test session:
     • swap sources with the exported helpers (~setSourceA / ~setSourceB)
     • clear processors by reconnecting sinks directly to sources
     • optionally insert simple processors inline (define + connect) without touching the GUI setup
   - Meters and audio keep running; GUI labels will update only when using ~setSourceA/~setSourceB.

   Style
   - var-first inside any inline Ndef functions
   - Ndef(left) <<> Ndef(right)
   - sinks/processors read \in.ar(2)
   - no server.sync, no ^ non-local returns
*/

// -------------------------------------------------------------
// A) Swap sources (updates the chain labels in the Layout Test GUI)
// -------------------------------------------------------------

~setSourceA.(\srcA);
~setSourceA.(\srcB);
~setSourceA.(\srcC);

~setSourceB.(\srcA);
~setSourceB.(\srcB);
~setSourceB.(\srcC);

// -------------------------------------------------------------
// B) Clear/force direct wiring (does NOT change the GUI text labels)
//    - Reconnect sinks directly to specific sources
//    - Safe to use anytime; it overrides any intermediate processors
// -------------------------------------------------------------

(Ndef(\outA) <<> Ndef(\srcA); Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\srcB); Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\srcC); Ndef(\outA).play(numChannels: 2););

(Ndef(\outB) <<> Ndef(\srcA); Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\srcB); Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\srcC); Ndef(\outB).play(numChannels: 2););

// -------------------------------------------------------------
// C) Quick inline processors (define if needed, then connect)
//    - These are one-liners that (re)define a processor and rebuild the A/B chain explicitly.
//    - GUI text won’t reflect processors; meters will show the result.
// -------------------------------------------------------------

// A: outA <- p_gain <- srcA
(Ndef(\p_gain, { var inSig, amp; inSig = \in.ar(2); amp = \amp.kr(0.8).clip(0.0, 2.0); inSig * amp }); Ndef(\outA) <<> Ndef(\p_gain); Ndef(\p_gain) <<> Ndef(\srcA); Ndef(\outA).play(numChannels:2););

// A: outA <- p_tanh <- srcB
(Ndef(\p_tanh, { var inSig, drive; inSig = \in.ar(2); drive = \drive.kr(1.2).clip(0.1, 5.0); (inSig * drive).tanh * 0.9 }); Ndef(\outA) <<> Ndef(\p_tanh); Ndef(\p_tanh) <<> Ndef(\srcB); Ndef(\outA).play(numChannels:2););

// A: outA <- p_delay <- srcC
(Ndef(\p_delay, { var inSig, time, fb; inSig = \in.ar(2); time = \time.kr(0.25).clip(0.0, 2.0); fb = \fb.kr(0.3).clip(0.0, 0.95); (DelayC.ar(inSig, 2.0, time) * 0.7) + (inSig * (1.0 - fb)) }); Ndef(\outA) <<> Ndef(\p_delay); Ndef(\p_delay) <<> Ndef(\srcC); Ndef(\outA).play(numChannels:2););

// B: outB <- p_gain <- p_tanh <- srcA
(Ndef(\p_gain, { var inSig, amp; inSig = \in.ar(2); amp = \amp.kr(0.9).clip(0.0, 2.0); inSig * amp }); Ndef(\p_tanh, { var inSig, drive; inSig = \in.ar(2); drive = \drive.kr(1.3).clip(0.1, 5.0); (inSig * drive).tanh * 0.9 }); Ndef(\outB) <<> Ndef(\p_gain); Ndef(\p_gain) <<> Ndef(\p_tanh); Ndef(\p_tanh) <<> Ndef(\srcA); Ndef(\outB).play(numChannels:2););

// B: outB <- p_delay <- p_gain <- srcB
(Ndef(\p_delay, { var inSig, time, fb; inSig = \in.ar(2); time = \time.kr(0.33).clip(0.0, 2.0); fb = \fb.kr(0.25).clip(0.0, 0.95); (DelayC.ar(inSig, 2.0, time) * 0.7) + (inSig * (1.0 - fb)) }); Ndef(\p_gain, { var inSig, amp; inSig = \in.ar(2); amp = \amp.kr(0.7).clip(0.0, 2.0); inSig * amp }); Ndef(\outB) <<> Ndef(\p_delay); Ndef(\p_delay) <<> Ndef(\p_gain); Ndef(\p_gain) <<> Ndef(\srcB); Ndef(\outB).play(numChannels:2););

// -------------------------------------------------------------
// D) Adjust processor params live (after you’ve connected them)
// -------------------------------------------------------------

Ndef(\p_gain).set(\amp, 1.2);
Ndef(\p_gain).set(\amp, 0.6);

Ndef(\p_tanh).set(\drive, 0.9);
Ndef(\p_tanh).set(\drive, 2.0);

Ndef(\p_delay).set(\time, 0.125, \fb, 0.35);
Ndef(\p_delay).set(\time, 0.50,  \fb, 0.20);

// -------------------------------------------------------------
// E) Quick source variations (optional redefinitions)
//    - You can re-evaluate these to change how a source sounds
// -------------------------------------------------------------

Ndef(\srcA, { PinkNoise.ar(0.05 ! 2) });
Ndef(\srcB, { SinOsc.ar([220, 221], mul: 0.15) });
Ndef(\srcC, { LFSaw.ar([123, 129]).tanh * 0.20 });

// -------------------------------------------------------------
// F) Safety / recover (if you get lost, go direct and re-play)
// -------------------------------------------------------------

(Ndef(\outA) <<> Ndef(\srcA); Ndef(\outA).play(numChannels:2););
(Ndef(\outB) <<> Ndef(\srcB); Ndef(\outB).play(numChannels:2););

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/out/ChainChange_Demo_Minimal.scd =====
// ChainChange_Demo_Minimal.scd
// v1.0 - change chain sources & processors interactively; meters + chain text
// MD 20250930

/* Purpose
   - Let you interactively change JITLib chains A and B:
     • setSourceA/B to swap sources
     • appendProcessorA/B to insert processors before the source
     • removeProcessorA/B to remove a processor by symbol
     • clearProcessorsA/B to keep only [sink, source]
     • setChainA/B to replace the whole chain explicitly
   - Show current chain strings in a small GUI + live meters (SendPeakRMS).
   - Keep re-eval safe: auto-close existing window, free/stop old defs.

   Style
   - var-first declarations everywhere
   - lowercase identifiers, descriptive names
   - Ndef(left) <<> Ndef(right); sinks/processors read \in.ar(2)
   - Server.default.waitForBoot, no server.sync, AppClock.defer for GUI touches
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString, postChain, updateGui;
var setSourceA, setSourceB, appendProcessorA, appendProcessorB, removeProcessorA, removeProcessorB, clearProcessorsA, clearProcessorsB, setChainA, setChainB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Chain Change Demo", { w.close }) });

window = Window("Chain Change Demo", Rect(100, 100, 720, 300))
    .background_(Color.white)
    .front;

paneColor = Color(0.15, 0.35, 0.15);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Chain A"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Chain B")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- PROCESSORS (stereo) ---
    Ndef(\p_gain, {
        var inSig, amp;
        inSig = \in.ar(2);
        amp = \amp.kr(0.8).clip(0.0, 2.0);
        inSig * amp
    });
    Ndef(\p_tanh, {
        var inSig, drive;
        inSig = \in.ar(2);
        drive = \drive.kr(1.0).clip(0.1, 5.0);
        (inSig * drive).tanh * 0.9
    });
    Ndef(\p_delay, {
        var inSig, delayTime, fb;
        inSig = \in.ar(2);
        delayTime = \time.kr(0.25).clip(0.0, 2.0);
        fb = \fb.kr(0.3).clip(0.0, 0.95);
        // simple stereo delay
        (DelayC.ar(inSig, 2.0, delayTime) * 0.7) + (inSig * (1.0 - fb))
    });

    // --- SINKS (stereo) send peak/rms to GUI ---
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });
    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // ensure 2-ch audio
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    postChain = { |label, anArray|
        (label ++ ": " ++ chainToString.(anArray)).postln;
    };

    updateGui = {
        {
            topLeftText.string_(chainToString.(chainA));
            topRightText.string_(chainToString.(chainB));
        }.defer;
    };

    rebuildChain = { |anArray|
        var linkIndex, maxLink;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            linkIndex = 0;
            maxLink = anArray.size - 1;
            while({ linkIndex < maxLink }, {
                Ndef(anArray[linkIndex]) <<> Ndef(anArray[linkIndex + 1]);
                linkIndex = linkIndex + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];
    chainB = [\outB, \srcB];
    rebuildChain.(chainA);
    rebuildChain.(chainB);
    updateGui.();
    postChain.("ChainA", chainA);
    postChain.("ChainB", chainB);

    // --- OSC bindings (rebind safely on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // Minimal value extractor for meters: last numeric (usually final RMS)
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) { v = msg[sz - 1].asFloat; };
        };
        v.clip(0.0, 1.0)
    };

    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // ---------- Chain edit API ----------
    setSourceA = { |srcSym|
        var newSym;
        newSym = srcSym.asSymbol;
        chainA[chainA.size - 1] = newSym;
        rebuildChain.(chainA);
        updateGui.();
        postChain.("ChainA", chainA);
    };

    setSourceB = { |srcSym|
        var newSym;
        newSym = srcSym.asSymbol;
        chainB[chainB.size - 1] = newSym;
        rebuildChain.(chainB);
        updateGui.();
        postChain.("ChainB", chainB);
    };

    appendProcessorA = { |procSym|
        var newSym, insertPos;
        newSym = procSym.asSymbol;
        insertPos = chainA.size - 1; // before source
        chainA = chainA.insert(insertPos, newSym);
        rebuildChain.(chainA);
        updateGui.();
        postChain.("ChainA", chainA);
    };

    appendProcessorB = { |procSym|
        var newSym, insertPos;
        newSym = procSym.asSymbol;
        insertPos = chainB.size - 1; // before source
        chainB = chainB.insert(insertPos, newSym);
        rebuildChain.(chainB);
        updateGui.();
        postChain.("ChainB", chainB);
    };

    removeProcessorA = { |procSym|
        var sym, newChain, keepIndex, lastIndex;
        sym = procSym.asSymbol;
        lastIndex = chainA.size - 1;
        newChain = Array.new;
        keepIndex = 0;
        while({ keepIndex < chainA.size }, {
            if((keepIndex == 0) or: { keepIndex == lastIndex } or: { chainA[keepIndex] != sym }) {
                newChain = newChain.add(chainA[keepIndex]);
            };
            keepIndex = keepIndex + 1;
        });
        chainA = newChain;
        rebuildChain.(chainA);
        updateGui.();
        postChain.("ChainA", chainA);
    };

    removeProcessorB = { |procSym|
        var sym, newChain, keepIndex, lastIndex;
        sym = procSym.asSymbol;
        lastIndex = chainB.size - 1;
        newChain = Array.new;
        keepIndex = 0;
        while({ keepIndex < chainB.size }, {
            if((keepIndex == 0) or: { keepIndex == lastIndex } or: { chainB[keepIndex] != sym }) {
                newChain = newChain.add(chainB[keepIndex]);
            };
            keepIndex = keepIndex + 1;
        });
        chainB = newChain;
        rebuildChain.(chainB);
        updateGui.();
        postChain.("ChainB", chainB);
    };

    clearProcessorsA = {
        var sinkSym, sourceSym;
        sinkSym = chainA[0];
        sourceSym = chainA[chainA.size - 1];
        chainA = [sinkSym, sourceSym];
        rebuildChain.(chainA);
        updateGui.();
        postChain.("ChainA", chainA);
    };

    clearProcessorsB = {
        var sinkSym, sourceSym;
        sinkSym = chainB[0];
        sourceSym = chainB[chainB.size - 1];
        chainB = [sinkSym, sourceSym];
        rebuildChain.(chainB);
        updateGui.();
        postChain.("ChainB", chainB);
    };

    setChainA = { |newArray|
        var arr;
        arr = newArray.asArray.collect(_.asSymbol);
        chainA = arr;
        rebuildChain.(chainA);
        updateGui.();
        postChain.("ChainA", chainA);
    };

    setChainB = { |newArray|
        var arr;
        arr = newArray.asArray.collect(_.asSymbol);
        chainB = arr;
        rebuildChain.(chainB);
        updateGui.();
        postChain.("ChainB", chainB);
    };

    // Export convenience into tilde-space
    ~setSourceA        = setSourceA;
    ~setSourceB        = setSourceB;
    ~appendProcessorA  = appendProcessorA;
    ~appendProcessorB  = appendProcessorB;
    ~removeProcessorA  = removeProcessorA;
    ~removeProcessorB  = removeProcessorB;
    ~clearProcessorsA  = clearProcessorsA;
    ~clearProcessorsB  = clearProcessorsB;
    ~setChainA         = setChainA;
    ~setChainB         = setChainB;
});

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
    "Stopped and freed OSC responders.".postln;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

   Style
   - var-first declarations in every block and function
   - lowercase names, descriptive identifiers
   - AppClock.defer for GUI updates
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // left chain: sink ... source
    chainB = [\outB, \srcB];   // right chain
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0)
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/SIMPLIFIED clode/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== _isolated_tests_and_experiments/SIMPLIFIED clode/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== _isolated_tests_and_experiments/SIMPLIFIED clode/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== _isolated_tests_and_experiments/SIMPLIFIED clode/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/testNdefsMetersWindow_v0.7.scd =====
// WindowLayout_Grid_WithNdefsMeters.scd
// v1.0 - Minimal dark-green grid + Ndefs + live meters (sinkA/B) + chain labels
// MD 20250930

/*
Purpose:
  - Create the same window as your minimal dark-green grid.
  - Define Ndefs (srcA, srcB, sinks with SendPeakRMS).
  - Drive the left/right meters from sinkA/sinkB RMS.
  - Show chain text in the top-left / top-right panes.

Style:
  - var-first, descriptive names, no non-local returns, no server.sync.
  - Uses OSCdef responders and .defer for GUI safety.
  - Returns '-> a Window'.
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var chainAString, chainBString;
var oscNameA, oscNameB;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// simple chain labels (edit any time)
chainAString = "srcA → sinkA";
chainBString = "srcB → sinkB";

// OSC address (and names) for meters
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        // LEFT: TextView + LevelIndicator (we keep references)
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        // RIGHT: TextView + LevelIndicator (keep references)
        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// set chain text in top panes
topLeftText.string_(chainAString);
topRightText.string_(chainBString);

// ---------- audio graph + metering ----------
Server.default.waitForBoot({
    // sources
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });                  // stereo pink at modest level
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });        // stereo close tones
    Ndef(\srcC, { SinOsc.ar([167, 171], mul: 0.20) });        // stereo close tones

/*    // sinks with SendPeakRMS -> GUI (20 Hz is light but responsive)
    Ndef(\sinkA, {
        var sig = Ndef(\srcA).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });*/

// Create them 2ch before we do anything else
	Ndef(\chainA, {Silent.ar(2)});
    Ndef(\chainB, {Silent.ar(2)});

	Ndef(\sinkA, {Silent.ar(2)});
    Ndef(\sinkB, {Silent.ar(2)});



	//Ndef(\p1, { var inSig; inSig = \in.ar(2) * 0.5; inSig });


		Ndef(\chainA, { var inSig; inSig = \in.ar(2) * 1; inSig });
Ndef(\chainB, { var inSig; inSig = \in.ar(2) * 1; inSig });



	Ndef(\sinkA, {
		var sig; Ndef(\chainA);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 2);
        sig
    });

    Ndef(\sinkB, {
        var sig; Ndef(\chainB);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // play sinks
    Ndef(\sinkA).play;
    Ndef(\sinkB).play;

    // meter responders (RMS at msg[6]); defer to GUI thread
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(msg[6]) }.defer;  }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(msg[6]) }.defer; }, '/peakrmsB');
});

// cleanup when window closes (stop sinks + free responders; leave sources defined)
window.onClose = {
    Ndef(\sinkA).stop;
    Ndef(\sinkB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
};

window  // -> a Window
)

/*

(Ndef(\srcA).bus).postln;
(Ndef(\srcB).bus).postln;
(Ndef(\srcC).bus).postln;
(Ndef(\sinkA).bus).postln;
(Ndef(\sinkB).bus).postln;

Ndef(\sinkA).play;
Ndef(\sinkA).stop;

Ndef(\sinkB).play;
Ndef(\sinkB).stop;

Ndef(\sinkB) <<> Ndef(\srcA);
Ndef(\sinkB) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

Ndef(\sinkA) <<> Ndef(\srcA);
Ndef(\sinkA) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

*/
===== _isolated_tests_and_experiments/testNdefsMetersWindow.scd =====
// WindowLayout_Grid_WithNdefsMeters.scd
// v1.0 - Minimal dark-green grid + Ndefs + live meters (sinkA/B) + chain labels
// MD 20250930

/*
Purpose:
  - Create the same window as your minimal dark-green grid.
  - Define Ndefs (srcA, srcB, sinks with SendPeakRMS).
  - Drive the left/right meters from sinkA/sinkB RMS.
  - Show chain text in the top-left / top-right panes.

Style:
  - var-first, descriptive names, no non-local returns, no server.sync.
  - Uses OSCdef responders and .defer for GUI safety.
  - Returns '-> a Window'.
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var chainAString, chainBString;
var oscNameA, oscNameB;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// simple chain labels (edit any time)
chainAString = "srcA → sinkA";
chainBString = "srcB → sinkB";

// OSC address (and names) for meters
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        // LEFT: TextView + LevelIndicator (we keep references)
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        // RIGHT: TextView + LevelIndicator (keep references)
        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// set chain text in top panes
topLeftText.string_(chainAString);
topRightText.string_(chainBString);

// ---------- audio graph + metering ----------
Server.default.waitForBoot({
    // sources
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });                  // stereo pink at modest level
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });        // stereo close tones
    Ndef(\srcC, { SinOsc.ar([167, 171], mul: 0.20) });        // stereo close tones

/*    // sinks with SendPeakRMS -> GUI (20 Hz is light but responsive)
    Ndef(\sinkA, {
        var sig = Ndef(\srcA).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });*/

// Create them 2ch before we do anything else
	Ndef(\sinkA, {Silent.ar(2)};
    Ndef(\sinkB, {Silent.ar(2)};

//			var inputSignal;
//			inputSignal = \in.ar(defaultNumChannels);
//			inputSignal

    Ndef(\sinkA, {
		var sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    Ndef(\sinkB, {
        var sig = Ndef(\srcB).ar;
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // play sinks
    Ndef(\sinkA).play;
    Ndef(\sinkB).play;

    // meter responders (RMS at msg[6]); defer to GUI thread
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(msg[6]) }.defer;  }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(msg[6]) }.defer; }, '/peakrmsB');
});

// cleanup when window closes (stop sinks + free responders; leave sources defined)
window.onClose = {
    Ndef(\sinkA).stop;
    Ndef(\sinkB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
};

window  // -> a Window
)

/*(Ndef(\srcA).bus).postln;
(Ndef(\srcB).bus).postln;
(Ndef(\srcC).bus).postln;
(Ndef(\sinkA).bus).postln;
(Ndef(\sinkB).bus).postln;

Ndef(\sinkA).play;
Ndef(\sinkA).stop;

Ndef(\sinkB).play;
Ndef(\sinkB).stop;

Ndef(\sinkB) <<> Ndef(\srcA);
Ndef(\sinkB) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);

Ndef(\sinkA) <<> Ndef(\srcA);
Ndef(\sinkA) <<> Ndef(\srcB);
Ndef(\sinkA) <<> Ndef(\srcC);*/
===== _isolated_tests_and_experiments/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.6 - no non-local returns (no ^); robust SendPeakRMS parser; console prints restored
// MD 20250930

/* Purpose
   - Fix “no console output” by eliminating ^ non-local returns inside parseRMS.
   - Robustly parse SendPeakRMS with/without address and with/without numCh.
   - Keep your GUI + chains intact and meters moving.

   Style
   - var-first declarations in every block
   - lowercase names, descriptive
   - AppClock defer for GUI updates
   - no non-local returns
*/

(

var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var parseRMS;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

("test").postln;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30).warning_(0.50).critical_(0.80)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30).warning_(0.50).critical_(0.80)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) ---
    // Keep distinct replyIDs (A=1, B=2) to match your earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];
    chainB = [\outB, \srcB];
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // Robust RMS parser (no ^ anywhere):
    // Supports:
    //   A) [address?, nodeID, replyID, numCh, peak1, rms1, peak2, rms2, ...]
    //   B) [address?, nodeID, replyID,        peak1, rms1, peak2, rms2, ...]
    parseRMS = { |msg|
        var ret, hasAddr, base, msgSize, maybeNumCh, dataStart, pairs, sum, k, rmsIndex;

        ret = 0.0;
        if(msg.notNil) {
            msgSize = msg.size;
            hasAddr = (msgSize > 0) && { msg[0].isString };
            base = hasAddr.binaryValue;

            // Decide layout by looking at slot base+2 and overall payload length
            if(msgSize >= (base + 4)) {
                maybeNumCh = msg[base + 2];
                if(maybeNumCh.isNumber and: { (msgSize - (base + 3)) >= (maybeNumCh.asInteger * 2) }) {
                    dataStart = base + 3;
                    pairs = maybeNumCh.asInteger.max(1);
                }{
                    dataStart = base + 2;
                    pairs = ((msgSize - dataStart) / 2).floor.max(0);
                };
            }{
                dataStart = base + 2;
                pairs = ((msgSize - dataStart) / 2).floor.max(0);
            };

            if(pairs > 0) {
                sum = 0.0;
                k = 0;
                while({ k < pairs }, {
                    rmsIndex = dataStart + (k * 2) + 1;  // second of each (peak,rms)
                    if(rmsIndex < msgSize) {
                        sum = sum + msg[rmsIndex].asFloat;
                    };
                    k = k + 1;
                });
                if(pairs > 0) {
                    ret = (sum / pairs).clip(0.0, 1.0);
                };
            };
        };
        ret
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(parseRMS.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(parseRMS.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = parseRMS.(msg);
            v = v.max(1e-6);
            ("A RMS: " ++ (v.ampDb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = parseRMS.(msg);
            v = v.max(1e-6);
            ("B RMS: " ++ (v.ampDb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/WindowLayout_Grid_WithSigChainsAndMeters.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters.scd
// v1.2 - Aligns with sigChainOperations: <<> wiring + \in.ar(2) sinks; meters A & B
// MD 20250930

/*
Purpose:
  - Same dark-green window (3x2 grid).
  - Sources: srcA/srcB/srcC (stereo).
  - Chains: chainA=[outA,...,src?], chainB=[outB,...,src?], wired by Ndef(left) <<> Ndef(right).
  - Sinks: outA/outB read \in.ar(2), meter with SendPeakRMS to GUI.
  - Left pane meters sinkA; right pane meters sinkB; both panes display the full chain string.

Conventions (from sigChainOperations v0.2.1):
  - Receivers that consume audio MUST declare \in.ar(2).
  - Wiring uses Ndef(left) <<> Ndef(right) (left receives right at \in).
  - (Optional) pre-arm proxies to stereo audio buses before wiring.  [See file notes]
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var oscNameA, oscNameB;

// --- chain data + functions (mirroring your sigChain style) ---
var chainA, chainB;
var ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + chains ----------
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (MUST declare \in.ar(2)) ---
    // outA: sink for chainA (also meters -> /peakrmsA)
    Ndef(\outA, {
        var sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // id=1
        sig
    });

    // outB: sink for chainB (also meters -> /peakrmsB)
    Ndef(\outB, {
        var sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);  // id=2
        sig
    });

    // --- OPTIONAL PROCESSORS (declared here to be ready if you insert them) ---
    // Ndef(\p1, { var inSig = \in.ar(2) * 0.8; inSig });
    // Ndef(\p2, { var inSig = \in.ar(2).tanh * 0.7; inSig });

    // --- CHAIN HELPERS (aligned with sigChainOperations) ---
    ensureStereo = { |key|
        var bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio
===== _isolated_tests_and_experiments/working/animateMetersWindowLayout_Grid_Minimal_DarkGreen.scd =====
// animateMetersWindowLayout_Grid_Minimal_DarkGreen.scd
// v1
// MD 20250930

(
// Attach + animate LevelIndicator meters in "Layout Test"
var win, collect, views;

views = List.new;
win = Window.allWindows.detect({ |w| w.name == "Layout Test" });

if(win.isNil) { "No window named 'Layout Test'.".warn; } {
    collect = { |v|
        views.add(v);
        v.children.do({ |c| collect.(c) });
    };
    collect.(win.view);
    ~meters = views.select({ |v| v.isKindOf(LevelIndicator) });

    // Start animation (single AppClock Routine)
    ~startMeters = {
        ~meterRoutine !? { ~meterRoutine.stop };
        ~meterRoutine = Routine({
            var t = 0.0;
            loop {
                var v1 = (sin(t * 0.30) * 0.5 + 0.5).clip(0, 1);
                var v2 = (sin(t * 0.21 + 1.1) * 0.5 + 0.5).clip(0, 1);
                ~meters.do({ |m, i| m.value_(i.even.if(v1, v2)) });
                t = t + 0.05;
                0.03.wait;  // ~33 fps
            }
        }).play(AppClock);
        "Meters animating…".postln;
    };

    // Stop animation
    ~stopMeters = {
        ~meterRoutine !? { ~meterRoutine.stop; ~meterRoutine = nil; "Meters stopped.".postln; };
    };

    "Found % meter(s). Use ~startMeters.() and ~stopMeters.().".format(~meters.size).postln;
};
)


/*
To use:

~startMeters.();
~stopMeters.();

*/
===== _isolated_tests_and_experiments/working/aSingleWindowPaneWORKING.scd =====
// aSingleWindowPane.scd
// v1.0 -- WORKING
// MD 20250930

// Let's try to pain a single outlined window pane.


/*
Purpose:
  - Show a minimal example: one window with one pane that has a thin contrasting outline.
*/


(
var debugLayout = true; // shows outline and pane name

var window, paneContainer, paneLayout;
var labelView, contentView;
var strokeColor;

strokeColor = if(debugLayout, { Color.red(1.0, 0.6) }, { Color.gray(0.55) });

// Close any previous window with the same name
Window.allWindows.do({ |w| if(w.name == "First Principles", { w.close }) });

// Create the window
window = Window("First Principles", Rect(150, 150, 420, 260))
    .background_(Color.white)
    .front;

// Minimal pane content: a label bar + a text area
labelView = StaticText()
    .string_(if(debugLayout, { "Pane" }, { "---" }))
    .align_(\center)
    .stringColor_(Color.white)
    .background_(strokeColor)
    .fixedHeight_(22);

contentView = TextView()
    .string_("Content goes here…")
    .minHeight_(140);

// Stack the label above the content
paneLayout = VLayout(
    labelView,
    contentView
)
.margins_(8)      // inner padding
.spacing_(6);

// The pane container that draws its own outline
paneContainer = UserView()
    .layout_(paneLayout);

// Draw a thin outline around the whole pane in **local** coordinates
paneContainer.drawFunc_({ |view|
    var b, rect;
    b = view.bounds;  // we only use width/height — origin is local (0, 0)
    rect = Rect(0.5, 0.5, b.width - 1, b.height - 1);
    Pen.use {
        Pen.color = strokeColor;
        Pen.width = 1;
        Pen.addRect(rect);
        Pen.stroke;
    };
});

// Put the single pane into the window, with some outer margin
window.layout = VLayout(
    paneContainer
)
.margins_(12)
.spacing_(12);

window  // -> a Window
)

===== _isolated_tests_and_experiments/working/sanityTestsWithNdefs.scd =====
// sanityTestsWithNdefs.scd
// v.0.4
// MD 20250930
(
// Debug flag
var debug = true;  // Set to false to disable debug output

// vars
var win, meterA, meterB;
var printCounterA = 0, printCounterB = 0;  // Local variables instead of environment

// create display window:
win = Window("RMS Meters", Rect(100, 100, 300, 400)).front;
win.layout = HLayout(  // Horizontal layout for left/right panes
    VLayout(  // Left pane
        StaticText().string_("Sink A").align_(\center),
        meterA = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)  // resize code 1: fixed dimensions
            .fixedWidth_(30)
    ).margins_(5).spacing_(5),   // Outline: margins create visible border
    VLayout(  // Right pane
        StaticText().string_("Sink B").align_(\center),
        meterB = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)
            .fixedWidth_(30)
    ).margins_(5).spacing_(5)
);

// create Ndef sources:
Ndef(\srcA, {PinkNoise.ar(0.1 ! 2)});
Ndef(\srcB, {SinOsc.ar([300,301], mul:0.2)});
Ndef(\srcC, {SinOsc.ar([250,301], mul:0.2)});

// Debug: display bus values for source Ndefs
if(debug, {
    "___ Source Ndef Bus Values ___".postln;
    "Ndef(\\srcA) bus: %".format(Ndef(\srcA).bus).postln;
    "Ndef(\\srcB) bus: %".format(Ndef(\srcB).bus).postln;
    "Ndef(\\srcC) bus: %".format(Ndef(\srcC).bus).postln;
});

// Sink Ndefs with SendPeakRMS monitoring
Ndef(\sinkA, {
    var sig = Ndef(\srcA).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // 20Hz for meters
    sig;
});

Ndef(\sinkB, {
    var sig = Ndef(\srcB).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
    sig;
});

// Debug: display bus values for sink Ndefs
if(debug, {
    "___ Sink Ndef Bus Values ___".postln;
    "Ndef(\\sinkA) bus: %".format(Ndef(\sinkA).bus).postln;
    "Ndef(\\sinkB) bus: %".format(Ndef(\sinkB).bus).postln;
    "____________________________".postln;
});

// Fast OSCdef responders for meters (20Hz updates)
OSCdef(\rmsAMeter, {|msg|
    // msg[3] = replyID, msg[4] = numChannels, msg[5] = peak, msg[6] = RMS
    {meterA.value = msg[6]}.defer;  // Use RMS value
}, '/peakrmsA');

OSCdef(\rmsBMeter, {|msg|
    {meterB.value = msg[6]}.defer;
}, '/peakrmsB');

// Slow responders for console printing (1Hz)
OSCdef(\rmsAConsole, {|msg|
    printCounterA = printCounterA + 1;
    if(printCounterA >= 20, {  // Print every 20th message (20Hz / 20 = 1Hz)
        "sinkA RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        printCounterA = 0;
    });
}, '/peakrmsA');

OSCdef(\rmsBConsole, {|msg|
    printCounterB = printCounterB + 1;
    if(printCounterB >= 20, {
        "sinkB RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        printCounterB = 0;
    });
}, '/peakrmsB');

// Cleanup when window closes
win.onClose = {
    OSCdef(\rmsAMeter).free;
    OSCdef(\rmsBMeter).free;
    OSCdef(\rmsAConsole).free;
    OSCdef(\rmsBConsole).free;
};

// Play the sinks
Ndef(\sinkA).play;
Ndef(\sinkB).play;
)
===== _isolated_tests_and_experiments/working/sendTextToWindowLayout_Grid_Minimal_DarkGreen.scd =====
// sendTextToWindowLayout_Grid_Minimal_DarkGreen.scd
// v1.0
// MD 20250930-1303

(
// Attach + simple text helpers for "Layout Test"
var win, collect, views;

views = List.new;
win = Window.allWindows.detect({ |w| w.name == "Layout Test" });

// look for window called "Layout Test"
if(win.isNil) { "No window named 'Layout Test'.".warn; } {
    collect = { |v|
        views.add(v);
        v.children.do({ |c| collect.(c) });
    };
    collect.(win.view);

    ~textViews = views.select({ |v| v.isKindOf(TextView) }); // collect the textviews

    // Set ALL panes' TextView to the same string
    ~broadcastText = { |txt|
        ~textViews.do({ |tv| tv.string_(txt) });
    };

    // Set a specific pane's TextView by its header label (green bar text)
    ~setPaneText = { |paneLabel, txt|
        var paneUserView, tv;

        // Find the pane's UserView by looking for a child StaticText whose .string == paneLabel
        paneUserView = views.detect({ |v|
            v.isKindOf(UserView) and: {
                v.children.any({ |c| c.isKindOf(StaticText) and: { c.string == paneLabel } })
            }
        });

        if(paneUserView.isNil) {
            "Pane not found: %".format(paneLabel).warn;
        } {
            // Pick the first TextView inside that pane and set its string
            tv = paneUserView.children.detect({ |c| c.isKindOf(TextView) });
            if(tv.isNil) {
                "No TextView in pane: %".format(paneLabel).warn;
            } {
                tv.string_(txt);
            };
        };
    };

    "Text helpers ready. Use ~broadcastText.(...) or ~setPaneText.(\"System State\", ...).".postln;
};
)

/*
To use:

~setPaneText.("System State","Testing Be-bop-a-lula")
~setPaneText.("Top Left Pane","I was a fiend...")
~broadcastText.("test")  // works

*/
===== _isolated_tests_and_experiments/working/test/turnintooneplease_singleblock_race_hardened.scd =====
// NEARLY WORKING just meters not moving.

// turnintooneplease_singleblock_race_hardened.scd
// One-shot bring-up with explicit CURRENT routing (A), safe taps, and RMS HUD.
// Strategy: avoid freeAll; clear/rebuild Ndefs; schedule steps to avoid group races.
(
var // ── helpers ──
post, warn, now,

// ── reset/bring-up vars ──
systemRef, windowRef, ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp, ensureGui,
resetLight, installSafeTapsLater, connectAndPlayLater, installCenteredPulse, reportPlayState,

// ── RMS HUD vars ──
rmsWindow, labelDbA, labelDbB, meterAL, meterAR, meterBL, meterBR, updateRoutine,
currentDbAL, currentDbAR, currentDbBL, currentDbBR,
defaultFloorDb, defaultTopDb, updateRateHz,
installSynthDef, stopRmsSynth, startRmsSynthAtTail, oscKeyName, installRmsListener,
getProxyBusInfo, discoverBussesAndStart;

post = { |txt| txt.postln };
warn = { |txt| ("⚠️ " ++ txt).warn };
now  = { SystemClock.seconds.round(0.001) };

// ───────────────────────────── 0) LIGHT RESET (no freeAll) ─────────────────────────────
resetLight = {
    // Close our GUI windows but do NOT free server groups globally.
    Window.allWindows.do { |w|
        var nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") or: { nm.asString.contains("RMS HUD") }}) { w.close };
    };
    // Free only our known OSCdefs (do not touch others)
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus,
      \md_rms_isolated_listener ].do { |k| var d = OSCdef.all.at(k); if(d.notNil) { d.free } };

    // Stop and clear only the Ndefs we control; this rebuilds their proxy groups safely.
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
    });
    Ndef(\chainA).clear; Ndef(\chainB).clear;  // remove filters & old nodes (no race with global groups)
    post.("✅ [" ++ now.() ++ "] Light reset done (no freeAll).");
};

// ──────────────────────────── 1) SYSTEM BRING-UP (GUI + meters) ────────────────────────────
ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0 ).source.isNil)   { Ndef(\ts0,  { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, { Silent.ar(2) }); // temporary; we install centered pulse later
        };
        // Ensure 2ch
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2); Ndef(\ts0).ar(2); Ndef(\testmelody).ar(2);
    });
    post.("🔧 [" ++ now.() ++ "] Proxies ensured (chainA/B/ts0/testmelody ar(2)).");
};

startSystem = {
    if(s.serverRunning.not) { "Booting server…".postln; s.waitForBoot }; // allowed; you forbid server.sync, not waitForBoot
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll;  // may create PerfHUD or GridDemo
    ~system = systemRef; ~mpb = systemRef.pedalboard; ~gui = systemRef.statusDisplay;
    post.("🚀 [" ++ now.() ++ "] bringUpAll dispatched.");
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

ensureGui = {
    var giveUpAt;
    if(~gui.notNil) { ^~gui };
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) { ~gui = findMagicDisplayWindow.() };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            if(~gui.isNil) {
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);
                ~gui = MagicDisplayGUI_GridDemo.new;
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) { ~mpb.setDisplay(~gui) };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ──────────────────────────── 2) CONNECT + SAFE TAPS (with small delays) ────────────────────────────
reportPlayState = {
    ["[PLAY] A=", Ndef(\chainA).isPlaying, "B=", Ndef(\chainB).isPlaying].postln;
};

connectAndPlayLater = {
    // Delay a hair after bringUpAll so any internal server ops settle.
    AppClock.sched(0.15, {
        Server.default.bind({
            " [PATCH] testmelody → chainA; play A / stop B".postln;
            // Install the centered pulse source right before connecting
            Ndef(\testmelody, {
                var trig = Impulse.kr(2), env = Decay2.kr(trig, 0.01, 0.22);
                var sig = SinOsc.ar(440) * env * 0.30; [sig, sig] // equal L/R
            });
            Ndef(\testmelody).ar(2);

            // Freshly (re)play sinks to create fresh groups if needed
            Ndef(\chainA).play; Ndef(\chainB).stop;

            // JITLib connect: explicit source -> CURRENT (A)
            Ndef(\testmelody) <<> Ndef(\chainA);
        });
        reportPlayState.();
        nil
    });
};

installSafeTapsLater = {
    // Install pass-through taps AFTER we know chainA/B have groups again.
    AppClock.sched(0.25, {
        Server.default.bind({
            Ndef(\chainA).filter(\mdVisTapA, { |in|
                var sig = in.asArray;
                var aL = Amplitude.kr(sig[0], 0.01, 0.20).clip(1e-5, 1);
                var aR = Amplitude.kr(sig.wrapAt(1), 0.01, 0.20).clip(1e-5, 1);
                SendReply.kr(Impulse.kr(24), "/md/levels", [aL, aR], 2001); in
            });
            Ndef(\chainB).filter(\mdVisTapB, { |in|
                var sig = in.asArray;
                var aL = Amplitude.kr(sig[0], 0.01, 0.20).clip(1e-5, 1);
                var aR = Amplitude.kr(sig.wrapAt(1), 0.01, 0.20).clip(1e-5, 1);
                SendReply.kr(Impulse.kr(24), "/md/levels", [aL, aR], 2002); in
            });
        });
        "[*] SAFE taps (A=2001,B=2002) installed.".postln;
        nil
    });
};

// ──────────────────────────── 3) RMS HUD (robust bus discovery) ────────────────────────────
defaultFloorDb = -72.0; defaultTopDb = 0.0; updateRateHz = 15;
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

rmsWindow = Window("RMS HUD", Rect(100,100,440,210)).front;
meterAL = LevelIndicator(rmsWindow, Rect( 40,40,60,110)).drawsPeak_(false);
meterAR = LevelIndicator(rmsWindow, Rect(120,40,60,110)).drawsPeak_(false);
meterBL = LevelIndicator(rmsWindow, Rect(230,40,60,110)).drawsPeak_(false);
meterBR = LevelIndicator(rmsWindow, Rect(310,40,60,110)).drawsPeak_(false);
labelDbA = StaticText(rmsWindow, Rect(10,175,210,18)).string_("A: L=-∞ R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220,175,210,18)).string_("B: L=-∞ R=-∞");

currentDbAL = -140.0; currentDbAR = -140.0; currentDbBL = -140.0; currentDbBR = -140.0;

installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA = In.ar(inBusA,2), sigB = In.ar(inBusB,2);
            var rmsAL = RMS.ar(sigA[0], 500), rmsAR = RMS.ar(sigA[1], 500);
            var rmsBL = RMS.ar(sigB[0], 500), rmsBR = RMS.ar(sigB[1], 500);
            var dbAL = (max(rmsAL,1e-9)).log10*20, dbAR = (max(rmsAR,1e-9)).log10*20;
            var dbBL = (max(rmsBL,1e-9)).log10*20, dbBR = (max(rmsBR,1e-9)).log10*20;
            SendReply.kr(Impulse.kr(fps), "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef added.".postln;
};

stopRmsSynth = {
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil; "[RMS HUD] old synth freed.".postln; };
};

startRmsSynthAtTail = { |busIndexForA, busIndexForB|
    AppClock.sched(0.05, {  // small delay after .add; no server.sync
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA, \inBusB, busIndexForB, \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] started A=" ++ busIndexForA ++ " B=" ++ busIndexForB).postln;
        nil
    });
};

oscKeyName = \md_rms_isolated_listener;
installRmsListener = {
    var existing = OSCdef.all.at(oscKeyName); if(existing.notNil) { existing.free };
    OSCdef(oscKeyName, { |msg|
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat; currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat; currentDbBR = msg[6].asFloat;
        }; nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);
    "[RMS HUD] listener installed.".postln;
};

getProxyBusInfo = { |sym|
    var px = Ndef(sym), busObj = px.bus;
    (
        symbol: sym,
        playing: px.isPlaying,
        numChannels: px.numChannels,
        busIndex: busObj.notNil.if({ busObj.index }, { nil })
    )
};

discoverBussesAndStart = {
    var triesLeft = 24; // ~6 s at 0.25s step
    Routine({
        var resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            var a = getProxyBusInfo.(\chainA), b = getProxyBusInfo.(\chainB);
            if(a[\busIndex].notNil and: { b[\busIndex].notNil }) {
                installSynthDef.(); stopRmsSynth.();
                startRmsSynthAtTail.(a[\busIndex], b[\busIndex]);
                resolved = true;
            }{
                if(triesLeft == 24) { "[RMS HUD] waiting for chainA/chainB busses…".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };
        if(resolved.not) { warn.("[RMS HUD] could not resolve busses; play state?") };
    }).play(AppClock);
};

// ──────────────────────────── 4) RUN SEQUENCE ────────────────────────────
resetLight.();
ensureAudioProxies.();
startSystem.();
windowRef = afterBringUp.(systemRef);
ensureGui.();

connectAndPlayLater.();   // schedules at t+0.15
installSafeTapsLater.();  // schedules at t+0.25

installRmsListener.();
discoverBussesAndStart.(); // will start synth once busses are known

// clean-up when closing HUD
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed.".postln;
});

// return window so you see '-> a Window'
rmsWindow
)

===== _isolated_tests_and_experiments/working/test/WindowLayout_Grid_Minimal_DarkGreen_WORKING.scd =====
// THIS IS WORKING, CLEAN AND UNDERSTOOD.


// WindowLayout_Grid_Minimal_DarkGreen.scd
// v1.1 - Minimal 3x2 grid with dark green labels + thin outlines
// MD 20250930

/*
Single-colour (dark green) labels and matching thin outlines for all panes in a 3x2 GridLayout.
*/

(
var window, makePane, paneColor;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white) // text colour
        .background_(paneColor);

    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var w = v.bounds.width, h = v.bounds.height, inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.addRect(Rect(inset, inset, w - (2 * inset), h - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        makePane.(HLayout(TextView(), LevelIndicator()./*style_(\led).*/fixedWidth_(30)), "Top Left Pane"),
        makePane.(HLayout(TextView(), LevelIndicator().style_(\led).fixedWidth_(30)), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

window  // -> a Window
)

===== _isolated_tests_and_experiments/working/test/WindowLayoutTest_20250930WORKING_Grid.scd =====
// WindowLayoutTest_20250930_Grid.scd
// v1.4 - GridLayout (3x2), crisp borders, coloured labels, correct var placement
// MD 20250930-1210

/*
Purpose:
  - Fix the var-placement syntax error and ensure a proper GridLayout with shared columns.
  - Provide thin (1px) outlines and coloured pane-name bars in debug mode.
  - Draw borders in local coordinates to avoid offsets and “overlap” artifacts.

Style:
  - var-first declarations, descriptive lowercase names, no non-local returns.
  - Returns '-> a Window'.
*/

(
var debugLayout = true;
var outlineContentOnly = false;   // true = border excludes label; false = includes label

// ---- declare ALL vars up front (SuperCollider requirement) ----
var window, grid;

var topLeftText, topLeftMeter, topRightText, topRightMeter;
var systemStateText, diagnosticMessagesText;
var choicesText, receivingCommandsText;

var outerMargin, cellSpacing, paneMargin, paneSpacing, labelFixedHeight, strokeWidth, strokeInset;

var makePane;
var topLeftPane, topRightPane, systemStatePane, diagnosticPane, choicesPane, receivingPane;

// ---- geometry constants ----
outerMargin = 12;       // margins around the entire grid
cellSpacing = 12;       // spacing between grid cells
paneMargin = 8;         // inner padding inside each pane
paneSpacing = 6;        // gap between label and content inside a pane
labelFixedHeight = 22;  // stable label height so borders don't jump
strokeWidth = 1;        // thin outline
strokeInset = strokeWidth * 0.5;

// ---- helper: construct one pane (UserView) with label bar + thin outline ----
makePane = { |contentLayout, labelString, debugColor|
    var strokeColor, labelStringToShow, labelView, innerLayout, containerView;

    strokeColor = if(debugLayout, { debugColor }, { Color.gray(0.55) });
    labelStringToShow = if(debugLayout, { labelString }, { "---" });

    // Label bar
    labelView = StaticText()
        .string_(labelStringToShow)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(labelFixedHeight)
        .resize_(3); // fill horizontally

    // Stack label above the content
    innerLayout = VLayout(
        labelView,
        contentLayout
    )
    .margins_(paneMargin)
    .spacing_(paneSpacing);

    // Container: fills its grid cell and draws its own outline in LOCAL coordinates
    containerView = UserView()
        .layout_(innerLayout)
        .resize_(3); // fill both directions

    containerView.drawFunc_({ |view|
        var w, h, rect;
        w = view.bounds.width;
        h = view.bounds.height;

        if(outlineContentOnly, {
            // outline content area only (exclude the label bar)
            rect = Rect(
                paneMargin + strokeInset,
                paneMargin + labelFixedHeight + paneSpacing + strokeInset,
                w - (2 * paneMargin) - (2 * strokeInset),
                h - (2 * paneMargin) - labelFixedHeight - paneSpacing - (2 * strokeInset)
            );
        }, {
            // outline the entire pane (including the label bar)
            rect = Rect(strokeInset, strokeInset, w - (2 * strokeInset), h - (2 * strokeInset));
        });

        Pen.use {
            Pen.color = strokeColor;
            Pen.width = strokeWidth;
            Pen.addRect(rect);
            Pen.stroke;
        };
    });

    containerView
};

// ---- close any existing window with the same name ----
Window.allWindows.do({ |w|
    if(w.name == "Layout Test", { w.close });
});

// ---- create window ----
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// ---- build pane contents ----
topLeftPane = makePane.(
    VLayout(
        HLayout(
            topLeftText = TextView()
                .string_("Top Left Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topLeftMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)  // keep rail width fixed
                .resize_(2)       // vertical stretch only
        )
    ),
    "Top Left Pane",
    Color.red(1.0, 0.55)
);

topRightPane = makePane.(
    VLayout(
        HLayout(
            topRightText = TextView()
                .string_("Top Right Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topRightMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)
                .resize_(2)
        )
    ),
    "Top Right Pane",
    Color.blue(1.0, 0.55)
);

systemStatePane = makePane.(
    VLayout(
        StaticText().string_("System State").align_(\center).resize_(3),
        systemStateText = TextView()
            .string_("System state info here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "System State",
    Color.green(1.0, 0.55)
);

diagnosticPane = makePane.(
    VLayout(
        StaticText().string_("Diagnostic Messages").align_(\center).resize_(3),
        diagnosticMessagesText = TextView()
            .string_("Diagnostic messages here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Diagnostic Messages",
    Color.yellow(1.0, 0.6)
);

choicesPane = makePane.(
    VLayout(
        StaticText().string_("Choices").align_(\center).resize_(3),
        choicesText = TextView()
            .string_("Choices text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Choices",
    Color.magenta(1.0, 0.5)
);

receivingPane = makePane.(
    VLayout(
        StaticText().string_("Receiving Commands").align_(\center).resize_(3),
        receivingCommandsText = TextView()
            .string_("Receiving commands text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Receiving Commands",
    Color.cyan(1.0, 0.6)
);

// ---- compose a 3x2 grid and assign to the window ----
// Safer, version-agnostic approach: create the grid and add cells explicitly.
grid = GridLayout()
    .margins_(outerMargin)
    .spacing_(cellSpacing);

// Place panes by (row, col)
grid.add(topLeftPane,     0, 0);
grid.add(topRightPane,    0, 1);
grid.add(systemStatePane, 1, 0);
grid.add(diagnosticPane,  1, 1);
grid.add(choicesPane,     2, 0);
grid.add(receivingPane,   2, 1);

// Optional (if available in your SC build): set column/row stretch to balance space
// (safe to comment out if your SC doesn't support these)
// grid.setColumnStretch(0, 1);
// grid.setColumnStretch(1, 1);
// grid.setRowStretch(0, 2);   // make the top row taller if you wish
// grid.setRowStretch(1, 1);
// grid.setRowStretch(2, 1);

window.layout = grid;

if(debugLayout) {
    "DEBUG ON: GridLayout aligned; coloured labels + crisp thin outlines.".postln;
} {
    "DEBUG OFF: GridLayout aligned; neutral labels + thin grey outlines.".postln;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/working/windowLayout_Grid_Minimal_DarkGreen.scd =====
// THIS IS WORKING, CLEAN AND UNDERSTOOD.


// windowLayout_Grid_Minimal_DarkGreen.scd
// v1.1 - Minimal 3x2 grid with dark green labels + thin outlines
// MD 20250930

/*
Single-colour (dark green) labels and matching thin outlines for all panes in a 3x2 GridLayout.
*/

(
var window, makePane, paneColor;

// close any existing window with the same name
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

// window
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// single colour (dark green)
paneColor = Color(0.0, 0.35, 0.0);

// helper: pane with coloured label + thin outline (local coords)
makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white) // text colour
        .background_(paneColor);

    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var w = v.bounds.width, h = v.bounds.height, inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.addRect(Rect(inset, inset, w - (2 * inset), h - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

// grid (3 rows × 2 columns) with shared column boundaries
window.layout = GridLayout.rows(
    [
        makePane.(HLayout(TextView(), LevelIndicator()./*style_(\led).*/fixedWidth_(30)), "Top Left Pane"),
        makePane.(HLayout(TextView(), LevelIndicator()./*style_(\led).*/fixedWidth_(30)), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

window  // -> a Window
)

===== _isolated_tests_and_experiments/working/WindowLayout_Grid_WithChainA_BusMapped_ToSinkA.scd =====
// WindowLayout_Grid_WithChainA_BusMapped_ToSinkA.scd
// v1.0 - Dark-green grid + srcA/B/C + chainA (bus-mapped) -> sinkA + live meter
// MD 20250930

/*
// After evaluating the block:
~routeChainA.(\srcB);   // Left label -> "srcB → sinkA"; left meter follows srcB
~routeChainA.(\srcC);
~routeChainA.(\srcA);
*/

/*
Purpose:
  - Same minimal dark-green window.
  - Sources: srcA, srcB, srcC (stereo).
  - chainA reads from a bus chosen via set(\in, busIndex) and can host processing.
  - sinkA reads chainA, meters with SendPeakRMS, and plays.
  - Left pane shows "srcX → sinkA". Use ~routeChainA.(\srcB) to switch.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var oscNameA, chainLabelFor;

// ---------- GUI ----------

Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);
chainLabelFor = { |srcSym, sinkSym| srcSym.asString ++ " → " ++ sinkSym.asString };

makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        // LEFT: chain text + meter (sinkA)
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        // RIGHT: free notes or future second sink
        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph: src -> chainA (bus) -> sinkA (metered) ----------

oscNameA = \rmsA_toGUI;

Server.default.waitForBoot({
    // Sources (stereo)
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // chainA: read audio from a BUS chosen via the named control \in
    // IMPORTANT: use In.ar(\in.kr(0), 2)  (NOT \in.ar(2))
    Ndef(\chainA, {
        var inBus = \in.kr(0);          // control for input bus index
        var sig   = In.ar(inBus, 2);    // read 2 channels from that bus
        // Optional processing on sig goes here (e.g., sig = sig * 0.9;)
        sig
    });

    // sinkA: read the chain, meter to GUI, and play
    Ndef(\sinkA, {
        var sig = Ndef(\chainA).ar;       // *** actually read chainA audio ***
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });

    // Start sink
    Ndef(\sinkA).play;

    // Safe (re)bind for OSC responder
    { OSCdef(oscNameA).free }.value;
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(msg[6]) }.defer; }, '/peakrmsA');

    // Initial routing: map chainA's input bus to srcA's bus
    Ndef(\chainA).set(\in, Ndef(\srcA).bus.index);

    // GUI labels / hints
    { topLeftText.string_(chainLabelFor.(\srcA, \sinkA)) }.defer;
    { topRightText.string_("Use ~routeChainA.(\\srcB) or (\\srcC) to reroute chainA.") }.defer;
});

// ---------- Helper: re-route chainA by bus mapping ----------

~routeChainA = { |srcSym|
    var s = srcSym.asSymbol;
    var b = Ndef(s).bus.index;              // source's audio bus index
    Ndef(\chainA).set(\in, b);              // re-route
    { topLeftText.string_(chainLabelFor.(s, \sinkA)) }.defer;
};

// ---------- Cleanup ----------

window.onClose = {
    Ndef(\sinkA).stop;
    OSCdef(oscNameA).free;
};

window  // -> a Window
)



===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"🗂 CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "✅ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "⚠️ No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("✅ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "⚠️ Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("🗑 Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("⚠️ Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "💾 Tree saved to versioned file.".postln;
} {
    "⚠️ No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "✅ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "❌ Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("✅ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "⚠️ Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"💾 Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandNode test.scd =====
(
// Set a fixed random seed for reproducibility
thisThread.randSeed = 12345;

// Global node counter and limit
~nodeLimit = 50;
~nodeCount = 1;
~fixedChildren = 3;

// Create root node
~root = MDCommandNode.new("root", 0);

// Breadth-first queue
~nodeQueue = List[~root];

// Build tree
while {
    (~nodeQueue.notEmpty and: { ~nodeCount < ~nodeLimit })
} {
    var parent = ~nodeQueue.removeAt(0);
    ("Adding " ++ ~fixedChildren ++ " children to " ++ parent.name).postln;

    ~fixedChildren.do {
        if (~nodeCount < ~nodeLimit) {
            var childName = parent.name ++ "_" ++ ~nodeCount;
            var child = MDCommandNode.new(childName, ~nodeCount);
            parent.addChild(child);
            ~nodeQueue.add(child);
            ("Created node: " ++ child.name ++ " | Total nodes: " ++ ~nodeCount).postln;
            ~nodeCount = ~nodeCount + 1;
        };
    };
};

// Print tree
"Generated Tree Structure:".postln;
~root.printTreePretty("", true);

// Check integrity
"Running integrity check...".postln;
~root.checkIntegrity;

// Count total nodes
~countNodes = { |node|
    var count = 1;
    node.children.do { |c|
        count = count + ~countNodes.(c);
    };
    ^count;
};

("✅ Total nodes in tree: " ++ ~countNodes.(~root)).postln;
"Tree printed.".postln;
"end".postln;
)


b = MDCommandTree("root", 0);

===== CommandTree/MDCommandNodeTest20250731.scd =====
(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 3);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 11);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 7);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 5);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 11);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 11);


// Tag all nodes with depth
tree.root.tagByDepth(0);

// 📋 Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " →").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;

)



/////////////////////
/// BUILD A TREE - older version.
/////////////////////

(
// Setup
var tree, root, lvl1A, lvl1B, lvl2A, lvl2B, lvl3A, lvl3B, lvl3C;
var printSummary;

// 🌱 Initialize tree and root
tree = MDCommandTree.new("root", 0, 1);
root = tree.root;

// 🧩 Level 1
lvl1A = tree.addNode(root.id, "Branch A", 2);
lvl1B = tree.addNode(root.id, "Branch B", 3);

// 🧩 Level 2
lvl2A = tree.addNode(lvl1A.id, "SubBranch A1", 4);
lvl2B = tree.addNode(lvl1B.id, "SubBranch B1", 5);

// 🧩 Level 3
lvl3A = tree.addNode(lvl2A.id, "Twig A1a", 6);
lvl3B = tree.addNode(lvl2A.id, "Twig A1b", 7);
lvl3C = tree.addNode(lvl2B.id, "Twig B1a", 8);

// 🏷️ Tag depth from root
tree.root.tagByDepth(0);

// 📋 Node Summary
printSummary = {
    tree.nodeMap.values.do { |node|
        (node.name ++ " → depthTag: " ++ node.depthTag ++ ", getDepth: " ++ node.getDepth).postln;
    };
};

// 🖼️ Print results
printSummary.();
tree.printTreePretty;

tree.getNodeByName("Twig A1b").printPathToRoot;

)

===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// 📋 Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " →").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// 📋 Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " →").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/test_circularSaves20250826.scd =====
// test_circularSaves20250826.scd
// MD



(
// Step 1: Load the latest saved tree version
~tree = MDCommandTree.new("root");
~loaded = ~tree.loadLatestVersion;

if (~loaded) {
    "Latest tree loaded.".postln;
    "Tree before modification:".postln;
    ~tree.printTreePretty;
} {
    "⚠️ No saved tree found. Starting with empty tree.".postln;
};
)

(
// Step 2: Save current version for comparison
~originalJSON = ~tree.saver.latestVersion;
)

(
// Step 3: Modify the tree
~newNode = ~tree.addNode(0, "NewNode", 99);

if (~newNode.notNil) {
    "New node added.".postln;
    ~tree.printTreePretty;
} {
    "⚠️ Failed to add new node.".postln;
};
)

(
// Step 4: Save the modified tree as a new version
~tree.saveVersioned;
)

(
// Step 5: Compare original and new JSON
~newJSON = ~tree.saver.latestVersion;

if (~originalJSON != ~newJSON) {
    "Change confirmed: tree content has been updated.".postln;
} {
    "⚠️ No change detected between versions.".postln;
};
)













// (
// // Step 1: Create a new tree
// ~tree = MDCommandTree.new("root");
//
// // Step 2: Add some nodes
// ~tree.addNode(0, "A", 1);
// ~tree.addNode(1, "B", 2);
// ~tree.addNode(2, "C", 3);
// "✅ Nodes added.".postln;
// ~tree.printTreePretty;
// )
//
// (
// // Step 3: Save the tree using CircularFileSave
// ~tree.saveVersioned;
// )
//
// (
// // Step 4: List saved versions
// ~tree.listSavedVersions;
// )
//
// (
// // Step 5: Load the latest saved version
// ~tree.loadLatestVersion;
// )
//
// (
// // Step 6: Print the tree to confirm it was restored
// "✅ Tree after loading latest version:".postln;
// ~tree.printTreePretty;
// )

===== CommandTree/testCircularSave_20250819.scd =====
// Create a saver
~saver = CircularFileSave.new("myTree");

// Save a version
~saver.saveVersion("This is version " ++ Date.getDate.stamp);

// List saved versions
~saver.listVersions;

// Load a specific version
~saver.loadVersion(0).postln;

===== CommandTree/Tests/TestLogging_CommandBuilder.scd =====
TestLogging_CommandBuilder.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var jsonPath, tree, builder;

MDMiniLogger.get.setverbosity(3); // DEBUG

jsonPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
tree = MDCommandTree.new("root");
tree.importJSONFile(jsonPath);

builder = MDCommandBuilder.new(tree);
builder.printChildren;
builder.navigateByName(nil, "SomeChildName"); // INFO/WARN depending on your tree
builder.resetNavigation;
builder.printfretPath;
)

===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path → " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok → " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) — informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic — print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' → " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported → " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("⚠️ Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== CommandTree/Tests/TestLogging_FullBringUp.scd =====
TestLogging_FullBringUp.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var lps;
MDMiniLogger.get.setverbosity(2); // INFO

lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;

// Switch to DEBUG if you want more detail for a moment
MDMiniLogger.get.setverbosity(3);

lps.commandManager.setStatus("Sanity check: status via MDMiniLogger");
)

===== CommandTree/TestUserDisplay.scd =====
(
~displayTest = UserDisplay.new;

~displayTest.display(\state, "🧭 State: treeNav");
~displayTest.display(\queue, "📋 Queue: audio → noise → 100");
~displayTest.display(\lastCommand, "🕘 Last Command: 100");
~displayTest.display(\choices, "🎚 Choices:\nFret 7: noise\nFret 9: oscillators");
)

===== CommandTree/testVerbosity.scd =====
// temp

(
// 🧪 Set verbosity level to 0 (errors only)
Verbosity.setLevel(0);
Verbosity.postIf(0, "🔴 Level 0: Errors only");
Verbosity.postIf(1, "🟠 Level 1: Actions");
Verbosity.postIf(2, "🟡 Level 2: Input/Output");
Verbosity.postIf(3, "🔵 Level 3: Object reporting");
Verbosity.postIf(4, "🟣 Level 4: Everything");

"---".postln;

// 🧪 Set verbosity level to 2 (up to input/output)
Verbosity.setLevel(2);
Verbosity.postIf(0, "🔴 Level 0: Errors only");
Verbosity.postIf(1, "🟠 Level 1: Actions");
Verbosity.postIf(2, "🟡 Level 2: Input/Output");
Verbosity.postIf(3, "🔵 Level 3: Object reporting");
Verbosity.postIf(4, "🟣 Level 4: Everything");

"---".postln;

// 🧪 Set verbosity level to 4 (everything)
Verbosity.setLevel(4);
Verbosity.postIf(0, "🔴 Level 0: Errors only");
Verbosity.postIf(1, "🟠 Level 1: Actions");
Verbosity.postIf(2, "🟡 Level 2: Input/Output");
Verbosity.postIf(3, "🔵 Level 3: Object reporting");
Verbosity.postIf(4, "🟣 Level 4: Everything");
)

Verbosity.help;
===== Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd =====
// Sim_MIDIInput_Emulator_For_TreeNav.scd
// v0.1.2
// MD 20250924-1510
/*
Purpose
- Emulate hardware control of your system:
  • FOOT controller: mode changes (idle/prog/queue/send).
  • MIDI GUITAR: string/fret → channel/pitch → tree navigation.
- Keep everything in ONE file; evaluate section-by-section.

Style
- var-first in every block/closure; lowercase methods; no server.sync.
- Works with your current LivePedalboardSystem, CommandManager, and adapter bridge.
- Generated audio only (no SoundIn); Option A exclusivity remains enforced by your bring-up.
*/

// ───────────────────────────────────────────────────────────────────────────
// [0] Bring-up (idempotent): system + GUI + MagicPedalboard + adapter bridge
//    Evaluate once after a fresh compile (or re-run to refresh).
// ───────────────────────────────────────────────────────────────────────────
(
var needNew, systemRef;

// If an older system exists, shut it down cleanly.
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) {
    ~system.shutdownAll;
};

// Create (or reuse) the LivePedalboardSystem and bring everything up.
needNew = (~system.isNil);
if(needNew) {
    systemRef = LivePedalboardSystem.new(nil); // nil → class default JSON path resolver
    ~system = systemRef;
};

~system.bringUpAll;          // server + GUI + pedalboard + command system + meters
~system.installAdapterBridge; // queueExportCallback routes SHORT canonicals to MPB via adapter

// Convenience handles
~cm  = ~system.commandManager;
~mm  = ~cm.midiManager;
~mpb = ~system.pedalboard;
~gui = ~system.statusDisplay;

"✅ System is up. (~system, ~cm, ~mm, ~mpb, ~gui)".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [1] Emulation helpers (define once)
//    These call your actual handlers—no MIDI devices required.
//    FOOT MAPPING (noteOn): 36→\idle, 38→\prog, 40→\queue, 41→\send
//    GUITAR MAPPING (channels 0..5 → strings 6..1) with bases [40,45,50,55,59,64]
// ───────────────────────────────────────────────────────────────────────────
(
var ensure, bases;

// Basic guard so we don't call handlers before bring-up.
ensure = {
    var ok;
    ok = ~system.notNil
     and: { ~system.commandManager.notNil }
     and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "⚠️ Run section [0] (bring-up) first.".warn };
    ok
};

// E A D G B E (low→high), per your GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40,  // chan 0 → string 6 (E2)
    1 -> 45,  // chan 1 → string 5 (A2)
    2 -> 50,  // chan 2 → string 4 (D3)
    3 -> 55,  // chan 3 → string 3 (G3)
    4 -> 59,  // chan 4 → string 2 (B3)
    5 -> 64   // chan 5 → string 1 (E4)
];

// FOOT: emulate pressing a foot button (note number).
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    // channel is irrelevant for FootControllerHandler; value = note number.
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);
};

// Foot shortcuts
~toIdle  = { ~fc.(36) };  // idle
~toProg  = { ~fc.(38) };  // prog (tree navigation)
~toQueue = { ~fc.(40) };  // queue (enqueue current canonical)
~toSend  = { ~fc.(41) };  // send  (export & apply queue via bridge)

// GUITAR: emulate “play fret” on given string (1..6).
// Computes channel = 6 - string, pitch = base + fret; calls your GuitarMIDIHandler.
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "⚠️ Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Convenience alias for navigation (string,fret)
~nav = { arg s, f; ~gm.(s, f) };

// Peek: print the builder’s path and the canonical short form (e.g., "/add/delay").
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);
    ("• long=" ++ long ++ "  |  canonical=" ++ short).postln;
};

// Optional: show available choices in GUI (if present)
~refreshChoices = {
    if(~system.notNil) { ~system.commandManager.updateDisplay };
};
)

// ───────────────────────────────────────────────────────────────────────────
// [2] Scenario A — Add delay to NEXT via guitar nav, then switch
//    Top-level/children/grandchildren frets per your mapping:
//    string 6 fret 1 → "audio", string 5 fret 5 → "timebased", string 4 fret 3 → "delay"
//    Then queue (note 40) and send (note 41) → adapter applies "/add/delay"
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();           // enter navigation mode
~refreshChoices.();   // optional UI refresh
~nav.(6, 1);          // 6/1 → audio
~nav.(5, 5);          // 5/5 → timebased
~nav.(4, 3);          // 4/3 → delay
~showNav.();          // should report canonical "/add/delay"
~toQueue.();          // enqueue
~toSend.();           // apply via adapter
done = true;
"✅ Scenario A complete (add delay, then you can use Scenario B to switch).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [3] Scenario B — Switch chain from top-level “switch”
//    string 6 fret 5 → "switch" → queue → send
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();
~nav.(6, 5);      // top-level "switch"
~showNav.();      // should be "/switch"
~toQueue.();
~toSend.();
done = true;
"✅ Scenario B complete (switch with guarded crossfade).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [4] Scenario C — Bypass: chain → bypass → delay → on
//    Adjust frets if your JSON uses slightly different grandchildren numbers.
//    Example: 6/3="chain", 5/9="bypass", 4/3="delay", 3/3="on"
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();
~nav.(6, 3);   // "chain"
~nav.(5, 9);   // "bypass"
~nav.(4, 3);   // "delay"
~nav.(3, 3);   // "on"    // change to actual fret if needed
~showNav.();
~toQueue.();
~toSend.();
done = true;
"✅ Scenario C complete (bypass delay ON).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [5] Quick extras
//    • Re-run [2] then [3] to hear the effect.
//    • To bypass OFF, redo [4] but pick “…/off” as per your tree’s leaf fret.
//    • Inspect the current queue at any time:
//        ~system.commandManager.midiManager.queue.commandList.postln;
// ───────────────────────────────────────────────────────────────────────────

===== index_vsc_entrypoints.scd =====
// index_vsc_entrypoints.scd
// Project Entry Points Index for LivePedalboardSuite
//
// This file lists the main entry points (scripts, bring-up routines, test harnesses, and editors)
// for all major components in the project. Use this as a reference for launching, testing, or exploring the system.
//
// -----------------------------------------------------------------------------
// System Bring-Up & Main Launchers
// -----------------------------------------------------------------------------
"LivePedalboardSystem/Start_LivePedalboardSystem.scd"      // Main system bring-up (Option B)
"MagicPedalboard/MagicPedalboardNew.scd"                   // Main pedalboard engine
"MagicPedalboardTestRunner.sc"                             // Test/bring-up runner

// -----------------------------------------------------------------------------
// CommandTree System: Editors, Tests, Utilities
// -----------------------------------------------------------------------------
"CommandTree/martinTreeEditor.scd"                         // Interactive tree editor (load, add, remove, save nodes)
"CommandTree/MDCommandSystemTest20250804.scd"              // CommandTree structure and navigation test
"CommandTree/MDCommandSystemTest20250812.scd"              // CommandTree structure and navigation test (string+fret)
"CommandTree/MDCommandBuilderTest.scd"                     // CommandBuilder navigation and queue test

// -----------------------------------------------------------------------------
// Utilities & Simulations
// -----------------------------------------------------------------------------
"utilities/Simulate_CommandTree_Queue_AddDelay.scd"        // Simulate queueing "/add/delay" via CommandTree
"utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd"   // Stepwise navigation and queueing
"utilities/Queue_AddDelay_DirectCanonical.scd"             // Direct canonical command queueing
"utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd"       // Inspect tree and auto-route add/delay

// -----------------------------------------------------------------------------
// MagicPedalboard Troubleshooting & Demos
// -----------------------------------------------------------------------------
"MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd" // GUI, server, probe bring-up
"MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd" // Server/meter bring-up

// -----------------------------------------------------------------------------
// Test Harnesses & Acceptance Suites
// -----------------------------------------------------------------------------
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd" // Health check script
"MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd"       // One-go acceptance suite

// -----------------------------------------------------------------------------
// Miscellaneous & Example Scripts
// -----------------------------------------------------------------------------
"test 31tp8ve.scd"                                        // 31-tone scale test script

// -----------------------------------------------------------------------------
// Notes
// -----------------------------------------------------------------------------
// - For each entry, evaluate the file in VS Code to launch or test the corresponding component.
// - Most scripts assume you have run the main bring-up (Start_LivePedalboardSystem.scd) first.
// - See README.md and LivePedalboardSystem_README.md for further documentation and workflow details.
===== LivePedalboardSystem/CommandTreeStructureDiagram.scd =====
// updated 20250922-2147

root
├── audio (string 6, fret 1)
│   ├── source      (string 5, fret 3)
│   │   ├── testmelody (string 4, fret 3)
│   │   ├── sine       (string 4, fret 5)
│   │   └── noise      (string 4, fret 7)
│   ├── timebased   (string 5, fret 5)
│   │   ├── delay     (string 4, fret 3)
│   │   │   ├── multitap  (string 3, fret 3)
│   │   │   └── pingpong  (string 3, fret 5)
│   │   └── chorus    (string 4, fret 5)
│   ├── modulation (string 5, fret 7)
│   │   ├── tremolo   (string 4, fret 3)
│   │   ├── phaser    (string 4, fret 5)
│   │   └── flanger   (string 4, fret 7)
│   ├── filter (string 5, fret 9)
│   │   ├── lowpass   (string 4, fret 3)
│   │   ├── highpass  (string 4, fret 5)
│   │   └── bandpass  (string 4, fret 7)
│   ├── reverb (string 5, fret 11)
│   └── drive  (string 5, fret 13)

├── chain (string 6, fret 3)
│   ├── add         (string 5, fret 3)
│   ├── remove      (string 5, fret 5)
│   ├── swap        (string 5, fret 7)
│   ├── bypass      (string 5, fret 9)
│   ├── clear       (string 5, fret 11)
│   ├── setsource   (string 5, fret 13)
│   └── print       (string 5, fret 15)

├── switch (string 6, fret 5)
│   ├── crossfade         (string 5, fret 3)
│   └── crossfade_custom  (string 5, fret 5)

├── preset (string 6, fret 7)
│   ├── save        (string 5, fret 3)
│   └── load        (string 5, fret 5)

├── system (string 6, fret 9)
│   ├── reset       (string 5, fret 3)
│   ├── healthcheck (string 5, fret 5)
│   └── status      (string 5, fret 7)
===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue→adapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ← ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil → class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;



	    ~system.installAdapterBridge;         // ← MUST be before enableAutoMeters


	    // *** NEW: inline meter taps + post-switch auto-reinstall + GUI re-arm
    ~system.enableAutoMeters(18, 0.35);
    }.defer;
)


===== LivePedalboardSystem/Tests/Demo_Today_Playbook_FallbackOnly.scd =====
// Demo_Today_Playbook_FallbackOnly.scd
// v0.1.3
// MD 2025-09-22 23:45 BST

/* Purpose
   - Hardware-independent fallback to demonstrate MagicPedalboardNew.
   - Applies canonical commands in sequence, EVEN IF hardware is connected.
   - If your adapter (~ct_applyOSCPathToMPB) is present, it is used; otherwise
     this script calls MagicPedalboardNew methods directly for /add, /setSource,
/switch, /bypass commands.
   - Uses generated audio only (no SoundIn) and enforces Option A exclusivity.

   Style
   - tilde vars ok at top level; var-first in every function/closure.
   - lowercase method names; no server.sync; Server.default.bind for Ndef ops.
   - AppClock-only UI updates; no caret returns in deferred closures.
*/

(

var gapSeconds, playlistA, playlistB,
    systemReady, pedalboardReady,
    logMessage, showGuiHint,
    ensureGeneratedSources,
    tryEnsureAdapter, adapterAvailable, applyViaAdapter,
    applyDirectToPedalboard, applyOneCommand,
    runPlaylist, stopPlaylist, startGeneration;

"[FALLBACK] entered".postln;
thisProcess.nowExecutingPath.postln;  // helps confirm you ran the right file

// ── settings ─────────────────────────────────────────────────────────────────
gapSeconds = 0.60;
playlistA  = [ "/add/delay", "/switch" ];
playlistB  = [ "/bypass/delay/on", "/bypass/delay/off", "/switch" ];

// ── guards ───────────────────────────────────────────────────────────────────
systemReady     = ~system.notNil;
pedalboardReady = systemReady and: { ~system.pedalboard.notNil };


if(systemReady.not) {
    "⚠️  Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B)".warn;
    ^nil;
};

// ── logging + GUI hint ───────────────────────────────────────────────────────
logMessage = { |text| ("[FALLBACK] " ++ text).postln };
showGuiHint = { |text|
    var canShow;
    canShow = (~system.notNil)
        and: { ~system.statusDisplay.notNil }
        and: { ~system.statusDisplay.respondsTo(\showExpectation) };
    if(canShow) { ~system.statusDisplay.showExpectation(text, 0) };
};

// ── audio sources + option A exclusivity ─────────────────────────────────────
ensureGeneratedSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
/*            Ndef(\testmelody, {
                var trig, frequencySeq, freq, env, pan;
                trig         = Impulse.kr(3.2);
                frequencySeq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq         = Demand.kr(trig, 0, frequencySeq);
                env          = Decay2.kr(trig, 0.01, 0.35);
                pan          = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });*/

			Ndef(\testmelody, {
    var trig, freq, env, pan, scale, idx;
    trig = Impulse.kr(2.2); // relaxed tempo
    scale = [60, 62, 64, 67, 69]; // C major pentatonic
    idx = Demand.kr(trig, 0, Dwhite(0, scale.size, inf)); // returns control-rate index
    freq = Select.kr(idx, scale).midicps; // safe indexing
    env = Decay2.kr(trig, 0.01, 0.4);
    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
});

        };
        Ndef(\testmelody).ar(2);

        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    if(~mpb.notNil) {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.setSource(\testmelody);
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
    };
};

// ── try to use your adapter (~ct_applyOSCPathToMPB) if available ─────────────
tryEnsureAdapter = {
    var scriptFolderPath, candidateNames, found;
    if(~ct_applyOSCPathToMPB.notNil) { ^true };

    scriptFolderPath = PathName(thisProcess.nowExecutingPath).pathOnly;
    candidateNames = [
        "adapter_CommandTree_to_MagicPedalboard.scd",
        "adapter_commandtree_to_magicpedalboard.scd"
    ];
    found = candidateNames.detect({ |leaf|
        var fullPath = scriptFolderPath +/+ leaf;
        File.exists(fullPath).if({ fullPath.load; true }, { false })
    });

    (~ct_applyOSCPathToMPB.notNil)
};
adapterAvailable = tryEnsureAdapter.();

applyViaAdapter = { |canonicalPath|
    var guiRef;
    guiRef = ~system.statusDisplay;
    // signature from your existing adapter: (path, mpb, gui)
    ~ct_applyOSCPathToMPB.(canonicalPath, ~system.pedalboard, guiRef);
};

// ── direct mapping for the demo verbs if adapter is absent ───────────────────
applyDirectToPedalboard = { |canonicalPath|
    var pathSegments, verbName, effectSymbol, sourceSymbol,
        onOffString, bypassState, pedalboardRef;

    pedalboardRef = ~system.pedalboard;
    if(pedalboardRef.isNil) { logMessage.("pedalboard missing"); ^nil };

    pathSegments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(pathSegments.size == 0) { ^nil };
    verbName = pathSegments[0].asString;

    switch(verbName,

        "add", {
            if(pathSegments.size >= 2) {
                effectSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(effectSymbol);
                }{
                    logMessage.("no pedalboard.add; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /add path: " ++ canonicalPath);
            };
        },

        "setSource", {
            if(pathSegments.size >= 2) {
                sourceSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\setSource)) {
                    pedalboardRef.setSource(sourceSymbol);
                }{
                    logMessage.("no pedalboard.setSource; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /setSource path: " ++ canonicalPath);
            };
        },

        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                pedalboardRef.switchChain(0.12);
            }{
                logMessage.("no pedalboard.switchChain; skipped: " ++ canonicalPath);
            };
        },

        "bypass", {
            if(pathSegments.size >= 3) {
                effectSymbol = pathSegments[1].asSymbol;
                onOffString  = pathSegments[2].asString.toLower;
                bypassState  = (onOffString == "on") or: { onOffString == "true" } or: { onOffString == "1" };
                // for demo: act on CURRENT; your adapter usually controls NEXT
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(effectSymbol, bypassState);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        pedalboardRef.bypass(effectSymbol, bypassState);
                    }{
                        logMessage.("no pedalboard.bypass; skipped: " ++ canonicalPath);
                    };
                };
            }{
                logMessage.("bad /bypass path: " ++ canonicalPath);
            };
        },

        { // default
            logMessage.("unhandled verb: " ++ verbName ++ " (path=" ++ canonicalPath ++ ")");
        }
    );
};

// ── unified apply: prefer adapter; fall back to direct mapping ───────────────
applyOneCommand = { |canonicalPath|

    "DEBUG: applyOneCommand called with %".format(canonicalPath).postln;

    logMessage.("apply → " ++ canonicalPath);
    if(adapterAvailable) { applyViaAdapter.(canonicalPath) } { applyDirectToPedalboard.(canonicalPath) };
    if(~procHud_update.notNil) { ~procHud_update.() }; // optional HUD refresh
};

// ── sequenced playlist runner (AppClock; cancel-safe via generation id) ──────
runPlaylist = { |listOfCanonicalPaths, gap = 0.6|
    var myGeneration, indexCounter, totalCount, stepOnce, scheduleNext;

    // bump global generation to cancel older chains
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    myGeneration = ~fallback_gen;

    indexCounter = 0;
    totalCount   = listOfCanonicalPaths.size;

    stepOnce = {
        if(~fallback_gen != myGeneration) { ^nil }; // cancelled
        applyOneCommand.( listOfCanonicalPaths[indexCounter] );
        indexCounter = indexCounter + 1;
        if(indexCounter < totalCount) { scheduleNext.() } { logMessage.("done.") };
    };

    scheduleNext = {
        var delaySeconds;
        delaySeconds = gap ? 0.6;
        AppClock.sched(delaySeconds, {
            if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
        });
    };

    AppClock.sched(0.0, {
        if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
    });

    ^myGeneration;
};

// ── hard stop utility ────────────────────────────────────────────────────────
stopPlaylist = {
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    logMessage.("stopped.");
};

// ── go ───────────────────────────────────────────────────────────────────────
showGuiHint.(
    "Fallback-only demo (adapter=" ++ adapterAvailable ++ "):\n" ++
    "A: " ++ playlistA.asString ++ "\n" ++
    "B: " ++ playlistB.asString
);
ensureGeneratedSources.();
startGeneration = runPlaylist.(playlistA, gapSeconds);

// queue playlist B after A with a tail margin
AppClock.sched((playlistA.size * gapSeconds + 1.0).max(1.0), {
    if(~fallback_gen == startGeneration) {
        runPlaylist.(playlistB, gapSeconds);
    };
    nil
});
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail_Delayed.scd =====
// Fallback_Acceptance_PassFail_Delayed.scd
// v0.1.3
// MD 20250923-1534


/*
Purpose
- Run: /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
- Verify A XOR B only AFTER crossfade settles (avoid false FAIL during fade).
- Extra diagnostics: print plan.size, first path, and every step index.
Style
- var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.
- Generated audio only; Option A enforced if available.
*/

(
var say, trace, assertXorAfter;
var ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne;
var plan, idx, gap, settle, runStep, kickOff;

/* logging helpers */
say   = { |msg| ("[ACCEPT] " ++ msg).postln };
trace = { |msg| ("[TRACE] "  ++ msg).postln };

/* delayed assertion to avoid crossfade overlap */
assertXorAfter = { |expectA, expectB, label, delaySeconds|
    var doCheck, delay;
    delay = delaySeconds ? 0.35; // default settle > 0.12 crossfade
    doCheck = {
        var a, b, okFlag, tag;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        okFlag = (a == expectA) and: { b == expectB };
        tag = if(okFlag) { "PASS" }{ "FAIL" };
        (tag ++ " — " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    };
    AppClock.sched(delay, { doCheck.value; nil });
};

/* guards */
ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("⚠️ Bring-up first (Start Option B)"); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

/* ensure generated sources & Option A */
ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

/* application modes */
applyViaAdapter = { |path|
    var canShow;
    say.("apply → " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct → " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

/* plan: Events with optional verify on switch */
plan = [
    ( idx: 1, total: 5, path: "/add/delay" ),
    ( idx: 2, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: false, expectB: true,  label: "after first switch" ),
    ( idx: 3, total: 5, path: "/bypass/delay/on" ),
    ( idx: 4, total: 5, path: "/bypass/delay/off" ),
    ( idx: 5, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: true,  expectB: false, label: "after second switch" )
];

/* extra instrumentation to confirm the plan really exists */
trace.("plan.size = " ++ plan.size);
if(plan.size > 0) {
    trace.("plan[0].path = " ++ plan[0][\path].asString);
} {
    say.("⚠️ plan is empty — aborting to avoid a no-op run."); ^nil;
};

idx    = 0;
gap    = 0.60;
settle = 0.35;

/* run one step, then re-schedule next */
runStep = {
    var step, path, haveVerify, label, eA, eB, vd;
    if(idx >= plan.size) { say.("done."); ^nil; };

    step = plan[idx];
    trace.("step " ++ step[\idx] ++ " / " ++ step[\total]);

    path = step[\path].asString;
    applyOne.value(path);

    haveVerify = step.includesKey(\verifyDelay);
    if(haveVerify) {
        vd   = step[\verifyDelay] ? settle;
        eA   = step[\expectA];
        eB   = step[\expectB];
        label= step[\label].asString;
        assertXorAfter.value(eA, eB, label, vd);
        AppClock.sched(vd.max(gap), { idx = idx + 1; runStep.value; nil });
    }{
        AppClock.sched(gap, { idx = idx + 1; runStep.value; nil });
    };
};

/* go */
ensureSources.value;
kickOff = {
    var scheduled;
    trace.("scheduling kickoff in 0.03s on AppClock…");
    scheduled = AppClock.sched(0.03, { runStep.value; nil });
    ("[TRACE] AppClock.sched → " ++ scheduled.asString).postln;
};
kickOff.value;
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 — 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " — " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("⚠️ Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply → " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct → " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== LPDisplay/LPDisplay_AllInOne_BringUp.scd =====
// LPDisplay_AllInOne_BringUp.scd
// v0.9.8 — open the layout test window + export helpers for a guided tour
// MD 2025-10-01

/*
Purpose
- One-file bring-up for the LivePedalboardDisplay demo window:
  * Open a 6-pane GUI with A/B meters driven by SendPeakRMS.
  * Create a HUD mapper (dB headroom + gamma) and allow on/off toggling.
  * Provide safe, readable one-liners to swap sources and send pane text.
  * Keep to known-good wiring: Ndef(left) <<> Ndef(right); sinks read \in.ar(2).

Style / Conventions
- var-first declarations; descriptive names; tilde vars exported for convenience.
- No server.sync; GUI ops are deferred inside the window class.
- Single bring-up block that returns -> a Window.
- No SoundIn; the window defines internal demo sources/sinks (stereo).
- If the classes are missing, recompile after installing them at:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
*/

(
var hud, inst, win;

// --- Create a HUD map (top/floor/gamma), then build the window instance
hud  = LPDisplayHudMap.new(-6, -60, 1.0);         // defaults: headroom -6 dB, floor -60 dB, gamma 1.0
inst = LPDisplayLayoutTestWindow.new(hud);        // pass nil here if you prefer raw 0..1 meters initially

// --- Open the window (the class ensures only one "Layout Test" window is active)
win = inst.open;                                  // -> a Window

// --- Export handles (tilde vars) so you can drive the demo interactively
~hud  = hud;          // current HUD map instance (may be replaced by ~hud_on)
~inst = inst;         // the layout test window controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;          // the Window; optional use

// --- Demo helpers: all nil-safe through the class methods they call
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;
};

~hud_set = { |key, value|
    // Ensure we have a HUD instance, then tweak a single parameter (\top, \floor, \gamma)
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);  // ensure mapping is active while tweaking
    ~hud.set(key, value).print;  // prints settings
};

~hud_preview = { |rmsDb = -9|
    // Convenience to see the UI mapping for a specific RMS dB value
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);
};

~setA = { |sym|  ~inst.setSourceA(sym) };         // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };         // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|
    // paneKey ∈: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    // Close the window and free OSCdefs & Ndefs inside the class
    ~inst.close;
};

// --- Friendly banner so the recipient knows what to try next:
"LivePedalboardDisplay — bring-up complete. See 'Quick Tour' below for optional steps.".postln;
"Tip: you can now call ~hud_off.(), ~hud_on.(), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

// Return the Window so SC shows '-> a Window'
win
)

===== LPDisplay/LPDisplay_AllInOne_Demo_Tour.scd =====

// LPDisplay_AllInOne_Demo_Tour.scd
// v0.9.8.1 added check that GUI window is open at start of last block
// v0.9.8 — single-file bring-up + guided quick tour (evaluate blocks top-to-bottom)
// MD 2025-10-01

/*
Overview
- This single .scd opens the LivePedalboardDisplay demo window and provides a guided "Quick Tour".
- The window shows A/B chains with meters (via SendPeakRMS), optional HUD mapping (dB headroom + gamma),
  and several text panes you can write to.

Prerequisites
- Ensure these classes are installed and you have recompiled the class library:
  .../PhD_projects/LivePedalboardSuite/LivePedalboardDisplay/Classes/
    • LPDisplayHudMap.sc
    • LPDisplaySigChain.sc
    • LPDisplayLayoutWindow.sc
  SuperCollider menu: Language → Recompile Class Library

How to use this file
1) Evaluate the first block (Bring-Up). You should see '-> a Window'.
2) Then evaluate the Quick Tour chunks (00..06) as needed, one line at a time or a few at a time.
3) To close and clean up, evaluate the Close chunk (06) at the end.

Style / Coding rules
- var-first declarations; descriptive names; GUI updates are deferred in the classes.
- JITLib wiring strictly: Ndef(left) <<> Ndef(right). Sinks read \in.ar(2).
- Generated demo sources only (no SoundIn).
*/

(
// --- Bring-Up: create HUD, create instance, open the window, export helpers ---
var hud, inst, win;

hud  = LPDisplayHudMap.new(-6, -60, 1.0);           // defaults: top=-6 dB, floor=-60 dB, gamma=1.0
inst = LPDisplayLayoutWindow.new(hud);          // pass nil if you prefer raw meters initially
win  = inst.open;                                   // -> a Window (ensures only one "Layout Test")

// Export handles for interactive use during the tour
~hud  = hud;                                        // current HUD instance (may be replaced)
~inst = inst;                                       // the controller (has setSourceA/B, setHudMap, sendPaneText, printHud)
~win  = win;                                        // the Window

// Helper one-liners used by the tour
~hud_on  = { |topDb = -6, floorDb = -60, gamma = 1.0|
    var newHud = LPDisplayHudMap.new(topDb, floorDb, gamma);
    ~hud = newHud;
    ~inst.setHudMap(newHud).printHud;               // console prints HUD params
};

~hud_off = {
    ~inst.setHudMap(nil).printHud;                  // console: "HUD mapping: none (raw 0..1)"
};

~hud_set = { |key, value|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~inst.setHudMap(~hud);
    ~hud.set(key, value).print;                     // tweak \top/\floor/\gamma; prints settings
};

~hud_preview = { |rmsDb = -9|
    ~hud = ~hud ?? { LPDisplayHudMap.new(-6, -60, 1.0) };
    ~hud.preview(rmsDb);                             // prints UI fraction for given dB RMS
};

~setA = { |sym|  ~inst.setSourceA(sym) };           // e.g., ~setA.(\srcC)
~setB = { |sym|  ~inst.setSourceB(sym) };           // e.g., ~setB.(\srcA)

~text = { |paneKey, aString|                        // pane keys: \left, \right, \system, \diag, \choices, \recv
    ~inst.sendPaneText(paneKey, aString);
};

~print_hud = {  ~inst.printHud  };

~close = {
    ~inst.close;                                     // frees OSCdefs; stops sink Ndefs; closes window
};

"LivePedalboardDisplay — bring-up complete. See Quick Tour blocks below.".postln;
"Tip: try ~hud_off.(), ~hud_on.(-9, -60, 1.0), ~setA.(\\srcC), ~text.(\\diag, \"Hello\").".postln;

win                                                // return -> a Window
)


// =============================
// Quick Tour 00 — Sanity checks
// =============================

// LPDisplay_Tour_00_Sanity
// v1.0 — MD 2025-10-01
//
// Purpose
// - Confirm bring-up ran and helpers exist before running the tour.
// Style
// - Each line prints a boolean; 'true' means you're good to proceed.

(~inst.notNil).postln;                               // expected: true
~inst.respondsTo(\setHudMap).postln;                 // expected: true
(~text.notNil).postln;                               // expected: true
(~hud_on.notNil and: { ~hud_off.notNil }).postln;    // expected: true


// ==========================================
// Quick Tour 01 — Verify window + status text
// ==========================================

// LPDisplay_Tour_01_VerifyAndStatus
// v1.0 — MD 2025-10-01
//
// Purpose
// - Confirm the window is open and panes update.
// Style
// - Evaluate lines one by one; text should appear immediately.

~text.(\diag,   "Ready @ " ++ Date.getDate.stamp);  // diag pane prints timestamp
~text.(\system, "A/B chains running. HUD is ON by default."); // system pane status


// =======================================
// Quick Tour 02 — Swap tail sources (A/B)
// =======================================

// LPDisplay_Tour_02_SwapTailSources
// v1.0 — MD 2025-10-01
//
// Purpose
// - Swap each chain's tail source; you will hear/see changes.
// Style
// - After swap, the window auto-updates the top labels to show the new chain strings.

~setA.(\srcC);                                       // A tail -> \srcC (LFSaw/tanh) ; left meter responds
~setB.(\srcA);                                       // B tail -> \srcA (PinkNoise)  ; right meter responds
~text.(\diag, "Swapped: A->\\srcC, B->\\srcA");     // diag note confirming the change


// ==============================================
// Quick Tour 03 — Toggle HUD mapping & preview UI
// ==============================================

// LPDisplay_Tour_03_ToggleHUD
// v1.0 — MD 2025-10-01
//
// Purpose
// - Show raw meters (no mapping), then enable HUD with new top/floor/gamma.
// - Preview mapping for a specific RMS dB value.
// Style
// - Use helpers created at bring-up.

~hud_off.();                                         // raw linear RMS on meters ; console prints mapping=none
~hud_on.(-9, -60, 1.0);                              // enable mapping top=-9 ; console prints params
~hud_set.(\gamma, 1.2);                              // add curvature ; console prints updated params
~hud_preview.(-9);                                   // prints UI fraction for -9 dB RMS ; e.g., 0.83
~print_hud.();                                       // print current HUD parameters


// ============================================
// Quick Tour 04 — Populate the lower text panes
// ============================================

// LPDisplay_Tour_04_Panes_Content
// v1.0 — MD 2025-10-01
//
// Purpose
// - Simulate a fuller display by writing to \choices and \recv.
// Style
// - Multiline strings using \n.

~text.(\choices, "Choices:\n  1) Swap A/B\n  2) Toggle HUD\n  3) Send message\n  4) Close");            // choices pane shows 4 options

~text.(\recv,"Receiving:\n  /peakrmsA and /peakrmsB @ 20 Hz\n  Console prints ~1 Hz (decimated)"); // recv pane shows OSC info


// =====================================
// Quick Tour 05 — Lightweight smoke tests
// =====================================

// LPDisplay_Tour_05_SmokeTests
// v1.0 — MD 2025-10-01
//
// Purpose
// - Quick PASS/FAIL checks in the Post window.
// Style
// - Run while the main demo window is open. Avoid LPDisplayLayoutWindow.test here.

LPDisplayHudMap.test;                                 // expected: prints cases + "LPDisplayHudMap.test: PASS"
LPDisplaySigChain.test;                               // expected: brief run + "LPDisplaySigChain.test: PASS"


// ================================
// Quick Tour 06 — Close and cleanup
// ================================

// LPDisplay_Tour_06_Close
// v1.0 — MD 2025-10-01
//
// Purpose
// - Cleanly close the window and free responders.
// Style
// - Re-run the Bring-Up block to open again.

~close.();                                            // expected: window closes; OSCdefs freed; sinks stopped


// ======================================================
// Optional: One-button smoke runner (evaluate as a block,
// keeping first block running.)
// ======================================================

// LPDisplay_Tour_07_OneButtonSmoke
// v1.0 — MD 2025-10-01
//
// Purpose
// - Minimal automated walk-through: flip sources, post a diag line, print HUD, then stop.
// Style
// - Safe timings via AppClock; does not assume SoundIn.

(
var step1, step2;

// Ensure GUI is up before scheduling steps:
if (~inst.isNil or: { ~win.isNil } or: { ~win.isClosed }) {
    var hud = LPDisplayHudMap.new(-6, -60, 1.0);
    ~inst = LPDisplayLayoutWindow.new(hud);
    ~win  = ~inst.open;
    ~hud  = hud;
};

step1 = {
    ~setA.(\srcC); ~setB.(\srcA);                    // swap tails
    ~text.(\diag, "Smoke: swapped A/B @ " ++ Date.getDate.stamp);
};
step2 = {
    ~print_hud.();                                    // print active HUD state
    ~text.(\system, "Smoke: HUD printed; closing in 1s");
    AppClock.sched(1.0, { ~close.(); nil });          // close after 1s
};
AppClock.sched(0.5, { step1.(); AppClock.sched(1.0, { step2.(); nil }); nil });
)

===== LPDisplay/LPDisplay_CompatExports.scd =====
// LPDisplay_CompatExports.scd
// v0.9.2 - shims for old tilde variables + bring-up
// MD 20251001

(
var hud, win, inst;

// Create a HUD map (or set to nil to keep raw 0..1 meters)
hud = LPDisplayHudMap.new(-6, -60, 1.0);

// Open the window (-> a Window)
win = LPDisplayLayoutWindow.new(hud).open; // the window
win = inst.open; // the controller for the window

// Export legacy one-liners:
~setSourceA = { |sym| inst.setSourceA(sym) };
~setSourceB = { |sym| inst.setSourceB(sym) };

// Pane text helper (keys: \left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString| win.sendPaneText(paneKey, aString) };

// HUD helpers to mirror your previous patch commands:
~hud_set     = { |key, value| hud.set(key, value) };
~hud_preview = { |db| hud.preview(db) };
~hud_print   = { hud.print };

// Quick ping:
~hud_print.();
)
===== LPDisplay/LPDisplayClasses_tests.scd =====
// LPDisplayClasses_tests.scd
// v0.9
// MD 20251002

LPDisplayHudMap.help;
LPDisplayLayoutWindow.help;
LPDisplaySigChain.help;



LPDisplayHudMap.apihelp
LPDisplayLayoutWindow.apihelp;
LPDisplaySigChain.apihelp;


LPDisplayHudMap.test;
LPDisplayLayoutWindow.test;
LPDisplaySigChain.test;
===== LPDisplay/Migration_tests/archived/ Close_LPDisplayLayoutWindow.scd =====
// Close_LPDisplayLayoutWindow.scd
// v0.1.0
// MD 20251003-1110

/* Purpose/Style:
- Find and close any open windows whose name matches LPDisplayLayoutWindow (or default).
*/

(
var closedCount;

closedCount = 0;
Window.allWindows.do({ |w|
    var matches;
    matches = (w.name == "LPDisplayLayoutWindow") or: { w.name.contains("LPDisplayLayoutWindow") };
    matches.if({
        w.close;
        closedCount = closedCount + 1;
    });
});

("Closed LPDisplayLayoutWindow windows: " ++ closedCount.asString).postln;
)
===== LPDisplay/Migration_tests/archived/LivePedalboardSystem_Integrate_Bounds.scd =====
// LivePedalboardSystem_Integrate_Bounds.scd
// v0.1.0
// MD 20251003-1125

/* Purpose/Style:
- Minimal integration: apply saved bounds after creation; save on close.
- Returns '-> a Window'.
*/

(
var createdWindow, windowPrefix, builderFunction, desiredTitle;

("Running: LivePedalboardSystem_Integrate_Bounds.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// Bring up single window using your existing manager
createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

// Apply saved bounds (if any), then front
~lps_applyLastWindowBounds.(createdWindow, windowPrefix);
createdWindow.front;

// Save bounds when the window closes
createdWindow.onClose = {
    ~lps_saveWindowBounds.(createdWindow, windowPrefix);
};

// Keep a handle
~lps_mainWindow = createdWindow;

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/archived/LivePedalboardSystem_Integrate_WindowManagement.scd =====
// LivePedalboardSystem_Integrate_WindowManagement.scd
// v0.1.1
// MD 20251003-1031

/* Purpose/Style:
- Minimal integration call for use inside LivePedalboardSystem bring-up.
- Ensures exactly one display window is present, with policy-compliant title.
- Returns '-> a Window'.
*/

(
var createdWindow, windowPrefix, builderFunction, desiredTitle;

("Running: LivePedalboardSystem_Integrate_WindowManagement.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_mainWindow = createdWindow;

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/archived/LivePedalboardSystem_WindowBounds.scd =====
// LivePedalboardSystem_WindowBounds.scd
// v0.1.1
// MD 20251003-1136

/* Purpose/Style:
- Define *pure* helpers to save/load/apply window bounds safely.
- IMPORTANT: uses isNil.if to assign Function objects (no '??' auto-eval).
- Writes to <Extensions>/LivePedalboardSuite/prefs/<prefix>_window_bounds.txt
- Known-good SC only: File.exists, File.mkdir, File.use, split/asFloat.
*/

(
var ensureDefaults;

("Running: LivePedalboardSystem_WindowBounds.scd").postln;

ensureDefaults = {
    ~lps_prefsDir.isNil.if({
        ~lps_prefsDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "prefs";
    });

    ~lps_boundsFilePathForPrefix.isNil.if({
        ~lps_boundsFilePathForPrefix = { |prefix|
            var safePrefix;
            safePrefix = prefix ?? { ~lps_windowPrefix ?? { "MagicDisplayGUI" } };
            ~lps_prefsDir +/+ (safePrefix ++ "_window_bounds.txt")
        };
    });

    ~lps_saveWindowBounds.isNil.if({
        ~lps_saveWindowBounds = { |window, prefix|
            var filePath, rect, content;
            if(window.isNil) { "saveWindowBounds: window is nil".warn; ^nil };
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(~lps_prefsDir).if({ }, { File.mkdir(~lps_prefsDir) });
            rect = window.bounds; // Rect(x, y, width, height)
            content = [rect.left, rect.top, rect.width, rect.height].collect(_.asString).join(" ");
            File.use(filePath, "w", { |f| f.write(content) });
            ("Saved bounds to: " ++ filePath ++ " -> " ++ content).postln;
            filePath
        };
    });

    ~lps_loadWindowBounds.isNil.if({
        ~lps_loadWindowBounds = { |prefix|
            var filePath, content, parts, rect;
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(filePath).if({
                content = File.readAllString(filePath);
                parts = content.split($ );
                if(parts.size >= 4) {
                    rect = Rect(parts[0].asFloat, parts[1].asFloat, parts[2].asFloat, parts[3].asFloat);
                    ("Loaded bounds from: " ++ filePath ++ " -> " ++ rect.asString).postln;
                    rect
                } {
                    ("Bounds file malformed: " ++ filePath ++ " -> '" ++ content ++ "'").warn;
                    nil
                }
            }, {
                ("No saved bounds at: " ++ filePath).postln;
                nil
            })
        };
    });

    ~lps_applyLastWindowBounds.isNil.if({
        ~lps_applyLastWindowBounds = { |window, prefix|
            var rect;
            if(window.isNil) { "applyLastWindowBounds: window is nil".warn; ^nil };
            rect = ~lps_loadWindowBounds.(prefix);
            if(rect.notNil) {
                window.bounds = rect;
                ("Applied saved bounds: " ++ rect.asString).postln;
            };
            window
        };
    });

    ~lps_frontByPrefix.isNil.if({
        ~lps_frontByPrefix = { |prefix|
            var effectivePrefix, wins;
            effectivePrefix = prefix ?? { ~lps_windowPrefix ?? { "MagicDisplayGUI" } };
            wins = Window.allWindows.select({ |win| win.name.asString.beginsWith(effectivePrefix) });
            wins.notEmpty.if({ wins.first.front; wins.first }, { nil })
        };
    });
};

ensureDefaults.();
)

===== LPDisplay/Migration_tests/archived/LivePedalboardSystem_WindowManager_FrontHelpers.scd =====
// LivePedalboardSystem_WindowManager_FrontHelpers.scd
// v0.1.0
// MD 20251003-1136

/* Purpose/Style:
- Adds a non-destructive 'front or bring-up' helper alongside existing manager.
- Does NOT modify existing helpers; safe to load any time.
- Returns a Window when bringing up; returns nil if fronting was possible but no window.
*/

(
var ensureHelpers;

("Running: LivePedalboardSystem_WindowManager_FrontHelpers.scd").postln;

ensureHelpers = {
    ~lps_frontOrBringUpByPrefix.isNil.if({
        ~lps_frontOrBringUpByPrefix = { |prefix, buildFunc, desiredTitle|
            var win, effectivePrefix;
            effectivePrefix = prefix ?? { ~lps_windowPrefix ?? { "MagicDisplayGUI" } };

            win = ~lps_frontByPrefix.notNil.if({ ~lps_frontByPrefix.(effectivePrefix) }, { nil });
            win.notNil.if({
                // Found one; fronted already, do not recreate
                win
            }, {
                // None found; bring up exactly one via existing manager
                ~lps_bringUpSingleWindow.(effectivePrefix, buildFunc, desiredTitle)
            })
        };
    });
};

ensureHelpers.();
)

===== LPDisplay/Migration_tests/archived/Test_LPS_Front_Then_BringUp.scd =====
// Test_LPS_Front_Then_BringUp.scd
// v0.1.0
// MD 20251003-1136

/* Purpose/Style:
- First tries to front an existing window; if none, brings one up.
- Returns '-> a Window' in the bring-up path, or '-> a Window' if one existed.
*/

(
var windowPrefix, builderFunction, desiredTitle, win;

("Running: Test_LPS_Front_Then_BringUp.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

win = ~lps_frontOrBringUpByPrefix.(windowPrefix, builderFunction, desiredTitle);

// Return -> a Window
win
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowBounds_Persist.scd =====
// Test_LPS_WindowBounds_Persist.scd
// v0.1.0
// MD 20251003-1125

/* Purpose/Style:
- Proves that window bounds are saved and restored.
- Sets a known Rect, saves, closes, reopens, and checks equality.
- Returns '-> a Window'.
*/

(
var windowPrefix, builderFunction, desiredTitle, firstWindow, secondWindow, testRect, reopenedRect, closedCount, pass;

("Running: Test_LPS_WindowBounds_Persist.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";
testRect = Rect(120, 140, 730, 420);

// Builder
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// 1) Bring up, apply saved (if any), set testRect, save
firstWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
firstWindow.bounds = testRect;
~lps_saveWindowBounds.(firstWindow, windowPrefix);

// 2) Close all with prefix
closedCount = ~lps_closeWindowsByPrefix.(windowPrefix);
("Closed " ++ closedCount.asString ++ " window(s)").postln;

// 3) Reopen and apply saved bounds, then check
secondWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_applyLastWindowBounds.(secondWindow, windowPrefix);
reopenedRect = secondWindow.bounds;

pass = (reopenedRect.left == testRect.left)
    and: { reopenedRect.top == testRect.top }
    and: { reopenedRect.width == testRect.width }
    and: { reopenedRect.height == testRect.height };

("Bounds persist check: " ++ pass.asString
 ++ " (got " ++ reopenedRect.asString ++ ", expected " ++ testRect.asString ++ ")").postln;

// Return -> a Window
secondWindow
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_BringUp_Debug.scd =====
// Test_LPS_WindowManager_BringUp_Debug.scd
// v0.1.1
// MD 20251003-1138

/* Purpose/Style:
- Diagnostic bring-up to confirm counts and return type.
- Returns '-> a Window' when successful.
*/

(
var windowPrefix, desiredTitle, builderFunction, resultWindow, beforeCount, afterCount;

("Running: Test_LPS_WindowManager_BringUp_Debug.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.notNil.if({
        createdWindowLocal.name = requestedTitle;
    });
    ("DBG builder -> " ++ (createdWindowLocal.notNil.if({ createdWindowLocal.class.name.asString }, { "nil" }))).postln;
    createdWindowLocal
};

beforeCount = ~lps_findWindowsByPrefix.(windowPrefix).size;
("DBG before: " ++ beforeCount.asString ++ " window(s) with prefix").postln;

resultWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

afterCount = ~lps_findWindowsByPrefix.(windowPrefix).size;
("DBG after:  " ++ afterCount.asString ++ " window(s) with prefix").postln;
("DBG result is Window: " ++ (resultWindow.notNil and: { resultWindow.isKindOf(Window) }).asString).postln;

resultWindow.notNil.if({ resultWindow.front; });

// Return -> a Window (or nil)
resultWindow
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_BringUp.scd =====
// Test_LPS_WindowManager_BringUp.scd
// v0.1.2
// MD 20251003-1138

/* Purpose/Style:
- Acceptance: enforce a single GUI window using the manager, building LPDisplayLayoutWindow.
- Returns '-> a Window'.
*/

(
var createdWindow, windowPrefix, builderFunction, desiredTitle;

("Running: Test_LPS_WindowManager_BringUp.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

// Builder must return a Window
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.notNil.if({
        createdWindowLocal.name = requestedTitle;
    });
    createdWindowLocal
};

// Bring up exactly one window and front it
createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_CloseAll.scd =====
// Test_LPS_WindowManager_CloseAll.scd
// v0.1.0
// MD 20251003-1031

/* Purpose/Style:
- Closes all windows whose name begins with the policy prefix.
- Returns '-> a Window' by reopening a single window after close.
*/

(
var closedCount, reopenedWindow, windowPrefix, builderFunction;

("Running: Test_LPS_WindowManager_CloseAll.scd").postln;

windowPrefix = "MagicDisplayGUI";

// Close all with the prefix
closedCount = ~lps_closeWindowsByPrefix.(windowPrefix);
("Closed " ++ closedCount.asString ++ " window(s) with prefix '" ++ windowPrefix ++ "'").postln;

// Builder to bring a fresh single window back up
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// Reopen single window and return it
reopenedWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, "MagicDisplayGUI - LPDisplayLayout");
reopenedWindow
)

===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_DuplicateHandling.scd =====
// Test_LPS_WindowManager_DuplicateHandling.scd
// v0.1.0
// MD 20251003-1031

/* Purpose/Style:
- Creates a deliberate duplicate, then reruns bring-up to prove consolidation to one window.
- Returns '-> a Window' (the surviving, normalized window).
*/

(
var strayWindow, consolidatedWindow, windowPrefix, builderFunction;

("Running: Test_LPS_WindowManager_DuplicateHandling.scd").postln;

windowPrefix = "MagicDisplayGUI";

// Create a stray duplicate (simulates accidental extra window)
strayWindow = LPDisplayLayoutWindow.respondsTo(\open).if({
    LPDisplayLayoutWindow.open
}, {
    LPDisplayLayoutWindow.new
});
strayWindow.name = "MagicDisplayGUI - TEMP stray";
strayWindow.front;

// Reuse the same builder as the BringUp test
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// Consolidate to exactly one window
consolidatedWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, "MagicDisplayGUI - LPDisplayLayout");

// Return -> a Window
consolidatedWindow
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_Front.scd =====
// Test_LPS_WindowManager_Front.scd
// v0.1.0
// MD 20251003-1125

/* Purpose/Style:
- Brings the single policy window to front (no recreation).
- If missing, returns nil (prints info); otherwise returns '-> a Window'.
*/

(
var windowPrefix, win;

("Running: Test_LPS_WindowManager_Front.scd").postln;

windowPrefix = "MagicDisplayGUI";

win = ~lps_frontByPrefix.(windowPrefix);

if(win.isNil) {
    ("No window found with prefix '" ++ windowPrefix ++ "'").postln;
} {
    ("Fronted window: " ++ win.name.asString).postln;
};

// Return -> a Window (or nil if none existed)
win
)

===== LPDisplay/Migration_tests/Bind_CM_to_LPDisplay_Robust.scd =====
// Bind_CM_to_LPDisplay_Robust.scd
// v0.2.0
// MD 20251003-1412

/* Purpose / Style
- Bind LPDisplayAdapter to a CommandManager:
  • Prefer ~system’s CM if we can find it under common names or by scanning zero-arg methods.
  • Otherwise create a standalone CommandManager.
- Expose deterministic nav helpers bound to explicit strings:
  root → string 6 (frets 1,3,5,7,9), children → string 5, deeper → string 4.
- Style: var-first; tilde vars; lowercase; descriptive names; no server.sync.
*/

(
var findSystemCM, pickOrCreateCM, bindAdapter, tryNav, reportWhich;

// 1) Try to locate a CM on ~system using common selectors or a safe zero-arg scan
findSystemCM = {
    var cmObj, preferred, allNames, hits;
    cmObj = nil;
    if(~system.notNil) {
        preferred = [\commandManager, \cmdManager, \cm, \manager].detect({ arg sel;
            (~system.respondsTo(sel)) and: { ~system.perform(sel).notNil }
        });
        if(preferred.notNil) {
            cmObj = ~system.perform(preferred);
        }{
            // scan only safe zero-arg methods whose names *look* like managers
            allNames = ~system.class.methods.collect(_.name).collect(_.asString);
            hits = allNames.select({ arg n;
                var ns = n.toLower;
                (ns.contains("command") or: { ns.contains("manager") or: { ns == "cm" or: { ns.contains("cmd") } } })
            });
            hits.do({ arg n;
                var candidate;
                candidate = ~system.tryPerform(n.asSymbol);
                if(candidate.notNil and: { candidate.respondsTo(\updateDisplay) and: { candidate.respondsTo(\builder) } }) {
                    cmObj = candidate;
                };
            });
        };
    };
    cmObj
};

// 2) Choose CM: prefer system CM, else create a standalone one
pickOrCreateCM = {
    var cmLocal;
    cmLocal = findSystemCM.();
    cmLocal = (cmLocal.notNil).if({ cmLocal }, { CommandManager.new(nil) });
    ~cm = cmLocal;  // publish for quick access elsewhere
    cmLocal
};

// 3) Bind adapter to the chosen CM (idempotent), and show initial display
bindAdapter = { arg cmLocal;
    var adapterLocal;
    adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
    ~lp_adapter = adapterLocal;
    cmLocal.display = adapterLocal;
    cmLocal.updateDisplay;
    adapterLocal
};

// 4) Deterministic navigation (explicit string/fret); always writes Diag feedback
tryNav = { arg cmLocal, stringNum, fretNum;
    var ok;
    ok = cmLocal.builder.tryPerform(\navigateByFret, stringNum, fretNum);
    (ok == false or: { ok.isNil }).if({
        ok = cmLocal.builder.tryPerform(\navigateByFret, fretNum);
    });
    cmLocal.updateDisplay;
    (~guiLP.notNil).if({
        ~guiLP.sendPaneText(\diag, "Tried: string " ++ stringNum ++ ", fret " ++ fretNum ++ " | result: " ++ ok.asString);
    });
    ok
};

// 5) Report which CM we bound to (system vs standalone)
reportWhich = { arg cmLocal;
    var isSystemCM;
    isSystemCM = (~system.notNil) and: {
        [\commandManager, \cmdManager, \cm, \manager].any({ arg sel;
            (~system.respondsTo(sel)) and: { ~system.perform(sel) === cmLocal }
        })
    };
    (isSystemCM.if({ "Bound to: SYSTEM CommandManager" }, { "Bound to: STANDALONE CommandManager" })).postln;
};

// sequence
~cm = pickOrCreateCM.();
bindAdapter.(~cm);
reportWhich.(~cm);

// public helpers (root-first: 6→5→4)
~nav6 = { arg fret; tryNav.(~cm, 6, fret) };  // root
~nav5 = { arg fret; tryNav.(~cm, 5, fret) };  // depth 1
~nav4 = { arg fret; tryNav.(~cm, 4, fret) };  // depth 2+

"Nav ready. From root use ~nav6.(1|3|5|7|9); then ~nav5.(3|5|7); then ~nav4.(3|5|7).".postln;

// tracked progress
~md_progress = (~md_progress ? List.new).add("Robust bind + nav @ " ++ Date.localtime.stamp);
)
===== LPDisplay/Migration_tests/Bind_LPDisplayAdapter.scd =====
// Bind_LPDisplayAdapter.scd
// v0.1.0
// MD 20251003-1252

/* Purpose / Style
- Create and bind the adapter so CommandManager writes into LPDisplay panes.
- Style: tilde vars; var-first; known-good SC syntax.
*/

(
var cm;
~lp_adapter = LPDisplayAdapter.new(~guiLP);
cm = (~system.notNil).if({ ~system.tryPerform(\commandManager) }, { nil });
(cm.notNil).if({ cm.display = ~lp_adapter });
"LPDisplayAdapter bound to CommandManager (if present).".postln;

// quick smoke
(~guiLP.notNil).if({ ~guiLP.sendPaneText(\system, "Adapter OK"); });
)

===== LPDisplay/Migration_tests/BringUp_System_Then_Autobind_LPDisplay.scd =====
// BringUp_System_Then_Autobind_LPDisplay.scd
// v0.1.0
// MD 20251003-1559

/* Purpose / Style
- Ensure ~system exists (if LivePedalboardSystem is compiled), resolve its CommandManager,
  bind LPDisplayAdapter, and refresh LPDisplay panes once.
- Non-destructive to audio: does not clear the server tree.
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var lpsClass, ensureSystem, resolveCm, bindAdapter, reportBind, cmLocal, pathNote;

// 0) get the class if compiled
lpsClass = \LivePedalboardSystem.asClass;

// 1) create ~system if class exists and ~system is nil (non-destructive)
ensureSystem = {
    if(lpsClass.notNil and: { ~system.isNil }) {
        ~system = lpsClass.new(nil);  // uses class defaults; opens no extra GUI here
        "System created (LivePedalboardSystem).".postln;
        (~md_log.notNil).if({ ~md_log.("System created by BringUp_System_Then_Autobind") });
    };
    nil
};

// 2) resolve CommandManager from ~system
resolveCm = {
    var selectors, pb, pbSelectors, via;
    cmLocal = nil;
    pathNote = "n/a";

    if(~system.notNil) {
        // preferred: accessor you installed today (plus aliases)
        selectors = [\commandManager, \cmdManager, \cm, \manager];
        selectors.do({ arg sel;
            var candidate;
            if(cmLocal.isNil and: { ~system.respondsTo(sel) }) {
                candidate = ~system.perform(sel);
                if(candidate.notNil and: { candidate.respondsTo(\updateDisplay) and: { candidate.respondsTo(\builder) } }) {
                    cmLocal = candidate; pathNote = "~system." ++ sel.asString;
                };
            };
        });

        // fallback: look under pedalboard.* using same selector list
        if(cmLocal.isNil) {
            pb = ~system.tryPerform(\pedalboard);
            if(pb.notNil) {
                pbSelectors = [\commandManager, \cmdManager, \cm, \manager];
                pbSelectors.do({ arg sel;
                    var candidate;
                    if(cmLocal.isNil and: { pb.respondsTo(sel) }) {
                        candidate = pb.perform(sel);
                        if(candidate.notNil and: { candidate.respondsTo(\updateDisplay) and: { candidate.respondsTo(\builder) } }) {
                            cmLocal = candidate; pathNote = "~system.pedalboard." ++ sel.asString;
                        };
                    };
                });
            };
        };
    };
    cmLocal
};

// 3) bind adapter (idempotent) and update panes
bindAdapter = {
    var adapterLocal;
    if(cmLocal.notNil) {
        adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
        ~lp_adapter = adapterLocal;
        cmLocal.display = adapterLocal;
        cmLocal.updateDisplay;
        "Adapter bound to SYSTEM CommandManager.".postln;
        (~md_log.notNil).if({ ~md_log.("Auto-bind OK via " ++ pathNote) });
    }{
        (~system.isNil).if({
            "System class missing or ~system not created; staying in STANDALONE mode.".postln;
        },{
            "Could not resolve a system CommandManager; staying in STANDALONE mode.".postln;
        });
    };
    nil
};

// 4) compact report
reportBind = {
    "system class: ".post; (lpsClass.notNil.if({ lpsClass }, { "nil" })).postln;
    "~system present: ".post; (~system.notNil).postln;
    "CM path: ".post; pathNote.postln;
    "display bound: ".post;
    (cmLocal.notNil and: { cmLocal.display.notNil } and: { cmLocal.display.respondsTo(\showExpectation) }).postln;
};

// sequence
ensureSystem.();
resolveCm.();
bindAdapter.();
reportBind.();
)
===== LPDisplay/Migration_tests/Close_LPDisplayLayoutWindow.scd =====
// Close_LPDisplayLayoutWindow.scd
// v0.1.1
// MD 20251003-1120

/* Purpose/Style:
- Close any windows created by LPDisplayLayoutWindow tests.
- Matches both "Layout Test" and names containing "LPDisplayLayoutWindow".
- Style: var-first, descriptive names, no single-letter locals.
*/

(
var closedCount;

closedCount = 0;

Window.allWindows.do({ |w|
    var windowName;
    windowName = w.name.asString;
    if(windowName == "Layout Test" or: { windowName.contains("LPDisplayLayoutWindow") }) {
        w.close;
        closedCount = closedCount + 1;
    };
});

("Closed LPDisplayLayoutWindow windows: " ++ closedCount).postln;
closedCount
)
===== LPDisplay/Migration_tests/Install_LPD_ProgressLogger.scd =====
// Install_LPD_ProgressLogger.scd
// v0.1.3
// MD 20251003-1518

/* Purpose / Style
- Append-only progress logger to OneDrive so notes survive recompile/restart.
- Uses File.exists / File.mkdir on STRING paths (portable).
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var baseDirPathString, logsDirPathString, logFilePathString, ensureDir, writeLine;

// 0) base dir in OneDrive
baseDirPathString = "~/Library/CloudStorage/OneDrive-TheOpenUniversity/LivePedalboardSuite".standardizePath;

//baseDirPathString = "~/LivePedalboardSuite".standardizePath;

// 1) Logs dir path (string)
logsDirPathString = baseDirPathString ++ "/Logs";

// 2) ensure Logs dir exists (portable: File.exists / File.mkdir)
ensureDir = { arg dirPathString;
    (File.exists(dirPathString)).if({
        // directory already exists
    },{
        File.mkdir(dirPathString);
        ("Created Logs directory: " ++ dirPathString).postln;
    });
    nil
};
ensureDir.(logsDirPathString);

// 3) setup logger function & path
logFilePathString = logsDirPathString ++ "/LPDisplay_Sessions.log";
~md_log_path = logFilePathString;

writeLine = { arg text;
    var fileHandle, lineString;
    lineString = Date.localtime.stamp ++ " | " ++ text.asString ++ Char.nl.asString;
    fileHandle = File(~md_log_path, "a");
    fileHandle.write(lineString);
    fileHandle.close;
    ("[logged] " ++ text).postln;
    nil
};

~md_log = { arg text; writeLine.(text) };

"LPD progress logger installed -> ".post; ~md_log_path.postln;
)
===== LPDisplay/Migration_tests/LivePedalboardSystem_WindowManager_Install.scd =====
// LivePedalboardSystem_WindowManager_Install.scd
// v0.2.2
// MD 20251003-1248

/* Purpose/Style:
- Install ALL LivePedalboardSystem GUI helpers right here (single source of truth):
  * policy prefix
  * find/close/bring-up (single-window invariant)
  * front and front-or-bring-up
  * bounds save/load/apply (NO onClose hooks)
- Known-good SC only; idempotent installs via isNil.if (no '??' auto-eval).
- Style: tilde vars, var-first, descriptive names, lowercase methods.
*/

(
var ensure;

("Running: LivePedalboardSystem_WindowManager_Install.scd").postln;

ensure = {
    // --- policy prefix
    ~lps_windowPrefix.isNil.if({
        ~lps_windowPrefix = "MagicDisplayGUI";
    });

    // --- find windows by prefix
    ~lps_findWindowsByPrefix.isNil.if({
        ~lps_findWindowsByPrefix = { |prefix|
            var effectivePrefix, matchingWindows;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            matchingWindows = Window.allWindows.select({ |win|
                var windowName;
                windowName = win.name.asString;
                windowName.notNil and: { windowName.beginsWith(effectivePrefix) }
            });
            matchingWindows
        };
    });

    // --- close windows by prefix
    ~lps_closeWindowsByPrefix.isNil.if({
        ~lps_closeWindowsByPrefix = { |prefix|
            var windowsToClose, closedCount;
            windowsToClose = ~lps_findWindowsByPrefix.(prefix).copy; // avoid mutating while iterating
            closedCount = 0;
            windowsToClose.do({ |win|
                win.close;
                closedCount = closedCount + 1;
            });
            closedCount
        };
    });

    // --- bring up exactly one window via builder
    ~lps_bringUpSingleWindow.isNil.if({
        ~lps_bringUpSingleWindow = { |prefix, buildFunc, desiredTitle|
            var effectivePrefix, existing, windowTitle, createdWindow;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            windowTitle = desiredTitle ?? { effectivePrefix };
            existing = ~lps_findWindowsByPrefix.(effectivePrefix);

            if(existing.size == 1) {
                createdWindow = existing.first;
                if(createdWindow.name.asString != windowTitle) { createdWindow.name = windowTitle };
                createdWindow.front;
                createdWindow
            } {
                // Close *all* of ours, then build fresh
                ~lps_closeWindowsByPrefix.(effectivePrefix);
                createdWindow = buildFunc.value(windowTitle);
                if(createdWindow.notNil and: { createdWindow.isKindOf(Window) }) {
                    createdWindow.name = windowTitle;
                    createdWindow.front;
                };
                createdWindow
            }
        };
    });

    // --- front existing (non-destructive)
    ~lps_frontByPrefix.isNil.if({
        ~lps_frontByPrefix = { |prefix|
            var effectivePrefix, wins;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            wins = ~lps_findWindowsByPrefix.(effectivePrefix);
            wins.notEmpty.if({ wins.first.front; wins.first }, { nil })
        };
    });

    // --- front or bring-up
    ~lps_frontOrBringUpByPrefix.isNil.if({
        ~lps_frontOrBringUpByPrefix = { |prefix, buildFunc, desiredTitle|
            var effectivePrefix, win;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            win = ~lps_frontByPrefix.(effectivePrefix);
            win.notNil.if({ win }, {
                ~lps_bringUpSingleWindow.(effectivePrefix, buildFunc, desiredTitle)
            })
        };
    });

    // --- bounds: prefs dir + file path
    ~lps_prefsDir.isNil.if({
        ~lps_prefsDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "prefs";
    });

    ~lps_boundsFilePathForPrefix.isNil.if({
        ~lps_boundsFilePathForPrefix = { |prefix|
            var safePrefix;
            safePrefix = prefix ?? { ~lps_windowPrefix };
            ~lps_prefsDir +/+ (safePrefix ++ "_window_bounds.txt")
        };
    });

    // --- save bounds (guards for nils)
    ~lps_saveWindowBounds.isNil.if({
        ~lps_saveWindowBounds = { |window, prefix|
            var filePath, rect, content;
            if(window.isNil) { "saveWindowBounds: window is nil".warn; ^nil };
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(~lps_prefsDir).if({ }, { File.mkdir(~lps_prefsDir) });
            rect = window.bounds;
            if(rect.isNil) { "saveWindowBounds: window.bounds is nil".warn; ^nil };
            content = [rect.left, rect.top, rect.width, rect.height].collect(_.asString).join(" ");
            File.use(filePath, "w", { |f| f.write(content) });
            ("Saved bounds to: " ++ filePath ++ " -> " ++ content).postln;
            filePath
        };
    });

    // --- load bounds
    ~lps_loadWindowBounds.isNil.if({
        ~lps_loadWindowBounds = { |prefix|
            var filePath, content, parts, rect;
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(filePath).if({
                content = File.readAllString(filePath);
                parts = content.split($ );
                if(parts.size >= 4) {
                    rect = Rect(parts[0].asFloat, parts[1].asFloat, parts[2].asFloat, parts[3].asFloat);
                    ("Loaded bounds from: " ++ filePath ++ " -> " ++ rect.asString).postln;
                    rect
                } {
                    ("Bounds file malformed: " ++ filePath ++ " -> '" ++ content ++ "'").warn;
                    nil
                }
            }, {
                ("No saved bounds at: " ++ filePath).postln;
                nil
            })
        };
    });

    // --- apply bounds (guard: rect not nil)
    ~lps_applyLastWindowBounds.isNil.if({
        ~lps_applyLastWindowBounds = { |window, prefix|
            var rect;
            if(window.isNil) { "applyLastWindowBounds: window is nil".warn; ^nil };
            rect = ~lps_loadWindowBounds.(prefix);
            if(rect.notNil) {
                window.bounds = rect;
                ("Applied saved bounds: " ++ rect.asString).postln;
            };
            window
        };
    });
};

ensure.();
)
===== LPDisplay/Migration_tests/LivePedalboardSystem_WindowManager_ReturnGuard.scd =====
// LivePedalboardSystem_WindowManager_ReturnGuard.scd
// v0.1.0
// MD 20251003-1125

/* Purpose/Style:
- Patch the bring-up helper to ensure it always returns a Window when one exists.
- Minimal change: add a fallback lookup before returning.
*/

(
var originalFunc;

("Running: LivePedalboardSystem_WindowManager_ReturnGuard.scd").postln;

originalFunc = ~lps_bringUpSingleWindow;

~lps_bringUpSingleWindow = { |prefix, buildFunc, desiredTitle|
    var effectivePrefix, existing, windowTitle, createdWindow, fallbackWindow;

    effectivePrefix = prefix ?? { ~lps_windowPrefix };
    existing = ~lps_findWindowsByPrefix.(effectivePrefix);
    windowTitle = desiredTitle ?? { effectivePrefix };

    if(existing.size == 1) {
        createdWindow = existing.first;
        if(createdWindow.name.asString != windowTitle) {
            createdWindow.name = windowTitle;
        };
        createdWindow.front;
    }{
        ~lps_closeWindowsByPrefix.(effectivePrefix);
        createdWindow = buildFunc.value(windowTitle);
        if(createdWindow.notNil and: { createdWindow.isKindOf(Window) }) {
            createdWindow.name = windowTitle;
            createdWindow.front;
        };
    };

    // Fallback: if builder returned nil or a non-Window, try to pick up a window by prefix
    if(createdWindow.isNil or: { createdWindow.isKindOf(Window).not }) {
        fallbackWindow = ~lps_findWindowsByPrefix.(effectivePrefix).first;
        createdWindow = fallbackWindow;
    };

    createdWindow
};
)

===== LPDisplay/Migration_tests/LivePedalboardSystem_WindowManager.scd =====
// LivePedalboardSystem_WindowManager.scd
// v0.1.0
// MD 20251003-1028

/* Purpose/Style:
- Utilities to enforce a single GUI window for LivePedalboardSystem.
- Default prefix is "MagicDisplayGUI"; you can override per call.
- Style: tilde vars, var-first, descriptive names, no single-letter locals.
*/

(
var ensureDefaults;

("Running: LivePedalboardSystem_WindowManager.scd").postln;

ensureDefaults = {
    ~lps_windowPrefix = ~lps_windowPrefix ?? { "MagicDisplayGUI" };

    ~lps_findWindowsByPrefix = ~lps_findWindowsByPrefix ?? { |prefix|
        var effectivePrefix, matchingWindows;
        effectivePrefix = prefix ?? { ~lps_windowPrefix };
        matchingWindows = Window.allWindows.select({ |win|
            var windowName;
            windowName = win.name.asString;
            windowName.notNil and: { windowName.beginsWith(effectivePrefix) }
        });
        matchingWindows
    };

    ~lps_closeWindowsByPrefix = ~lps_closeWindowsByPrefix ?? { |prefix|
        var windowsToClose, closedCount;
        windowsToClose = ~lps_findWindowsByPrefix.(prefix).copy; // copy to avoid modifying during iteration
        closedCount = 0;
        windowsToClose.do({ |win|
            win.close;
            closedCount = closedCount + 1;
        });
        closedCount
    };

    ~lps_bringUpSingleWindow = ~lps_bringUpSingleWindow ?? { |prefix, buildFunc, desiredTitle|
        var effectivePrefix, existing, windowTitle, createdWindow;

        effectivePrefix = prefix ?? { ~lps_windowPrefix };
        existing = ~lps_findWindowsByPrefix.(effectivePrefix);

        // Determine title we want to enforce; default to the prefix itself
        windowTitle = desiredTitle ?? { effectivePrefix };

        // Reuse if exactly one exists; otherwise close all and build fresh
        if(existing.size == 1) {
            createdWindow = existing.first;
            // normalize the title if different
            if(createdWindow.name.asString != windowTitle) {
                createdWindow.name = windowTitle;
            };
            createdWindow.front;
            createdWindow
        } {
            // remove strays and create a single window via builder
            ~lps_closeWindowsByPrefix.(effectivePrefix);

            // buildFunc must return a Window; we pass the title
            createdWindow = buildFunc.value(windowTitle);

            // ensure title and visibility
            if(createdWindow.notNil and: { createdWindow.isKindOf(Window) }) {
                createdWindow.name = windowTitle;
                createdWindow.front;
            };
            createdWindow
        }
    };
};

ensureDefaults.();
)
===== LPDisplay/Migration_tests/Log_Session_Summary_Today.scd =====
// Log_Session_Summary_Today.scd
// v0.1.2
// MD 20251003-1613

(
var systemPresent, cmBound, cmCandidate, line;

systemPresent = (~system.notNil);
cmCandidate = ~cm ? (
    ~system.tryPerform(\commandManager) ?
    ~system.tryPerform(\cmdManager) ?
    ~system.tryPerform(\cm) ?
    ~system.tryPerform(\manager)
);

cmBound = (
    cmCandidate.notNil and: { cmCandidate.display.notNil } and: { cmCandidate.display.respondsTo(\showExpectation) }
);

line = "LPD v0.1.6 OK; logger OK; auto-bind path pending; systemPresent="
    ++ systemPresent.asString
    ++ ", cmBound=" ++ cmBound.asString;

(~md_log.notNil).if({ ~md_log.(line) }, { line.postln });
)

===== LPDisplay/Migration_tests/LPDisplay_AdapterForCommandManager.scd =====
// LPDisplay_AdapterForCommandManager.scd
// v0.2.0
// MD 20251003-1242

/* Purpose / Style
- Provide a small 'object' that CommandManager can treat as a display.
- Uses JITLib Proto so .respondsTo(\showExpectation) etc. return true.
- Maps old GUI calls to LPDisplay panes via ~guiLP.sendPaneText.
- Style: tilde vars; var-first; lowercase; no args starting with '_'; known-good SC syntax.
*/

(
var makeAdapter, toStringSafe;

toStringSafe = { arg obj; obj.asString };

makeAdapter = {
    var adapter;
    adapter = Proto({
        var self;

        ~showExpectation = { arg self, text, idx = 0;
            var t;
            t = toStringSafe.(text);
            (~guiLP.notNil).if({ ~guiLP.sendPaneText(\system, t) });
            nil
        };

        ~updateTextField = { arg self, box, msg;
            var pane, t, target;
            pane = box.asSymbol;
            t = toStringSafe.(msg);
            target = (pane == \state).if({ \system }, { (pane == \choices).if({ \choices }, { \diag }) });
            (~guiLP.notNil).if({ ~guiLP.sendPaneText(target, t) });
            nil
        };

        ~setOperations = { arg self, lines;
            var joined;
            joined = ((lines ? []) collect: { arg x; x.asString }).join(Char.nl.asString);
            (~guiLP.notNil).if({ ~guiLP.sendPaneText(\choices, joined) });
            nil
        };

        // legacy in tests (safe no-ops)
        ~highlightCurrentColumn = { arg self, which; nil };
        ~enableMeters          = { arg self, flag = true; nil };
    });

    ~lp_displayAdapter = adapter;

    // If the system is already up, bind immediately
    if(~system.notNil) {
        var cm = ~system.tryPerform(\commandManager);
        (cm.notNil).if({ cm.display = adapter });
    };

    "LPDisplay adapter ready (bound if ~system.commandManager exists).".postln;
    adapter
};

makeAdapter.();
)
===== LPDisplay/Migration_tests/LPDisplay_BindAdapter_Inline.scd =====
// LPDisplay_BindAdapter_Inline.scd
// v0.1.0
// MD 20251003-1302

(
var cm;
~lp_adapter = LPDisplayAdapter.new(~guiLP);  // ~guiLP is your LPDisplayLayoutWindow controller
cm = (~system.notNil).if({ ~system.tryPerform(\commandManager) }, { nil });
(cm.notNil).if({ cm.display = ~lp_adapter; "Adapter bound.".postln; });

// quick sanity
(~guiLP.notNil).if({
    ~guiLP.sendPaneText(\system, "Adapter OK");
    ~guiLP.sendPaneText(\choices, "fret 3 → audio\nfret 5 → control\nfret 7 → names");
});
)

===== LPDisplay/Migration_tests/LPDisplay_Nav_RootFirst.scd =====
// LPDisplay_Nav_RootFirst.scd
// v0.1.0
// MD 20251003-1408

/* Purpose / Style
- Deterministic navigation helpers that target a specific string at each step:
  root:   string 6  (frets 1,3,5,7,9)
  depth1: string 5  (frets 3,5,7,...)
  depth2+: string 4 (frets 3,5,7,...)
- Rebind adapter safely if needed, then expose ~nav6, ~nav5, ~nav4.
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var cmLocal, adapterLocal, bindAdapterIfNeeded, forceDiag, tryNav;

// 0) choose a CommandManager source: prefer real system, else fallback standalone
cmLocal = (~cm.notNil).if({
    ~cm
}, {
    (~system.notNil).if({
        var candidates, chosen;
        candidates = [\commandManager, \cmdManager, \cm, \manager];
        chosen = candidates.detect({ arg sel;
            (~system.respondsTo(sel)) and: { ~system.perform(sel).notNil }
        });
        (chosen.notNil).if({ ~system.perform(chosen) }, { CommandManager.new(nil) })
    }, {
        CommandManager.new(nil)
    })
});
~cm = cmLocal;

// 1) bind LPDisplayAdapter to cm.display (idempotent)
bindAdapterIfNeeded = {
    adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
    ~lp_adapter = adapterLocal;
    ~cm.display = adapterLocal;
    true
};

forceDiag = { arg text;
    (~guiLP.notNil).if({ ~guiLP.sendPaneText(\diag, text.asString) });
};

tryNav = { arg stringNum, fretNum;
    var ok, beforeText, afterText;
    // attempt preferred signature: navigateByFret(string, fret)
    ok = ~cm.builder.tryPerform(\navigateByFret, stringNum, fretNum);
    // fallback signature used in some branches: navigateByFret(fret)
    (ok == false or: { ok.isNil }).if({
        ok = ~cm.builder.tryPerform(\navigateByFret, fretNum);
    });
    // update the panes whatever happened
    beforeText = "Tried: string " ++ stringNum ++ ", fret " ++ fretNum;
    ~cm.updateDisplay;
    afterText  = " | result: " ++ (ok.asString);
    forceDiag.(beforeText ++ afterText);
    ok
};

// rebind now (safe if already bound)
bindAdapterIfNeeded.();

// expose explicit string helpers
~nav6 = { arg fret; tryNav.(6, fret) };  // use at root: frets 1,3,5,7,9
~nav5 = { arg fret; tryNav.(5, fret) };  // use at depth 1: frets 3,5,7,...
~nav4 = { arg fret; tryNav.(4, fret) };  // use at depth 2+: frets 3,5,7,...

// tip text
"Root-first nav ready. From root use ~nav6.(1|3|5|7|9); then ~nav5.(3|5|7); then ~nav4.(3|5|7).".postln;

// progress (in-memory only)
~md_progress = (~md_progress ? List.new).add("Sprint4.1: root-first nav helpers @ " ++ Date.localtime.stamp);
)

===== LPDisplay/Migration_tests/LPDisplay_Navigation_Smoke_DepthAware.scd =====
// LPDisplay_Navigation_Smoke_DepthAware.scd
// v0.2.0
// MD 20251003-1358

/* Purpose / Style
- Depth-aware navigation helpers so a fret press from root uses string 6,
  at depth 1 uses string 5, and deeper uses string 4.
- Works with standalone ~cm (CommandManager) and your LPDisplayAdapter.
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var cmLocal, adapterLocal, showNow, depthOf, targetStringForDepth, tryNavigate, showDiag;

// 1) CommandManager (standalone if ~system not present)
cmLocal = (~cm.notNil).if({ ~cm }, { CommandManager.new(nil) });
~cm = cmLocal;

// 2) Ensure adapter is present and bound to the current LPDisplay controller
adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
~lp_adapter = adapterLocal;
cmLocal.display = adapterLocal;

// helper: compute depth from canonical path (root -> 0, first child -> 1, etc.)
depthOf = {
    var canon, parts, depthCount;
    canon = (~cm.respondsTo(\canonicalPathFromBuilder))
        .if({ ~cm.canonicalPathFromBuilder(~cm.builder).asString }, { "root" });

    parts = canon.split($/).reject({ arg s; s.isEmpty });
    depthCount = if(canon == "root" or: { canon == "/" }) { 0 } { parts.size };
    depthCount
};

// helper: choose string index from depth
targetStringForDepth = { arg depthCount;
    if(depthCount <= 0) { 6 } { if(depthCount == 1) { 5 } { 4 } }
};

// try a depth-aware navigate; return true if it appears to succeed
tryNavigate = { arg fret;
    var depthCount, targetString, ok, beforeCanon, afterCanon;
    depthCount = depthOf.();
    targetString = targetStringForDepth.(depthCount);

    beforeCanon = (~cm.respondsTo(\canonicalPathFromBuilder))
        .if({ ~cm.canonicalPathFromBuilder(~cm.builder).asString }, { "n/a" });

    // Preferred form: (string, fret)
    ok = ~cm.builder.tryPerform(\navigateByFret, targetString, fret);

    // Fallback: some older signatures might ignore the string argument
    (ok == false or: { ok.isNil }).if({
        ok = ~cm.builder.tryPerform(\navigateByFret, nil, fret);
    });

    afterCanon = (~cm.respondsTo(\canonicalPathFromBuilder))
        .if({ ~cm.canonicalPathFromBuilder(~cm.builder).asString }, { "n/a" });

    // consider it succeeded if the canonical path changed
    (afterCanon != beforeCanon)
};

// show panes and the canonical "Next:" in Diag
showDiag = {
    var canon;
    canon = (~cm.respondsTo(\canonicalPathFromBuilder))
        .if({ ~cm.canonicalPathFromBuilder(~cm.builder) }, { "n/a" });
    (~guiLP.notNil).if({ ~guiLP.sendPaneText(\diag, "Next: " ++ canon.asString) });
};

showNow = {
    ~cm.updateDisplay;  // legacy selectors -> adapter -> LPDisplay panes
    showDiag.();
};

// PUBLIC one-liners (depth-aware now)
~nav_show  = { showNow.() };
~nav_fret  = { arg fret;
    var ok, depthCountNow, chosenString;

    depthCountNow = depthOf.();
    chosenString  = targetStringForDepth.(depthCountNow);

    ok = tryNavigate.(fret);
    (ok.not).if({
        "No mapping for fret % at depth % (target string %)."
        .format(fret, depthCountNow, chosenString)
        .postln;
    });

    showNow.();
};
~nav_reset = {
    ~cm.builder.tryPerform(\resetNavigation);
    showNow.();
    "🔄 Navigation reset".postln;
};

// small where-am-I helper (optional)
~nav_where = {
    var depthCountNow, chosenString, canon;
    depthCountNow = depthOf.();
    chosenString  = targetStringForDepth.(depthCountNow);
    canon = (~cm.respondsTo(\canonicalPathFromBuilder))
        .if({ ~cm.canonicalPathFromBuilder(~cm.builder) }, { "n/a" });
    ("Depth=" ++ depthCountNow ++ " → string " ++ chosenString ++ " | path=" ++ canon).postln;
};

// initial smoke
"Depth-aware nav ready. From root use ~nav_fret.(1|3|5|7|9); then ~nav_fret.(3|5|7)…; ~nav_where.() shows mapping."
.postln;
~nav_show.();

// progress note (in-memory only)
~md_progress = (~md_progress ? List.new).add("Sprint3: depth-aware nav v0.2.0 @ " ++ Date.localtime.stamp);
)
===== LPDisplay/Migration_tests/LPDisplay_Navigation_Smoke.scd =====
// LPDisplay_Navigation_Smoke.scd
// v0.1.1
// MD 20251003-1342

/* Purpose / Style
- Standalone CommandManager → LPDisplay via LPDisplayAdapter.
- Drive real navigation text into LPDisplay (System, Choices, Diag).
- Style: var-first; tilde vars; lowercase; known-good SC; AppClock only in classes.
*/

(
var cmLocal, adapterLocal, showNow;

// 1) CommandManager (standalone); it resolves default tree path inside the class
cmLocal = (~cm.notNil).if({ ~cm }, { CommandManager.new(nil) });
~cm = cmLocal;

// 2) Ensure adapter is present and bound to the current LPDisplay controller
adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
~lp_adapter = adapterLocal;
cmLocal.display = adapterLocal;

// 3) Small helper to refresh panes (declaring vars first INSIDE the block too)
showNow = {
    var hasCanon, canonText;

    hasCanon = ~cm.respondsTo(\canonicalPathFromBuilder) and: { ~cm.builder.notNil };
    canonText = if(hasCanon) { ~cm.canonicalPathFromBuilder(~cm.builder) } { "n/a" };

    // This triggers CommandManager → (legacy selectors) → adapter → LPDisplay panes
    ~cm.updateDisplay;

    // Show canonical "Next:" in Diag pane (non-destructive)
    (~guiLP.notNil).if({
        ~guiLP.sendPaneText(\diag, "Next: " ++ canonText.asString)
    });
};

// Public one-liners
~nav_show  = { showNow.value };
~nav_fret  = { arg fret; ~cm.builder.navigateByFret(nil, fret); showNow.value };
~nav_reset = { ~cm.builder.resetNavigation; showNow.value };

// Initial smoke
"Ready: ~nav_fret.(3), ~nav_fret.(5), ~nav_fret.(7) … ; and ~nav_reset.()".postln;
~nav_show.();

// Progress (in-memory only; no file I/O)
~md_progress = (~md_progress ? List.new).add("Sprint3 fixed: nav smoke v0.1.1 @ " ++ Date.localtime.stamp);
)
===== LPDisplay/Migration_tests/LPDisplay_SystemWireUp_Min.scd =====
// LPDisplay_SystemWireUp_Min.scd
// v0.1.1
// MD 20251003-1420

/* Purpose / Style
- Ensure ~system exists (LivePedalboardSystem.new if missing).
- Bind its CommandManager to LPDisplay via LPDisplayAdapter.
- Expose ~sys_nav_* helpers so you can navigate with the real system.
- Style: var-first; tilde vars; lowercase; descriptive names.
*/

(
var makeSystem, bindAdapterToSystem, exposeSysNav, cm;

makeSystem = {
    if(~system.isNil) {
        ~system = LivePedalboardSystem.new(nil);  // uses class defaults; no GUI windows needed here
    };
    ~system
};

bindAdapterToSystem = {
    var adapterLocal;
    cm = ~system.tryPerform(\commandManager);
    adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
    ~lp_adapter = adapterLocal;
    if(cm.notNil) {
        cm.display = adapterLocal;
        cm.updateDisplay;
        "System bound: CommandManager → LPDisplay (updateDisplay called).".postln;
    }{
        "Note: could not find ~system.commandManager.".warn;
    };
    cm
};

exposeSysNav = {
    ~sys_nav_show  = { var c = ~system.tryPerform(\commandManager); c.notNil.if({ c.updateDisplay }) };
    ~sys_nav_fret  = { arg fret; var c = ~system.tryPerform(\commandManager);
        c.notNil.if({ c.builder.navigateByFret(nil, fret); c.updateDisplay })
    };
    ~sys_nav_reset = { var c = ~system.tryPerform(\commandManager);
        c.notNil.if({ c.builder.resetNavigation; c.updateDisplay; "🔄 System navigation reset".postln })
    };
    nil
};

makeSystem.();
bindAdapterToSystem.();
exposeSysNav.();

(~lp_front.notNil).if({ ~lp_front.() });
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Append_FinalReport.scd =====
// LPDisplayLayoutWindow_Append_FinalReport.scd
// v0.1.0
// MD 20251003-1055

/* Purpose/Style:
- Append a finalization note to progress_report.txt summarizing completion.
*/

(
var dirPath, reportPath, note;

dirPath = ~md_migration[\projectRoot] +/+ "reports";
reportPath = dirPath +/+ "progress_report.txt";
File.exists(dirPath).if({ }, { File.mkdir(dirPath) });

note = [
    "",
    "Finalization Note:",
    " - Verified: old class absent; new class constructs -> a Window.",
    " - Compiled .sc filename hits for old name: 0",
    " - Archives present (non-.sc): OK to keep.",
    ""
].join(Char.nl.asString);

File.use(reportPath, "a", { |f| f.write(note) });
("Appended finalization note to: " ++ reportPath).postln;
)

===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Check_MigrationNames.scd =====
// LPDisplayLayoutWindow_Check_MigrationNames.sc
// v0.1.0
// MD 2025-10-03 10:10 GMT+01

/* Purpose:
- Ensure ~md_migration has correct old/new names for verification.
*/

(
var currentOld, currentNew, expectedOld, expectedNew, needsFix;

expectedOld = "LPDisplayLayoutTestWindow";
expectedNew = "LPDisplayLayoutWindow";

currentOld = ~md_migration[\oldName];
currentNew = ~md_migration[\newName];

("oldName (in state): " ++ currentOld).postln;
("newName (in state): " ++ currentNew).postln;

needsFix = (currentOld != expectedOld) or: { currentNew != expectedNew };

needsFix.if({
    ~md_migration[\oldName] = expectedOld;
    ~md_migration[\newName] = expectedNew;
    ~md_log.("Corrected migration names in state to expected values.");
}, {
    ~md_log.("Migration names already correct.");
});
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_List_SC_FilenameHits.scd =====
// LPDisplayLayoutWindow_List_SC_FilenameHits.scd
// v0.1.1
// MD 20251003-1055

/* Purpose/Style:
- Quick helper to list ONLY .sc filename hits for the old name (compiled files).
*/

(
var projectRoot, oldName, scHits;

projectRoot = Platform.userExtensionDir +/+ "LivePedalboardSuite";
oldName = "LPDisplayLayoutTestWindow";

scHits = List.new;
PathName(projectRoot).deepFiles.do({ |pn|
    var fileName, fullPath;
    fileName = pn.fileName.asString;
    fullPath = pn.fullPath;
    if(fileName.contains(oldName) and: { fileName.endsWith(".sc") }) {
        scHits.add(fullPath);
    };
});

"— .sc filename hits for old name —".postln;
scHits.do({ |p| ("  - " ++ p).postln; });
(scHits.isEmpty).if({ "None.".postln; });
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Migration_Status.scd =====
// LPDisplayLayoutWindow_Migration_Status.scd
// v0.1.0
// MD 20251003-1055

/* Purpose/Style:
- Print and return an Event snapshot of current migration flags.
*/

(
var snapshot;
snapshot = (
    scannedContents: ~md_migration[\steps][\scannedContents],
    scannedFilenames: ~md_migration[\steps][\scannedFilenames],
    callSitesUpdated: ~md_migration[\steps][\callSitesUpdated],
    shimInPlace: ~md_migration[\steps][\shimInPlace],
    oldFileRemoved: ~md_migration[\steps][\oldFileRemoved],
    helpUpdated: ~md_migration[\steps][\helpUpdated],
    acceptancePassed: ~md_migration[\steps][\acceptancePassed],
    reportWritten: ~md_migration[\steps][\reportWritten]
);
"— Migration Status Snapshot —".postln;
snapshot.postln;
snapshot
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Report_AppendAcceptance.scd =====
// LPDisplayLayoutWindow_Report_AppendAcceptance.scd
// v0.1.0
// MD 20251003-1110

/* Purpose:
- Append acceptance notes (basics, snapshot, resize) to progress_report.txt
*/

(
var reportDir, reportPath, note;

("Running: LPDisplayLayoutWindow_Report_AppendAcceptance.scd").postln;


reportDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "reports";
reportPath = reportDir +/+ "progress_report.txt";
File.exists(reportDir).if({ }, { File.mkdir(reportDir) });

note = [
    "",
    "Acceptance Notes (LPDisplayLayoutWindow):",
    " - Basics: constructed -> a Window",
    " - Snapshot: reports/LPDisplayLayoutWindow_layout_snapshot.txt",
    " - ResizeSanity: children inside content view (see console for WARN if any)",
    ""
].join(Char.nl.asString);

File.use(reportPath, "a", { |f| f.write(note) });
("Appended acceptance notes to: " ++ reportPath).postln;
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Verify_Rename.scd =====
// LPDisplayLayoutWindow_Verify_Rename.scd
// v0.1.5
// MD 20251003-1055

/* Purpose/Style:
- Self-contained verification; safe to run anytime.
- Confirms:
  - content hits for old name = 0
  - .sc filename hits = 0 (must be 0)
  - new class loaded = true
  - old class missing = true
  - constructs -> a Window = true
*/

(
var ensureState, projectRoot, oldName, newName, searchExtensions;
var contentsHits, filenameHits, scFilenameHits, totalScanned;
var newClass, oldClass, createdWindow;
var okNewClassLoaded, okOldClassMissing, okConstructsWindow;

ensureState = {
    var stepsEvent;
    ~md_migration = ~md_migration ?? {
        stepsEvent = (
            scannedContents: false, scannedFilenames: false, callSitesUpdated: false,
            shimInPlace: false, oldFileRemoved: false, helpUpdated: false,
            acceptancePassed: false, reportWritten: false
        );
        (
            projectRoot: Platform.userExtensionDir +/+ "LivePedalboardSuite",
            oldName: "LPDisplayLayoutTestWindow",
            newName: "LPDisplayLayoutWindow",
            steps: stepsEvent,
            logLines: List.new, hitFiles: List.new, filenameHits: List.new,
            updatedFiles: List.new, helpFiles: List.new
        )
    };
    ~md_log = ~md_log ?? { |message| ~md_migration[\logLines].add(message.asString); message.postln; };
    ~md_mark = ~md_mark ?? { |keySymbol, isDone=true| ~md_migration[\steps].put(keySymbol, isDone); };
};
ensureState.();

// config
projectRoot = ~md_migration[\projectRoot];
oldName = ~md_migration[\oldName];
newName = ~md_migration[\newName];
searchExtensions = [ "sc", "scd", "schelp", "md", "json", "yaml", "yml", "txt", "quark" ];

// scan contents
contentsHits = List.new;
totalScanned = 0;
PathName(projectRoot).deepFiles.do({ |pn|
    var filePath, ext, content;
    filePath = pn.fullPath;
    ext = pn.extension;
    ext = ext.isNil.if({ "" }, { ext.asString.toLower });
    if(searchExtensions.includes(ext)) {
        totalScanned = totalScanned + 1;
        content = File.readAllString(filePath);
        if(content.notNil and: { content.contains(oldName) }) {
            contentsHits.add(filePath);
        };
    };
});

// scan filenames
filenameHits = List.new;
scFilenameHits = List.new;
PathName(projectRoot).deepFiles.do({ |pn|
    var fileName;
    fileName = pn.fileName.asString;
    if(fileName.contains(oldName)) {
        filenameHits.add(pn.fullPath);
        if(fileName.endsWith(".sc")) { scFilenameHits.add(pn.fullPath) };
    };
});

// class presence and acceptance
newClass = newName.asSymbol.asClass;
oldClass = oldName.asSymbol.asClass;
okNewClassLoaded = newClass.notNil;
okOldClassMissing = oldClass.isNil;

createdWindow = okNewClassLoaded.if({
    newClass.respondsTo(\open).if({ newClass.open }, { newClass.new })
}, { nil });

okConstructsWindow = createdWindow.notNil and: { createdWindow.isKindOf(Window) };
okConstructsWindow.if({ createdWindow.front });

// summary
"— Verification Summary —".postln;
("Scanned files (contents): " ++ totalScanned.asString).postln;
("Content hits for old name: " ++ contentsHits.size.asString).postln;
("Filename hits for old name: " ++ filenameHits.size.asString).postln;
(" .sc filename hits (must be 0): " ++ scFilenameHits.size.asString).postln;
("New class loaded: " ++ okNewClassLoaded.asString).postln;
("Old class missing: " ++ okOldClassMissing.asString).postln;
("Constructs -> a Window: " ++ okConstructsWindow.asString).postln;

// update state
~md_migration[\hitFiles] = contentsHits;
~md_migration[\filenameHits] = filenameHits;
~md_migration[\lastOpenedWindow] = createdWindow;

~md_mark.(\scannedContents, true);
~md_mark.(\scannedFilenames, true);
(contentsHits.isEmpty).if({ ~md_mark.(\callSitesUpdated, true) });
(okOldClassMissing).if({ ~md_mark.(\oldFileRemoved, true) });
(okConstructsWindow).if({ ~md_mark.(\acceptancePassed, true) });

// return the window so you see '-> a Window'
createdWindow
)
===== LPDisplay/Migration_tests/LPDisplayLayoutWindow_Write_Report.scd =====
// LPDisplayLayoutWindow_Write_Report.scd
// v0.1.4
// MD 20251003-1042

/* Purpose/Style:
- Write progress_report.txt under <Extensions>/LivePedalboardSuite/reports
- Self-contained: initializes default state if ~md_migration is missing.
- Uses File.mkdir + File.use (known-good).
*/

(
var ensureState, dirPath, reportPath, lines, stepsDict, keys, content;

// Ensure defaults if state missing
ensureState = {
    var stepsEvent;
    ~md_migration = ~md_migration ?? {
        stepsEvent = (
            scannedContents: false, scannedFilenames: false, callSitesUpdated: false,
            shimInPlace: false, oldFileRemoved: false, helpUpdated: false,
            acceptancePassed: false, reportWritten: false
        );
        (
            projectRoot: Platform.userExtensionDir +/+ "LivePedalboardSuite",
            oldName: "LPDisplayLayoutTestWindow",
            newName: "LPDisplayLayoutWindow",
            steps: stepsEvent,
            logLines: List.new, hitFiles: List.new, filenameHits: List.new,
            updatedFiles: List.new, helpFiles: List.new
        )
    };
};
ensureState.();

// Paths
dirPath = ~md_migration[\projectRoot] +/+ "reports";
reportPath = dirPath +/+ "progress_report.txt";

// Ensure directory exists
File.exists(dirPath).if({ }, { File.mkdir(dirPath) });

// Build content
stepsDict = ~md_migration[\steps];
keys = stepsDict.keys.asArray.sort;

lines = List.new;
lines.add("Rename Migration Report: LPDisplayLayoutTestWindow -> LPDisplayLayoutWindow");
lines.add("");
lines.add("Root: " ++ ~md_migration[\projectRoot]);
lines.add("");

lines.add("Steps:");
keys.do({ |k| lines.add(" - " ++ k.asString ++ ": " ++ stepsDict[k].asString) });
lines.add("");

lines.add("Content hits (last scan): " ++ ~md_migration[\hitFiles].size);
~md_migration[\hitFiles].do({ |p| lines.add("   - " ++ p) });
lines.add("");

lines.add("Filename hits (last scan): " ++ ~md_migration[\filenameHits].size);
~md_migration[\filenameHits].do({ |p| lines.add("   - " ++ p) });
lines.add("");

lines.add("Updated files (manual, recorded): " ++ ~md_migration[\updatedFiles].size);
~md_migration[\updatedFiles].do({ |p| lines.add("   - " ++ p) });
lines.add("");

lines.add("Help files touched (recorded): " ++ ~md_migration[\helpFiles].size);
~md_migration[\helpFiles].do({ |p| lines.add("   - " ++ p) });
lines.add("");

lines.add("Log:");
~md_migration[\logLines].do({ |msg| lines.add(" - " ++ msg) });

content = lines.join(Char.nl.asString);

// Write file
File.use(reportPath, "w", { |f| f.write(content) });
("Wrote: " ++ reportPath).postln;

~md_mark.(\reportWritten, true);
~md_printStatus.();
)
===== LPDisplay/Migration_tests/Probe_System_Pedalboard_FindCM.scd =====
// Probe_System_Pedalboard_FindCM.scd
// v0.1.0
// MD 20251003-1613

/* Purpose / Style
- Look for a CommandManager under ~system.pedalboard using common selector names.
- Bind LPDisplayAdapter if found; otherwise print pedalboard zero-arg selectors for inspection.
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var pb, selectorNames, foundSel, cm, adapter, pbZeroArgNames;

// guard
if(~system.isNil) {
    "No ~system present (staying in standalone helpers is fine).".postln;
} {
    pb = ~system.tryPerform(\pedalboard);

    if(pb.isNil) {
        "~system has no zero-arg 'pedalboard' method; accessor will be added next session."
        .postln;
    }{
        selectorNames = [\commandManager, \cmdManager, \cm, \manager, \commandCenter, \commandCentre];

        foundSel = selectorNames.detect({ arg sel;
            pb.respondsTo(sel) and: {
                var candidate = pb.perform(sel);
                candidate.notNil and: { candidate.respondsTo(\updateDisplay) and: { candidate.respondsTo(\builder) } }
            }
        });

        if(foundSel.notNil) {
            cm = pb.perform(foundSel);
            ~cm = cm;  // publish for convenience

            adapter = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
            ~lp_adapter = adapter;

            cm.display = adapter;
            cm.updateDisplay;

            ("Adapter bound to SYSTEM CommandManager via ~system.pedalboard." ++ foundSel.asString).postln;
            (~md_log.notNil).if({ ~md_log.("Adapter bound via pedalboard selector " ++ foundSel.asString) });
        }{
            "Could not find a CM under ~system.pedalboard with common names.".postln;

            // show pedalboard's zero-arg methods (first 20) to guide a tiny accessor next time
            pbZeroArgNames = pb.class.methods.select({ arg m; m.argNames.size == 0 }).collect(_.name).collect(_.asString);
            "Zero-arg selectors on pedalboard (first 20):".postln;
            pbZeroArgNames.copyRange(0, (pbZeroArgNames.size - 1).min(19)).postln;

            (~md_log.notNil).if({ ~md_log.("Pedalboard zero-arg methods enumerated for CM accessor planning") });
        };
    };
};
)
===== LPDisplay/Migration_tests/Start_LiveMagicPedalboardSuite_LPDisplay.scd =====
// Start_LiveMagicPedalboardSuite_LPDisplay.scd
// v0.1.6
// MD 20251003-1530

/* Purpose / Style
- (Re)open LPDisplay safely and return -> a Window.
- NON-DESTRUCTIVE to your running audio (no initTree, no defaultGroup.freeAll).
- Teardown only LPDisplay's controller + OSC responders between runs.
- Auto-bind LPDisplayAdapter to SYSTEM CommandManager *if ~system already exists*.
- Publishes ~guiLP (controller), ~lp_window (Window), ~lp_front helper.
- Style: tilde vars; var-first; lowercase; AppClock UI only; no server.sync.
*/

(
var ensureServerReady, freeOscdefIf, cleanupLPDisplayOnly, openLP, autoBindIfSystemExists, defaultServer, windowLocal;

ensureServerReady = {
    defaultServer = Server.default;
    defaultServer.waitForBoot({ "Server is up (non-destructive)".postln; });
    true
};

freeOscdefIf = { arg nameSymbol;
    var oscDef;
    oscDef = OSCdef.all.tryPerform(\at, nameSymbol);
    (oscDef.notNil).if({
        oscDef.free;
        ("Freed OSCdef: " ++ nameSymbol.asString).postln;
    });
    nil
};

cleanupLPDisplayOnly = {
    if(~guiLP.notNil) {
        ~guiLP.close;  // closes window and stops LPDisplay-owned responders/JIT state
        // belt-and-braces: free known OSCdef names if the controller exposes them
        [ ~guiLP.tryPerform(\oscNameA)
        , ~guiLP.tryPerform(\oscNameB)
        , ~guiLP.tryPerform(\oscConsoleA)
        , ~guiLP.tryPerform(\oscConsoleB)
        ].do({ arg sym; (sym.notNil).if({ freeOscdefIf.(sym) }) });
        ~guiLP = nil;
        ~lp_window = nil;
        "Closed previous LPDisplay instance (controller + responders).".postln;
    };
    nil
};

openLP = {
    var controller, win;
    controller = LPDisplayLayoutWindow.new(nil);   // start with raw 0..1 meters
    win = controller.open;                         // -> a Window
    win.tryPerform(\name_, "LPDisplay — LivePedalboard");
    ~guiLP = controller;
    ~lp_window = win;
    ~lp_front = { (~lp_window.notNil).if({ ~lp_window.front.alwaysOnTop_(true) }) };
    "LPDisplay is up. Try ~guiLP.sendPaneText(\\system, \"hello\");".postln;

    // optional: persist a log line if logger is installed
    (~md_log.notNil).if({ ~md_log.("LPDisplay bring-up v0.1.6") });

    win
};

autoBindIfSystemExists = {
    var cm, selectors, sel, adapter;
    // only bind if ~system already exists and exposes a CM under common names
    if(~system.notNil and: { LPDisplayAdapter.respondsTo(\new) }) {
        selectors = [\commandManager, \cmdManager, \cm, \manager];
        sel = selectors.detect({ arg s; ~system.respondsTo(s) and: { ~system.perform(s).notNil } });
        if(sel.notNil) {
            cm = ~system.perform(sel);
            adapter = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
            ~lp_adapter = adapter;
            cm.display = adapter;
            cm.updateDisplay;
            "Adapter bound to SYSTEM CommandManager.".postln;
            (~md_log.notNil).if({ ~md_log.("Auto-bound LPDisplayAdapter to SYSTEM CM via selector " ++ sel.asString) });
        };
    };
    nil
};

ensureServerReady.();
cleanupLPDisplayOnly.();

windowLocal = openLP.();
autoBindIfSystemExists.();

windowLocal.front.alwaysOnTop_(true);
windowLocal   // -> a Window
)
===== LPDisplay/Migration_tests/Start_LPDisplay_NoRetap.scd =====
// Start_LPDisplay_NoRetap.scd
// v0.1.1
// MD 20251003-1642

/*
Purpose
- Open LPDisplayLayoutWindow; bring up LivePedalboardSystem headless;
- Enable inline SendPeakRMS taps (/peakrmsA, /peakrmsB) inside Ndef chains;
- Ensure audible source; bind display adapter for text panes; no retap scripts needed.
Style
- Single ( ) block; var-first; ~ tilde vars only; Server.default.bind for server ops;
  AppClock for GUI; no server.sync; returns -> a Window.
*/

(
var okWin, okSystem;

// 1) LPDisplay controller + window (meters listen to /peakrmsA/B)
~guiLP = LPDisplayLayoutWindow.new;
~win = ~guiLP.open;                         // -> a Window
// Keep the window's internal demo sources silent so meters reflect LPS chains only
~guiLP.setSourceA(\srcZ);
~guiLP.setSourceB(\srcZ);

// 2) LivePedalboardSystem up (headless UI)
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;
~system.bringUpCommandSystem;
~system.installAdapterBridge;               // routes canonical paths ("/add/...", "/switch", ...)

// 3) Enable inline SendPeakRMS taps (sends /peakrmsA & /peakrmsB)
~system.enableAutoMeters(20);

// 4) Bind CommandManager -> LPDisplay text panes (optional but recommended)
~system.autoBindLPDisplayIfPresent;

// 5) Make sure something is audible; CURRENT plays (inactive chain silenced at source)
~system.ensureAudioOn;

// 6) Quick acceptance print
okWin = (~win.notNil);
okSystem = (~system.notNil) and: { ~system.commandManager.notNil };
[ \lpWindow, okWin, \systemUp, okSystem ].postln;

// Final expression keeps the window "-> a Window"
~win
)
===== LPDisplay/Migration_tests/StartHere_BringUp_MagicDisplayGUI.scd =====
// StartHere_BringUp_MagicDisplayGUI.scd
// v0.1.1
// MD 20251003-1248

/* Purpose/Style:
- Bring up exactly ONE MagicDisplayGUI window using LPDisplayLayoutWindow.
- Applies saved bounds if present; stores ~lps_mainWindow.
- Returns '-> a Window'.
*/

(
var windowPrefix, desiredTitle, builderFunction, createdWindow;

("Running: StartHere_BringUp_MagicDisplayGUI.scd").postln;

// Require helpers to be loaded first (Install file)
(~lps_bringUpSingleWindow.isNil or: { ~lps_applyLastWindowBounds.isNil }).if({
    "ERROR: Window manager helpers are not installed. Run LivePedalboardSystem_WindowManager_Install.scd first.".warn;
    ^nil
});

// Policy + title
windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

// Builder: prefer .open, fallback to .new; must return a Window
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// Create/reuse single window, then apply saved bounds
createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_applyLastWindowBounds.(createdWindow, windowPrefix);

// Store handle
~lps_mainWindow = createdWindow;

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/StartHere_CleanBoot_OneWindow_BringUp_patched.scd =====
// StartHere_CleanBoot_OneWindow_BringUp_patched.scd
// v0.2.2
// MD 20251003-1220

/* Purpose/Style:
- Single-file bring-up: installs helpers and brings up exactly ONE MagicDisplayGUI window.
- Applies saved bounds if present; stores ~lps_mainWindow.
- Known-good SC only; no onClose hooks; var-first; tilde vars; descriptive names.
- Returns '-> a Window'.
*/

(
var ensure, windowPrefix, desiredTitle, builderFunction, createdWindow;

// --- Install helpers (idempotent; no side effects except function defs) ---
("Running: LivePedalboardSystem_WindowManager_Install.scd").postln;

ensure = {
    ~lps_windowPrefix.isNil.if({ ~lps_windowPrefix = "MagicDisplayGUI" });

    ~lps_findWindowsByPrefix.isNil.if({
        ~lps_findWindowsByPrefix = { |prefix|
            var effectivePrefix, matchingWindows;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            matchingWindows = Window.allWindows.select({ |win|
                var windowName;
                windowName = win.name.asString;
                windowName.notNil and: { windowName.beginsWith(effectivePrefix) }
            });
            matchingWindows
        };
    });

    ~lps_closeWindowsByPrefix.isNil.if({
        ~lps_closeWindowsByPrefix = { |prefix|
            var windowsToClose, closedCount;
            windowsToClose = ~lps_findWindowsByPrefix.(prefix).copy;
            closedCount = 0;
            windowsToClose.do({ |win|
                win.close;
                closedCount = closedCount + 1;
            });
            closedCount
        };
    });

    ~lps_bringUpSingleWindow.isNil.if({
        ~lps_bringUpSingleWindow = { |prefix, buildFunc, desiredTitleLocal|
            var effectivePrefix, existing, windowTitle, winLocal;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            windowTitle = desiredTitleLocal ?? { effectivePrefix };
            existing = ~lps_findWindowsByPrefix.(effectivePrefix);
            if(existing.size == 1) {
                winLocal = existing.first;
                if(winLocal.name.asString != windowTitle) { winLocal.name = windowTitle };
                winLocal.front;
                winLocal
            } {
                ~lps_closeWindowsByPrefix.(effectivePrefix);
                winLocal = buildFunc.value(windowTitle);
                if(winLocal.notNil and: { winLocal.isKindOf(Window) }) {
                    winLocal.name = windowTitle;
                    winLocal.front;
                };
                winLocal
            }
        };
    });

    ~lps_frontByPrefix.isNil.if({
        ~lps_frontByPrefix = { |prefix|
            var effectivePrefix, wins;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            wins = ~lps_findWindowsByPrefix.(effectivePrefix);
            wins.notEmpty.if({ wins.first.front; wins.first }, { nil })
        };
    });

    ~lps_frontOrBringUpByPrefix.isNil.if({
        ~lps_frontOrBringUpByPrefix = { |prefix, buildFunc, desiredTitleLocal|
            var effectivePrefix, win;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            win = ~lps_frontByPrefix.(effectivePrefix);
            win.notNil.if({ win }, {
                ~lps_bringUpSingleWindow.(effectivePrefix, buildFunc, desiredTitleLocal)
            })
        };
    });

    ~lps_prefsDir.isNil.if({
        ~lps_prefsDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "prefs";
    });

    ~lps_boundsFilePathForPrefix.isNil.if({
        ~lps_boundsFilePathForPrefix = { |prefix|
            var safePrefix;
            safePrefix = prefix ?? { ~lps_windowPrefix };
            ~lps_prefsDir +/+ (safePrefix ++ "_window_bounds.txt")
        };
    });

    ~lps_saveWindowBounds.isNil.if({
        ~lps_saveWindowBounds = { |window, prefix|
            var filePath, rect, content;
            if(window.isNil) { "saveWindowBounds: window is nil".warn; ^nil };
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(~lps_prefsDir).if({ }, { File.mkdir(~lps_prefsDir) });
            rect = window.bounds;
            if(rect.isNil) { "saveWindowBounds: window.bounds is nil".warn; ^nil };
            content = [rect.left, rect.top, rect.width, rect.height].collect(_.asString).join(" ");
            File.use(filePath, "w", { |f| f.write(content) });
            ("Saved bounds to: " ++ filePath ++ " -> " ++ content).postln;
            filePath
        };
    });

    ~lps_loadWindowBounds.isNil.if({
        ~lps_loadWindowBounds = { |prefix|
            var filePath, content, parts, rect;
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(filePath).if({
                content = File.readAllString(filePath);
                parts = content.split($ );
                if(parts.size >= 4) {
                    rect = Rect(parts[0].asFloat, parts[1].asFloat, parts[2].asFloat, parts[3].asFloat);
                    ("Loaded bounds from: " ++ filePath ++ " -> " ++ rect.asString).postln;
                    rect
                } {
                    ("Bounds file malformed: " ++ filePath ++ " -> '" ++ content ++ "'").warn;
                    nil
                }
            }, {
                ("No saved bounds at: " ++ filePath).postln;
                nil
            })
        };
    });

    ~lps_applyLastWindowBounds.isNil.if({
        ~lps_applyLastWindowBounds = { |window, prefix|
            var rect;
            if(window.isNil) { "applyLastWindowBounds: window is nil".warn; ^nil };
            rect = ~lps_loadWindowBounds.(prefix);
            if(rect.notNil) {
                window.bounds = rect;
                ("Applied saved bounds: " ++ rect.asString).postln;
            };
            window
        };
    });
};

ensure.();

// --- Bring up the single window ---
("Running: StartHere_BringUp_MagicDisplayGUI.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_applyLastWindowBounds.(createdWindow, windowPrefix);
~lps_mainWindow = createdWindow;

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/Stop_All_TestSounds.scd =====
// Stop_All_TestSounds.scd
// v0.1.0
// MD 20251003-1302

/* Purpose/Style:
- Stop any test synths safely by freeing default group.
- No server.sync; posts what it did.
*/

(
var freed;

freed = s.serverRunning.if({
    s.defaultGroup.freeAll;
    "Freed all synths in default group.".postln;
    true
}, {
    "Server not running; nothing to free.".postln;
    false
});

freed
)
===== LPDisplay/Migration_tests/System_CM_Nav_Smoke_Fixed.scd =====
// System_CM_Nav_Smoke_Fixed.scd
// v0.1.0
// MD 20251003-1613

/* Purpose / Style
- Minimal system CM display smoke: updateDisplay → LPDisplay, then one fret step.
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var cm;

"// System CM nav smoke (optional)".postln;

cm = ~cm ? (
    ~system.tryPerform(\commandManager) ?
    ~system.tryPerform(\cmdManager) ?
    ~system.tryPerform(\cm) ?
    ~system.tryPerform(\manager)
);

cm.notNil.if({
    cm.updateDisplay;                    // should land in LPDisplay via adapter
    cm.builder.tryPerform(\navigateByFret, nil, 3);  // adjust fret per your top-level mapping
    cm.updateDisplay;
},{
    "System CM not available (staying with standalone helpers ~nav6/~nav5/~nav4 is fine).".postln;
});
)
===== LPDisplay/Migration_tests/Test_Audio_Server_Status.scd =====
// Test_Audio_Server_Status.scd
// v0.1.0
// MD 20251003-1302

/* Purpose/Style:
- Print quick status so you know if sound is even possible.
- Does not change server state.
*/

(
var serverRunning, outputBuses;

serverRunning = s.serverRunning;
outputBuses = s.options.numOutputBusChannels;

("Audio status — serverRunning: " ++ serverRunning.asString
 ++ ", outputBusChannels: " ++ outputBuses.asString).postln;

serverRunning.if({
    "OK: Server is running; you should hear sound if a synth/chain is started.".postln;
}, {
    "Server is NOT running. Boot it (or run your StartHere) before testing sound.".warn;
});
)
===== LPDisplay/Migration_tests/Test_LPDisplay_BootAndScenarios.scd =====
// Test_LPDisplay_BootAndScenarios.scd
// v0.1.0
// MD 20251003-1232

/* Purpose / Style
- Bring up LPDisplay, attach the adapter, and exercise CommandManager text updates.
- Expect the final expression in block [A] to print '-> a Window'.
- Style: var-first, tilde vars, known-good SC API, AppClock.defer inside classes only.
*/

(
// [A] Bring-up (-> a Window)
var win;

"--- LPDisplay bring-up ---".postln;
thisProcess.openHelpFile ? nil;  // no-op safety
win = { Start_LiveMagicPedalboardSuite_LPDisplay.scd }.postln; // (note: just a breadcrumb in console)
(
// actually evaluate the bring-up inline to avoid external dependency:
var ensureServerReady, closeExistingLPDisplayWindows, openLP;
ensureServerReady = { var s = Server.default; s.waitForBoot({ s.initTree; s.defaultGroup.tryPerform(\freeAll) }); true };
closeExistingLPDisplayWindows = {
    Window.allWindows.select({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("Layout Test") }
    }).do(_.close);
    nil
};
openLP = { var inst, w; inst = LPDisplayLayoutWindow.new(nil); w = inst.open; ~guiLP = inst; ~lp_window = w; w };
ensureServerReady.(); closeExistingLPDisplayWindows.(); openLP.()  // -> a Window
);

// [B] Adapter in place
"--- Adapter ---".postln;
(
// inline load of the adapter:
var asStringSafe = { arg obj; obj.asString };
~lp_displayAdapter = IdentityDictionary[
    \showExpectation -> { arg text, _idx=0; (~guiLP.notNil).if({ ~guiLP.sendPaneText(\system, asStringSafe.(text)) }); nil },
    \updateTextField -> { arg box, msg;
        var pane = box.asSymbol, t = asStringSafe.(msg), target;
        target = (pane == \state).if({ \system }, { (pane == \choices).if({ \choices }, { \diag }) });
        (~guiLP.notNil).if({ ~guiLP.sendPaneText(target, t) }); nil
    },
    \setOperations -> { arg lines; var joined = ((lines ? []) collect: _.asString).join(Char.nl.asString);
        (~guiLP.notNil).if({ ~guiLP.sendPaneText(\choices, joined) }); nil
    },
    \highlightCurrentColumn -> { arg which; nil },
    \enableMeters -> { arg flag = true; nil }
];
// bind if available:
if(~system.notNil) { var cm = ~system.tryPerform(\commandManager); (cm.notNil).if({ cm.display = ~lp_displayAdapter }) };
"Adapter bound if ~system.commandManager exists.".postln;
);

// [C] Drive a few updates
"--- Smoke text ---".postln;
(
var cm, fakeChoices;
cm = (~system.notNil).if({ ~system.commandManager }, { nil });
~guiLP.sendPaneText(\system, "Mode: idle");    // direct write (LPDisplay API)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/allfiles_20251003-1225.txt)
fakeChoices = ["fret 3 → audio", "fret 5 → control", "fret 7 → names"].join(Char.nl.asString);
~guiLP.sendPaneText(\choices, fakeChoices);    // verify choices area
cm.notNil.if({
    cm.display.showExpectation("Mode: test", 0);
    cm.display.updateTextField(\state, "Mode: test");
    cm.display.updateTextField(\choices, fakeChoices);
});
"Check LPDisplay: System & Choices panes should be updated.".postln;
);

// [D] Optional: play with sources shown in LPDisplay’s top panes
~guiLP.setSourceA(\srcA);   // available in your LPDisplay classes  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/allfiles_20251003-1225.txt)
~guiLP.setSourceB(\srcB);
)
===== LPDisplay/Migration_tests/Test_LPDisplayLayoutWindow_Basics.scd =====
// Test_LPDisplayLayoutWindow_Basics.scd
// v0.1.0
// MD 20251003-1110

/* Purpose/Style:
- Construct the window via .open if present, else .new.
- Verify it is a Window, bring it to front, and return it (-> a Window).
- Post a few basic properties without mutating the class.
*/

(
var createdWindow, ctorName, hasOpen, isWindow;

("Running: Test_LPDisplayLayoutWindow_Basics.scd").postln;

hasOpen = LPDisplayLayoutWindow.respondsTo(\open);
ctorName = hasOpen.if({ "open" }, { "new" });
createdWindow = hasOpen.if({ LPDisplayLayoutWindow.open }, { LPDisplayLayoutWindow.new });

isWindow = createdWindow.notNil and: { createdWindow.isKindOf(Window) };

("LPDisplayLayoutWindow constructor used: " ++ ctorName).postln;
("createdWindow is Window: " ++ isWindow.asString).postln;

isWindow.if({
    ("window name: " ++ (createdWindow.name ? "<nil>")).postln;
    ("window bounds: " ++ createdWindow.bounds.asString).postln;
    createdWindow.front;
}, {
    "Issue: LPDisplayLayoutWindow did not return a Window.".warn;
});

// Return the window so SC prints '-> a Window'
createdWindow
)
===== LPDisplay/Migration_tests/Test_LPDisplayLayoutWindow_LayoutSnapshot.scd =====
// Test_LPDisplayLayoutWindow_LayoutSnapshot.scd
// v0.1.1
// MD 20251003-1115

/* Purpose/Style:
- Build a textual snapshot of LPDisplayLayoutWindow's view tree (class, optional name, bounds).
- Writes to <Extensions>/LivePedalboardSuite/reports/LPDisplayLayoutWindow_layout_snapshot.txt
- Known-good SC only: no 'trim', no PathName.mkdir/exists, uses File.mkdir/File.use.
- Returns '-> a Window' so acceptance is visible.
*/

(
var createdWindow, reportDir, reportPath, lines, walkView;

("Running: Test_LPDisplayLayoutWindow_LayoutSnapshot.scd").postln;

reportDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "reports";
File.exists(reportDir).if({ }, { File.mkdir(reportDir) });
reportPath = reportDir +/+ "LPDisplayLayoutWindow_layout_snapshot.txt";

lines = List.new;

walkView = { |view, depth=0|
    var indent, clsStr, nameStr, boundsStr, line;
    indent = Array.fill(depth, { "  " }).join;  // two spaces per depth level
    clsStr = view.class.name.asString;
    nameStr = view.respondsTo(\name).if({ view.name.asString }, { "" });
    // If you want trimming, use stripWhiteSpace (not trim):
    nameStr = nameStr.stripWhiteSpace;
    boundsStr = view.bounds.asString;

    line = indent
        ++ clsStr
        ++ (nameStr.size == 0).if({ "" }, { " name:" ++ nameStr })
        ++ " bounds:" ++ boundsStr;

    lines.add(line);

    view.children.do({ |child|
        walkView.(child, depth + 1);
    });
};

createdWindow = LPDisplayLayoutWindow.respondsTo(\open).if({
    LPDisplayLayoutWindow.open
}, {
    LPDisplayLayoutWindow.new
});

createdWindow.front;

walkView.(createdWindow.view, 0);

// write snapshot
File.use(reportPath, "w", { |f|
    f.write(lines.join(Char.nl.asString))
});

("Wrote: " ++ reportPath).postln;

// Return the window so SC prints '-> a Window'
createdWindow
)

===== LPDisplay/Migration_tests/Test_LPDisplayLayoutWindow_PrototypeBringUp.scd =====
// Test_LPDisplayLayoutWindow_PrototypeBringUp.scd
// v0.1.0
// MD 20251003-1055

/* Purpose/Style:
- Prototype bring-up for LPDisplayLayoutWindow with minimal assumptions.
- Closes any existing LPDisplayLayoutWindow instances, opens a fresh one, and returns it (-> a Window).
- Known-good syntax; var-first; descriptive names; no single-letter locals; AppClock not required.
*/

(
var wantServerBoot, closedCount, openSelector, createdWindow, windowTitle, closeExisting;

("Running: Test_LPDisplayLayoutWindow_PrototypeBringUp.scd").postln;


wantServerBoot = false; // set true only if your window expects a running server
windowTitle = "LPDisplayLayoutWindow";

// Close any existing windows whose names begin with our title
closeExisting = {
    var survivors, nameMatches;
    survivors = List.new;
    Window.allWindows.do({ |w|
        nameMatches = w.notNil and: {
            var n;
            n = w.name;
            n.notNil and: { n.asString.beginsWith(windowTitle) }
        };
        if(nameMatches) { w.close } { survivors.add(w) };
    });
    survivors.size // not used, but keeps return; satisfies var-first discipline
};

closedCount = closeExisting.value;

// Boot server only if explicitly asked (UI-only window should not require it)
wantServerBoot.if({
    s = Server.default;
    s.waitForBoot({ /* no server ops needed for UI-only bring-up */ });
});

// Choose .open if present, otherwise .new
openSelector = LPDisplayLayoutWindow.respondsTo(\open).if({ \open }, { \new });

// Construct the window
createdWindow = LPDisplayLayoutWindow.perform(openSelector);
createdWindow.front;

// If the class didn’t set a name/title, enforce a stable title
(createdWindow.notNil and: {
    var existingTitle;
    existingTitle = createdWindow.name;
    existingTitle.isNil or: { existingTitle.asString.size == 0 }
}).if({
    createdWindow.name = windowTitle;
});

// Console hints
("Closed " ++ closedCount.asString ++ " existing '" ++ windowTitle ++ "' windows.").postln;
("Opened: " ++ createdWindow.name.asString).postln;

// Acceptance: return the window so SC prints '-> a Window'
createdWindow
)

===== LPDisplay/Migration_tests/Test_LPDisplayLayoutWindow_ResizeSanity.scd =====
// Test_LPDisplayLayoutWindow_ResizeSanity.scd
// v0.1.0
// MD 20251003-1110

/* Purpose/Style:
- Try a few window sizes and check all child views remain inside the content view.
- Posts warnings if any child bounds exceed the content area.
- Leaves the window at its original bounds; returns -> a Window.
*/

(
var createdWindow, originalBounds, testBoundsList, contentView, checkChildrenInside;

("Running: Test_LPDisplayLayoutWindow_ResizeSanity.scd").postln;

createdWindow = LPDisplayLayoutWindow.respondsTo(\open).if({
    LPDisplayLayoutWindow.open
}, {
    LPDisplayLayoutWindow.new
});

originalBounds = createdWindow.bounds;
contentView = createdWindow.view;

checkChildrenInside = { |parentView|
    var parentRect;
    parentRect = parentView.bounds;
    parentView.children.do({ |v|
        var b, inside;
        b = v.bounds; // bounds are relative to parent
        inside = (b.left >= 0) and: { b.top >= 0 } and: { (b.right <= parentRect.width) } and: { (b.bottom <= parentRect.height) };
        inside.if({
            // ok
        }, {
            ("WARN: Child " ++ v.class.name.asString ++ " bounds " ++ b.asString
             ++ " exceed parent size " ++ parentRect.asString).warn;
        });
    });
};

testBoundsList = [
    Rect(100, 100, originalBounds.width.max(360), originalBounds.height.max(240)),  // small but reasonable
    Rect(100, 100, (originalBounds.width * 1.2).round, (originalBounds.height * 1.2).round),
    Rect(100, 100, (originalBounds.width * 1.6).round, (originalBounds.height * 1.6).round)
];

testBoundsList.do({ |r|
    ("Resizing window to: " ++ r.asString).postln;
    createdWindow.bounds = r;
    AppClock.sched(0.05, { 0 }); // brief tick to let layout settle
    checkChildrenInside.(contentView);
});

// restore and front
createdWindow.bounds = originalBounds;
createdWindow.front;

// return -> a Window
createdWindow
)

===== LPDisplay/Migration_tests/Test_LPS_WindowManager_Acceptance.scd =====
// Test_LPS_WindowManager_Acceptance.scd
// v0.1.1
// MD 20251003-1248

/* Purpose/Style:
- Single end-to-end acceptance for (B) window management:
  1) bring-up single window
  2) create a stray, then consolidate to one via bring-up
  3) front-or-bring-up should front if exists, otherwise create
  4) bounds save/close/reopen/apply
- Returns '-> a Window'.
*/

(
var windowPrefix, desiredTitle, builderFunction, win, stray, testRect;

("Running: Test_LPS_WindowManager_Acceptance.scd").postln;

(~lps_bringUpSingleWindow.isNil or: { ~lps_applyLastWindowBounds.isNil } or: { ~lps_frontOrBringUpByPrefix.isNil }).if({
    "ERROR: Window manager helpers are not installed. Run LivePedalboardSystem_WindowManager_Install.scd first.".warn;
    ^nil
});

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// 1) bring-up single
win = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

// 2) create a stray, then consolidate
stray = LPDisplayLayoutWindow.respondsTo(\open).if({ LPDisplayLayoutWindow.open }, { LPDisplayLayoutWindow.new });
stray.name = "MagicDisplayGUI - STRAY";
win = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

// 3) front-or-bring-up (non-destructive if exists)
win = ~lps_frontOrBringUpByPrefix.(windowPrefix, builderFunction, desiredTitle);

// 4) bounds save/close/reopen/apply
testRect = Rect(160, 180, 700, 420);
win.bounds = testRect;
~lps_saveWindowBounds.(win, windowPrefix);
~lps_closeWindowsByPrefix.(windowPrefix);
win = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_applyLastWindowBounds.(win, windowPrefix);

// Return -> a Window
win
)
===== LPDisplay/Migration_tests/Test_LPS_WindowManager_BuilderStandalone.scd =====
// Test_LPS_WindowManager_BuilderStandalone.scd
// v0.1.0
// MD 20251003-1125

/* Purpose/Style:
- Call the same builder logic directly and confirm it returns a Window.
- Returns '-> a Window'.
*/

(
var createdWindow, requestedTitle;

("Running: Test_LPS_WindowManager_BuilderStandalone.scd").postln;

requestedTitle = "MagicDisplayGUI - LPDisplayLayout";

createdWindow = LPDisplayLayoutWindow.respondsTo(\open).if({
    LPDisplayLayoutWindow.open
}, {
    LPDisplayLayoutWindow.new
});

createdWindow.notNil.if({
    createdWindow.name = requestedTitle;
    createdWindow.front;
    ("Builder returned: " ++ createdWindow.class.name.asString).postln;
}, {
    "Builder returned: nil".warn;
});

// Return -> a Window (or nil if builder failed)
createdWindow
)
===== LPDisplay/Migration_tests/Test_LPS_WindowManager_Cleanup.scd =====
// Test_LPS_WindowManager_Cleanup.scd
// v0.1.0
// MD 20251003-1210

/* Purpose/Style:
- Optional helper: closes all windows with the policy prefix, then brings one back.
- Returns '-> a Window' so the IDE prints a Window reference at the end.
*/

(
var windowPrefix, closedCount, builderFunction, reopened;

("Running: Test_LPS_WindowManager_Cleanup.scd").postln;

windowPrefix = "MagicDisplayGUI";

closedCount = ~lps_closeWindowsByPrefix.(windowPrefix);
("Closed " ++ closedCount.asString ++ " window(s) with prefix '" ++ windowPrefix ++ "'").postln;

builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

reopened = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, "MagicDisplayGUI - LPDisplayLayout");
reopened
)
===== LPDisplay/Migration_tests/Test_LPS_WindowManager_Sanity.scd =====
// Test_LPS_WindowManager_Sanity.scd
// v0.1.1
// MD 20251003-1138

/* Purpose/Style:
- Confirm helpers are installed after running the *_Install.scd script.
*/

(
var hasBringUp, hasFind;

("Running: Test_LPS_WindowManager_Sanity.scd").postln;

hasBringUp = (~lps_bringUpSingleWindow.notNil) and: { ~lps_bringUpSingleWindow.isKindOf(Function) };
hasFind = (~lps_findWindowsByPrefix.notNil) and: { ~lps_findWindowsByPrefix.isKindOf(Function) };

("hasBringUp: " ++ hasBringUp.asString).postln;
("hasFind:    " ++ hasFind.asString).postln;
)
===== LPDisplay/Migration_tests/Test_Play_ShortBeep.scd =====
// Test_Play_ShortBeep.scd
// v0.1.0
// MD 20251003-1302

/* Purpose/Style:
- Play a short generated beep (no SoundIn, stereo) to confirm audio path.
- Safe: independent SynthDef with doneAction:2; no server.sync.
*/

(
var synthDefName, makeIfMissing, startBeep, startedSynth;

synthDefName = \md_shortBeep;

makeIfMissing = {
    SynthDescLib.global.at(synthDefName).isNil.if({
        SynthDef(synthDefName, {
            var amplitude, envelope, signal;
            amplitude = 0.2; // keep it gentle
            envelope = Env.perc(0.01, 0.35, curve: -4).kr(doneAction: 2);
            signal = SinOsc.ar(880) * envelope * amplitude;
            Out.ar(0, [signal, signal]);  // stereo
        }).add;
        "Defined SynthDef(\\md_shortBeep).".postln;
    });
};

startBeep = {
    s.serverRunning.if({
        startedSynth = Synth(synthDefName);
        ("Started " ++ synthDefName.asString ++ " -> " ++ startedSynth.asString).postln;
    }, {
        "Server is not running; beep skipped.".warn;
    });
};

makeIfMissing.();
startBeep.();
)
===== LPDisplay/Migration_tests/Wire_SystemCM_to_LPDisplay_Min.scd =====
// Wire_SystemCM_to_LPDisplay_Min.scd
// v0.1.2
// MD 20251003-1455

/* Purpose / Style
- Prefer SYSTEM CommandManager (if LivePedalboardSystem class is available), else use STANDALONE CM.
- Bind LPDisplayAdapter (~lp_adapter) to whichever CM we use and refresh panes once.
- Deterministic navigation helpers:
    root   → string 6 (frets 1,3,5,7,9)
    depth1 → string 5 (frets 3,5,7,...)
    depth2+→ string 4 (frets 3,5,7,...)
- Style: tilde vars; var-first; lowercase; descriptive names; no server.sync.
*/

(
var lpsClass, systemCm, selectors, sel, cmLocal, adapterLocal, bind, tryNav, report;

// prefer system CM if class exists + selector resolves; else fallback
lpsClass = \LivePedalboardSystem.asClass;
systemCm = nil;

if(lpsClass.notNil) {
    if(~system.isNil) { ~system = lpsClass.new(nil) };  // no extra GUI
    selectors = [\commandManager, \cmdManager, \cm, \manager];
    sel = selectors.detect({ arg s; ~system.respondsTo(s) and: { ~system.perform(s).notNil } });
    (sel.notNil).if({ systemCm = ~system.perform(sel) });
};

cmLocal = (systemCm.notNil).if({ systemCm }, { CommandManager.new(nil) });
~cm = cmLocal;

// bind adapter and refresh
bind = {
    adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
    ~lp_adapter = adapterLocal;
    cmLocal.display = adapterLocal;
    cmLocal.updateDisplay;
    nil
};
bind.();

// deterministic string navigation; always echo a Diag line
tryNav = { arg stringNum, fretNum;
    var ok;
    ok = cmLocal.builder.tryPerform(\navigateByFret, stringNum, fretNum);
    (ok == false or: { ok.isNil }).if({ ok = cmLocal.builder.tryPerform(\navigateByFret, fretNum) });
    cmLocal.updateDisplay;
    (~guiLP.notNil).if({
        ~guiLP.sendPaneText(\diag, "Tried: string " ++ stringNum ++ ", fret " ++ fretNum ++ " | result: " ++ ok.asString);
    });
    ok
};

// publish helpers
~nav6 = { arg fret; tryNav.(6, fret) };  // root
~nav5 = { arg fret; tryNav.(5, fret) };  // depth 1
~nav4 = { arg fret; tryNav.(4, fret) };  // depth 2+

// report binding
report = {
    var systemBound;
    systemBound = (systemCm.notNil) and: {
        [\commandManager, \cmdManager, \cm, \manager].any({ arg s; ~system.respondsTo(s) and: { ~system.perform(s) === cmLocal } })
    };
    (systemBound.if({ "Bound to: SYSTEM CommandManager" }, { "Bound to: STANDALONE CommandManager" })).postln;
};
report.();

"Nav ready. From root use ~nav6.(1|3|5|7|9); then ~nav5.(3|5|7); then ~nav4.(3|5|7).".postln;
)
===== LPDisplay/older versions/starting files/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== LPDisplay/older versions/starting files/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== LPDisplay/older versions/starting files/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== LPDisplay/older versions/starting files/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation’s audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through “processor” that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) → short delay → mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through “processor” you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== MagicPedalboard/Adapter_UIHook_Install.scd =====
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)

===== MagicPedalboard/bootstrap_audio_and_fx_min.scd =====
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) – guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) – matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)

===== MagicPedalboard/demo_apply_after_fix.scd =====
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_hotfix.scd =====
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON → OFF → final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_now.scd =====
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_milestone.scd =====
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)

===== MagicPedalboard/demo_commandtree_preformed_queues.scd =====
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <— Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)

===== MagicPedalboard/Demo_Install_MinProcessors.scd =====
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)

===== MagicPedalboard/Diag_BusChannel_Map.scd =====
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2→1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)

===== MagicPedalboard/docs and references/cheatsheet.scd =====
// cheatsheet.cd
// MD 20250913-1037

// Inspect
~pedalboard.printChains;            // or use your display adaptor

// Build NEXT non-destructively
~pedalboard.add(\delay);
~pedalboard.bypass(\delay, true);
~pedalboard.swap(1, 2);

// Go live with a short crossfade
~pedalboard.switchChain(0.1);

// Adjust CURRENT temporarily
~pedalboard.bypassAtCurrent(1, false);

// Change sources
~pedalboard.setSource(\ts1);
~pedalboard.setSourceCurrent(\ts2);

// Panic-safe reset
~pedalboard.reset;

===== MagicPedalboard/docs and references/usingLibraryWithMagicPedalboard.scd =====
// usingLibraryWithMagicPedalboard.scd
// MD 20250915-0914


(
// If you’ve loaded MagicProcessorLibrary_defs.scd already:
~procLib.ensureMany([\ts0, \delay, \tremolo, \reverb, \chorus, \drive], 2);

// Then (re)build your pedalboard chains knowing those symbols resolve:
~pedalboard.reset;
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
)

===== MagicPedalboard/editor_commandtree_add_demo_verbs.scd =====
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "✅ Loaded tree for editing.".postln;
} {
    "❌ Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("⚠️ addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd =====
// MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd
// v0.1.0
// MD 2025-09-24 23:55 BST

/*
Purpose
- Ensure the Choices panel uses light text on a dark background.
Style
- Class extension only; var-first; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  fixChoicesContrast { arg fg = Color(0.96,0.96,0.96), bg = Color(0.12,0.12,0.12,0.92);
    var apply;
    apply = {
      if(choicesPanel.notNil) { choicesPanel.background = bg };
      if(choicesTitle.notNil) { choicesTitle.stringColor = fg };
      if(choicesText.notNil)  { choicesText.stringColor  = fg };
    };
    AppClock.sched(0.0, { apply.value; nil });
    ^this
  }

  // Keep existing behavior but guarantee readable \choices text
  updateTextField { arg box, msg;
    var doIt;
    doIt = {
      if(box == \choices) {
        if(choicesText.notNil) {
          choicesText.string = msg.asString;
          choicesText.stringColor = Color(0.96,0.96,0.96);  // light text
          if(choicesTitle.notNil) { choicesTitle.stringColor = Color(0.96,0.96,0.96) };
        };
      }{
        if(expectationView.notNil) {
          expectationView.string = "[" ++ box.asString ++ "] " ++ msg.asString;
        };
      };
    };
    AppClock.sched(0.0, { doIt.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.scd =====
// MagicDisplayGUI_GridDemo_Ext_Meters.scd
// v0.3.0
// MD 2025-09-24 23:56 BST

/*
Purpose
- Provide enableMeters(true): listen to /ampA and /ampB (from SendReply.kr)
  and draw two moving bars in meterStrip.
Style
- Class extension only; var-first; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  enableMeters { arg on = true;
    var state, setupUI, install, remove;

    // Simple per-window state (no ivars added)
    state = (
      valA: 0.0,   // 0..1 (A bar)
      valB: 0.0,   // 0..1 (B bar)
      rxA:  nil,   // OSCdef handles
      rxB:  nil
    );

    setupUI = {
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds, pad = 8, w = b.width - (pad*2), h = b.height;
          var barH = ((h - (pad*2) - 4)/2).clip(8,14);
          var top1 = pad, top2 = pad + barH + 4;
          var a = state[\valA].clip(0,1), bb = state[\valB].clip(0,1);

          // backgrounds
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top1, w, barH)); Pen.fill;
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top2, w, barH)); Pen.fill;

          // dynamic fills
          Pen.color = Color(0.20, 0.70, 0.20); Pen.addRect(Rect(pad, top1, w * a,  barH)); Pen.fill;  // A
          Pen.color = Color(0.20, 0.40, 0.90); Pen.addRect(Rect(pad, top2, w * bb, barH)); Pen.fill;  // B

          // border
          Pen.color = Color.gray(0.5); Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
        };
      };
    };

    install = {
      setupUI.value;

      // IMPORTANT: these paths must match the ones used in SendReply.kr
      state[\rxA] = OSCdef(\mdAmpA, { |msg|
        // SendReply places floats after some metadata; first value is msg[3]
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        // quick smoothing
        state[\valA] = (state[\valA] * 0.7) + (max(l, r) * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampA');

      state[\rxB] = OSCdef(\mdAmpB, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var mean = ((l + r) * 0.5).clip(0,1);
        state[\valB] = (state[\valB] * 0.7) + (mean * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampB');
    };

    remove = {
      if(state[\rxA].notNil) { state[\rxA].free; state[\rxA] = nil };
      if(state[\rxB].notNil) { state[\rxB].free; state[\rxB] = nil };
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds;
          Pen.color = Color.gray(0.7);
          Pen.strokeRect(Rect(0.5,0.5,b.width-1,b.height-1));
        };
        meterStrip.refresh;
      };
    };

    AppClock.sched(0.0, { if(on) { install.value } { remove.value }; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveChain_Ext.scd
// v0.1.2
// MD 2025-09-26 15:36 BST

/* Purpose
   Provide a tiny, explicit CURRENT chain flag for the HUD (no pulsing).
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_setCurrentChain = { arg chainSymbol;
    var valid;
    valid = (chainSymbol == \A) or: { chainSymbol == \B };
    if(valid) { ~md_currentChain = chainSymbol };
    nil
};

~md_toggleCurrentChain = {
    var now;
    now = ~md_currentChain ? \A;
    ~md_currentChain = (now == \A).if({ \B }, { \A });
    nil
};

~md_isChainAActive = { (~md_currentChain ? \A) == \A };
~md_isChainBActive = { (~md_currentChain ? \A) == \B };
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveOverlay_Ext.scd
// v0.1.1 (robust attach + returns view)
// MD 2025-09-26 15:58 BST

/* Purpose
   A thin ACTIVE overlay bar at the top of the HUD.
   - A = green, B = blue-ish.
   - Robust window lookup (name contains "MagicDisplayGUI" or "PerfHUD").
   - Returns the overlay view (so "-> a UserView" shows in post).
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_currentChain = ~md_currentChain ? \A;

~md_attachActiveOverlay = {
    var windowsList, hudWindow, nameString, barHeight, overlayView, refreshRoutine;
    windowsList = Window.allWindows;

    hudWindow = windowsList.detect({ arg w;
        var n;
        n = w.tryPerform(\name);
        nameString = n.notNil.if({ n.asString }, { "" });
        (nameString.contains("MagicDisplayGUI") or: { nameString.contains("PerfHUD") })
    });

    if(hudWindow.isNil) {
        "⚠️ No MagicDisplayGUI/PerfHUD window found.".warn;
        ^nil
    };

    barHeight = 8;

    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color;
        Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height));
        Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    ~md_activeOverlayView = overlayView;
    ~md_activeOverlayRoutine = refreshRoutine;

    "[HUD] active overlay attached (top bar)".postln;
    overlayView   // IMPORTANT: return the view (not nil)
};

~md_detachActiveOverlay = {
    var view, routine;
    view = ~md_activeOverlayView; routine = ~md_activeOverlayRoutine;
    if(routine.notNil) { routine.stop };
    if(view.notNil) { view.remove };
    ~md_activeOverlayView = nil; ~md_activeOverlayRoutine = nil;
    "[HUD] active overlay removed".postln;
    nil
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd =====
// MagicDisplayGUI_PerfHUD_ActiveTint_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Keep the Chain A/B panel backgrounds in sync with ~md_currentChain (solid green).
   - Finds the A/B panels by locating "Chain A"/"Chain B" StaticText labels.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_findHudPanels = {
    var windowRef, collectViews, allViews, panelForLabel, aPanel, bPanel;

    windowRef = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });
    if(windowRef.isNil) { ^[nil, nil] };

    collectViews = { arg rootView, list;
        var children;
        children = rootView.children ? [];
        children.do({ arg c; list.add(c); collectViews.(c, list) });
        list
    };

    allViews = collectViews.(windowRef.view, List.new);

    panelForLabel = { arg labelString;
        var labelView, panelView;
        labelView = allViews.detect({ arg v; v.isKindOf(StaticText) and: { v.string == labelString } });
        panelView = labelView.notNil.if({ labelView.parent }, { nil });
        panelView
    };

    aPanel = panelForLabel.("Chain A");
    bPanel = panelForLabel.("Chain B");
    [aPanel, bPanel]
};

~md_startActiveTintOverlay = {
    var panels, aPanel, bPanel, winRef, routine, activeColor, idleColor;

    panels = ~md_findHudPanels.();
    aPanel = panels[0]; bPanel = panels[1];

    if(aPanel.isNil or: { bPanel.isNil }) {
        "⚠️ Could not locate Chain A/B panels; tint overlay not installed.".warn;
        ^nil
    };

    winRef = aPanel.window;
    activeColor = Color(0.18, 0.28, 0.18);
    idleColor   = Color.grey(0.15);

    routine = Routine({
        var keepRunning, isA, isB;
        keepRunning = true;
        while({ keepRunning and: { winRef.notNil and: { winRef.isClosed.not } } }, {
            isA = (~md_currentChain ? \A) == \A;
            isB = (~md_currentChain ? \A) == \B;
            aPanel.background_( isA.if({ activeColor }, { idleColor }) );
            bPanel.background_( isB.if({ activeColor }, { idleColor }) );
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] ACTIVE tint overlay running (current=" ++ (~md_currentChain ? \A).asString ++ ")".postln;
    routine
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd =====
// MagicDisplayGUI_PerfHUD_LevelsGUI_Listener_Ext.scd
// v0.1.0
// MD 2025-09-26 16:10 BST

/* Purpose
   Listen to /md/levels_gui (GA=32001, GB=32002), fill ~md_gui_levelsById,
   and provide a tiny overlay + helpers that read from that dict.
   Style: var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
~md_gui_levelsById  = ~md_gui_levelsById  ? IdentityDictionary.new;
~md_gui_lastStamp   = ~md_gui_lastStamp   ? SystemClock.seconds.asFloat;

~md_installGuiLevelsListener = {
    var key, existing;
    key = \md_levels_gui_listener;

    existing = OSCdef.all.at(key);
    if(existing.notNil) { existing.free };

    OSCdef(key, { arg msg;
        var replyId, l, r, safeL, safeR, now;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        l = msg[3].asFloat; r = msg[4].asFloat;
        safeL = l.isFinite.if({ l.clip(0, 1) }, { 0.0 });
        safeR = r.isFinite.if({ r.clip(0, 1) }, { 0.0 });
        ~md_gui_levelsById.put(replyId, [safeL, safeR]);
        now = SystemClock.seconds.asFloat;
        ~md_gui_lastStamp = now;
        nil
    }, "/md/levels_gui", recvPort: NetAddr.langPort);

    "[HUD] /md/levels_gui listener installed (key=md_levels_gui_listener)".postln;
    nil
};

~md_attachGuiOverlayMeters = {
    var hudWindow, overlayView, barWidth, pad, height, refreshRoutine;

    // robust window search
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "⚠️ No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    pad = 8; barWidth = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, barWidth, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        aPair = ~md_gui_levelsById.at(32001) ? [0, 0];
        bPair = ~md_gui_levelsById.at(32002) ? [0, 0];

        aL = aPair[0]; aR = aPair[1];
        bL = bPair[0]; bR = bPair[1];

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B top half
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "[HUD] overlay meters (GUI) attached (top-left)".postln;
    overlayView  // return view
};

~md_currentChain = ~md_currentChain ? \A;
~md_attachActiveOverlay = {  // reuse name, returns a UserView
    var hudWindow, overlayView, barHeight, refreshRoutine;
    hudWindow = Window.allWindows.detect({ arg w;
        var n = w.tryPerform(\name);
        n.notNil and: { n.asString.contains("MagicDisplayGUI") or: { n.asString.contains("PerfHUD") } }
    });
    if(hudWindow.isNil) { "⚠️ No MagicDisplayGUI/PerfHUD window found.".warn; ^nil };

    barHeight = 8;
    overlayView = UserView(hudWindow, Rect(0, 0, hudWindow.bounds.width, barHeight));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var isA, color;
        isA = (~md_currentChain ? \A) == \A;
        color = isA.if({ Color(0.18, 0.8, 0.18) }, { Color(0.18, 0.45, 0.95) });
        Pen.fillColor = color; Pen.addRect(Rect(0, 0, v.bounds.width, v.bounds.height)); Pen.fill;
    });

    refreshRoutine = Routine({
        var keepRunning;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.bounds = Rect(0, 0, hudWindow.bounds.width, barHeight);
            overlayView.refresh;
            0.20.wait;
        });
    }).play(AppClock);

    "[HUD] active overlay attached (top bar)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext_V0.1.0.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.1
// MD 2025-09-29 16:58 BST

/* Purpose
   Install language-side OSC responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters. Also install HUD
   meter mapping helpers so UI levels have headroom and do not peg at 1.0.

   Keeper notes
   - 2025-09-29: Ensure ampA/ampB responders auto-install on HUD bring-up (after reset).
                 Added ~hud_map_linear_to_ui (and dB sibling) with defaults:
                 floor -60 dB, top -6 dB, gamma 1.0. Apply at UI write-site.
                 Without responders, ~md_levelsById may be stale/empty → solid green meters.

Style
   - var-first; descriptive lowercase names; AppClock-only for UI; no server.sync; no non-local returns.
*/

(
var ensureAmpRespondersInstalled, installHudMeterMappingHelpers;

~md_installAmpToModelResponders = {
    var ensureModelReady, existingResponderA, existingResponderB;

    ensureModelReady = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModelReady.();

    // /ampA -> model[2001]
    existingResponderA = OSCdef.all.at(\ampA_to_model);
    if(existingResponderA.notNil) { existingResponderA.free };
    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingResponderB = OSCdef.all.at(\ampB_to_model);
    if(existingResponderB.notNil) { existingResponderB.free };
    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};

ensureAmpRespondersInstalled = {
    var hasResponderA, hasResponderB;
    hasResponderA = OSCdef.all.at(\ampA_to_model).notNil;
    hasResponderB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasResponderA.not or: { hasResponderB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Keeper defaults (adjust to taste across sessions)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 lifts lows; >1 tames lows

    // Linear (0..1) → UI 0..1 via dB mapping + optional perceptual curve
    ~hud_map_linear_to_ui = ~hud_map_linear_to_ui ? { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear → dBFS
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dBFS → 0..1
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);
        curvedValue
    };

    // dB (e.g., -60..0) → UI 0..1 (sibling helper if a dB route is used anywhere)
    ~hud_map_db_to_ui = ~hud_map_db_to_ui ? { arg dbValue;
        var floorDb, topDb, gammaValue, normalizedValue;
        floorDb    = ~hud_meter_floor_db ? -60.0;
        topDb      = ~hud_meter_top_db   ? -6.0;
        gammaValue = ~hud_meter_gamma    ? 1.0;
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0).clip(0.0, 1.0);
        normalizedValue.pow(gammaValue)
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

// Schedule both on AppClock so they are present after HUD bring-up and after a reset
AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });
)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Install language-side responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(

	//new
	var ensureAmpRespondersInstalled;
var installHudMeterMappingHelpers;


~md_installAmpToModelResponders = {
    var ensureModel, existingA, existingB;




    ensureModel = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModel.();

    // /ampA -> model[2001]
    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};


ensureAmpRespondersInstalled = {
    var hasAmpA, hasAmpB;

    hasAmpA = OSCdef.all.at(\ampA_to_model).notNil;
    hasAmpB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasAmpA.not or: { hasAmpB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Display calibration (keeper defaults; tweak to taste)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 raises lows; >1 tames lows

    // Linear (0..1) → UI value (0..1) with dB headroom and optional curve
    ~hud_map_linear_to_ui = { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db;
        topDb      = ~hud_meter_top_db;
        gammaValue = ~hud_meter_gamma;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear → dB
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dB → 0..1 (with top < 0 dBFS)
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);                // perceptual shaping (optional)
        curvedValue
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });

)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_Meters_Ext.scd =====
// MagicDisplayGUI_PerfHUD_Meters_Ext.scd
// v0.1.0
// MD 2025-09-26 15:05 BST

/* Purpose / Style
   Provide a small dbScale helper and an optional overlay you can attach to the HUD.
   - var-first; descriptive lowercase; AppClock-only; no server.sync; no non-local '^'.
*/

(
~md_dbScale = { arg linAmp, dbMin = -60.0;
    var safeAmp, dbVal, norm;
    safeAmp = (linAmp ? 0.0).max(1e-6);
    dbVal   = safeAmp.ampdb;                      // language-side conversion
    norm    = ((dbVal - dbMin) / (0 - dbMin)).clip(0.0, 1.0);
    norm
};

~md_attachOverlayMeters = {
    var hudWindow, pad, width, height, overlayView;

    hudWindow = Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    });

    if(hudWindow.isNil) { "⚠️ No MagicDisplayGUI window found.".warn; ^nil };

    pad = 8; width = 12; height = 84;
    overlayView = UserView(hudWindow, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);

    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, aLs, aRs, bLs, bRs, h, halfW;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0]; aR = aPair[1]; bL = bPair[0]; bR = bPair[1];

        aLs = ~md_dbScale.(aL, -60.0); aRs = ~md_dbScale.(aR, -60.0);
        bLs = ~md_dbScale.(bL, -60.0); bRs = ~md_dbScale.(bR, -60.0);

        h = v.bounds.height; halfW = v.bounds.width/2;

        // A bottom half
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, h/2 - (h/2 * aLs), halfW, (h/2 * aLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aRs), halfW, (h/2 * aRs))); Pen.fill;

        // B top half (lighter)
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bLs), halfW, (h/2 * bLs))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bRs), halfW, (h/2 * bRs))); Pen.fill;
    });

    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left; dB-scaled)".postln;
    overlayView
};
)

===== MagicPedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects – same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== MagicPedalboard/Manage_MagicDisplayGUI_Singleton.scd =====
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_CloseRecreateBind_GUI_GridDemo.scd =====
// MPBTest_CloseRecreateBind_GUI_GridDemo.scd
// v0.1.0
// MD 20250920-1919
(
var closeExisting, createGrid, bindAndFill;

/*closeExisting = {
    AppClock.sched(0.00, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            var nm = w.tryPerform(\name) ? "";
            nm.asString.beginsWith("MagicDisplayGUI")
        });
        wins.do(_.close);
        nil
    });
};*/

closeExisting = {
    AppClock.sched(0.00, {
        var windowList;

        windowList = Window.allWindows.select({ arg w;
            var nameString;
            nameString = w.tryPerform(\name) ? "";
            nameString.asString.beginsWith("MagicDisplayGUI")
        });

        windowList.do({ arg w; w.close });
        nil
    });
};

createGrid = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
        nil
    });
};

bindAndFill = {
    AppClock.sched(0.10, {
        if(~mpb.notNil and: { ~gui.notNil }) {
            ~mpb.setDisplay(~gui);
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            ~mpb.printChains;
            ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
        }{
            "[REBIND] ~mpb or ~gui missing".warn;
        };
        nil
    });
};

closeExisting.value;
createGrid.value;
bindAndFill.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd =====
// MPBTest_FreshBootBringUp_Now.scd
// v0.1.1
// MD 20250920-1642

(
var s, startBoot, afterBoot, waitDown, doFreshBoot;

s = Server.default;

afterBoot = {
    AppClock.sched(0.00, {
        ~bring = MPBTest_BringUp.new(true, 2, 0.40, true); // use loud test source & publish tildes
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };
        nil
    })
};

startBoot = {
    s.doWhenBooted({ afterBoot.value });
    if(s.serverRunning.not) { s.boot };
};

waitDown = {
    if(s.serverRunning.not) { startBoot.value; nil } {
        AppClock.sched(0.05, waitDown)
    }
};

doFreshBoot = {
    if(s.serverRunning) {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };
        s.quit;
        AppClock.sched(0.05, waitDown);
    }{
        startBoot.value;
    };
};

doFreshBoot.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_RebindAndFillGUI.scd =====
// MPBTest_RebindAndFillGUI.scd
// v0.1.0
// MD 20250920-1919

(
var need;

// 0) Precondition: we want ~mpb and ~gui alive
need = (~mpb.notNil) && (~gui.notNil);
if(need.not) {
    "[REBIND] need ~mpb and ~gui; run MPBTest_BringUp first.".warn;
    ^nil;
};

// 1) If the GUI was created after MPB, bind it now
if(~mpb.display.isNil or: { ~mpb.display !== ~gui }) {
    ~mpb.setDisplay(~gui);
    "[REBIND] bound ~gui to ~mpb".postln;
};

// 2) Make sure it’s in front (and visible)
AppClock.sched(0.02, {
    var w;
    w = ~gui.tryPerform(\window);
    if(w.notNil) { w.front; w.alwaysOnTop_(true) };
    nil
});

// 3) Reattach meters (guards inside GUI)
AppClock.sched(0.04, {
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
    nil
});

// 4) Fill the chains view now
AppClock.sched(0.06, {
    ~mpb.printChains; // drives showChainsDetailed when a display is bound
    // highlight current column for good measure
    ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
    nil
});
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Record_WorkingState.scd =====
// MPBTest_Record_WorkingState.scd
// v0.1.1
// MD 20250920-1930

(
var now, stamp, docDir, mdPath, jsonPath, mkDir;
var s, o, outDev, sr, blk, scv, lines, md, js;
var v_mpbtest_bring, v_mpbtest_scen, v_mpbtest_suites, v_mpbtest_assert;
var v_mpb, v_md, v_mdgui, v_mdgrid;
var fileList, classPaths;

/*// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930
docDir = PathName(thisProcess.nowExecutingPath ?? thisProcess.cwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;*/

// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930

// Use script location if available, else current working directory
docDir = PathName(thisProcess.nowExecutingPath ? File.getcwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;


mkDir = { |p|
    var pn = PathName(p);
    if(pn.isFolder.not) {
        File.mkdir(p);
    };
};


// 1) Ensure docs dir
mkDir.(docDir);

// 2) Environment
s  = Server.default;
o  = s.options;
outDev = o.outDevice ? "default";
sr  = s.sampleRate ? 0;
blk = o.blockSize;
/*scv = Main.scVersionString ? Main.scVersion;*/
/*scv = Platform.version.asString;*/
scv = thisProcess.interpreter.version;


// 3) Versions
v_mpbtest_bring  = (MPBTest_BringUp.respondsTo(\version)).if({ MPBTest_BringUp.version },{ "unknown" });
v_mpbtest_scen   = (MPBTest_Scenario.respondsTo(\version)).if({ MPBTest_Scenario.version },{ "unknown" });
v_mpbtest_suites = (MPBTest_AcceptanceSuites.respondsTo(\version)).if({ MPBTest_AcceptanceSuites.version },{ "unknown" });
v_mpbtest_assert = (MPBTest_Assertions.respondsTo(\version)).if({ MPBTest_Assertions.version },{ "unknown" });

v_mpb    = (MagicPedalboardNew.respondsTo(\version)).if({ MagicPedalboardNew.version },{ "unknown" });
v_md     = (MagicDisplay.respondsTo(\version)).if({ MagicDisplay.version },{ "unknown" });
v_mdgui  = (MagicDisplayGUI.respondsTo(\version)).if({ MagicDisplayGUI.version },{ "unknown" });
v_mdgrid = (MagicDisplayGUI_GridDemo.respondsTo(\version)).if({ MagicDisplayGUI_GridDemo.version },{ "unknown" });

// 4) Class file paths (confirm there’s only one of each)
classPaths = Class.allClasses
    .select({ |c| ["MPBTest_BringUp","MPBTest_Scenario","MPBTest_AcceptanceSuites","MPBTest_Assertions"].includes(c.name.asString) })
    .collect(_.filenameSymbol.asString);

// 5) Chain snapshot
~mpb = ~mpb ?? { nil };
fileList = if(~mpb.notNil, {
    var effC = ~mpb.effectiveCurrent, effN = ~mpb.effectiveNext;
    [
        "CURRENT=" ++ effC.asString,
        "NEXT   =" ++ effN.asString,
        "[PLAY] A=" ++ Ndef(\chainA).isPlaying ++ " B=" ++ Ndef(\chainB).isPlaying
    ]
}, { ["no ~mpb"] });

// 6) Write Markdown + JSON
mdPath   = docDir +/+ ("WorkingState_" ++ stamp ++ ".md");
jsonPath = docDir +/+ ("WorkingState_" ++ stamp ++ ".json");

// Markdown
md = String.new;
md = md
++ "# MagicPedalboard – Working State (" ++ stamp ++ ")\n\n"
++ "## Versions\n"
++ "- MPBTest_BringUp: "   ++ v_mpbtest_bring  ++ "\n"
++ "- MPBTest_Scenario: "  ++ v_mpbtest_scen   ++ "\n"
++ "- MPBTest_AcceptanceSuites: " ++ v_mpbtest_suites ++ "\n"
++ "- MPBTest_Assertions: "++ v_mpbtest_assert ++ "\n"
++ "- MagicPedalboardNew: "++ v_mpb ++ "\n"
++ "- MagicDisplay: "      ++ v_md  ++ "\n"
++ "- MagicDisplayGUI: "   ++ v_mdgui  ++ "\n"
++ "- MagicDisplayGUI_GridDemo: " ++ v_mdgrid ++ "\n\n"
++ "## Environment\n"
++ "- sclang: " ++ scv ++ "\n"
++ "- output device: " ++ outDev ++ "\n"
++ "- sample rate: " ++ sr ++ "\n"
++ "- block size: " ++ blk ++ "\n\n"
++ "## Class Files\n- " ++ classPaths.join("\n- ") ++ "\n\n"
++ "## Chain Snapshot\n- " ++ fileList.join("\n- ") ++ "\n";

File.writeText(mdPath, md);

// JSON (minimal)
js = (
    timestamp: stamp,
    versions: (
        MPBTest_BringUp: v_mpbtest_bring, MPBTest_Scenario: v_mpbtest_scen,
        MPBTest_AcceptanceSuites: v_mpbtest_suites, MPBTest_Assertions: v_mpbtest_assert,
        MagicPedalboardNew: v_mpb, MagicDisplay: v_md,
        MagicDisplayGUI: v_mdgui, MagicDisplayGUI_GridDemo: v_mdgrid
    ),
    environment: (
        sclang: scv, outDevice: outDev, sampleRate: sr, blockSize: blk
    ),
    classFiles: classPaths
).asCompileString;

File.writeText(jsonPath, js);

("[RECORD] wrote\n- " ++ mdPath ++ "\n- " ++ jsonPath).postln;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== MagicPedalboard/old but good/Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd
// MD 20250912-1527

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets; no double /n_free


(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight (avoid double free: only clear Ndefs)
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces…".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var exists;
            exists = proxyRef.notNil;
            if(exists) {
                proxyRef.clear; // no proxy.stop here → avoids duplicate /n_free
            };
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2→12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT→\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (GUI queues until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== MagicPedalboard/PERFHUD_UIWriter_Headroom_Overlay.scd =====
// PERFHUD_UIWriter_Headroom_Overlay.scd
// v0.1.0
// MD 2025-09-29

(
var disableLegacyHudOsc, findPerfHudWindow, collectIndicatorsRecursively;
var bindMetersOnce, updateMetersFromModelMapped, startHudTicker;
var desiredFps, mappingExists, meterOrderNote;

// Desired HUD update cadence
desiredFps = 24.0;

// 1) Disable the legacy /md/levels HUD OSCdef so it cannot overwrite our mapped values
disableLegacyHudOsc = {
    var existingHudOsc, resultText;
    existingHudOsc = OSCdef.all.at(\md_levels_hud);
    if(existingHudOsc.notNil) {
        existingHudOsc.free;
        resultText = "[HUD] Disabled legacy OSCdef(\\md_levels_hud) for /md/levels to prevent raw 0..1 pegging.";
    }{
        resultText = "[HUD] Legacy OSCdef(\\md_levels_hud) not present (nothing to disable).";
    };
    resultText.postln;
    nil
};

// 2) Utilities to find the PerfHUD window and collect all LevelIndicators
findPerfHudWindow = {
    var perfWindow;
    perfWindow = Window.allWindows.detect({ arg eachWindow;
        var windowNameString;
        windowNameString = (eachWindow.tryPerform(\name) ? "").asString;
        windowNameString.beginsWith("MagicDisplayGUI")
    });
    perfWindow
};

collectIndicatorsRecursively = { arg rootView;
    var allIndicators, recurseChildren;
    allIndicators = List.new;
    recurseChildren = { arg viewToScan;
        if(viewToScan.isKindOf(LevelIndicator)) { allIndicators.add(viewToScan) };
        viewToScan.children.do({ arg childView; recurseChildren.(childView) });
    };
    recurseChildren.(rootView);
    allIndicators.asArray
};

// 3) Cache references to the first 4 meters (A L, A R, B L, B R)
//    Adjust here if your layout uses a different order or more meters.
bindMetersOnce = {
    var perfWindow, rootView, allMeters, bindOk;
    bindOk = false;

    perfWindow = findPerfHudWindow.();
    if(perfWindow.isNil) {
        "PerfHUD window not found (MagicDisplayGUI...). Will retry.".warn;
    }{
        rootView = perfWindow.tryPerform(\view);
        if(rootView.isNil) {
            "PerfHUD host view missing. Will retry.".warn;
        }{
            allMeters = collectIndicatorsRecursively.(rootView);
            if(allMeters.size < 4) {
                ("[HUD] Found only " ++ allMeters.size ++ " LevelIndicators; expecting ≥ 4. Will retry.").warn;
            }{
                // Cache the first four meters (override if you have a specific order)
                ~hud_meterA_left   = allMeters[0];
                ~hud_meterA_right  = allMeters[1];
                ~hud_meterB_left   = allMeters[2];
                ~hud_meterB_right  = allMeters[3];

                meterOrderNote = "[HUD] Bound meters: [0]=A_L  [1]=A_R  [2]=B_L  [3]=B_R (override if your layout differs)";
                meterOrderNote.postln;
                bindOk = true;
            };
        };
    };
    bindOk
};

// 4) Mapped update from model → LevelIndicators
updateMetersFromModelMapped = {
    var levelsA, levelsB;
    var mappedAL, mappedAR, mappedBL, mappedBR;

    // Ensure mapping helper exists (installed by your responders extender file)
    mappingExists = (~hud_map_linear_to_ui.notNil);
    if(mappingExists.not) {
        "⚠️ ~hud_map_linear_to_ui is not defined. Evaluate MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd first.".warn;
        ^nil;
    };

    // Pull linear A/B pairs from model; default to zeros
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });

    // Map linear (0..1) → UI value (0..1) using your headroom + gamma
    mappedAL = ~hud_map_linear_to_ui.(levelsA[0]);
    mappedAR = ~hud_map_linear_to_ui.(levelsA[1]);
    mappedBL = ~hud_map_linear_to_ui.(levelsB[0]);
    mappedBR = ~hud_map_linear_to_ui.(levelsB[1]);

    // Assign to cached meters (guards in case binding failed)
    if(~hud_meterA_left.notNil)   { ~hud_meterA_left.value   = mappedAL };
    if(~hud_meterA_right.notNil)  { ~hud_meterA_right.value  = mappedAR };
    if(~hud_meterB_left.notNil)   { ~hud_meterB_left.value   = mappedBL };
    if(~hud_meterB_right.notNil)  { ~hud_meterB_right.value  = mappedBR };
    nil
};

// 5) Start/replace one AppClock ticker that updates HUD at desiredFps
startHudTicker = {
    var makeTicker;

    // Stop a previous ticker if present
    if(~hud_tickerRoutine.notNil) {
        ~hud_tickerRoutine.stop;
        ~hud_tickerRoutine = nil;
        "[HUD] Replaced previous HUD ticker.".postln;
    };

    makeTicker = {
        ~hud_tickerRoutine = Routine({
            var waitSeconds;
            waitSeconds = 1.0 / desiredFps;
            while({ true }) {
                updateMetersFromModelMapped.();
                waitSeconds.yield;
            }
        });
        ~hud_tickerRoutine.play(AppClock);
        ("[HUD] HUD ticker active @ " ++ desiredFps.round(0.1) ++ " fps.").postln;
        nil
    };

    makeTicker.();
};

// Execute overlay
AppClock.sched(0.0, {
    var bound;
    disableLegacyHudOsc.();
    bound = bindMetersOnce.();
    if(bound.not) {
        // try again shortly in case the window just spawned
        AppClock.sched(0.25, {
            if(bindMetersOnce.()) { startHudTicker.() }{ "[HUD] Binding failed again; run this block once the HUD window is visible.".warn };
            nil
        });
    }{
        startHudTicker.();
    };
    nil
});
)

===== MagicPedalboard/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "⚠️ ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "⚠️ CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "⚠️ queueExportCallback missing.".warn };
)

===== MagicPedalboard/QuickRestore_AudioAndExclusive.scd =====
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== MagicPedalboard/switchDelayCheck.scd =====
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optional Final) probes using your stereo BUS INDICES.
   - A uses replyID 2001, B uses 2002, Final uses 2101.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain stereo bus base index (e.g., 16)
busB = -1;      // TODO: set to your B chain stereo bus base index (e.g., 24)
busFinal = -1;  // optional final mix stereo bus base index (e.g., 32)

ok = true;

if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd
// v0.3.13
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter filters to avoid duplicate /md/levels.
   - Announce everything in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, aResult, bResult, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, def1, def2;

    ok2 = true;

    // mono probe
    def1 = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // silent synth
        Silent.ar(1).mute;
    }).add;

    // stereo probe
    def2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        Silent.ar(2).mute;
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any in-proxy meter/tap filters to identity (no duplicate SendReply)
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Collect Ndef info: exists, playing, bus index, channel count, group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2; // default to stereo if unknown
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, tagSym, outVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            // Free previous probe if any
            freeIfPlaying.value(thisProcess.interpreter.getVar(outVarSym));

            // Ensure a fresh group placed after the Ndef's group
            grp = Group.after(groupTarget);

            // Attach appropriate probe
            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            // Publish references
            thisProcess.interpreter.setVar(tagSym, grp);
            thisProcess.interpreter.setVar(outVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

// Ensure our probe SynthDefs exist
ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, ~md_probeGroupA, ~md_probeA);
attachAfterNdef.value(bInfo, 2002, ~md_probeGroupB, ~md_probeB);

("Attach_ProbesAfterNdefs: done.").postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd
// v0.3.14
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announces itself in the console so logs show what ran and in what order.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe (no Out, just SendReply)
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output; silent by design
    }).add;

    // stereo probe (no Out, just SendReply)
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output; silent by design
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any prior filters (meter/tap) to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Gather Ndef info: existence, playing, bus index, channel count (clamped 1..2), and group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, groupVarSym, synthVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            freeIfPlaying.value(thisProcess.interpreter.getVar(synthVarSym));
            thisProcess.interpreter.setVar(synthVarSym, nil);

            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            thisProcess.interpreter.setVar(groupVarSym, grp);
            thisProcess.interpreter.setVar(synthVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, \~md_probeGroupA, \~md_probeA);
attachAfterNdef.value(bInfo, 2002, \~md_probeGroupB, \~md_probeB);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd
// v0.3.15
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (mono or stereo).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announce actions in console so logs clearly show what ran.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyFilters,
    detectInfo, freeIfPlaying, attachAfterNdef,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe: reads 1 channel, sends a single float
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output
    }).add;

    // stereo probe: reads 2 channels, sends an array of two floats
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output
    }).add;

    ok2;
};

neutralizeInProxyFilters = {
    var ok2;

    ok2 = true;

    // Overwrite prior filters/taps to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Inspect an Ndef and report (exists, playing, bus index, channel count, group)
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group AFTER the Ndef's group and attach the proper probe synth.
// Uses setter closures to store references in ~vars (no reflection).
attachAfterNdef = { |info, replyID, setGroupFunc, setSynthFunc, freeOldSynthFunc|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        // free the previous synth if any (quietly)
        freeOldSynthFunc.value;

        s.bind({
            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };
        });

        setGroupFunc.value(grp);
        setSynthFunc.value(synth);

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Ensure our base routing exists WITHOUT clearing your Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy filters/taps
neutralizeInProxyFilters.value;

// Detect chains (prints status)
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes AFTER the Ndef groups (ordering-safe)
attachAfterNdef.value(
    aInfo, 2001,
    { |g| ~md_probeGroupA = g },            // set group
    { |sy| ~md_probeA = sy },               // set synth
    { freeIfPlaying.value(~md_probeA); ~md_probeA = nil }  // free old synth if any
);

attachAfterNdef.value(
    bInfo, 2002,
    { |g| ~md_probeGroupB = g },
    { |sy| ~md_probeB = sy },
    { freeIfPlaying.value(~md_probeB); ~md_probeB = nil }
);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd =====
// MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - For JITLib chains Ndef(\chainA) and Ndef(\chainB), install .filter taps
     that mirror their outputs to private 2ch busses for metering.
   - Attach probes to those busses (replyID 2001 for A, 2002 for B).
   - Provides a removal helper for the taps and busses.

   Style
   - var-first in every block; no non-local returns (^).
   - Uses .filter as you prefer; does not alter chain sound (passes input through).
*/

(
var setupBusTaps, removeBusTaps;

setupBusTaps = {
    var ok, haveA, haveB;

    ok = true;
    haveA = false;
    haveB = false;

    // preflight: Ndefs must exist
    if (Ndef(\chainA).notNil) { haveA = true; } { "Ndef(\\chainA) not found.".postln; };
    if (Ndef(\chainB).notNil) { haveB = true; } { "Ndef(\\chainB) not found.".postln; };

    if (haveA.not and: { haveB.not }) {
        "Neither chainA nor chainB found; nothing to attach.".postln;
    } {
        // free previous busses if any
        if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
        if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

        // allocate new private 2ch busses
        ~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
        ~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

        // install taps using .filter; each tap writes to its bus, then passes input through
        if (haveA) {
            Ndef(\chainA).filter(\mdProbeTapA, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busA.index, outSig);
                outSig
            });
        };
        if (haveB) {
            Ndef(\chainB).filter(\mdProbeTapB, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busB.index, outSig);
                outSig
            });
        };

        // attach probes to those busses
        if (~md_attachProbesAB.notNil) {
            ~md_attachProbesAB.value(
                busA: (if (haveA) { ~md_busA.index } { -1 }),
                busB: (if (haveB) { ~md_busB.index } { -1 })
            );
            ("Attached A bus=" ++ (if (haveA) { ~md_busA.index.asString } { "none" })
             ++ " B bus=" ++ (if (haveB) { ~md_busB.index.asString } { "none" })).postln;
        } {
            "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
        };
    };

    ok;
};

removeBusTaps = {
    var ok;

    ok = true;

    // remove taps if present
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).removeFilter(\mdProbeTapA);
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).removeFilter(\mdProbeTapB);
    };

    // free private busses
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    ok;
};

// ---------- run setup now ----------
setupBusTaps.value;

// Later, to remove taps + free busses:
// removeBusTaps.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optionally Final) probes by BUS INDICES you provide.
   - Leaves the window unchanged; meters switch to A/B once replies arrive.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain bus index (stereo base index)
busB = -1;      // TODO: set to your B chain bus index (stereo base index)
busFinal = -1;  // optional: set to your final mix bus index

ok = true;

// sanity check
if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    } {
        "Final bus not set; skipping.".postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd =====
// MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Fix "sound but meters not moving" by:
     * ensuring OUR routing non-destructively
     * reinstalling receiver
     * auto-attaching A(2001)/B(2002) probes to Ndef buses
     * printing quick status
   - Assumes your chains are Ndef(\chainA) and Ndef(\chainB) and are PLAYING.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, detectBusIndex, aIdx, bIdx, reinstallReceiver, postStatus;

("MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd").postln;
ok = true;

if (~md_ensureRouting.isNil or: { ~md_attachProbesAB.isNil }) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure our bus/groups/probe exist without killing your Ndefs
    ~md_ensureRouting.value;

    // reinstall receiver safely
    reinstallReceiver = {
        var existing;
        existing = OSCdef(\md_levels);
        if (existing.notNil) { existing.free; };
        ~md_levelsById = IdentityDictionary.new;
        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = Main.elapsedTime;

        OSCdef(
            \md_levels,
            { |msg, time, addr, recvPort|
                var nodeId, replyId, count, i, outArray;

                nodeId = 0;
                replyId = 0;
                count = 0;
                i = 0;
                outArray = nil;

                if (msg.size >= 3) {
                    nodeId = msg[1].asInteger;
                    replyId = msg[2].asInteger;
                    count = msg.size - 3;
                    outArray = Array.newClear(count);
                    i = 0;
                    while { i < count } {
                        outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                        i = i + 1;
                    };
                    ~md_levelsById[replyId] = outArray;
                    ~levels = outArray;
                    ~md_lastLevelAt = Main.elapsedTime;
                };
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );

        true;
    };

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid when proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    postStatus = {
        var keys, msg;
        keys = ~md_levelsById.keys.asArray.sort;
        msg = "Active replyIDs: " ++ keys.asString;
        msg.postln;
        if (~md_levelsById[2001].notNil) { ("A: " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B: " ++ ~md_levelsById[2002].asString).postln; };
    };

    reinstallReceiver.value;

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected Ndef buses → A=" ++ aIdx.asString ++ "  B=" ++ bIdx.asString).postln;

    // attach probes directly to those buses (skip -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // small delayed status check (allow first /md/levels to arrive)
    AppClock.sched(0.5, {
        postStatus.value;
        nil;
    });
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd =====
// MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Add simple HUD labels inside the existing MagicDisplayGUI A/B window.
   - Top-left anchored, no FlowLayout; read-only labels for the demo.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, win, content, hudTitle, hudA, hudB;

ok = true;

win = ~mdGui_window;

if (win.isNil) {
    "No MagicDisplayGUI window found. Open MagicDisplayGUI_New_Window_AB_v0.3.7.scd first.".postln;
} {
    content = win.view;

    // Title HUD
    hudTitle = StaticText(content, Rect(16, 0, 400, 12));
    hudTitle.string = "HUD: A=replyID 2001 | B=replyID 2002 | fallback=test 1001";
    hudTitle.stringColor = Color.gray(0.8);
    hudTitle.background = Color.clear;
    hudTitle.align = \left;

    // Chain labels (editable here if you want different names)
    hudA = StaticText(content, Rect(16, 24, 200, 12));
    hudA.string = "A: Ndef(\\chainA)";
    hudA.stringColor = Color.gray(0.8);
    hudA.background = Color.clear;
    hudA.align = \left;

    hudB = StaticText(content, Rect(292, 24, 200, 12));
    hudB.string = "B: Ndef(\\chainB)";
    hudB.stringColor = Color.gray(0.8);
    hudB.background = Color.clear;
    hudB.align = \left;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.1.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.1.scd
// v0.3.1
// MD timestamp: 2025-09-25

/* Purpose
   - Fast way to remove GUI, OSC receiver, synths, groups, bus; leave server running clean.
*/

(
var ok;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// Receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Synths
if (~md_testSynth.notNil) { ~md_testSynth.free; ~md_testSynth = nil; };
if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };

// Groups
if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

s.defaultGroup.freeAll;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.5.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Close GUI, free OSC receiver, clear server nodes/bus, and reset state.
   - Silent and idempotent: safe to run multiple times; no 'Node not found' noise.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, hadServer;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// OSC receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Server nodes (only if server running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
}

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// ensure final expression is a simple boolean
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.6.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.6.scd
// v0.3.6
// MD timestamp: 2025-09-25

/* Purpose
   - Close MagicDisplayGUI windows, stop GUI ticker, free OSC receiver.
   - Clear server default group (if running), free private bus, reset state vars.
   - Silent and idempotent; final expression is 'true' (never returns a Window).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, hadServer, windows, i, w, nameString;

ok = true;

// stop GUI ticker if present
if (~mdGui_ticker.notNil) {
    ~mdGui_ticker.stop;
    ~mdGui_ticker = nil;
};

// close any MagicDisplayGUI windows (explicitly; this does not return the window)
windows = Window.allWindows;
i = 0;
while { i < windows.size } {
    w = windows[i];
    nameString = w.name.asString;
    if (nameString.beginsWith("MagicDisplayGUI")) {
        w.close;
    };
    i = i + 1;
};

// free OSC receiver if present
if (OSCdef(\md_levels).notNil) {
    OSCdef(\md_levels).free;
};

// clear server nodes (only if server is running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
};

// free private bus if allocated
if (~md_mixBus.notNil) {
    ~md_mixBus.free;
    ~md_mixBus = nil;
};

// nil any cached node/bus references
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

// final value: simple boolean (prevents '-> a Window')
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot the server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create a private bus, groups, relay-to-hardware and a level probe.
   - Install an OSC receiver bound to '/md/levels' (matches SendReply).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probe reads a private bus; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // Close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // Reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = 0.0;
    ~md_testSynth = nil;
    ~md_probe = nil;
    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // Reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // Test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // Relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // Level probe (2ch fixed) → '/md/levels'
    // Message format: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// Install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// Create routing (fresh bus + fresh groups + relay + probe). Clears default group first.
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // Clear any stale nodes from previous runs
        s.defaultGroup.freeAll;

        // Fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // Fresh groups in strict order: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // Relay and probe (safe even without source)
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // No source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    // Always rebuild routing to avoid stale groups after a server reboot
    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // Clean everything (leave server running)
    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  OSC: listening on /md/levels".postln;

    ok;
};

// ---------- Run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
// ~md_ensureRouting.value;
// ~md_reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd
// v0.3.7
// MD 2025-09-25 15:10 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Returns input unchanged (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz;

var windowNote, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        // free old one if present (idempotent reset)
        existing = OSCdef(defName);
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var each;
    each = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    each.value(\chainA, ids[\A]);
    each.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId, ~slotName;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ~md_probeA = ~md_probeA ? { makeOne.value(\chainA, ids[\A]) } !? { ~md_probeA };
    ~md_probeB = ~md_probeB ? { makeOne.value(\chainB, ids[\B]) } !? { ~md_probeB };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
        // leave signal path untouched; if silent they’ll still meter 0.0
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> You can switch to Plan B by calling: ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};
apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:22 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Pass-through (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        existing = OSCdef(defName); // returns nil or the OSCdef
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var installOne;
    installOne = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    installOne.value(\chainA, ids[\A]);
    installOne.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ensureDef.value;
    if(~md_probeA.isNil) { ~md_probeA = makeOne.value(\chainA, ids[\A]) };
    if(~md_probeB.isNil) { ~md_probeB = makeOne.value(\chainB, ids[\B]) };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

// expose helpers as requested
~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> To switch to Plan B later:
//    ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.1.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday’s GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) — tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels…";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views’ bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday’s GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) — tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels…";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views’ bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd
// v0.4.4
// MD 2025-09-25 16:48 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday’s GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, meterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay, startTicker, stopTicker, tickerFlag;
var identityBanner;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === identity banner (after var-first) ======================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.4.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) — tweak here to adjust spacing
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;
labelWidth = 84;   // wider, more readable
meterWidth = 360;

// init meter values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, getLevelFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, meterWidth, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD string with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    stepFunc = {
        readLevelsAndUpdateDisplay.value;
        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;
        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// compute total height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + labelWidth + 8 + meterWidth + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=false, border=true -> proper title bar visible
windowRef = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.4)", windowRect, false, true);

// HUD
hudLabel = StaticText(windowRef, Rect(paddingX, paddingY, labelWidth + 8 + meterWidth, headerHeight));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels…";

// Frame area that draws section boxes
meterFrameView = makeFrameView.value(windowRef, Rect(
    paddingX,
    paddingY + headerHeight + rowGap,
    (labelWidth + 8 + meterWidth),
    (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)
));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

// Deterministic Y positions (no dependency on .bounds of other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// Chain A
chainATitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainATitleY, 120, sectionTitleHeight));
chainATitleLabel.string = "Chain A";

chainALabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight));
chainALabelLeft.string = "A-L";
barViewALeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar1Y, { displayALevelLeft });

chainALabelRight = StaticText(windowRef, Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight));
chainALabelRight.string = "A-R";
barViewARight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainABar2Y, { displayALevelRight });

// Chain B
chainBTitleLabel = StaticText(windowRef, Rect(paddingX + 8, chainBTitleY, 120, sectionTitleHeight));
chainBTitleLabel.string = "Chain B";

chainBLabelLeft = StaticText(windowRef, Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight));
chainBLabelLeft.string = "B-L";
barViewBLeft = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar1Y, { displayBLevelLeft });

chainBLabelRight = StaticText(windowRef, Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight));
chainBLabelRight.string = "B-R";
barViewBRight = makeBarView.value(windowRef, paddingX + 16 + labelWidth + 8, chainBBar2Y, { displayBLevelRight });

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd
// v0.4.5
// MD 2025-09-25 16:58 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout akin to your previous GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch HORIZONTALLY as you resize.
  (No FlowLayout; manual top-left anchored layout on AppClock.)

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed rect metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, minMeterWidth, maxMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.5.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics)
paddingX = 12; paddingY = 10;
rowGap = 8;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;            // readable label width
minMeterWidth = 260;         // minimum bar width
maxMeterWidth = 900;         // clamp to keep drawing pleasant

// deterministic Y positions (do not depend on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- layout that responds to window width (manual, no FlowLayout) ------------
computeAndApplyLayout = {
    var innerWidth, currentMeterWidth, frameWidth, frameHeight;

    // NOTE: keep vertical metrics fixed; stretch horizontally
    innerWidth = windowRef.bounds.width - (paddingX * 2);
    currentMeterWidth = (innerWidth - (labelWidth + 8)).clip(minMeterWidth, maxMeterWidth);

    frameWidth  = (labelWidth + 8 + currentMeterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, currentMeterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, currentMeterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, currentMeterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, currentMeterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with a reasonable initial width; height from fixed metrics
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + minMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A section
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B section
    + paddingY
);

// NOTE: resizable=true, border=true -> proper title + resizeable window
windowRef = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.5)", windowRect, true, true);

// HUD label
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10)); // will be set by computeAndApplyLayout
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels…";

// Frame + section titles + bars (create; exact bounds set in computeAndApplyLayout)
meterFrameView = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string = "Chain A";
chainALabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string  = "A-L";
barViewALeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelLeft });
chainALabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string = "A-R";
barViewARight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayALevelRight });

chainBTitleLabel = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string = "Chain B";
chainBLabelLeft  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string  = "B-L";
barViewBLeft     = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelLeft });
chainBLabelRight = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string = "B-R";
barViewBRight    = makeBarView.value(windowRef, 0, 0, { minMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker will keep it current on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd
// v0.4.6
// MD 2025-09-25 17:10 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable layout similar to yesterday’s GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002); if both are effectively zero, mirror test(1001) for demo fallback.
- Window is RESIZABLE; bars stretch horizontally and ALWAYS fit within the content area
  (no FlowLayout; manual top-left anchored layout on AppClock).

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; fixed vertical metrics.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap;
var headerHeight, sectionTitleHeight, barHeight, labelWidth, defaultMeterWidth;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var hudLabel;
var meterFrameView;
var chainATitleLabel, chainALabelLeft, chainALabelRight, barViewALeft, barViewARight;
var chainBTitleLabel, chainBLabelLeft, chainBLabelRight, barViewBLeft, barViewBRight;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var makeFrameView, makeBarView, drawSectionFrames, readLevelsAndUpdateDisplay;
var startTicker, stopTicker, tickerFlag;
var identityBanner;
var computeAndApplyLayout, lastWindowWidth, lastWindowHeight;
var chainATitleY, chainABar1Y, chainABar2Y, chainBTitleY, chainBBar1Y, chainBBar2Y;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_AB_Styled_v0.4.6.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // if sum(A+B) <= threshold, mirror test(1001)
uiGamma = 1.0;               // 1.0=linear; 0.7..0.5 boosts low-level visibility

// layout constants (fixed vertical metrics; match “yesterday” proportions)
paddingX = 12; paddingY = 10;
rowGap = 10;
headerHeight = 22;
sectionTitleHeight = 16;
barHeight = 14;

// horizontal metrics
labelWidth = 100;           // readable label width (yesterday’s GUI was ~72–100)
defaultMeterWidth = 340;    // comfortable default; will stretch or shrink to fit

// deterministic Y positions (no dependency on other views)
chainATitleY = paddingY + headerHeight + rowGap + 6;
chainABar1Y  = chainATitleY + sectionTitleHeight + rowGap;
chainABar2Y  = chainABar1Y + barHeight + rowGap;

chainBTitleY = chainATitleY + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap;
chainBBar1Y  = chainBTitleY + sectionTitleHeight + rowGap;
chainBBar2Y  = chainBBar1Y + barHeight + rowGap;

// init levels
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg winItem;
        var windowName;
        windowName = winItem.tryPerform(\name);
        windowName.notNil and: { windowName.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg winItem; winItem.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makeFrameView = { arg parentView, frameRect;
    var userView;
    userView = UserView(parentView, frameRect);
    userView.background_(Color(0.95,0.95,0.95));
    userView.drawFunc = { arg uv;
        var bounds;
        bounds = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

makeBarView = { arg parentView, left, top, widthGetterFunc, levelGetterFunc;
    var userView;
    userView = UserView(parentView, Rect(left, top, widthGetterFunc.value, barHeight));
    userView.background_(Color(0.92, 0.92, 0.92));
    userView.drawFunc = { arg uv;
        var bounds, raw, scaled;
        bounds = uv.bounds;
        raw = levelGetterFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, bounds.width, bounds.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, bounds.width * scaled, bounds.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, bounds.width-1, bounds.height-1));
    };
    userView
};

drawSectionFrames = { arg uv;
    var bounds, sectionHeight, aBoxTop, bBoxTop;
    bounds = uv.bounds;
    sectionHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionHeight + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, bounds.width-16, sectionHeight)); Pen.stroke;
};

readLevelsAndUpdateDisplay = {
    var aVals, bVals, tVals, sumAB, sumT, hudTextString;
    levelsDict = (~md_levelsById ? levelsDict);

    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // HUD with fine precision
    hudTextString =
        "A[" ++ chainALevelLeft.round(0.001) ++ "," ++ chainALevelRight.round(0.001) ++ "]  " ++
        "B[" ++ chainBLevelLeft.round(0.001) ++ "," ++ chainBLevelRight.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        hudTextString = hudTextString ++ "  (fallback: test " ++ [testLevelLeft.round(0.001), testLevelRight.round(0.001)] ++ ")";
    };
    hudLabel.string = "HUD: " ++ hudTextString;
};

// --- responsive layout (bars always fit horizontally) -----------------------
computeAndApplyLayout = {
    var interiorWidth, meterWidth, frameWidth, frameHeight;

    // Keep vertical metrics fixed; stretch/shrink horizontally to ALWAYS fit
    interiorWidth = windowRef.bounds.width - (paddingX * 2);
    meterWidth = (interiorWidth - (labelWidth + 8)).max(40); // lower bound only; never off-screen
    frameWidth  = (labelWidth + 8 + meterWidth);
    frameHeight = (sectionTitleHeight + rowGap + (2*barHeight) + rowGap) + rowGap
                + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap);

    // HUD
    hudLabel.bounds = Rect(paddingX, paddingY, frameWidth, headerHeight);

    // Frame area
    meterFrameView.bounds = Rect(
        paddingX,
        paddingY + headerHeight + rowGap,
        frameWidth,
        frameHeight
    );

    // Chain A
    chainATitleLabel.bounds = Rect(paddingX + 8,  chainATitleY, 120, sectionTitleHeight);
    chainALabelLeft.bounds  = Rect(paddingX + 16, chainABar1Y, labelWidth, barHeight);
    barViewALeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainABar1Y, meterWidth, barHeight);

    chainALabelRight.bounds = Rect(paddingX + 16, chainABar2Y, labelWidth, barHeight);
    barViewARight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainABar2Y, meterWidth, barHeight);

    // Chain B
    chainBTitleLabel.bounds = Rect(paddingX + 8,  chainBTitleY, 120, sectionTitleHeight);
    chainBLabelLeft.bounds  = Rect(paddingX + 16, chainBBar1Y, labelWidth, barHeight);
    barViewBLeft.bounds     = Rect(paddingX + 16 + labelWidth + 8, chainBBar1Y, meterWidth, barHeight);

    chainBLabelRight.bounds = Rect(paddingX + 16, chainBBar2Y, labelWidth, barHeight);
    barViewBRight.bounds    = Rect(paddingX + 16 + labelWidth + 8, chainBBar2Y, meterWidth, barHeight);
};

startTicker = {
    var periodSeconds, stepFunc;
    periodSeconds = 1.0 / framesPerSecond;
    lastWindowWidth  = windowRef.bounds.width;
    lastWindowHeight = windowRef.bounds.height;

    stepFunc = {
        var w, h;
        readLevelsAndUpdateDisplay.value;

        // re-layout on window size change
        w = windowRef.bounds.width;
        h = windowRef.bounds.height;
        if((w != lastWindowWidth) or: { h != lastWindowHeight }) {
            computeAndApplyLayout.value;
            lastWindowWidth = w;
            lastWindowHeight = h;
        };

        barViewALeft.refresh;  barViewARight.refresh;
        barViewBLeft.refresh;  barViewBRight.refresh;
        meterFrameView.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = {
    tickerFlag = nil;
};

// --- window + initial layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Start with proportions like yesterday’s GUI (fits on first open)
windowRect = Rect(
    60, 60,
    paddingX + (labelWidth + 8 + defaultMeterWidth) + paddingX,
    paddingY + headerHeight + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // A
    + rowGap
    + (sectionTitleHeight + rowGap + (2*barHeight) + rowGap)   // B
    + paddingY
);

// resizable=true, border=true -> proper title + resizable window
windowRef = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.6)", windowRect, true, true);

// HUD label (bounds set by computeAndApplyLayout)
hudLabel = StaticText(windowRef, Rect(0, 0, 10, 10));
hudLabel.stringColor = Color.black;
hudLabel.string = "HUD: waiting for levels…";

// Frame + section titles + bars (create once; bounds set in computeAndApplyLayout)
meterFrameView    = makeFrameView.value(windowRef, Rect(0,0,10,10));
meterFrameView.drawFunc = { arg uv; drawSectionFrames.value(uv) };

chainATitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainATitleLabel.string  = "Chain A";
chainALabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainALabelLeft.string   = "A-L";
barViewALeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelLeft });
chainALabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainALabelRight.string  = "A-R";
barViewARight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayALevelRight });

chainBTitleLabel  = StaticText(windowRef, Rect(0,0,10,10));  chainBTitleLabel.string  = "Chain B";
chainBLabelLeft   = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelLeft.string   = "B-L";
barViewBLeft      = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelLeft });
chainBLabelRight  = StaticText(windowRef, Rect(0,0,10,10));  chainBLabelRight.string  = "B-R";
barViewBRight     = makeBarView.value(windowRef, 0, 0, { defaultMeterWidth }, { displayBLevelRight });

// Apply initial layout (then ticker keeps it updated on resize)
computeAndApplyLayout.value;

// Run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.10.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.10.scd
// v0.3.10
// MD 2025-09-25 15:48 BST

/*
Purpose
- Single window "MagicDisplayGUI ..." with 4 bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- If A/B are effectively silent, mirror test(1001) into the bars (visual fallback) for the demo.
- HUD top-left; AppClock ticker ~30 Hz; fixed rects; single-window policy.

Style
- var-first in every block; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC API only; final expression -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var dAL=0.0, dAR=0.0, dBL=0.0, dBR=0.0; // displayed values after fallback logic
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;
var fallbackThreshold, uiGamma;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum below this = "effectively zero" for demo
uiGamma = 1.0;               // 1.0 = linear; you can set 0.5 for sqrt visual boost if needed

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI — A/B Meters (v0.3.10)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels…";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        // optional gamma for low-level visibility (uiGamma <= 1 boosts lows)
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { dAL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { dAR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { dBL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { dBR });

// read levels and compute display values with fallback
readLevels = {
    var a, b, t, sumAB, sumT, txt, showAL, showAR, showBL, showBR;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // Fallback rule: if both A and B effectively zero, mirror test into both A and B displays
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        showAL = tL; showAR = tR;
        showBL = tL; showBR = tR;
    } {
        showAL = aL; showAR = aR;
        showBL = bL; showBR = bR;
    };

    dAL = showAL.clip(0, 1);
    dAR = showAR.clip(0, 1);
    dBL = showBL.clip(0, 1);
    dBR = showBR.clip(0, 1);

    // HUD with finer precision so quiet values are visible
    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.7.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window with FOUR meters:
       A-L, A-R (replyID 2001), B-L, B-R (replyID 2002)
     and fall back to the default test probe (replyID 1001) if A/B not attached.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        labelA, aLeft, aRight, aDbL, aDbR,
        labelB, bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight;

    titleString = "MagicDisplayGUI — A/B Window (v0.3.7)";

    window = Window.new(titleString, Rect(60, 60, 560, 260), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // A section
    labelA = StaticText(content, Rect(16, 12, 240, 22));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    // B section
    labelB = StaticText(content, Rect(292, 12, 240, 22));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    barWidth = 26;
    barHeight = 160;

    // A meters
    aLeft  = LevelIndicator(content, Rect(40,  44, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    aLeft.warning = (-6).dbamp; aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(32, 210, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(92, 210, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(316, 44, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(376, 44, barWidth, barHeight));
    bLeft.warning = (-6).dbamp; bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(308, 210, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(368, 210, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age
    statusA = StaticText(content, Rect(180, 44, 100, 18));
    statusA.string = "A rx: —";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, 44, 100, 18));
    statusB.string = "B rx: —";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // test controls (optional)
    startButton = Button(content, Rect(180, 80, 100, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    stopButton = Button(content, Rect(180, 114, 100, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbL, aDbR, bDbL, bDbR,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbL = ampToDbString.value(aL);
            aDbR = ampToDbString.value(aR);
            bDbL = ampToDbString.value(bL);
            bDbR = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbL; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbR; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbL; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbR; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.8.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.8.scd
// v0.3.8
// MD 2025-09-25 15:10 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001); B-L, B-R (replyID 2002).
- HUD at top-left; AppClock ticker ~30 Hz; fallback to test (1001) if A/B absent.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).
Style
- var-first; AppClock only; fixed rects (no FlowLayout); no non-local returns.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver, w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = { ~md_levelsById ? IdentityDictionary.new }!(); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var have;
    have = (OSCdef(\md_levels) !? { true }) ? false; // just to probe
    ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } // idempotent
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI — A/B Meters (v0.3.8)", rect, false, false);
w.alwaysOnTop_(false);

w.drawFunc = { }; // no background drawing; keep it simple

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels…";

// Row helpers
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

makeBars = { arg left, top;
    var v;
    v = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var b, vNorm;
        b = uv.bounds;
        // caller sets a closure to draw current level (0..1)
        vNorm = uv.userCanDraw.value(uv);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm.clip(0,1), b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)));
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)));
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)));
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)));

viewAL.userCanDraw = { arg v; aL };
viewAR.userCanDraw = { arg v; aR };
viewBL.userCanDraw = { arg v; bL };
viewBR.userCanDraw = { arg v; bR };

// read levels (with fallback to test=1001 if A/B missing)
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    // update 4 numbers
    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];

    // HUD line
    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";
    // Fallback annotate if both A/B are zeros but test moves
    if((aL+aR+bL+bR) <= 0.0001 && (t[0]+t[1]) > 0.0, {
        txt = txt ++ "  (fallback: test " ++ t.collect(_.round(0.01)) ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, go;
    period = 1.0 / fps;
    go = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { ticker !? { go.value } });
        nil
    };
    ticker = true;
    AppClock.sched(0.0, { go.value; nil });
};

killTicker = {
    ticker = nil;
};

// clean close
w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.9.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.9.scd
// v0.3.9
// MD 2025-09-25 15:34 BST

/*
Purpose
- Create one window titled "MagicDisplayGUI ..." with 4 horizontal bars:
  A-L, A-R (replyID 2001) and B-L, B-R (replyID 2002).
- HUD top-left; AppClock ticker ~30 Hz; fallback shows test(1001) hint if A/B are zero.
- Enforce single-window policy (close any existing MagicDisplayGUI* windows).

Style
- var-first in every block; descriptive lowercase names; AppClock only for GUI.
- Known-good SC syntax only; no custom slots on views; no server.sync.
- Final expression returns -> a Window.
*/

(
// === RUN ===
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, pad, barH, labelW, meterW, meterH, lineGap, makeBars;
var aL=0.0, aR=0.0, bL=0.0, bR=0.0, tL=0.0, tR=0.0;
var hud, lblAL, lblAR, lblBL, lblBR, viewAL, viewAR, viewBL, viewBR;
var ticker, makeTicker, killTicker, readLevels, fps, ids, dict;

fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new); // tolerate cold start

closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// layout constants
pad    = 10;
labelW = 72;
meterW = 340;
lineGap= 10;
barH   = 14;
meterH = barH;

closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

rect = Rect(60, 60, pad + labelW + 8 + meterW + pad, pad + 24 + (4*(barH+lineGap)) + pad);
w = Window("MagicDisplayGUI — A/B Meters (v0.3.9)", rect, false, false);
w.alwaysOnTop_(false);

// HUD
hud = StaticText(w, Rect(pad, pad, meterW + labelW, 20));
hud.stringColor = Color.black;
hud.string = "HUD: waiting for levels…";

// row labels
lblAL = StaticText(w, Rect(pad,           pad+30 + (0*(barH+lineGap)), labelW, barH)); lblAL.string = "A-L";
lblAR = StaticText(w, Rect(pad,           pad+30 + (1*(barH+lineGap)), labelW, barH)); lblAR.string = "A-R";
lblBL = StaticText(w, Rect(pad,           pad+30 + (2*(barH+lineGap)), labelW, barH)); lblBL.string = "B-L";
lblBR = StaticText(w, Rect(pad,           pad+30 + (3*(barH+lineGap)), labelW, barH)); lblBR.string = "B-R";

// Meter factory: pass a getter closure that the drawFunc will capture
makeBars = { arg left, top, getLevelFunc;
    var uv;
    uv = UserView(w, Rect(left, top, meterW, meterH)).background_(Color(0.92,0.92,0.92));
    uv.drawFunc = { arg v;
        var b, vNorm;
        b = v.bounds;
        vNorm = getLevelFunc.value.clip(0, 1);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * vNorm, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

viewAL = makeBars.value(pad + labelW + 8, pad+30 + (0*(barH+lineGap)), { aL });
viewAR = makeBars.value(pad + labelW + 8, pad+30 + (1*(barH+lineGap)), { aR });
viewBL = makeBars.value(pad + labelW + 8, pad+30 + (2*(barH+lineGap)), { bL });
viewBR = makeBars.value(pad + labelW + 8, pad+30 + (3*(barH+lineGap)), { bR });

// read levels from shared dict (set by /md/levels receiver)
// fallback shows test=1001 if both A and B sum to ~0
readLevels = {
    var a, b, t, txt;
    dict = (~md_levelsById ? dict);
    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    txt = "A[" ++ aL.round(0.01) ++ "," ++ aR.round(0.01) ++ "]  " ++
          "B[" ++ bL.round(0.01) ++ "," ++ bR.round(0.01) ++ "]";

    if(((aL+aR+bL+bR) <= 0.0001) and: { (tL+tR) > 0.0 }, {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.01), tR.round(0.01)] ++ ")";
    });
    hud.string = "HUD: " ++ txt;
};

// AppClock ticker
makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

w.onClose_({
    killTicker.value;
});

// run
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd
// v0.5.0
// MD 2025-09-25 17:35 BST

/*
Purpose
- Performance HUD window for live use (single, resizable "MagicDisplayGUI ..." window).
- Top row: Chain A (left) and Chain B (right) panels.
  * Active chain panel shows a green background (CURRENT inferred from Ndef.isPlaying).
  * Per-chain vertical meters (L/R) at each panel’s outer edge (A: left; B: right).
- Second row: full-width yellow status box (“system read” by default).
- Bottom-left: Choices pane (safe: reads CommandManager builder if present).
- Bottom-right: Messages/Next pane (safe: shows md/levels rate & last values; optional queued canonical).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- GUI uses AppClock only; no server.sync; avoids destructive operations.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var borderWidth, minTextWidth, minMeterWidth;
var headerString;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
var statusLabel;
var chainAPanel, chainBPanel, chainAMeterView, chainBMeterView;
var choicesTitle, choicesText, messagesTitle, messagesText;
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
var makePanelView, makeVerticalMeterView, drawVerticalMeters, setPanelActiveColor, setPanelNeutralColor;
var readLevelsAndUpdate, refreshChoicesFromBuilder, refreshMessages;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;
var identityBanner;

// === console identity (var-first ensured) ====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.0.scd";
identityBanner.postln;

// --- constants / state -------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B quiet, mirror test for display continuity (demo-safe)
uiGamma = 1.0;               // 1.0 linear; 0.7..0.5 boosts low levels

// layout metrics (tuned for iPad side-screen; adjust as needed)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 10;

topRowHeight    = 120;       // Chain A/B row height
statusRowHeight = 26;        // yellow status row
bottomRowHeight = 160;       // bottom panes row height
borderWidth     = 1;
minTextWidth    = 180;       // minimal inner text panel width per side
minMeterWidth   = 18;        // slim vertical meter (two bars drawn inside this view)

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;  testLevelRight  = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existing;
    existing = Window.allWindows.select({ arg w;
        var title;
        title = w.tryPerform(\name);
        title.notNil and: { title.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existing.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

// simple panel with border whose background we can recolor for "active"
makePanelView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.94,0.94,0.94)); // neutral; greener when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

// slim vertical meter container; draw two vertical bars (L/R)
makeVerticalMeterView = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        drawVerticalMeters.value(uv);
    };
    v
};

drawVerticalMeters = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    // A or B values are injected by caller through display* variables
    // Decide which pair to draw by reading a tag on the view name (set below)
    if(uv.name == \metersA) {
        leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    } {
        leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
        rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    };

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    // backgrounds
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    // dynamic fills (bottom-up)
    Pen.color = Color(0.20, 0.70, 0.20); // green-ish for visibility
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    // borders
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

setPanelActiveColor = { arg uv;
    uv.background = Color(0.86, 0.97, 0.86); // soft green for "active"
};

setPanelNeutralColor = { arg uv;
    uv.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // demo-safe fallback: if A/B are effectively zero but test is alive, mirror test
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // active chain (CURRENT) visual
    isAActive = Ndef(\chainA).isPlaying; // safe, non-blocking check
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil and: { chainBPanel.notNil }) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // lightweight HUD text
    statusLabel.string = "system read"; // change to "system ready" if you prefer
};

// bottom-left: print current navigation choices if CommandManager is present
refreshChoicesFromBuilder = {
    var haveSystem, cm, builder, lines, text;
    haveSystem = (~system.notNil);
    if(haveSystem.not) {
        text = "Choices:\n(n/a — no ~system)";
    } {
        cm = ~system.commandManager;
        builder = (cm.notNil).if({ cm.builder }, { nil });
        if(builder.notNil and: { builder.currentNode.notNil }) {
            lines = builder.currentNode.children.collect({ arg ch;
                ("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString)
            });
            text = "Choices:\n" ++ lines.join("\n");
        } {
            text = "Choices:\n(n/a — no builder or no node)";
        };
    };
    choicesText.string = text;
};

// bottom-right: last A/B values + optional canonical “next”
refreshMessages = {
    var cm, canonicalPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ",R=" ++ chainALevelRight.round(0.01) ++ "]  " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ",R=" ++ chainBLevelRight.round(0.01) ++ "]";
    cm = (~system.notNil).if({ ~system.commandManager }, { nil });
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        canonicalPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesText.string = base ++ "\nNext: " ++ canonicalPath.asString;
    } {
        messagesText.string = base;
    };
};

// --- layout ------------------------------------------------------------------
computeAndApplyLayout = {
    var w, h, contentW, contentH;
    var halfW, meterW, textW, panelY, statusY, bottomY;

    // guard window bounds
    w = windowRef.bounds.width; h = windowRef.bounds.height;
    if((w.isNumber.not) or: { h.isNumber.not }) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (w - (paddingX * 2)).max(320);
        contentH = (h - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + rowGap*3);

        halfW = ((contentW - columnGap) / 2).max(minTextWidth + minMeterWidth + 20);
        meterW = minMeterWidth;                    // fixed slim meter strip
        textW  = (halfW - meterW - 10).max(minTextWidth);

        // y anchors
        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // ---- Chain A (left) ----
        chainAPanel.bounds     = Rect(paddingX, panelY, halfW, topRowHeight);
        chainAMeterView.bounds = Rect(paddingX + 4, panelY + 8, meterW, topRowHeight - 16); // left edge (outer)
        // A text area (inside panel, to the right of meter) — if you later want chain text, add a StaticText here.

        // ---- Chain B (right) ----
        chainBPanel.bounds     = Rect(paddingX + halfW + columnGap, panelY, halfW, topRowHeight);
        chainBMeterView.bounds = Rect(paddingX + halfW + columnGap + halfW - 4 - meterW, panelY
===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd
// v0.5.1
// MD 2025-09-25 17:56 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI …").
- Top row: Chain A (left) and Chain B (right). The ACTIVE one is highlighted (soft green).
  • Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width yellow status row with "system ready".
- Bottom-left: Choices pane (safe; reads from ~system.commandManager.builder if present).
- Bottom-right: Messages / Next pane (safe; last A/B values and optional canonical next).
- Non-intrusive: reads /md/levels A=2001 B=2002 (fallback mirrors test=1001 when A/B quiet).

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt GUI only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

var chainAPanel, chainBPanel;
var meterViewBetweenA, meterViewBetweenB; // A's meters (at A right edge), B's meters (at B left edge)
var statusLabel;
var choicesTitleLabel, choicesTextView, messagesTitleLabel, messagesTextView;

var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

var makePanelView, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB;
var setPanelActiveColor, setPanelNeutralColor;

var readLevelsAndUpdate, refreshChoicesPane, refreshMessagesPane;
var computeAndApplyLayout, lastWidth, lastHeight;
var startTicker, stopTicker, tickerFlag;

var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.1.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;   // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;               // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (kept steady vertically for predictability on iPad)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight    = 124;       // Chain A/B row height
statusRowHeight = 26;        // "system ready" row
bottomRowHeight = 168;       // bottom panes row height

minPanelTextWidth = 220;     // minimal inner text area width per chain panel
meterStripWidth   = 18;      // width of each slim vertical meter (2 bars drawn inside)
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, rect;
    var panelView;
    panelView = UserView(parent, rect);
    panelView.background_(Color(0.94, 0.94, 0.94)); // neutral; will be greener when active
    panelView.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    panelView
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, rect;
    var v;
    v = UserView(parent, rect);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data refresh ------------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    statusLabel.string = "system ready";
};

// bottom-left: Choices (safe; optional)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a — no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " → " ++ nm) }, { nm });
            });
            s = "Choices:\n" ++ textLines.join($\n);
        } {
            s = "Choices:\n(n/a — no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// bottom-right: Messages / Next (safe; optional)
refreshMessagesPane = {
    var sysObj, cm, nextPath, base;
    base = "A[L=" ++ chainALevelLeft.round(0.01) ++ ", R=" ++ chainALevelRight.round(0.01) ++ "]   " ++
           "B[L=" ++ chainBLevelLeft.round(0.01) ++ ", R=" ++ chainBLevelRight.round(0.01) ++ "]";
    sysObj = ~system;
    cm = sysObj.tryPerform(\commandManager);
    if(cm.notNil and: { cm.respondsTo(\canonicalPathFromBuilder) }) {
        nextPath = cm.canonicalPathFromBuilder(cm.builder);
        messagesTextView.string = base ++ "\nNext: " ++ nextPath.asString;
    } {
        messagesTextView.string = base;
    };
};

// --- layout (always fit; meters between chains) ------------------------------
computeAndApplyLayout = {
    var winBounds, contentW, contentH;
    var halfW, panelY, statusY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;

    winBounds = windowRef.bounds;
    if(winBounds.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (winBounds.width - (paddingX * 2)).max(520);
        contentH = (winBounds.height - (paddingY * 2)).max(topRowHeight + statusRowHeight + bottomRowHeight + (rowGap*3));

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY  = paddingY;
        statusY = panelY + topRowHeight + rowGap;
        bottomY = statusY + statusRowHeight + rowGap;

        // panel bounds
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // meters BETWEEN chains
        meterY = panelY + 8;
        meterH = topRowHeight - 16;

        // A meters at RIGHT edge (inside A panel)
        meterAX = aX + aW - 8 - meterStripWidth;
        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);

        // B meters at LEFT edge (inside B panel)
        meterBX = bX + 8;
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // status row
        statusLabel.bounds = Rect(paddingX, statusY, contentW, statusRowHeight);
        statusLabel.background = Color(1.0, 0.95, 0.6); // yellow

        // bottom panes
        choicesTitleLabel.bounds  = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds    = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        messagesTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        messagesTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates ~5 Hz
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshMessagesPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- bring-up + construct ----------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// start with proportions that fit on first open
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 40,
    paddingY + topRowHeight + rowGap + statusRowHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI — Performance HUD (v0.5.1)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// status row
statusLabel = StaticText(windowRef, Rect(0,0,10,10));
statusLabel.stringColor = Color.black;
statusLabel.align = \left;

// bottom row
choicesTitleLabel   = StaticText(windowRef, Rect(0,0,10,10)); choicesTitleLabel.string = "Choices"; choicesTitleLabel.stringColor = Color.black;
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));  choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

messagesTitleLabel  = StaticText(windowRef, Rect(0,0,10,10)); messagesTitleLabel.string = "Messages / Next"; messagesTitleLabel.stringColor = Color.black;
messagesTextView    = TextView(windowRef, Rect(0,0,10,10));  messagesTextView.editable = false; messagesTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd
// v0.5.2
// MD 2025-09-25 18:12 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI ...").
- Top row: Chain A (left) and Chain B (right), EACH with a title. The ACTIVE chain is highlighted (soft green).
  • Vertical meters are BETWEEN the chains (to the right of A, to the left of B).
- Second row: full-width "System State" section (title + triple-height yellow panel, text "system ready").
- Bottom-left: "Choices" section (title + text).
- Bottom-right: "Processors" section (title + text; safe placeholder until you point me to the API).
- Non-intrusive: reads /md/levels (A=2001, B=2002); if A/B quiet, mirrors test=1001 for visual continuity.

Style
- var-first in every block/closure; descriptive lowercase names; known-good SC/Qt only.
- AppClock-only; no server.sync; avoids destructive server actions.
- Final expression returns -> a Window. Title starts with "MagicDisplayGUI".
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + layout metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, statusRowTitleHeight, statusRowBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth, panelBorder;

// ids + levels + render shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB; // A’s meters (right edge), B’s meters (left edge)

// status row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// state values
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitledLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// data + UI refresh
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;

// layout + ticker
var computeAndApplyLayout, lastWidth, lastHeight, startTicker, stopTicker, tickerFlag;

// identity banner
var identityBanner;

// === console identity (after var-first) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.2.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

// visual shaping
fallbackThreshold = 0.003;  // if A+B near zero, mirror test into display for demo continuity
uiGamma = 1.0;              // 1.0 linear; lower (0.7..0.5) visually boosts quiet levels

// layout metrics (steady verticals for iPad mirroring)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight          = 140; // Chain A/B panels
statusRowTitleHeight  = 18;  // "System State" title
statusRowBodyHeight   = 78;  // triple-height yellow body (≈3× a standard line)
bottomRowHeight       = 180; // Choices + Processors row

minPanelTextWidth = 220;     // min inner width per chain panel
meterStripWidth   = 18;      // slim vertical meter strip
panelBorder       = 1;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft   = 0.0; testLevelRight   = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var titleString;
        titleString = w.tryPerform(\name);
        titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94)); // neutral; turn soft green when active
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitledLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, barCount, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    barCount = 2;
    oneWidth = ((b.width - gap) / barCount).max(3);

    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);

    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);

    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;

    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;

    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil; // var-first placeholder
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView;
    panelView.background = Color(0.86, 0.97, 0.86);
};

setPanelNeutralColor = { arg panelView;
    panelView.background = Color(0.94, 0.94, 0.94);
};

// --- data + UI refresh -------------------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // fallback for demo continuity
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // visual active state (CURRENT)
    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // "System State" text (yellow panel)
    systemStateTextView.string = "system ready";
};

// "Choices" (safe placeholder; reads from ~system if present)
refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "Choices:\n(n/a — no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " → " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a — no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

// "Processors" (safe placeholder; wire up when you point me to the API)
refreshProcessorsPane = {
    var s;
    // TODO: replace with your chain processor query (e.g., ~system.listProcessors() or similar)
    s = "Processors:\n(A) …\n(B) …\n(Provide the method to query each chain’s processor list and I’ll wire it.)";
    processorsTextView.string = s;
};

// --- layout (titles added; meters between chains; System State 3× height) ---
computeAndApplyLayout = {
    var wb, contentW, contentH;
    var halfW, panelY, statusTitleY, statusBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleHeight;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        contentH = (wb.height - (paddingY * 2)).max(
            topRowHeight + rowGap +
            statusRowTitleHeight + statusRowBodyHeight + rowGap +
            bottomRowHeight
        );

        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        // y anchors
        panelY       = paddingY;
        statusTitleY = panelY + topRowHeight + rowGap;
        statusBodyY  = statusTitleY + statusRowTitleHeight + 4;
        bottomY      = statusBodyY + statusRowBodyHeight + rowGap;

        // panels A/B
        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        // titles inside panels (top-left)
        titleHeight = 16;
        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleHeight);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleHeight);

        // meter strips BETWEEN chains (inside panels near center gap)
        meterY = panelY + 8 + titleHeight + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;

        meterAX = aX + aW - 8 - meterStripWidth;          // right edge of A panel
        meterBX = bX + 8;                                  // left edge of B panel

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State section
        systemStateTitleLabel.bounds = Rect(paddingX, statusTitleY, contentW, statusRowTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, statusBodyY, contentW, statusRowBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6); // yellow

        // Bottom panes: Choices (L) and Processors (R)
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker ------------------------------------------------------------------
startTicker = {
    var periodSeconds, stepFunc, slowCounter;
    periodSeconds = 1.0 / framesPerSecond;
    lastWidth  = windowRef.bounds.width;
    lastHeight = windowRef.bounds.height;
    slowCounter = 0;

    stepFunc = {
        var w, h;
        readLevelsAndUpdate.value;

        // lighter updates at ~5 Hz for text panes
        slowCounter = slowCounter + 1;
        if(slowCounter >= (framesPerSecond / 5)) {
            refreshChoicesPane.value;
            refreshProcessorsPane.value;
            slowCounter = 0;
        };

        w = windowRef.bounds.width; h = windowRef.bounds.height;
        if((w != lastWidth) or: { h != lastHeight }) {
            computeAndApplyLayout.value;
            lastWidth = w; lastHeight = h;
        };

        meterViewBetweenA.refresh;
        meterViewBetweenB.refresh;

        AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
    };
    tickerFlag = true;
    AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    AppClock.sched(0.0, { stepFunc.value; nil });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + statusRowTitleHeight + statusRowBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI — Performance HUD (v0.5.2)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel   = makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel= makeTitledLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView  = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd
// v0.5.3
// MD 2025-09-25 18:45 BST

/*
Purpose
- Performance HUD window (single, resizable "MagicDisplayGUI …").
- Top row: "Chain A" (left) and "Chain B" (right). ACTIVE chain highlighted (soft green).
  • Vertical meters BETWEEN the chains (right of A, left of B).
- Second row: "System State" title + triple-height yellow panel with "system ready".
- Bottom-left: "Choices" (title + text).
- Bottom-right: "Processors" (title + text placeholder—wire once you provide API).
- Non-intrusive: reads /md/levels A=2001 B=2002; if A/B quiet, mirrors test=1001 to keep visuals moving.

Style
- var-first in every block/closure; descriptive lowercase names; AppClock-only; no server.sync.
- Known-good SC/Qt calls only. Final expression returns -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;

// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;

// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;

// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;

// system row views
var systemStateTitleLabel, systemStateTextView;

// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;

// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;

// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;

// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;

// identity banner
var identityBanner;

// === console identity (var-first ensured) =====================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.3.scd";
identityBanner.postln;

// --- constants/state ---------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);

fallbackThreshold = 0.003;  // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0;              // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap   = 8;
columnGap= 12;

topRowHeight      = 140;  // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight  = 78;   // ~triple height
bottomRowHeight   = 180;  // Choices + Processors

minPanelTextWidth = 220;
meterStripWidth   = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0;   testLevelRight = 0.0;

displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;

isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ---------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string = titleString;
    label.stringColor = Color.black;
    label.align = \left;
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0, b.height - leftH, oneWidth, leftH)); Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersA.value(uv);
    };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv;
        var dummy;
        dummy = nil;
        drawVerticalMetersB.value(uv);
    };
    v
};

setPanelActiveColor = { arg panelView; panelView.background = Color(0.86, 0.97, 0.86) };
setPanelNeutralColor = { arg panelView; panelView.background = Color(0.94, 0.94, 0.94) };

// --- data + UI refresh -------------------------------------------------------
/*readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    isAActive = Ndef(\chainA).isPlaying;
    isBActive = Ndef(\chainB).isPlaying;

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    systemStateTextView.string = "system ready";
};*/

readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;

    levelsDict = (~md_levelsById ? levelsDict);
    aVals = levelsDict[levelIds[\A]] ? [0.0, 0.0];
    bVals = levelsDict[levelIds[\B]] ? [0.0, 0.0];
    tVals = levelsDict[levelIds[\test]] ? [0.0, 0.0];

    chainALevelLeft  = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft  = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft    = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    // Keep demo visual continuity: mirror test if A/B effectively zero but test alive.
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    } {
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    // ACTIVE tint based on displayed energy (robust when both Ndefs are "playing")
    sumAEnergy = (displayALevelLeft + displayALevelRight);
    sumBEnergy = (displayBLevelLeft + displayBLevelRight);
    epsilon    = 0.001;

    isAActive = (sumAEnergy > sumBEnergy + epsilon);
    isBActive = (sumBEnergy > sumAEnergy + epsilon);

    if(chainAPanel.notNil) {
        if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) };
    };
    if(chainBPanel.notNil) {
        if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) };
    };

    // System State text + last /md/levels age (requires ~md_lastMsgStamp from bring-up)
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string = "system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)";
};


refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a — no ~system)";
    } {
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " → " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        } {
            s = "(n/a — no builder or no node)";
        };
    };
    choicesTextView.string = s;
};

refreshProcessorsPane = {
    var s;
    s = "Processors:\n(A) …\n(B) …\n(Provide the method to query each chain’s processor list; I’ll wire it.)";
    processorsTextView.string = s;
};

// --- layout (GUARDED; never writes nil Rect) ---------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    } {
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW = ((contentW - columnGap) / 2).max(minPanelTextWidth + meterStripWidth + 16);

        panelY       = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY      = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX;                  aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;

        titleH = 16;

        // Panels
        chainAPanel.bounds = Rect(aX, panelY, aW, topRowHeight);
        chainBPanel.bounds = Rect(bX, panelY, bW, topRowHeight);

        chainATitleLabel.bounds = Rect(aX + 8, panelY + 6, 120, titleH);
        chainBTitleLabel.bounds = Rect(bX + 8, panelY + 6, 120, titleH);

        // Meters between panels
        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth;        // A: right edge
        meterBX = bX + 8;                                // B: left edge

        meterViewBetweenA.bounds = Rect(meterAX, meterY, meterStripWidth, meterH);
        meterViewBetweenB.bounds = Rect(meterBX, meterY, meterStripWidth, meterH);

        // System State
        systemStateTitleLabel.bounds = Rect(paddingX, systemTitleY, contentW, systemTitleHeight);
        systemStateTextView.bounds   = Rect(paddingX, systemBodyY, contentW, systemBodyHeight);
        systemStateTextView.background = Color(1.0, 0.95, 0.6);

        // Bottom row
        choicesTitleLabel.bounds    = Rect(paddingX, bottomY, halfW, 16);
        choicesTextView.bounds      = Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20);

        processorsTitleLabel.bounds = Rect(paddingX + halfW + columnGap, bottomY, halfW, 16);
        processorsTextView.bounds   = Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20);
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ---------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    // Do a first layout AFTER all views exist and the window has bounds.
    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    // Start the periodic step slightly AFTER initial layout to avoid any race.
    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;

            // Re-layout only if size changed AND layout initialized
            if(layoutInitialized) {
                w = windowRef.bounds.width; h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };

            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;

            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = {
    tickerFlag = nil;
};

// --- construct + run ---------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// initial size (fits on first open)
windowRect = Rect(
    70, 70,
    paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
    paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI — Performance HUD (v0.5.3)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable = false; systemStateTextView.background = Color(1.0, 0.95, 0.6);
systemStateTextView.string = "system ready";

// bottom row
choicesTitleLabel     = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView       = TextView(windowRef, Rect(0,0,10,10)); choicesTextView.editable = false; choicesTextView.background = Color(0.97,0.97,0.97);

processorsTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView    = TextView(windowRef, Rect(0,0,10,10)); processorsTextView.editable = false; processorsTextView.background = Color(0.97,0.97,0.97);

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd  / v0.5.4-p1 (safe background) / MD 2025-09-28
//
// Purpose
// - Performance HUD window (single, resizable "MagicDisplayGUI …").
// - Same layout and features as v0.5.4, but with SAFE deferred background color
//   assignment for TextView widgets to avoid 'base_' on nil during early layout.
//
// Style
// - var-first in every block/closure; AppClock-only; no server.sync; known-good SC/Qt calls.
// - Final expression returns -> a Window.

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;
// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;
// system row views
var systemStateTitleLabel, systemStateTextView;
// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;
// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;
var safeSetBackground; // NEW: safe, deferred TextView background setter
// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;
// identity banner
var identityBanner;

// === console identity =========================================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ----------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003; // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0; // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap = 8;
columnGap= 12;
topRowHeight = 140;       // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight = 78;    // ~triple height
bottomRowHeight = 180;    // Choices + Processors
minPanelTextWidth = 220;
meterStripWidth = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0; testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;
isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ----------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

// NEW: safe, deferred setter for TextView backgrounds (prevents 'base_' on nil)
safeSetBackground = { |view, color, delay=0.03|
    AppClock.sched(delay, {
        if(view.notNil and: { view.isClosed.not }) {
            view.background_(color);
        };
        nil
    });
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersA.value(uv) };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersB.value(uv) };
    v
};

setPanelActiveColor  = { arg panelView;  panelView.background_(Color(0.86, 0.97, 0.86)) };
setPanelNeutralColor = { arg panelView;  panelView.background_(Color(0.94, 0.94, 0.94)) };

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
        .if({ arr }, { [0.0, 0.0] })
    };

    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    chainALevelLeft = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft   = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    }{
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    sumAEnergy = ((displayALevelLeft.isNumber.if({ displayALevelLeft }, { 0.0 })) +
                  (displayALevelRight.isNumber.if({ displayALevelRight }, { 0.0 })));
    sumBEnergy = ((displayBLevelLeft.isNumber.if({ displayBLevelLeft }, { 0.0 })) +
                  (displayBLevelRight.isNumber.if({ displayBLevelRight }, { 0.0 })));
    epsilon = 0.001;

    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // System State with last /md/levels age
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a — no ~system)";
    }{
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " → " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        }{
            s = "(n/a — no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });
    if(providerFunc.notNil) {
        s = providerFunc.value;
    }{
        s = "Processors / Queue:\n"
        ++ "(no provider)\n"
        ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
        ++ "Example (temporary):\n"
        ++ "~md_cmdTextProvider = {\n"
        ++ " var cm, next;\n"
        ++ " cm = (~system.tryPerform(\\commandManager));\n"
        ++ " next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
        ++ " .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
        ++ " \"Next: \" ++ next.asString\n"
        ++ "};";
    };
    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ----------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    }{
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW    = (((contentW - columnGap) / 2)).max(minPanelTextWidth + meterStripWidth + 16);
        panelY = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX; aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;
        titleH = 16;

        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));
        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth; // A: right edge
        meterBX = bX + 8; // B: left edge
        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));

        // SAFE: defer TextView background (prevents 'base_' on nil)
        safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));

        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));
        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ----------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;
            if(layoutInitialized) {
                w = windowRef.bounds.width;  h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };
            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;
            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ----------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Initial size (fits on first open)
windowRect = Rect(
  70, 70,
  paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
  paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// Resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI — Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
// SAFE: defer initial background too
safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel   = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
safeSetBackground.(choicesTextView,    Color(0.97,0.97,0.97));

processorsTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView   = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
safeSetBackground.(processorsTextView, Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.2.scd =====
// MagicDisplayGUI_New_Window_v0.3.2.scd
// v0.3.2
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call ~md_startTestSource / ~md_stopTestSource.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI — New Window (v0.3.2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.5.scd =====
// MagicDisplayGUI_New_Window_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call robust API (~md_startTestSource / ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI — New Window (v0.3.5)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;  // auto-heals routing if server rebooted
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_QuickPeek_Levels.scd =====
// MagicDisplayGUI_NewPath_QuickPeek_Levels.scd
// v0.1.0
// MD timestamp: 2025-09-25

/* Purpose
   - Print ~levels a few times to verify updates.
   - No top-level 'var'; local vars are inside the Routine function.

   Style
   - var-first inside the Routine; no non-local returns (^).
*/

~md_levelsPeek = Routine({
    var i;
    i = 0;
    12.do {
        ("~levels now: " ++ ~levels.asString).postln;
        0.25.wait;
    };
}).play(AppClock);

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd =====
// MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd
// v0.2.2
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall the /reply receiver for level updates with explicit recvPort.
   - Keep updating ~levels and record a heartbeat time (~md_lastLevelAt) for GUI status.
   - Non-invasive: does not touch groups/synths/busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; known-good SC syntax.
*/

(
var reinstallReceiver;

reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var tag, count, i, outArray;

            tag = msg[2];
            count = 0;
            i = 0;
            outArray = nil;

            if (tag == "/md/levels") {
                count = msg.size - 3;
                outArray = Array.newClear(count);
                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };
                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/reply',
        recvPort: NetAddr.langPort  // explicit
    );

    true;
};

"Reinstalling /reply receiver...".postln;
reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd =====
// MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd
// v0.2.4
// MD timestamp: 2025-09-25

/* Purpose
   - Bind OSC receiver to '/md/levels' (matches SendReply in the probe SynthDef).
   - Parse values at indices 3..end and update ~levels and ~md_lastLevelAt.
   - No top-level 'var' declarations to avoid parse errors.

   Style
   - var-first inside function bodies; no non-local returns (^).
   - descriptive lowercase variable names; known-good SC syntax.
*/

(
// remove any previous receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = Main.elapsedTime;

// Expected message from SendReply:
// [ '/md/levels', nodeID, replyID, val1, val2, ... ]
OSCdef(
    \md_levels,
    { |msg, time, addr, recvPort|
        var nodeId, replyId, count, i, outArray;

        nodeId = 0;
        replyId = 0;
        count = 0;
        i = 0;
        outArray = nil;

        if (msg.size >= 3) {
            nodeId = msg[1].asInteger;
            replyId = msg[2].asInteger;

            count = msg.size - 3;
            outArray = Array.newClear(count);

            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };

            ~levels = outArray;
            ~md_lastLevelAt = Main.elapsedTime;
        };
    },
    '/md/levels',
    recvPort: NetAddr.langPort
);
"Patch C installed: listening on /md/levels".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd =====
// MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd
// v0.2.1
// MD timestamp: 2025-09-25
/* Purpose
   - Cleanly (re)initialize the audio server tree, build a generated-only test signal path,
     and install a level probe that reports channel levels via /reply.
   - Publish public tilde helpers (~md_startTestSource, ~md_stopTestSource, ~md_cleanup) for GUI use.
   - Use compile-time channel counts (2ch) in SynthDefs.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; no server.sync; server ops wrapped in s.bind where relevant.
   - generated audio only; probe reads a private bus.
*/

(
var prepareServerAndDefs, setupRouting, installOscReceiver, definePublicAPI, startStartupSequence;

prepareServerAndDefs = {
    var ok;
    ok = true;

    s.waitForBoot({
        var def_testSource, def_toHardware2, def_levelProbe2;

        s.initTree;
        s.defaultGroup.freeAll;

        ~levels = [0.0, 0.0];

        // Test source: stereo beeps
        def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.20|
            var trig, freqSeq, sig, env, stereo;
            trig = Impulse.kr(2);
            freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
            env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
            sig = SinOsc.ar(freqSeq) * env;
            stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
            Out.ar(outBus, stereo * amp);
        }).add;

        // Relay to hardware (fixed 2ch)
        def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
            var sig;
            sig = In.ar(inBus, 2);
            Out.ar(0, sig);
        }).add;

        // Level probe (fixed 2ch) → /reply
        def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, sendID = 1001|
            var sig, amps, ticker;
            sig = In.ar(inBus, 2);
            amps = Amplitude.kr(sig, 0.01, 0.30);
            ticker = Impulse.kr(20);
            SendReply.kr(ticker, "/md/levels", amps, sendID);
        }).add;
    });

    ok;
};

setupRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        ~md_mixBus = Bus.audio(s, 2);

        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \sendID, 1001]);

        ~md_testSynth = nil;
    });

    ok;
};

installOscReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];

    OSCdef(\md_levels, { |msg, time, addr, recvPort|
        var tag, count, i, outArray;

        tag = msg[2];
        count = 0;
        i = 0;
        outArray = nil;

        if (tag == "/md/levels") {
            count = msg.size - 3;
            outArray = Array.newClear(count);
            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };
            ~levels = outArray;
        };
    }, '/reply');

    true;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_startTestSource = {
        var ok2;
        ok2 = true;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.20]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        if (~md_probe.notNil) {
            ~md_probe.free;
            ~md_probe = nil;
        };

        if (~md_toHardware.notNil) {
            ~md_toHardware.free;
            ~md_toHardware = nil;
        };

        if (~md_outGroup.notNil) {
            ~md_outGroup.free;
            ~md_outGroup = nil;
        };
        if (~md_meterGroup.notNil) {
            ~md_meterGroup.free;
            ~md_meterGroup = nil;
        };
        if (~md_srcGroup.notNil) {
            ~md_srcGroup.free;
            ~md_srcGroup = nil;
        };

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        s.defaultGroup.freeAll;

        ok2;
    };

    ok;
};

startStartupSequence = {
    var ok;

    ok = true;

    "Step 1: preparing server + defs...".postln;
    prepareServerAndDefs.value;

    "Step 1: setting up routing (bus, groups, probe)...".postln;
    setupRouting.value;

    "Step 1: installing OSC receiver...".postln;
    installOscReceiver.value;

    // ✅ Publish the API so Step 2 can call it
    "Step 1: defining public API...".postln;
    definePublicAPI.value;

    "Step 1: ready. Use ~md_startTestSource.value to begin audio.".postln;

    ok;
};

// ---------- run ----------
startStartupSequence.value;

// Tips:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd =====
// MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd
// v0.2.3
// MD timestamp: 2025-09-25

/* Purpose
   - Add a status label showing seconds since last level message ('rx age').
   - Helps confirm receiver is live.

   Style
   - var-first inside function bodies; no non-local returns (^).
*/

(
if (~mdGui_window.notNil) {
    var content, statusLabel;

    content = ~mdGui_window.view;

    statusLabel = StaticText(content, Rect(200, 120, 180, 18));
    statusLabel.string = "rx age: —";
    statusLabel.stringColor = Color.gray(0.85);
    statusLabel.background = Color.clear;
    statusLabel.align = \left;

    ~mdGui_status = statusLabel;

    // start an AppClock updater (store it so we can stop later)
    ~mdGui_statusTicker = Routine({
        var running, age, lastAt;

        running = true;
        while { running } {
            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_status.notNil) {
                ~mdGui_status.string = "rx age: " ++ age.asString ++ " s";
            };

            0.2.yield;
            running = (~mdGui_window.notNil);
        };
    }).play(AppClock);

    "Status label installed.".postln;
} {
    "Open the MagicDisplayGUI window first, then run this patch.".postln;
};
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd =====
// MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd
// v0.2.0
// MD timestamp: 2025-09-25
/* Purpose
   - Build a robust single-window GUI that follows the window patterns you used in MagicPedalboard-WindowDisplayExamples:
     * one window whose name starts with "MagicDisplayGUI"
     * no FlowLayout
     * AppClock-only refresh loop
     * LevelIndicators for meters
   - Buttons call the public Step 1 tilde helpers (~md_startTestSource, ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; LevelIndicator values in [0..1].
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString, levelLeft, levelRight, labelLeft, labelRight, labelTitle, buttonRowY, startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI — New Path (Step 2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // title
    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    // level bars
    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    // db readouts
    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    // control buttons (call Step 1 helpers if present)
    buttonRowY = 44;

    startButton = Button(content, Rect(200, buttonRowY, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, buttonRowY + 36, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    // store references for the ticker
    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30; // ~30 Hz

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) {
                ~mdGui_levelLeft.value = leftVal;
            };
            if (~mdGui_levelRight.notNil) {
                ~mdGui_levelRight.value = rightVal;
            };
            if (~mdGui_labelLeft.notNil) {
                ~mdGui_labelLeft.string = leftDb;
            };
            if (~mdGui_labelRight.notNil) {
                ~mdGui_labelRight.string = rightDb;
            };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) {
        ~mdGui_window.close;
        ~mdGui_window = nil;
    };
    ok;
};

// ---------- run ----------
mdGuiOpen.value;

// Later: mdGuiClose.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd =====
// MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Trace /md/levels briefly and then print active replyIDs with current values.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^).
*/

(
var postStatus;

"=== RUN MagicDisplayGUI_OSC_TraceAndReport_v0.3.11 ===".postln;

postStatus = {
    var keys, msg;
    keys = if (~md_levelsById.notNil) { ~md_levelsById.keys.asArray.sort } { [] };
    msg = "Active replyIDs: " ++ keys.asString;
    msg.postln;
    if (~md_levelsById.notNil) {
        if (~md_levelsById[2001].notNil) { ("A (2001): " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B (2002): " ++ ~md_levelsById[2002].asString).postln; };
        if (~md_levelsById[1001].notNil) { ("Test (1001): " ++ ~md_levelsById[1001].asString).postln; };
    };
};

OSCFunc.trace(true);
AppClock.sched(1.0, {
    var ok;
    ok = true;
    OSCFunc.trace(false);
    postStatus.value;
    ok;
});
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd =====
// MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Replace ~md_ensureRouting with a NON-DESTRUCTIVE version:
     * does NOT call s.defaultGroup.freeAll
     * only creates/repairs OUR groups/bus/probes if missing or not playing
   - Keeps your Ndefs and any other nodes intact.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var safeEnsure;

("MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd").postln;

safeEnsure = {
    var ok, needBus, needGroups, needRelay, needProbe, defaultGroup;

    ok = true;

    if (s.serverRunning.not) {
        s.boot;
        s.waitForBoot({
            var ok2;
            ok2 = true;
            s.initTree;
            ok2;
        });
    };

    defaultGroup = s.defaultGroup;

    // bus
    needBus = (~md_mixBus.isNil);

    // groups
    needGroups = (
        ~md_srcGroup.isNil or: { ~md_meterGroup.isNil } or: { ~md_outGroup.isNil } or: {
            (~md_srcGroup.notNil and: { ~md_srcGroup.isPlaying.not })
            or: (~md_meterGroup.notNil and: { ~md_meterGroup.isPlaying.not })
            or: (~md_outGroup.notNil and: { ~md_outGroup.isPlaying.not })
        }
    );

    // relay + default probe
    needRelay = (~md_toHardware.isNil or: { ~md_toHardware.isPlaying.not });
    needProbe = (~md_probe.isNil or: { ~md_probe.isPlaying.not });

    s.bind({
        // bus
        if (needBus) {
            if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };
            ~md_mixBus = Bus.audio(s, 2);
        };

        // groups in strict order
        if (needGroups) {
            if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
            if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
            if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

            ~md_srcGroup = Group.head(defaultGroup);
            ~md_meterGroup = Group.after(~md_srcGroup);
            ~md_outGroup = Group.after(~md_meterGroup);

            // force re-create relay/probe after new groups
            needRelay = true;
            needProbe = true;
        };

        if (needRelay) {
            if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };
            ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        };

        if (needProbe) {
            if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
            ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);
        };
    });

    ok;
};

// replace the old ensure with the safe one
~md_ensureRouting = {
    var ok;
    ok = true;
    safeEnsure.value;
    ok;
};

"Patched ~md_ensureRouting to be non-destructive.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd =====
// MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd
// v0.3.12
// MD timestamp: 2025-09-25

/* Purpose
   - Install .filter meters *inside* Ndef(\chainA) and Ndef(\chainB):
       * compute Amplitude.kr on the proxy signal
       * SendReply.kr directly to '/md/levels' with replyIDs 2001/2002
       * return the input signal unchanged (no audio change)
   - Neutralize any previous tap filters (bus mirroring) by overwriting them to identity.
   - Free any old external probe synths/busses used for taps; they are no longer needed.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables; known-good SC syntax.
*/

(
var hasA, hasB, attackTime, releaseTime, updateRateHz,
    installMeterFor, neutralizeTap, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_FilterMeters_v0.3.12 ===".postln;

hasA = (Ndef(\chainA).notNil);
hasB = (Ndef(\chainB).notNil);

attackTime = 0.01;
releaseTime = 0.30;
updateRateHz = 20;

// overwrite old bus-mirror taps to identity (safe if they don't exist)
neutralizeTap = { |name, key|
    var proxy, canFilter;
    proxy = Ndef(name);
    canFilter = false;
    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|  // identity pass-through
                var outSig;
                outSig = inputSig;
                outSig
            });
        };
    };
};

// install the actual meter filter (no bus, direct SendReply)
installMeterFor = { |name, replyID, key|
    var proxy, canFilter, ok;
    proxy = Ndef(name);
    canFilter = false;
    ok = true;

    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|
                var amps, ticker, outSig;
                amps = Amplitude.kr(inputSig, attackTime, releaseTime);
                ticker = Impulse.kr(updateRateHz);
                SendReply.kr(ticker, "/md/levels", amps, replyID);
                outSig = inputSig; // no audio change
                outSig
            });
            (("Installed meter on " ++ name.asString) ++ " (replyID " ++ replyID.asString ++ ").").postln;
        } {
            (name.asString ++ ": .filter not supported; skipped.").postln;
        };
    } {
        (name.asString ++ " not found; skipped.").postln;
    };

    ok;
};

// neutralize any prior tap keys used before (safe no-ops if absent)
neutralizeTap.value(\chainA, \mdProbeTapA);
neutralizeTap.value(\chainB, \mdProbeTapB);

// install in-proxy meters (distinct keys so they are idempotent)
if (hasA) { installMeterFor.value(\chainA, 2001, \mdMeterA); };
if (hasB) { installMeterFor.value(\chainB, 2002, \mdMeterB); };

// free old external probe synths/busses (from the tap approach)
freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

freeIfPlaying.value(~md_probeA);  ~md_probeA = nil;
freeIfPlaying.value(~md_probeB);  ~md_probeB = nil;

if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

"Installed in-proxy meters; removed external probes/tap busses.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.10.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Make A/B meters move reliably by reinstating .filter taps on Ndef(\chainA/\chainB).
   - Mirror audio to private stereo busses, then attach A(2001)/B(2002) probes to those busses.
   - Non-destructive: does not modify chain sound; taps return 'in'.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, haveA, haveB, tapBusA, tapBusB;

("MagicDisplayGUI_Reenable_Taps_v0.3.10.scd").postln;

ok = true;
haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

// (re)allocate private tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// install/overwrite taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes to tap busses (free stale ones first)
s.bind({
    if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
    if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
    };
});

("A probe -> inBus " ++ tapBusA.asString).postln;
("B probe -> inBus " ++ tapBusB.asString).postln;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.11.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall .filter taps on Ndef(\chainA/\chainB) to mirror audio to private 2ch busses.
   - Attach probes A(2001) and B(2002) to those busses.
   - Quiet stale frees; print nodeIDs of created probes.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables.
*/

(
var haveA, haveB, tapBusA, tapBusB, newProbeA, newProbeB, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_Taps_v0.3.11 ===".postln;

haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

// fresh tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// (re)install taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes (free stale ones only if playing)
s.bind({
    freeIfPlaying.value(~md_probeA);
    ~md_probeA = nil;

    freeIfPlaying.value(~md_probeB);
    ~md_probeB = nil;

    newProbeA = nil;
    newProbeB = nil;

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
        newProbeA = ~md_probeA;
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
        newProbeB = ~md_probeB;
    };
});

if (newProbeA.notNil) { ("A probe nodeID: " ++ newProbeA.nodeID.asString).postln; } { "A probe not created.".postln; };
if (newProbeB.notNil) { ("B probe nodeID: " ++ newProbeB.nodeID.asString).postln; } { "B probe not created.".postln; };

"Re-enable taps: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_ResetReceiver_v0.3.11.scd =====
// MagicDisplayGUI_ResetReceiver_v0.3.11.scd
// v0.3.11
// MD 2025-09-25 15:10 BST

/*
Purpose
- Reinstall the /md/levels receiver on NetAddr.langPort (idempotent).
- Posts identity banner so logs show exact order of actions.
Style
- var-first; no server.sync; returns -> true.
*/

(
// === RUN ===
var ok, dict;
dict = (~md_levelsById ? IdentityDictionary.new);
~md_levelsById = dict;
ok = ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } ? false;
("Receiver reset: " ++ ok).postln;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd
// v0.3.8
// MD timestamp: 2025-09-25
/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if playing).
   - Attach A (replyID 2001) and B (replyID 2002) probes directly to those busses.
   - Remove previously-installed .filter taps and free their private busses (if present).
   - Non-invasive: does not change your chain sound.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var detectBusIndex, aIdx, bIdx, ok, hadBringUp;

ok = true;
hadBringUp = (~md_attachProbesAB.notNil);

if (hadBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid if the proxy has produced output (ideally playing)
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // attach probes directly to A/B buses (even if one is -1, the helper skips it)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // remove taps if they exist (safe if none present)
    if (Ndef(\chainA).notNil) { Ndef(\chainA).removeFilter(\mdProbeTapA); };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).removeFilter(\mdProbeTapB); };

    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps removed (if present).".postln;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd
// v0.3.9
// MD timestamp: 2025-09-25

/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if present).
   - Ensure routing (bus/groups) exists even after a server reboot.
   - Attach A (2001) and B (2002) probes directly to those busses.
   - Neutralize any prior .filter taps (identity pass-through) and free their private busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, haveBringUp, detectBusIndex, aIdx, bIdx, neutralizeTap;

ok = true;
haveBringUp = (~md_attachProbesAB.notNil);

if (haveBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure routing exists (rebuilds groups/bus/probe if server rebooted)
    ~md_ensureRouting.value;

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus;   // valid when the proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    neutralizeTap = { |name, key|
        var proxy, canFilter;
        proxy = Ndef(name);
        canFilter = false;
        if (proxy.notNil) {
            canFilter = proxy.respondsTo(\filter);
            if (canFilter) {
                // Overwrite any existing tap with identity to stop extra Out.ar
                proxy.filter(key, { |in| in });
            };
        };
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // Attach probes directly (skips -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // Neutralize taps (works in all versions; no removeFilter needed)
    neutralizeTap.value(\chainA, \mdProbeTapA);
    neutralizeTap.value(\chainB, \mdProbeTapB);

    // Free the private tap busses if they exist
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps neutralized and tap busses freed.".postln;
};

ok;
)

===== MagicPedalboard/utils_mpb_force_reconnect.scd =====
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)

===== MagicPedalboard/WindowDisplayExamples/examplesSlidersButtons.scd =====
// examplesSlidersButtons.scd
// taken from Eli Fieldsteel book examples for chatper 8.

(
Window("Layout Management", Rect(100, 100, 250, 500)).front
.layout_(
	VLayout(
		HLayout(Knob(), Knob(), Knob(), Knob()),
		HLayout(Slider(), Slider(), Slider(), Slider()),
		Slider2D(),
		Button()
	)
);
)
===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes in GridLayout (3x2); top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, p;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

p = Array.newClear(6);

// ---------- factories ----------
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView();
    textColumn.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    pane
};

// ---------- build six panes (index 0 gets the meter) ----------
p[0] = makePaneWithMeter.(paneTitles[0], paneColors[0]); // top-left with meter
p[1] = makePane.(paneTitles[1], paneColors[1]);
p[2] = makePane.(paneTitles[2], paneColors[2]);
p[3] = makePane.(paneTitles[3], paneColors[3]);
p[4] = makePane.(paneTitles[4], paneColors[4]);
p[5] = makePane.(paneTitles[5], paneColors[5]);

// ---------- install grid 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with GridLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, paneArray;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build six panes ----------
paneArray = Array.newClear(6);
paneArray[0] = makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A); // top-left with meter A
paneArray[1] = makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B); // top-right with meter B
paneArray[2] = makeTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = makeTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = makeTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = makeTextPane.(paneTitles[5], paneBorderColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with two meters in the top row.
// - Meter A (top-left) is real (Ndef test source -> control bus); Meter B (top-right) is simulated.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterRoutine, serverBootRoutine;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI Grid + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build 3x2 grid: top row has meters ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"); // top-left real
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B"); // top-right simulated
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with 2 meters in the top row.
// - Audible test source (Ndef) plays; its amplitude steps in 10 dB increments every second.
// - Meters A and B both follow the same stepped level.
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0];
stepIntervalSeconds = 1.0;

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- assemble grid (top row has meters) ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A");
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B");
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- AUDIO bring-up (audible Ndef + stepped amplitude) ----------
serverBringUpRoutine = Routine({
    s.waitForBoot({
        var defaultNumChannels, leftFrequency, rightFrequency;
        defaultNumChannels = 2;
        s.initTree; s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\stepToneA, {
            var stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20, 20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30, 30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // smooth the steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            monoSignal    = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP meters + audible amplitude ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);

        { if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
          if(meterViewB.notNil, { meterViewB.value_(currentLinear) }); }.defer;

        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters.scd
// v0.3.1
// MD 2025-09-25 14:20
//
// Purpose / Style:
// - GUI-only: 6 panes in a GridLayout (3x2).
// - Top-left and top-right contain simulated meters (no audio).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makeTextPane, makeMeterPane, p;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

// returns [pane, meterView]
makeMeterPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    [pane, meterView]
};

// ---------- build six panes ----------
p = Array.newClear(6);
var pane, m;

#pane, m = makeMeterPane.(paneTitles[0], paneColors[0]); p[0] = pane; meterViewA = m; // top-left
#pane, m = makeMeterPane.(paneTitles[1], paneColors[1]); p[1] = pane; meterViewB = m; // top-right
p[2] = makeTextPane.(paneTitles[2], paneColors[2]);
p[3] = makeTextPane.(paneTitles[3], paneColors[3]);
p[4] = makeTextPane.(paneTitles[4], paneColors[4]);
p[5] = makeTextPane.(paneTitles[5], paneColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valA) });
            if(meterViewB.notNil, { meterViewB.value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_Grid.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_Grid.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: six colored panes arranged with GridLayout (3 rows x 2 columns).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles, makePane;
var p = Array.newClear(6);

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes GridLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

// ---------- styles ----------
titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView().background_(paneFill).minSize_(Size(500, 230));
    border = UserView(pane).resize_(1).drawFunc_({ |v|
        var rect; rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11,0.11,0.12); Pen.strokeColor = borderColor; Pen.width = 2;
        Pen.fillRect(rect); Pen.strokeRect(rect);
    });
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    pane.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane
};

// ---------- build array of six panes ----------
6.do({ |i| p[i] = makePane.(paneTitles[i], paneColors[i]) });

// ---------- grid layout: 3 rows × 2 columns ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));

window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_VH.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_VH.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: draw 6 "pane" rectangles (colored borders) arranged with VLayout/HLayout.
// - No audio, no Ndefs, no server. Pure Qt layout.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, row1, row2, row3, rootLayout;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes VHLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill  = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

// six distinct colors and titles
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory: a container with colored border and two text lines ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView()  // no parent yet; layout will parent it
        .background_(paneFill)
        .minSize_(Size(500, 230)); // give layout something decent to work with

    border = UserView(pane)
        .resize_(1)
        .drawFunc_({ |v|
            var rect;
            rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
            Pen.fillColor = Color(0.11, 0.11, 0.12);
            Pen.strokeColor = borderColor;
            Pen.width = 2;
            Pen.fillRect(rect);
            Pen.strokeRect(rect);
        });

    titleText = StaticText()
        .string_(titleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyText = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    // inner stack inside each pane (title above body)
    pane.layout_(VLayout(
        // top margin shim
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        // bottom stretch
        nil
    ));

    pane
};

// ---------- build six panes ----------
row1 = HLayout(
    makePane.(paneTitles[0], paneColors[0]),
    UserView().minWidth_(cellPadding), // spacer
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout: 3 rows stacked, with vertical spacers ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding), // top margin
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)  // bottom margin
);

// install the layout on the window
window.layout_(rootLayout);
window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter on the right side
makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left uses the meter) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0]), // top-left with meter
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        // simple sine-driven value with a hint of noise, clipped to [0,1]
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, rowTop, rowMiddle, rowBottom, rootLayout;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B (decides which global meterView to write)
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A), // top-left
    UserView().minWidth_(cellPadding),
    makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B)  // top-right
);

rowMiddle = HLayout(
    makeTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    makeTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with two meters in the top row.
// - Meter A (top-left) shows a real level from a tiny Ndef test source.
// - Meter B (top-right) is simulated (sine + noise) to verify GUI update path.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterRoutine;           // GUI meter widgets + updater
var serverBootRoutine;                               // guard: keep GUI responsive
var amplitudeBusA;                                   // control bus for real meter A
var meterLabelFont;                                  // tiny label above meters

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VH + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    paneView.layout_(VLayout(
        UserView().minHeight_(6),
        textColumnView,
        nil
    ));

    paneView
};

// Pane with meter and label (labelTextString = "A" or "B")
// Returns: the pane view; assigns meterViewA/meterViewB internally
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    meterLabelView = StaticText()
        .string_(labelTextString)
        .font_(meterLabelFont)
        .stringColor_(Color.white)
        .align_(\center);

    localMeterView = LevelIndicator()
        .warning_(0.7)
        .critical_(0.95)
        .minSize_(Size(20, 180));

    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });

    meterColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(4),
        meterLabelView,
        UserView().minHeight_(4),
        localMeterView,
        nil
    ));

    paneView.layout_(HLayout(
        UserView().minWidth_(6),
        textColumnView,
        UserView().minWidth_(10),
        meterColumnView,
        UserView().minWidth_(6)
    ));

    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"), // top-left: meter A (real)
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")  // top-right: meter B (simulated)
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);

window.layout_(rootLayout);
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    // 1) Boot + minimal server prep
    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        // 2) Control bus for meter A
        amplitudeBusA = Bus.control(s, 1);

        // 3) Tiny test source -> real meter A (no OutputProxy indexing; no server.sync)
        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue;
            var meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);   // language sets this before/around play
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        // set meter bus, then play quietly to out
        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    // 4) Update both meters on AppClock (A from control bus, B simulated)
    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            // real meter A (read from control bus written by Ndef)
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            // simulated meter B (sine + noise)
            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with 2 meters in the top row.
// - Audible test source (Ndef) plays a soft stereo tone whose amplitude
//   steps through dB values once per second (default: [-60,-50,...,0] dB).
// - Meters A and B show the same stepped level (so you hear the same step).
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0]; // edit as you like
stepIntervalSeconds = 1.0;                                // 1 second per step

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Pane with labeled meter ("A" or "B"); assigns to meterViewA / meterViewB
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top has two meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"),
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- AUDIO bring-up (small audible Ndef + AMP stepping) ----------
serverBringUpRoutine = Routine({
    var defaultNumChannels;
    s.waitForBoot({
        defaultNumChannels = 2;
        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        // Test source with controlled amplitude (stepped)
        Ndef(\stepToneA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            // slow-moving, gentle timbre
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // prevent clicks on level steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            // drive a meter bus so GUI can also poll (optional)
            monoSignal   = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP both meters + audible level every 1s ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);     // e.g. -60 .. 0 dB
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);     // convert to 0..1

        // update meters
        {
            if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
            if(meterViewB.notNil, { meterViewB.value_(currentLinear) });
        }.defer;

        // update audible amplitude
        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters.scd
// v0.3.0
// MD 2025-09-25 14:08
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right contain simulated meters.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterViews, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// store two meter views [A, B]
meterViews = Array.newClear(2);

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter; meterIndex: 0 for top-left (A), 1 for top-right (B)
makePaneWithMeter = { |titleString, borderColor, meterIndex|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterViews.put(meterIndex, meterView);

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left & top-right use meters) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0], 0), // top-left meter A
    UserView().minWidth_(cellPadding),
    makePaneWithMeter.(paneTitles[1], paneColors[1], 1)  // top-right meter B
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single AppClock routine for both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 1.2; // offset so A and B differ
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViews[0].notNil, { meterViews[0].value_(valA) });
            if(meterViews[1].notNil, { meterViews[1].value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MDMiniLogger/test_MDMiniLogger.scd =====
// test_MDMiniLogger.scd

m = MDMiniLogger.get;

m.setverbosity(0);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(1);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(2);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");


===== RulesForChatGPT-Copilot.scd =====
// RulesForChatGPT-Copilot.scd

/*
STYLE, SYNTAX & CODING RULES (STRICT)
- SuperCollider ONLY known‑good syntax. Do NOT invent methods or pseudo‑slots.
- Variable style: descriptive lowercase names; **var-first in EVERY block and closure** (do a second pass each time).
- No non‑local returns; no `try` or `protect` (not supported).
- No `server.sync`. Use `Server.default.bind` for server ops. `s.waitForBoot` is allowed in bring‑up only.
- GUI: AppClock ONLY; NO FlowLayout; fixed vertical metrics; top‑left anchored; resizable width with safe layout; single titled window (“MagicDisplayGUI …”).
- Windows MUST return **→ a Window** as final expression.
- Titles/headers: Every SC file starts with my standard header:
  - Line 1: `<file name>`
  - Line 2: `// vX.Y.Z`
  - Line 3: `// MD <YYYY-MM-DD HH:MM TZ>`
  - Blank line
  - `/* Purpose / Style */`
  - Then code.
- Do not use any “v6” labels (legacy).
- JITLib connect operator: **`Ndef(left) <<> Ndef(right)`** ONLY (never `<>` or `<<>>`).
- Sinks/processors read from `\in.ar(defaultNumChannels)`.
- Acceptance tests: generated audio only; NO SoundIn.

- ALWAYS do a second pass to check for variables after statements before showing me code.
*/
===== RunBook_20251002_Diagnostics_VARFIRST.scd =====
// RunBook_20251002_Diagnostics_1311.scd
// v1.0.0 — diagnostic-first bring-up for LPS (headless) + LPDisplay window
// MD 2025-10-02

/*
Purpose
- Give you a single, self-contained runbook to bring up LivePedalboardSystem (headless)
  while using the new LPDisplay Layout Test window as the UI.
- Add strong diagnostics you can see in the LPDisplay panes: system status, chain info,
  and received canonical commands.
- Provide safe toggles and probes: enable/disable LPDisplay’s demo sources, retap meters
  from LPS chain ends, insert a test tremolo on Chain A (audible), and refresh a HUD summary.
- Provide a robust canonical sender (~sendCanonicalPath) that tries multiple adapter entry
  points and falls back to a safe subset of pedalboard verbs if needed (never calls mpb.switch()).

Style
- var-first in every block/closure; lowercase descriptive names; no server.sync; no ^ returns.
- Server.default.bind for server operations; AppClock only for UI (none scheduled here).
- Single-window policy: closes prior LPDisplay/MagicDisplay windows on cleanup.
*/

//////////////////////////////////////////////////////
// 1) Preflight cleanup (safe, idempotent; no errors)
//////////////////////////////////////////////////////
(
var windowsToClose, demoOscKeys, demoNdefSymbols;

windowsToClose = Window.allWindows.select({ |oneWindow|
    var nameString;
    nameString = (oneWindow.tryPerform(\name) ? "").asString;
    nameString.beginsWith("MagicDisplayGUI") or: { nameString == "Layout Test" }
});
windowsToClose.do(_.close);

// Free LPDisplay demo responders (if they exist)
demoOscKeys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
demoOscKeys.do({ |keySym| var def;
    def = OSCdef(keySym);
    if (def.notNil) { def.free };
});

// Stop LPDisplay demo Ndefs (if present)
demoNdefSymbols = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
demoNdefSymbols.do({ |ndefName|
    var ndefRef;
    ndefRef = Ndef(ndefName);
    if (ndefRef.notNil) { ndefRef.stop };
});

// Remove any prior visualization taps we may have installed
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"✔ Cleanup done.".postln;
)

//////////////////////////////////////////////////////////
// 2) Open the LPDisplay window + install PANE HELPERS
//////////////////////////////////////////////////////////
(
var displayController, displayWindow;

// Controller + window (-> a Window titled "Layout Test")
displayController = LPDisplayLayoutTestWindow.new(nil);  // nil HUD => raw meters
displayWindow     = displayController.open;

// Mute LPDisplay’s own demo tail sources (we’ll retap from LPS)
displayController.setSourceA(\srcZ);
displayController.setSourceB(\srcZ);

// Optional: quiet console if your class has the gate
try { displayController.setConsoleLevelsOn(false) } { };

// Export handles
~inst = displayController;
~win  = displayWindow;

// ---- Pane helpers ----
~pane = { |paneKey, paneText|
    var okController, paneKeySymbol, paneTextString;
    okController   = (~inst.notNil) and: { ~inst.respondsTo(\sendPaneText) };
    paneKeySymbol  = paneKey.asSymbol;
    paneTextString = paneText.asString;
    if (okController) {
        ~inst.sendPaneText(paneKeySymbol, paneTextString)
    } {
        paneTextString.postln;  // fallback to console
    };
};

~paneAppend = { |paneKey, lineText|
    var textString;
    textString = lineText.asString;
    ~pane.(paneKey, textString);
};

~statusHUD = { |messageString|
    var msgString;
    msgString = "[HUD] " ++ messageString.asString;
    msgString.postln;
    ~pane.(\system, msgString);
};

// Initial HUD
~pane.(\diag,   "LPDisplay ready @ " ++ Date.getDate.stamp);
~pane.(\system, "System: waiting for LPS…");
~pane.(\left,   "A: (LPDisplay demo source muted)");
~pane.(\right,  "B: (LPDisplay demo source muted)");
~pane.(\choices,"—");
~pane.(\recv,   "—");

// Ready check
[ displayController.notNil, displayWindow.notNil, displayWindow.class ].postln;
"→ a Window".postln;
)

////////////////////////////////////////////////////////////
// 3) Bring up LivePedalboardSystem (headless) + HUD sanity
////////////////////////////////////////////////////////////
(
var liveSystem, sanityAssoc;

liveSystem = LivePedalboardSystem.new(nil);
liveSystem.ensureServerReady;
liveSystem.bringUpPedalboard;
liveSystem.bringUpCommandSystem;
liveSystem.installAdapterBridge;

~system = liveSystem;

"✔ LPS up (headless).".postln;
~statusHUD.("LPS up (headless)");

// Materialize 2‑ch busses (does not force play state)
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
});

// Show core boolean sanity in console AND pane:
sanityAssoc = (
    system: ~system.notNil,
    pedalboard: ~system.pedalboard.notNil,
    commandManager: ~system.commandManager.notNil
);
sanityAssoc.postln;
~pane.(\diag, ("Sanity: " ++ sanityAssoc).asString);
)

///////////////////////////////////////////////////////////////
// 4) Retap meters so LPDisplay follows LPS chain A/B (safe)
///////////////////////////////////////////////////////////////
(
var updateRateHz, oscStateAssoc;

updateRateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |inSignal|
            var stereoSignal, rmsPair, tick;
            stereoSignal = inSignal.isArray.if({ inSignal }, { [inSignal, inSignal] });
            rmsPair      = RMS.kr(stereoSignal, 500);
            tick         = Impulse.kr(updateRateHz);
            SendReply.kr(tick, "/peakrmsA",   [rmsPair[0], rmsPair[1]], 1);
            SendReply.kr(tick, "/rmsA_toGUI", [rmsPair[0], rmsPair[1]], 1);
            inSignal
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |inSignal|
            var stereoSignal, rmsPair, tick;
            stereoSignal = inSignal.isArray.if({ inSignal }, { [inSignal, inSignal] });
            rmsPair      = RMS.kr(stereoSignal, 500);
            tick         = Impulse.kr(updateRateHz);
            SendReply.kr(tick, "/peakrmsB",   [rmsPair[0], rmsPair[1]], 2);
            SendReply.kr(tick, "/rmsB_toGUI", [rmsPair[0], rmsPair[1]], 2);
            inSignal
        });
    };
});

"✔ LPDisplay retap installed.".postln;

// Confirm which responders are live
oscStateAssoc = (
    rmsA_toGUI:   OSCdef(\rmsA_toGUI).notNil,
    rmsB_toGUI:   OSCdef(\rmsB_toGUI).notNil,
    rmsA_console: OSCdef(\rmsA_console).notNil,
    rmsB_console: OSCdef(\rmsB_console).notNil
);
oscStateAssoc.postln;
~pane.(\diag, ("OSC responders: " ++ oscStateAssoc).asString);
)

///////////////////////////////////////////////////////
// 5) Diagnostic controls (pane writers, toggles, probes)
///////////////////////////////////////////////////////
(
var chainInfoString;

// A) Toggle LPDisplay’s INTERNAL demo sources (UI-only; does not touch LPS)
~lpDemo_on = {
    var ok;
    ok = (~inst.notNil);
    if (ok) {
        ~inst.setSourceA(\srcA);
        ~inst.setSourceB(\srcB);
    };
    ~pane.(\left,  "A: LPDisplay demo src = \\srcA");
    ~pane.(\right, "B: LPDisplay demo src = \\srcB");
    ~statusHUD.("LPDisplay demo sources ON");
};

~lpDemo_off = {
    var ok;
    ok = (~inst.notNil);
    if (ok) {
        ~inst.setSourceA(\srcZ);
        ~inst.setSourceB(\srcZ);
    };
    ~pane.(\left,  "A: LPDisplay demo src = \\srcZ (muted)");
    ~pane.(\right, "B: LPDisplay demo src = \\srcZ (muted)");
    ~statusHUD.("LPDisplay demo sources OFF");
};

// B) Chain probes (prints + panes)
~probeChains = {
    var aPlaying, bPlaying, busA, busB, summaryText;
    aPlaying    = Ndef(\chainA).isPlaying;
    bPlaying    = Ndef(\chainB).isPlaying;
    busA        = (Ndef(\chainA).bus ? \nil);
    busB        = (Ndef(\chainB).bus ? \nil);
    summaryText = "A playing=" ++ aPlaying ++ " bus=" ++ busA
        ++ " | B playing=" ++ bPlaying ++ " bus=" ++ busB;
    summaryText.postln;
    ~pane.(\system, "Chains — " ++ summaryText);
};

// C) Audible test insert/remove on chain A (tremolo) — safe pass-through
~diag_addTremA = {
    Server.default.bind({
        Ndef(\chainA).filter(\diag_tremA, { |inSignal|
            var lfo;
            lfo = LFTri.kr(1).range(0.25, 1.0);
            inSignal * lfo
        });
    });
    ~statusHUD.("Inserted test tremolo on chain A");
};

~diag_clearTrem = {
    Server.default.bind({
        if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\diag_tremA) };
    });
    ~statusHUD.("Cleared test tremolo on chain A");
};

// D) Try to describe chains via pedalboard API if present (best-effort)
~describeChains = {
    var pedalboardRef, leftText, rightText, canDescribe, canChainToString;

    pedalboardRef   = ~system.tryPerform(\pedalboard);
    leftText        = "A: (unknown)";
    rightText       = "B: (unknown)";
    canDescribe     = pedalboardRef.notNil and: { pedalboardRef.respondsTo(\describe) };
    canChainToString= pedalboardRef.notNil and: { pedalboardRef.respondsTo(\chainToString) };

    if (canDescribe) {
        leftText  = pedalboardRef.describe(\A);
        rightText = pedalboardRef.describe(\B);
    } {
        if (canChainToString) {
            leftText  = pedalboardRef.chainToString(\A);
            rightText = pedalboardRef.chainToString(\B);
        };
    };

    chainInfoString = "ChainDesc: " ++ leftText.asString ++ " | " ++ rightText.asString;
    chainInfoString.postln;
    ~pane.(\left,  leftText.asString);
    ~pane.(\right, rightText.asString);
};

// E) HUD refresh bundle
~refreshHUD = {
    ~probeChains.();
    ~describeChains.();
    ~pane.(\choices, "Nav helpers: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend");
};

"✔ Diagnostics installed. Use: ~lpDemo_on/off, ~probeChains, ~diag_addTremA, ~diag_clearTrem, ~describeChains, ~refreshHUD".postln;
)

/////////////////////////////////////////////////////////////
// 6) Inline emulator + robust canonical sender (no mpb.switch)
/////////////////////////////////////////////////////////////
(
var commandManagerRef, midiManagerRef, builderRef;
var buildLongPathFromBuilder, canonicalizePath, applyCanonicalPath, sendCanonicalPath;
var showChildrenList, navigateByName, navigateByFret;

// gather references (var-first)
commandManagerRef = ~system.commandManager;
midiManagerRef    = commandManagerRef.midiManager;
builderRef        = commandManagerRef.builder;

// Build long path (drop "root")
buildLongPathFromBuilder = {
    var nameList, filteredNames, builtPath;
    nameList      = builderRef.currentNode.getPathToRoot;     // ["root", ...]
    filteredNames = (nameList.size > 1).if({ nameList.copyRange(1, nameList.size-1) }, { [] });
    builtPath     = "/" ++ filteredNames.join("/");
    builtPath
};

// Map long -> short canonical
canonicalizePath = { |rawPath|
    var parts, firstToken, resultString;

    parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { resultString = rawPath.asString } {
        firstToken = parts[0].asString;

        // already-canonical verbs are pass-through
        if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstToken)) {
            resultString = "/" ++ parts.join("/");
        } {
            if (firstToken == "switch") {
                resultString = "/switch";
            } {
                if (firstToken == "chain") {
                    if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
                        resultString = "/add/" ++ parts.last.asString;
                    } {
                        if (parts.size >= 5
                            and: { parts[1] == "setsource" }
                            and: { parts[2] == "audio" }
                            and: { parts[3] == "source" }) {
                            resultString = "/setSource/" ++ parts.last.asString;
                        } {
                            resultString = rawPath.asString;
                        };
                    };
                } {
                    resultString = rawPath.asString;
                };
            };
        };
    };

    resultString
};

// Apply canonical via adapter bridge (robust; avoids mpb.switch name clash)
applyCanonicalPath = { |shortPath|
    var adapterAny, appliedFlag, pedalboardRef, tokenList, verbSymbol, argSymbol, didFallback;

    appliedFlag = false;

    // 1) System-level applyCanonicalPath
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath);
        appliedFlag = true;
    } {
        // 2) adapterBridge object with .applyPath ?
        adapterAny = ~system.tryPerform(\adapterBridge);
        if (adapterAny.notNil and: { adapterAny.respondsTo(\applyPath) }) {
            adapterAny.applyPath(shortPath);
            appliedFlag = true;
        } {
            // 3) Sometimes adapterBridge is a Function
            if (adapterAny.isKindOf(Function)) {
                adapterAny.value(shortPath);
                appliedFlag = true;
            } {
                // 4) Sometimes adapterBridge is a Symbol that names another entry point
                if (adapterAny.isKindOf(Symbol)) {
                    var maybeMethodName;
                    maybeMethodName = adapterAny.asSymbol; // attempt ~system.perform on that symbol
                    if (~system.respondsTo(maybeMethodName)) {
                        ~system.perform(maybeMethodName, shortPath);
                        appliedFlag = true;
                    };
                };
            };
        };
    };

    if (appliedFlag) {
        ("Adapter applied: " ++ shortPath).postln;
        ~pane.(\recv, "Applied: " ++ shortPath);
        true
    } {
        // Fallback: direct pedalboard verbs if exposed (safe subset only)
        pedalboardRef = ~system.tryPerform(\pedalboard);
        didFallback   = false;

        if (pedalboardRef.notNil) {
            tokenList = shortPath.asString.split($/).reject(_.isEmpty);
            verbSymbol = tokenList[0].asSymbol;
            argSymbol  = (tokenList.size > 1).if({ tokenList[1].asSymbol }, { nil });

            switch(verbSymbol,
                \add, {
                    if (pedalboardRef.respondsTo(\add) and: { argSymbol.notNil }) {
                        pedalboardRef.add(argSymbol); didFallback = true;
                    };
                },
                \bypass, {
                    if (pedalboardRef.respondsTo(\bypass) and: { argSymbol.notNil }) {
                        pedalboardRef.bypass(argSymbol); didFallback = true;
                    };
                },
                \clear, {
                    if (pedalboardRef.respondsTo(\clear)) {
                        pedalboardRef.clear; didFallback = true;
                    };
                },
                \setSource, {
                    if (pedalboardRef.respondsTo(\setSource) and: { argSymbol.notNil }) {
                        pedalboardRef.setSource(argSymbol); didFallback = true;
                    };
                },
                \switch, {
                    // never call mpb.switch(); Object:switch is a control construct
                    // switching should be handled by the adapter
                },
                { } // default: do nothing
            );
        };

        if (didFallback) {
            ("Fallback MPB applied: " ++ shortPath).postln;
            ~pane.(\recv, "Fallback applied: " ++ shortPath);
            true
        } {
            ("⚠ No adapter for: " ++ shortPath).warn;
            ~pane.(\recv, "⚠ No adapter for: " ++ shortPath);
            false
        };
    };
};

sendCanonicalPath = { |shortPath|
    var okApply;
    okApply = applyCanonicalPath.(shortPath);
    ~refreshHUD.();
    okApply
};

// Navigation helpers
showChildrenList = {
    var items, shownText;
    items = builderRef.currentNode.children.collect({ |childNode| [childNode.name, childNode.fret] });
    shownText = "Children: " ++ items.asString;
    shownText.postln;
    ~pane.(\choices, items.asString);
    items
};

navigateByName = { |nameString|
    var nameStr;
    nameStr = nameString.asString;
    builderRef.navigateByName(nil, nameStr);
    commandManagerRef.updateDisplay;
    showChildrenList.();
};

navigateByFret = { |stringNumber, fretNumber|
    builderRef.navigateByFret(stringNumber, fretNumber);
    commandManagerRef.updateDisplay;
    showChildrenList.();
};

// Top-level aliases (emulator-like)
~toProg = {
    commandManagerRef.currentState = \prog;
    commandManagerRef.updateDisplay;
    "Navigation started (prog).".postln;
    ~pane.(\system, "Mode: prog (nav)");
    showChildrenList.();
};

~showNav = {
    var longPath, shortPath;
    longPath  = buildLongPathFromBuilder.();
    shortPath = canonicalizePath.(longPath);
    ("Long:  " ++ longPath).postln;
    ("Short: " ++ shortPath).postln;
    ~pane.(\diag, "Long=" ++ longPath ++ "  Short=" ++ shortPath);
};

~toQueue = {
    var shortPath;
    shortPath = canonicalizePath.( buildLongPathFromBuilder.() );
    commandManagerRef.queue.enqueueCommand(shortPath);
    ("Queued: " ++ shortPath).postln;
    ~pane.(\recv, "Queued: " ++ shortPath);
    shortPath
};

~toSend  = {
    var shortPath;
    shortPath = canonicalizePath.( buildLongPathFromBuilder.() );
    sendCanonicalPath.(shortPath);
};

~navName = navigateByName;
~navFret = navigateByFret;

"✔ Emulator online. Use: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend".postln;
)

//////////////////////////////////////////////////////
// 7) Scenarios (NAME-based first; then direct CANONICAL)
//////////////////////////////////////////////////////
(
var unused;
~toProg.();
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();               // expect Short: /add/delay
~toSend.();                // robust adapter call (or safe fallback)
unused = nil; // keep var-first pattern satisfied
)

(
var unused;
~sendCanonicalPath.("/add/delay");
unused = nil;
)

(
var unused;
~toProg.();
~navName.("switch");
~showNav.();               // expect Short: /switch
~toSend.();                // apply via adapter (or try: ~sendCanonicalPath.("/switch"))
unused = nil;
)

//////////////////////////////////////////////////////
// 8) Fast audible checks (optional, reversible)
//////////////////////////////////////////////////////
// ~lpDemo_on.();       // UI demo ON: bars should move immediately
// ~lpDemo_off.();      // UI demo OFF: back to LPS retap
// ~diag_addTremA.();   // audible wobble on Chain A proves we are in LPS path
// ~diag_clearTrem.();  // remove wobble
// ~refreshHUD.();      // panes: status/chain text

===== RunBook_20251002_Diagnostics.scd =====
// RunBook_20251002_Diagnostics.scd
// MD + Copilot 2025-10-02
// --- > RUN BLOCK BY BLOCK! <---
// Goal: Diagnosable bring-up of LPS headless + LPDisplay window.
// Adds pane writers, source toggles, retaps, chain probes, and robust adapter send.

//////////////////////////////////////////////////////
// 1) Preflight cleanup (safe, idempotent; no errors)
//////////////////////////////////////////////////////
(
var wins, demoKeys, demoSyms;

wins = Window.allWindows.select({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    or: { w.tryPerform(\name) == "Layout Test" }
});
wins.do(_.close);

// Free LPDisplay demo responders (if they exist)
demoKeys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
demoKeys.do({ |k| var d = OSCdef(k); if(d.notNil) { d.free } });

// Stop LPDisplay demo Ndefs (if present)
demoSyms = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
demoSyms.do({ |sym| var nd = Ndef(sym); if(nd.notNil) { nd.stop } });

// Remove any prior visualization taps we may have installed in an earlier run
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"✔ Cleanup done.".postln;
)


//////////////////////////////////////////////////////////
// 2) Open the LPDisplay window + install PANE HELPERS
//////////////////////////////////////////////////////////
(
var inst, win;

// Controller + window  (-> a Window titled "Layout Test")
inst = LPDisplayLayoutTestWindow.new(nil);  // nil HUD = raw meters
win  = inst.open;                           // -> a Window

// Keep LPDisplay's own demo quiet by default (we'll offer toggles)
inst.setSourceA(\srcZ);
inst.setSourceB(\srcZ);

// Optional console gate (if your class has it)
try { inst.setConsoleLevelsOn(false) } { };

// Export handles
~inst = inst; ~win = win;

// ---- Pane helpers (so we can write quickly) ----
// pane keys seen in LPDisplayLayoutTestWindow: \left \right \system \diag \choices \recv
~pane = { |paneKey, text|
    // failsafe if sendPaneText not present
    var ok = (~inst.notNil and: { ~inst.respondsTo(\sendPaneText) });
    if (ok) { ~inst.sendPaneText(paneKey.asSymbol, text.asString) } { text.postln };
};
~paneAppend = { |paneKey, text|
    // naive append: readback not available, so just post new line
    ~pane.(paneKey, text)
};
~statusHUD = { |msg|  // put important status in the system pane & console
    ("[HUD] " ++ msg).postln;
    ~pane.(\system, msg);
};

// Initial HUD
~pane.(\diag, "LPDisplay ready @ " ++ Date.getDate.stamp);
~pane.(\system, "System: waiting for LPS…");
~pane.(\left,  "A: (LPDisplay demo source muted)");
~pane.(\right, "B: (LPDisplay demo source muted)");
~pane.(\choices, "—");
~pane.(\recv, "—");

// Quick confirmation
[ inst.notNil, win.notNil, win.class ].postln;
"→ a Window".postln;
)


////////////////////////////////////////////////////////////
// 3) Bring up LivePedalboardSystem (headless) + quick HUD
////////////////////////////////////////////////////////////
(
var system;
var san;
system = LivePedalboardSystem.new(nil);
system.ensureServerReady;
system.bringUpPedalboard;
system.bringUpCommandSystem;
system.installAdapterBridge;

~system = system;

"✔ LPS up (headless).".postln;
~statusHUD.("LPS up (headless)");

Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2) });  // assert stereo busses

// Show core boolean sanity in console AND pane:
san = [ \system: ~system.notNil, \pedalboard: ~system.pedalboard.notNil, \cm: ~system.commandManager.notNil ];
san.postln;
~pane.(\diag, ("Sanity: " ++ san).asString);
)


///////////////////////////////////////////////////////////////
// 4) LPDisplay RETAP from LPS chain ends (safe pass-through)
///////////////////////////////////////////////////////////////
(
var rateHz;
var r;

rateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsA",  [rms[0], rms[1]], 1);   // console/legacy path
            SendReply.kr(t, "/rmsA_toGUI",[rms[0], rms[1]], 1);   // GUI path
            in
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsB",  [rms[0], rms[1]], 2);
            SendReply.kr(t, "/rmsB_toGUI",[rms[0], rms[1]], 2);
            in
        });
    };
});
"✔ LPDisplay retap installed.".postln;

// Confirm which responders are live
r = [
    \rmsA_toGUI: (OSCdef(\rmsA_toGUI).notNil),
    \rmsB_toGUI: (OSCdef(\rmsB_toGUI).notNil),
    \rmsA_console: (OSCdef(\rmsA_console).notNil),
    \rmsB_console: (OSCdef(\rmsB_console).notNil)
];
r.postln;
~pane.(\diag, ("OSC responders: " ++ r).asString);
)


///////////////////////////////////////////////////////
// 5) Quick DIAGNOSTIC CONTROLS & INSPECTION HELPERS
///////////////////////////////////////////////////////
(
// A) Toggle LPDisplay’s INTERNAL demo sources (pure UI demo, not LPS):
~lpDemo_on  = { ~inst.setSourceA(\srcA); ~inst.setSourceB(\srcB);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcA");
                ~pane.(\right, "B: LPDisplay demo src = \\srcB");
                ~statusHUD.("LPDisplay demo sources ON") };

~lpDemo_off = { ~inst.setSourceA(\srcZ); ~inst.setSourceB(\srcZ);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcZ (muted)");
                ~pane.(\right, "B: LPDisplay demo src = \\srcZ (muted)");
                ~statusHUD.("LPDisplay demo sources OFF") };

// B) Chain probes (prints + panes)
~probeChains = {
    var aPlay = Ndef(\chainA).isPlaying, bPlay = Ndef(\chainB).isPlaying;
    var busA  = (Ndef(\chainA).bus ? \nil), busB = (Ndef(\chainB).bus ? \nil);
    var msg   = ("A playing="++aPlay++" bus="++busA) ++ " | " ++ ("B playing="++bPlay++" bus="++busB);
    msg.postln;
    ~pane.(\system, "Chains — " ++ msg);
};

// C) Audible test insert/remove on chain A (tremolo) — safe pass-through
~diag_addTremA = {
    Server.default.bind({
        Ndef(\chainA).filter(\diag_tremA, { |in| in * LFTri.kr(1).range(0.25, 1.0) });
    });
    ~statusHUD.("Inserted test tremolo on chain A");
};
~diag_clearTrem = {
    Server.default.bind({
        if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\diag_tremA) };
    });
    ~statusHUD.("Cleared test tremolo on chain A");
};

// D) Try to describe chains via pedalboard API if present (best-effort)
~describeChains = {
    var pb = ~system.tryPerform(\pedalboard);
    var aTxt = "A: (unknown)", bTxt = "B: (unknown)";
    if (pb.notNil) {
        if (pb.respondsTo(\describe))      { aTxt = pb.describe(\A); bTxt = pb.describe(\B) } {
        if (pb.respondsTo(\chainToString)) { aTxt = pb.chainToString(\A); bTxt = pb.chainToString(\B) } };
    };
    ("ChainDesc: " ++ aTxt ++ " | " ++ bTxt).postln;
    ~pane.(\left,  aTxt.asString);
    ~pane.(\right, bTxt.asString);
};

// E) Minimal HUD refresh bundle
~refreshHUD = {
    ~probeChains.();
    ~describeChains.();
    ~pane.(\choices, "Nav helpers: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend");
};

"✔ Diagnostics installed. Use: ~lpDemo_on/off, ~probeChains, ~diag_addTremA, ~diag_clearTrem, ~describeChains, ~refreshHUD".postln;
)


/////////////////////////////////////////////////////////////
// 6) Inline Emulator: navigation + robust canonical sender
/////////////////////////////////////////////////////////////
(
// --- var-first: gather references
var cm, mm, builder;
var longFromBuilder, canonicalize, applyCanonical, sendCanonical;
var showChildren, navName, navFret;

cm      = ~system.commandManager;
mm      = cm.midiManager;
builder = cm.builder;

// --- path builders (drop "root")
longFromBuilder = {
    var names = builder.currentNode.getPathToRoot;
    var filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

canonicalize = { |rawPath|
    var parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };
    var first = parts[0].asString;

    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"));
    };
    if (first == "switch") { ^"/switch" };

    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString);
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString);
        };
    };

    ^rawPath.asString
};

// --- ROBUST sender: try bridge method names, then fallback direct to pedalboard if present
applyCanonical = { |shortPath|
    var bridge, applied=false;

    // 1) System-level applyCanonicalPath
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied=true;
    } {
        // 2) adapterBridge object with .applyPath ?
        bridge = ~system.tryPerform(\adapterBridge);
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied=true;
        } {
            // 3) Sometimes adapterBridge is a Function or symbol-wrapped
            if (bridge.isKindOf(Function)) {
                bridge.value(shortPath); applied=true;
            };
        };
    };

    if (applied) {
        ("Adapter applied: " ++ shortPath).postln;
        ~pane.(\recv, "Applied: " ++ shortPath);
        ^true
    } {
        // 4) Fallback: direct pedalboard verbs if exposed (best-effort)
        var pb = ~system.tryPerform(\pedalboard);
        if (pb.notNil) {
            var toks = shortPath.asString.split($/).reject(_.isEmpty);
            var verb = toks[0].asSymbol;
            var arg  = (toks.size>1).if({ toks[1].asSymbol }, { nil });
            var did  = false;

            switch(verb,
                \add,      { if (pb.respondsTo(\add) and: { arg.notNil }) { pb.add(arg); did=true } },
                \bypass,   { if (pb.respondsTo(\bypass) and: { arg.notNil }) { pb.bypass(arg); did=true } },
                \clear,    { if (pb.respondsTo(\clear)) { pb.clear; did=true } },
                \setSource,{ if (pb.respondsTo(\setSource) and: { arg.notNil }) { pb.setSource(arg); did=true } },
                \switch,   { /* NO direct mpb.switch() (name clashes with Object:switch) */ },
                { } // default
            );

            if (did) {
                ("Fallback MPB applied: " ++ shortPath).postln;
                ~pane.(\recv, "Fallback applied: " ++ shortPath);
                ^true
            };
        };

        ("⚠ Adapter not available for: " ++ shortPath).warn;
        ~pane.(\recv, "⚠ No adapter for: " ++ shortPath);
        ^false
    };
};

sendCanonical = { |shortPath|
    var ok = applyCanonical.(shortPath);
    ~refreshHUD.();  // update panes after any change
    ok
};

// --- Navigation helpers
showChildren = {
    var info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children: " ++ info).postln;
    ~pane.(\choices, info.asString);
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};
navFret = { |stringNum, fretNum|
    builder.navigateByFret(stringNum, fretNum);
    cm.updateDisplay;
    showChildren.();
};

// --- Top-level API (like the old emulator)
~toProg = {
    cm.currentState = \prog;
    cm.updateDisplay;
    "Navigation started (prog).".postln;
    ~pane.(\system, "Mode: prog (nav)");
    showChildren.();
};

~showNav  = {
    var long = longFromBuilder.(), short = canonicalize.(long);
    ("Long:  " ++ long).postln;  ("Short: " ++ short).postln;
    ~pane.(\diag, "Long="++long++"  Short="++short);
};

~toQueue  = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    ~pane.(\recv, "Queued: " ++ short);
    short
};

~toSend   = {
    var short = canonicalize.( longFromBuilder.() );
    sendCanonical.(short);
};

~navName  = navName;
~navFret  = navFret;
"✔ Emulator online. Use: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend".postln;
)


//////////////////////////////////////////////////////
// 7) Scenarios — first by NAME, then direct CANONICAL
//////////////////////////////////////////////////////

// 7A) NAME-based Add Delay
(
~toProg.();
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();               // expect Short: /add/delay
~toSend.();                // robust adapter call or fallback
)

// 7B) Direct CANONICAL (no nav) — prove the path independently
(
~sendCanonical.("/add/delay");
)

// 7C) Switch chains — ALWAYS via adapter (no direct mpb.switch())
(
~toProg.();
~navName.("switch");
~showNav.();               // expect Short: /switch
~toSend.();                // robust adapter call
// OR direct canonical:
// ~sendCanonical.("/switch");
)

//////////////////////////////////////////////////////
// 8) Quick audible checks (optional, reversible)
//////////////////////////////////////////////////////

// 8A) Turn LPDisplay demo sources ON (just to see UI move), then OFF
// ~lpDemo_on.();
// ~lpDemo_off.();

// 8B) Insert tremolo on A (you should hear amplitude wobble), then clear
// ~diag_addTremA.();
// ~diag_clearTrem.();

// 8C) Refresh HUD summary
// ~refreshHUD.();
===== Sim_MIDI_FootAndGuitar_Demo_v0.1.scd =====
// Sim_MIDI_FootAndGuitar_Demo_v0.1.scd
// v0.1.2
// MD 2025-09-26 10:45 BST

/* Purpose / Style
   Simulate foot controller + hex guitar without hardware:
   - FOOT (noteOn): 36→\idle, 38→\prog, 40→\queue, 41→\send
   - GUITAR (channels 0..5 → strings 6..1) bases [40,45,50,55,59,64]
   - Drives MIDIInputManager handlers + CommandManager + adapter bridge if present.

   Style
   - var-first everywhere; descriptive lowercase variable names; AppClock-only; no server.sync.
   - Generated audio only; exclusivity Option A remains enforced by bring-up (no SoundIn).
*/

(
var ensureSystem, basePitches, ensureReady, footToIdle, footToProg, footToQueue, footToSend;
var guitarNote, navFret, showCanonical, refreshChoices;
var runScenarioAddDelay, runScenarioSwitch, runScenarioBypassOn, runAllScenarios, logger;

logger = { arg message; ("[SIM] " ++ message).postln };

ensureSystem = {
    var systemInstance;
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    systemInstance = LivePedalboardSystem.new(nil);  // nil -> class path resolver
    ~system = systemInstance;
    ~system.bringUpAll;
    if(~system.respondsTo(\installAdapterBridge)) { ~system.installAdapterBridge };
    logger.("system is up (GUI + MPB + CommandTree)");
};

ensureReady = {
    var ok;
    ok = ~system.notNil
        and: { ~system.commandManager.notNil }
        and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "⚠️ Run ensureSystem.() first".warn };
    ok
};

basePitches = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

footToIdle  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 36) } };
footToProg  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 38) } };
footToQueue = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 40) } };
footToSend  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 41) } };

guitarNote = { arg stringNumber, fretNumber;
    var midiManager, channelIndex, baseNote, midiPitch;
    if(ensureReady.().not) { ^nil };
    midiManager = ~system.commandManager.midiManager;
    channelIndex = (6 - stringNumber.asInteger).clip(0, 5);
    baseNote = basePitches[channelIndex];
    if(baseNote.isNil) { "⚠️ Invalid string number".warn; ^nil };
    midiPitch = (baseNote + fretNumber.asInteger).asInteger;
    midiManager.guitarHandler.handleMessage(channelIndex, \noteOn, midiPitch);
};
navFret = { arg stringNumber, fretNumber; guitarNote.(stringNumber, fretNumber) };

showCanonical = {
    var cmRef, builderRef, longPath, shortPath;
    if(ensureReady.().not) { ^nil };
    cmRef = ~system.commandManager; builderRef = cmRef.builder;
    builderRef.printPathToRoot;
    longPath  = cmRef.buildLongPathFromBuilder(builderRef);
    shortPath = cmRef.canonicalPathFromBuilder(builderRef);
    ("• long=" ++ longPath ++ "  canonical=" ++ shortPath).postln;
};
refreshChoices = { if(~system.notNil) { ~system.commandManager.updateDisplay } };

runScenarioAddDelay = {
    footToProg.(); refreshChoices.();
    navFret.(6, 1); navFret.(5, 5); navFret.(4, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario A complete (add delay)");
};

runScenarioSwitch = {
    footToProg.();
    navFret.(6, 5);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario B complete (switch)");
};

runScenarioBypassOn = {
    footToProg.();
    navFret.(6, 3); navFret.(5, 9); navFret.(4, 3); navFret.(3, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario C complete (bypass delay on)");
};

runAllScenarios = {
    var stepIndex;
    stepIndex = 0;
    AppClock.sched(0.0, {
        switch(stepIndex,
            0, { ensureSystem.(); stepIndex = 1; AppClock.sched(0.40, { runAllScenarios.(); nil }) },
            1, { runScenarioAddDelay.(); stepIndex = 2; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            2, { runScenarioSwitch.();   stepIndex = 3; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            3, { runScenarioBypassOn.(); nil },
            { nil }
        );
        nil
    });
    "[SIM] queued runAllScenarios".postln;
};

~sim_runAll = { runAllScenarios.() };
logger.("Evaluate:  ensureSystem.();  then  ~sim_runAll.();");
)

===== StartHere_LivePedalboardSuite.scd =====
// StartHere_LivePedalboardSuite.scd
// v0.6.1
// MD 20250928-1824
//
// Purpose
// - Canonical bring-up for LivePedalboardSuite using ONE GUI with WORKING METERS.
// - Avoid duplicate GUI/taps: rely on LivePedalboardSystem.bringUpAll to open GUI,
//   then install the adapter bridge and auto-meters once.
//
// Style / Guard Rails
// - single () block; var-first; lowercase names; no server.sync; no non-local '^'.
// - UI via AppClock; server ops inside Server.default.bind when needed.
// - Returns -> a Window (MagicDisplayGUI…).

(
var meterRate, postSwitchDelay, systemRef, windowRef;
var findMagicDisplayWindow, closeExistingMagicDisplayWindows, frontWindow, afterBringUp;

// ---- tunables ----
meterRate = 24;
postSwitchDelay = 0.35;

// ---- helpers ----
closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows; i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }) {
            w.close;
        };
        i = i + 1;
    };
};

findMagicDisplayWindow = {
    var win;
    win = Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    win
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    // Adapter: route short canonical commands to MagicPedalboard (+HUD toggle on /switch)
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    // Meters: assert one set of taps + GUI re-arm (idempotent)
    if(lps.respondsTo(\enableAutoMeters)) { lps.enableAutoMeters(meterRate, postSwitchDelay) };
    // detect and front the GUI window
    frontWindow.(findMagicDisplayWindow.());
};

// ---- run ----

// 0) keep one GUI window only
closeExistingMagicDisplayWindows.();

// 1) shutdown existing system cleanly (if present)
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };

// 2) construct and bring up everything (this will open the GUI once)
systemRef = LivePedalboardSystem.new(nil);
systemRef.bringUpAll;

// 3) post-steps: adapter bridge + meters + front window
windowRef = afterBringUp.(systemRef);

// 4) publish handles
~system = systemRef;
~mpb = systemRef.pedalboard;
~gui = systemRef.statusDisplay;

// 5) return the GUI window
windowRef
)

===== test 31tp8ve.scd =====
// test 31tp8ve.scd
//

(
var baseFreq = 220.0; // A3
var stepsPerOctave = 31;
var numSteps = 62; // two octaves
var dur = 0.2;
var gap = 0.05;

Routine({
    numSteps.do { |step|
        var freq = baseFreq * (2 ** (step / stepsPerOctave));
        Synth(\play31tone, [\freq, freq]);
        dur.wait;
        gap.wait;
    };
}).play;

SynthDef(\play31tone, { |freq=220|
    var env = EnvGen.kr(Env.perc(0.01, 0.19), doneAction:2);
    var sig = SinOsc.ar(freq) * 0.2 * env;
    Out.ar(0, sig!2);
}).add;
)
===== Test_MagicDisplayGUI_BootAndScenarios.scd =====
// Test_MagicDisplayGUI_BootAndScenarios.scd
// v0.1.6
// MD 2025-09-26 11:58 BST

/* Purpose / Style
   One-click system bring-up using the PerfHUD v0.5.4 integration:
   - LivePedalboardSystem.new(nil).bringUpAll() -> your PerfHUD window (v0.5.4).
   - Install queue->MPB adapter bridge (if present) and inline AutoMeters taps.
   - AppClock-only; var-first in EVERY block; no server.sync; generated audio only.
   - Final expression returns -> a Window.
*/

(
var systemRef, pickedWindow, wins;

// Fresh system
systemRef = LivePedalboardSystem.new(nil);
~system = systemRef;  // convenience handle at top level (allowed per your style)
systemRef.bringUpAll;

// Optional: adapter and inline meter taps
if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
if(systemRef.respondsTo(\enableAutoMeters))     { systemRef.enableAutoMeters(18, 0.35) };

// Find MagicDisplay window produced by PerfHUD v0.5.4
wins = Window.allWindows;
pickedWindow = wins.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

// Final expression -> a Window
pickedWindow ? { wins.last }
)

===== Tests/Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd =====
// Demo_5pm_SimHexGuitar_Footcontroller_BringUp.scd
// v0.1.1
// MD 2025-09-26 16:35 BST

/* Purpose / Style
   Purpose: One-file, sectioned run-sheet for the 5pm demo. Brings up the system, ensures a single
            “MagicDisplayGUI …” window, installs the adapter bridge and robust meter taps, and provides
            simulated footcontroller + hex guitar. Applies canonical commands via the adapter to avoid
            the known queue/display crash path today.
   Style:   SC only; known-good syntax; var-first everywhere; no non-local returns; no try/protect;
            no server.sync; GUI on AppClock; the bring-up section returns → a Window.
*/

// [0] BRING-UP (build once; returns → a Window)
(
var needNew, winList, pickedWindow;

needNew = ~system.isNil;
if(needNew) {
    var treePath;  // nil → LivePedalboardSuite resolver precedence
    treePath = nil;
    ~system = LivePedalboardSystem.new(treePath);                     // resolver inside class
    ~system.bringUpAll;                                               // GUI+MPB+CommandManager+meters staged
} {
    // Refresh GUI only (avoid double full bring-up)
    ~system.closeExistingMagicDisplayWindows;
    ~system.bringUpMagicDisplayGUI;                                   // sets statusDisplay and re-binds if commandManager exists
};

// Return the single MagicDisplayGUI window and front it
winList = Window.allWindows;
pickedWindow = winList.detect({ arg w;
    var titleString;
    titleString = w.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});
if(pickedWindow.notNil) { pickedWindow.front };
pickedWindow
)

// [1] ADAPTER BRIDGE + STABLE TAPS + INLINE OVERLAY METERS (self-contained)
/* Reason:
   - Your GUI shows the /md/levels OSC listener is installed, but the overlay meters weren't attached in your run.
   - We install stable taps (A=2001, B=2002) and a minimal overlay here so you see movement immediately.  */
(
var ensureBridge, ensureStableTaps, installLevelsListener, attachOverlay;

ensureBridge = {
    ~system.installAdapterBridge;  // routes canonical queue strings through adapter; also toggles active-chain HUD
    nil
};

ensureStableTaps = {
    // Sanitised + smoothed visual taps to /md/levels with IDs 2001 (A) / 2002 (B)
    ~system.installStableMeters;
    nil
};

installLevelsListener = {
    // Minimal HUD-side listener (independent of any external file)
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    if(OSCdef.all.at(\md_levels_inline).notNil) { OSCdef.all.at(\md_levels_inline).free };
    OSCdef(\md_levels_inline, { arg msg;
        var id, l, r, L, R;
        if(msg.size >= 5) {
            id = msg[2];
            l  = msg[3].asFloat; r = msg[4].asFloat;
            L  = l.isFinite.if({ l.clip(0,1) }, { 0.0 });
            R  = r.isFinite.if({ r.clip(0,1) }, { 0.0 });
            ~md_levelsById.put(id, [L, R]);
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    nil
};

attachOverlay = {
    var hudWindow, overlayView, pad, w, h, tick;
    hudWindow = Window.allWindows.detect({ arg ww;
        var n = ww.tryPerform(\name);
        n.notNil and: { n.asString.beginsWith("MagicDisplayGUI") }
    });
    if(hudWindow.isNil) { "⚠️ No MagicDisplayGUI window yet; run [0] first.".warn; ^nil };

    pad = 8; w = 22; h = 86;
    overlayView = UserView(hudWindow, Rect(pad, pad, w, h));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var pairA, pairB, aL, aR, bL, bR, halfH, halfW;
        pairA = ~md_levelsById.at(2001) ? [0, 0];       // A (replyID 2001)
        pairB = ~md_levelsById.at(2002) ? [0, 0];       // B (replyID 2002)
        aL = pairA[0]; aR = pairA[1];
        bL = pairB[0]; bR = pairB[1];
        halfH = v.bounds.height/2; halfW = v.bounds.width/2;

        // A (bottom half): left=green, right=blue
        Pen.fillColor = Color(0.35, 0.9, 0.35);
        Pen.addRect(Rect(0, halfH - (halfH * aL), halfW, (halfH * aL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95);
        Pen.addRect(Rect(halfW, halfH - (halfH * aR), halfW, (halfH * aR))); Pen.fill;

        // B (top half): lighter tint
        Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
        Pen.addRect(Rect(0, v.bounds.height - (halfH * bL), halfW, (halfH * bL))); Pen.fill;
        Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, v.bounds.height - (halfH * bR), halfW, (halfH * bR))); Pen.fill;
    });

    // Refresh loop (AppClock only)
    tick = Routine({
        var keep;
        keep = true;
        while({ keep and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            0.15.wait;
        });
    }).play(AppClock);

    "✅ Inline overlay meters attached (top-left)".postln;
    overlayView
};

// Apply fixes
ensureBridge.();
ensureStableTaps.();
installLevelsListener.();
attachOverlay.();
nil
)

// [2] SIMULATED CONTROLLERS (foot + hex guitar → nav); AVOID queue/send crash today
(
var ensure, bases;

// Guard
ensure = {
    var ok;
    ok = ~system.notNil
      and: { ~system.commandManager.notNil }
      and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "⚠️ Run section [0] first.".warn };
    ok
};

// Channel→string base pitches (E A D G B E) as per GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

// FOOT: emulate a foot button press (note number)
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);  // 36 idle, 38 prog, 40 queue, 41 send
};

// Shortcuts
~toIdle  = { var n; n = 36; ~fc.(n) };
~toProg  = { var n; n = 38; ~fc.(n) };

// GUITAR: emulate “string s @ fret f”
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "⚠️ Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Helper: print current and canonical path
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);         // "/add/delay", "/switch", etc.
    ("• long=" ++ long ++ "  canonical=" ++ short).postln;
    short
};
nil
)

// [3] DEMO SCENARIOS (canonical applied via adapter to avoid queue/display crash path)

// Scenario A — Add delay to NEXT via guitar nav, then apply canonical via adapter (no queue/send today)
(
var path;
~toProg.();      // enter navigation mode
~gm.(6, 1);      // "audio"    (string 6 fret 1)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(5, 5);      // "timebased"(string 5 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
~gm.(4, 3);      // "delay"    (string 4 fret 3)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // should be "/add/delay"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // apply via adapter
} {
    "⚠️ Adapter not loaded.".warn;
};
"✅ Scenario A applied (add delay to NEXT).".postln;
nil
)

// Scenario B — Navigate to top-level “switch” and apply canonical via adapter
(
var path;
~toProg.();
~gm.(6, 5);      // "switch" (string 6 fret 5)  [1](https://openuniv-my.sharepoint.com/personal/md24538_open_ac_uk/Documents/Microsoft%20Copilot%20Chat%20Files/consoleout_20250926-1515.txt)
path = ~showNav.();           // "/switch"
if(~ct_applyOSCPathToMPB.notNil) {
    ~ct_applyOSCPathToMPB.(path, ~system.pedalboard, ~system.statusDisplay);  // guarded crossfade + post-audit
} {
    "⚠️ Adapter not loaded.".warn;
};
"✅ Scenario B applied (switch).".postln;
nil
)

===== troubleshooting/00_Reset_KnownClean_State.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"✅ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)

===== troubleshooting/00A_HUD_Sanity_Check.scd =====
//////////////////////////////////////////////////////////////
// 00A_HUD_Sanity_Check.scd
// v0.1.0
// MD 20250929-13:02

/* Purpose
   - Print which window(s) are open and what ~gui is.
Style
   - var-first; no server.sync; safe .tryPerform.
*/
(
var windowNames, guiClass, isWindow;

windowNames = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
guiClass = ~gui.tryPerform(\class);
isWindow = ~gui.notNil and: { ~gui.isKindOf(Window) };

"— HUD Sanity —".postln;
("Windows: " ++ windowNames).postln;
("~gui: " ++ (~gui ? "nil").asString).postln;
("~gui.class: " ++ (guiClass ? "nil").asString).postln;
("~gui is a Window? " ++ isWindow.asString).postln;
if(~gui.notNil) {
    ("GridDemo methods: highlight=" ++ ~gui.respondsTo(\highlightCurrentColumn)
      ++ " setOps=" ++ ~gui.respondsTo(\setOperations)).postln;
};
)

===== troubleshooting/00B_HUD_Force_GridDemo_Now.scd =====
//////////////////////////////////////////////////////////////
// 00B_HUD_Force_GridDemo_Now.scd
// v0.1.0
// MD 20250929-13:02
/* Purpose
   - Close PerfHUD/GridDemo windows and bring up GridDemo (non-pulsing).
   - Assign ~gui to the GridDemo controller and bring it to front.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/
(
var closeWindows, bringGrid, front;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller, not a Window
};

front = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (static A/B; no pulse)", 0);
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { front.value; nil }); nil });
)

===== troubleshooting/01_StartHere_LivePedalboardSuite.scd =====
// 01_StartHere_LivePedalboardSuite.scd
// v0.6.2
// MD 20250928-1935

(
// Purpose
// - Bring up LivePedalboardSuite from a clean state (server reboot, GUI, MPB, CommandTree).
// - Enable GUI taps for overlay; HUD meters will be driven by “02_ForceMeters_FromBuses.scd”.
// Style
// - var-first; no server.sync; use s.waitForBoot; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var rebootServer, ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

rebootServer = {
    if(s.serverRunning) { s.reboot } { s.boot };
    s.waitForBoot({
        s.initTree;
        Server.default.bind({ s.defaultGroup.freeAll });
        "🔁 Server booted & tree initialized.".postln;
    });
};

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };  // GUI taps for overlay
    frontWindow.(findMagicDisplayWindow.());
};

rebootServer.value;
ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_1_HUD_Adapter.scd =====
// 01b_1_HUD_Adapter.scd
// v0.1.0
// MD 2025-09-29 13:05

/* Purpose
   - Provide a stable HUD API regardless of which GUI is up:
        ~hud_highlightCurrent.(\chainA | \chainB)
        ~hud_showExpectation.("text", seconds=0)
        ~hud_setOperations.(["line1", "line2", ...])
   - If GridDemo is up, forward to its native methods.
   - If PerfHUD is up (meters!), create lightweight overlays on top of the window:
       • a solid A/B highlight (masks the pulsing)
       • a small text panel for status + choices
Style
   - var-first; AppClock for UI; no server.sync; nil-safe; idempotent.
*/

(
var findHudWindow, isGridDemo, adoptGridDemo, adoptPerfHUD, ensureOverlayBag;
var mkOrGetView, setSolidHighlight, setStatusText, setChoicesText;

findHudWindow = {
    Window.allWindows.detect { |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    }
};

isGridDemo = {
    // If ~gui is a GridDemo controller, prefer it
    (~gui.notNil)
    and: { ~gui.class.asString == "MagicDisplayGUI_GridDemo" }
    and: { ~gui.respondsTo(\highlightCurrentColumn) }
};

// ---- GridDemo path: forwarders to class methods -----------------------------
adoptGridDemo = {
    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            ~gui.highlightCurrentColumn(which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation(text, secs ? 0) };
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            if(~gui.respondsTo(\setOperations)) { ~gui.setOperations(lines ? []) };
            nil
        })
    };
    "HUD adapter: GridDemo forwarders installed.".postln;
};

// ---- PerfHUD path: overlays on top of the window ----------------------------
ensureOverlayBag = { |win|
    var dict;
    dict = Library.at(\HUD_Overlay, win.identityHash);
    if(dict.isNil) {
        dict = IdentityDictionary.new;
        Library.put(\HUD_Overlay, win.identityHash, dict);
    };
    dict
};

mkOrGetView = { |win, key, makeFunc|
    var bag, v;
    bag = ensureOverlayBag.(win);
    v = bag[key];
    if(v.isNil or: { v.wasRemoved ? false }) {
        v = makeFunc.value(win.view);
        bag[key] = v;
    };
    v
};

setSolidHighlight = { |win, which|
    var host, w, h, half, rect, color, key;
    host = win.view;
    w = host.bounds.width; h = host.bounds.height;
    half = (w * 0.5).round(1);
    rect = (which == \chainA)
        .if({ Rect(0, 0, half, h) }, { Rect(half, 0, w - half, h) });
    color = Color(0.85, 1.0, 0.85, 0.90);   // same tint as GridDemo "active"
    key = \highlightView;

    mkOrGetView.(win, key, { |parent|
        var v = CompositeView(parent);
        v.background = color;
        v
    }).bounds = rect;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).background = color;
    mkOrGetView.(win, key, { |parent| CompositeView(parent) }).front;
};

setStatusText = { |win, string|
    var host, rect, key;
    host = win.view;
    rect = Rect(8, 6, (host.bounds.width - 16).max(120), 22);
    key = \statusText;

    mkOrGetView.(win, key, { |parent|
        var tv = StaticText(parent);
        tv.stringColor = Color.black;
        tv.background = Color(1, 1, 0.6, 0.8);
        tv.align = \left;
        tv
    }).bounds = rect;

    mkOrGetView.(win, key, { |parent| StaticText(parent) }).string = string.asString;
    mkOrGetView.(win, key, { |parent| StaticText(parent) }).front;
};

setChoicesText = { |win, lines|
    var host, x, y, w, h, key, text;
    host = win.view;
    x = (host.bounds.width - 360).clip(8, host.bounds.width - 120);
    y = 40;
    w = 352;
    h = 220;
    text = (lines ? []).collect(_.asString).join("\n");
    key = \choicesText;

    mkOrGetView.(win, key, { |parent|
        var box = TextView(parent);
        box.string = text.size > 0.if({ text }, { "—" });
        box.background = Color(0.95, 0.98, 1.0, 0.85);
        box.editable = false;
        box.hasVerticalScroller = true;
        box
    }).bounds = Rect(x, y, w, h);

    mkOrGetView.(win, key, { |parent| TextView(parent) }).string = text.size > 0.if({ text }, { "—" });
    mkOrGetView.(win, key, { |parent| TextView(parent) }).front;
};

adoptPerfHUD = {
    var win;
    win = findHudWindow.();
    if(win.isNil) {
        "HUD adapter: no MagicDisplayGUI window found (PerfHUD expected).".warn;
        ^nil
    };

    ~hud_highlightCurrent = { |which|
        AppClock.sched(0.0, {
            setSolidHighlight.(win, which);
            nil
        })
    };
    ~hud_showExpectation = { |text, secs = 0|
        AppClock.sched(0.0, {
            setStatusText.(win, text.asString);
            nil
        })
    };
    ~hud_setOperations = { |lines|
        AppClock.sched(0.0, {
            setChoicesText.(win, lines ? []);
            nil
        })
    };
    "HUD adapter: PerfHUD overlays installed (solid A/B, status, choices).".postln;
};

// ---- Install adapter ---------------------------------------------------------
AppClock.sched(0.00, {
    var win;
    win = findHudWindow.();

    // Prefer GridDemo if controller is present and methods exist
    if(isGridDemo.()) {
        adoptGridDemo.();
    }{
        // Otherwise, adopt PerfHUD (overlays) if its window exists
        if(win.notNil) {
            adoptPerfHUD.();
        }{
            "HUD adapter: no GUI found yet; will try again shortly.".warn;
            AppClock.sched(0.10, {
                var win2 = findHudWindow.();
                if(isGridDemo.()) { adoptGridDemo.() } { if(win2.notNil) { adoptPerfHUD.() } };
                nil
            });
        };
    };
    nil
});
)

===== troubleshooting/01b_StartHere_NoReboot copy.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.2
// MD 20250929-0918

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay;
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w| if(w.notNil) { AppClock.sched(0.0, { w.front; nil }) }; w };

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

//new
~gui = Window.allWindows.detect { |w| w.name.asString.beginsWith("MagicDisplayGUI") };

ensureAudioProxies.value;
startSystem.value;
windowRef = afterBringUp.(systemRef);
windowRef
)

===== troubleshooting/01b_StartHere_NoReboot.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW — ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD’s window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ——— bring-up sequence ———

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your “-> a Window” acceptance pattern
windowRef
)

===== troubleshooting/01b_StartHere_NoRebootBROKEN.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-11:46

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoid reboot races; opens the single GUI window; enables GUI taps.
// - Force GridDemo for these tests (PerfHUD pulses and lacks setOperations).
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef, pedalboardRef, guiRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, closeMagicDisplayWindows;
var installGridDemo, bindDisplay, afterBringUp;

// ---------- helpers ----------

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0).source.isNil)    { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, { // neutral; 02D will replace with centered pulses
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                Pan2.ar(SinOsc.ar(f) * env * 0.22, 0.0)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

closeMagicDisplayWindows = {
    var wins = Window.allWindows.select({ |w|
        var nm = w.tryPerform(\name) ? "";
        nm.asString.beginsWith("MagicDisplayGUI")
    });
    AppClock.sched(0.00, { wins.do(_.close); nil });
};

installGridDemo = {
    // Create GridDemo and publish it
    AppClock.sched(0.05, {
        guiRef = MagicDisplayGUI_GridDemo.new;        // <- concrete GUI
        ~gui   = guiRef;                               // publish for step scripts
        // if LPS carries the variable, update it too (it’s a <> ivar, settable)
        if(systemRef.notNil and: { systemRef.respondsTo(\statusDisplay_) }) {
            systemRef.statusDisplay_(guiRef);
        };
        // bind display to pedalboard if possible
        bindDisplay.value;
        // meters off->on to ensure responders
        if(guiRef.respondsTo(\enableMeters)) { guiRef.enableMeters(false); guiRef.enableMeters(true) };
        guiRef.showExpectation("System ready.", 0);
        guiRef.window.front.alwaysOnTop_(true);
        nil
    });
};

bindDisplay = {
    pedalboardRef = systemRef.pedalboard;
    if(pedalboardRef.notNil and: { pedalboardRef.respondsTo(\setDisplay) } and: { guiRef.notNil }) {
        pedalboardRef.setDisplay(guiRef);
    };
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll;            // this may load PerfHUD if present
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    // Note: when PerfHUD is used, statusDisplay stays nil; we’ll force GridDemo next.
};

afterBringUp = { |lps|
    // Route short canonicals via adapter + post-switch meter re-arm
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };

    // If PerfHUD window was created, close it and switch to GridDemo
    AppClock.sched(0.05, {
        var win = findMagicDisplayWindow.();
        // If bringUpAll used PerfHUD, LivePedalboardSystem.statusDisplay is nil.
        if(lps.statusDisplay.isNil) {
            // Close the PerfHUD window (title contains "Performance HUD")
            if(win.notNil and: { win.name.asString.contains("Performance HUD") }) { win.close };
            installGridDemo.value; // create GridDemo, publish ~gui, bind to pedalboard
        } {
            // We already have a GUI object (GridDemo path)
            guiRef = lps.statusDisplay; ~gui = guiRef; bindDisplay.value;
            guiRef.window.front.alwaysOnTop_(true);
        };
        nil
    });
};

// ---------- run ----------

ensureAudioProxies.value;
startSystem.value;       // creates LPS + MPB; may open PerfHUD
closeMagicDisplayWindows.value;  // ensure only one window survives (we’ll reinstall)
afterBringUp.(systemRef);
)

===== troubleshooting/01b.1_HUD_Ensure_GridDemo.scd =====
// 01b.1_HUD_Ensure_GridDemo.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Close any existing MagicDisplayGUI windows (including PerfHUD) and bring up GridDemo
   so highlighting is NON-PULSING.
 - Set ~gui to the GridDemo controller and front the window.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeWindows, bringGrid, frontIt;

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

bringGrid = {
    ~gui = MagicDisplayGUI_GridDemo.new;  // controller object (not a Window)
};

frontIt = {
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA); // make it obvious we’re on A
    };
};

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.05, { bringGrid.value; AppClock.sched(0.05, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo_v0.1.0.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01b.1_HUD_EnsureGridDemoREJECTED.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/01c_PerfHUD_CompatAdapter.scd =====
//////////////////////////////////////////////////////////////
// 01c_PerfHUD_CompatAdapter.scd
// v0.9.0  MD 2025-09-29 12:35
//
// Purpose
// - Add a minimal, GridDemo-compatible layer on top of the existing
//   PerfHUD window (meters/layout unchanged).
// - Provide these helpers for test scripts:
//     ~hud_highlightCurrentColumn.(\chainA | \chainB)  // solid, no pulse
//     ~hud_showExpectation.("text", secs?)             // top status line
//     ~hud_updateTextField.(\state, "text")            // compat alias
//     ~hud_setOperations.([ "fret 3 → add", "fret 5 → …" ])
//
// Style
// - var-first; descriptive names; AppClock-only for UI; no server.sync.
// - Nil-safe: aborts cleanly if no PerfHUD window is found.
// - Does NOT modify PerfHUD's own ticker; simply draws opaque overlays.
//
(
var win, host, hasWindow, ensureOverlays, relayoutOverlays;
var overlayLeft, overlayRight, statusLabel, choicesText;
var drawSolidA, drawSolidB, setStatus, setChoices, attachResize;

////////////////////////////////////////////////////////////
// 0) Find the PerfHUD window synchronously
win = ~gui;   // you already set this in 01b; it prints as a Window
hasWindow = win.notNil and: { win.isKindOf(Window) };
if(hasWindow.not) {
    "PerfHUD_CompatAdapter: ~gui is not a Window; aborting adapter.".warn;
    ^nil;
};

// Root view of the window
host = win.tryPerform(\view);
if(host.isNil) {
    "PerfHUD_CompatAdapter: window has no .view; aborting adapter.".warn;
    ^nil;
};

////////////////////////////////////////////////////////////
// 1) Create overlays (idempotent)
ensureOverlays = {
    var b, halfW, pad, topY, colH, rightX, rightW;
    b = host.bounds;  // Rect in UI coords (origin at top-left in View)
    pad = 8;
    halfW = (b.width / 2).asInteger;

    // reserve a small top bar for status
    topY = pad;
    // columns height = full minus top/status area and a small bottom pad
    colH = (b.height - (pad*3) - 180).max(40);

    // LEFT column overlay (Chain A)
    overlayLeft = overlayLeft ?? { CompositeView(host) };
    overlayLeft.bounds = Rect(pad, topY + 28, halfW - (pad*1.5), colH);
    overlayLeft.background = Color(0.85, 1.0, 0.85, 1.0);  // ACTIVE-green
    overlayLeft.visible = false; // default off; we turn it on in highlight
    overlayLeft.front;

    // RIGHT column overlay (Chain B)
    rightX = halfW + (pad * 0.5);
    rightW = b.width - rightX - pad;
    overlayRight = overlayRight ?? { CompositeView(host) };
    overlayRight.bounds = Rect(rightX, topY + 28, rightW, colH);
    overlayRight.background = Color(0.85, 1.0, 0.85, 1.0);
    overlayRight.visible = false;
    overlayRight.front;

    // STATUS label at very top (compatible with showExpectation / updateTextField(\state))
    statusLabel = statusLabel ?? { StaticText(host) };
    statusLabel.bounds = Rect(pad, pad, b.width - (pad*2), 22);
    statusLabel.align = \center;
    statusLabel.stringColor = Color.black;
    statusLabel.string = "Ready";
    statusLabel.front;

    // CHOICES text (right side, under the status bar)
    choicesText = choicesText ?? { TextView(host) };
    choicesText.bounds = Rect(halfW + (pad * 0.5), overlayRight.bounds.top - 22, rightW, 160);
    choicesText.editable = false;
    choicesText.hasVerticalScroller = true;
    choicesText.background = Color(0.97, 0.97, 0.97);
    choicesText.string = ""; // empty until setOperations call
    choicesText.front;
};

relayoutOverlays = {
    AppClock.sched(0.0, { ensureOverlays.value; nil });
};

////////////////////////////////////////////////////////////
// 2) Small helpers used by the tests (GridDemo-compatible)

drawSolidA = { // solid ACTIVE on A
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = true;
        overlayRight.visible = false;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

drawSolidB = { // solid ACTIVE on B
    AppClock.sched(0.0, {
        ensureOverlays.value;
        overlayLeft.visible = false;
        overlayRight.visible = true;
        statusLabel.string = (statusLabel.tryPerform(\string) ? "Ready").asString;
        nil
    });
};

setStatus = { |textString = "Ready", seconds = 0|
    AppClock.sched(0.0, {
        ensureOverlays.value;
        statusLabel.string = textString.asString;
        nil
    });
};

setChoices = { |itemsArray|
    var s;
    s = (itemsArray ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        ensureOverlays.value;
        choicesText.string = (s.size > 0).if({ s }, { "—" });
        choicesText.scrollToTop;
        nil
    });
};

////////////////////////////////////////////////////////////
// 3) Public tilde helpers (what your 02B / 02F will call if ~gui lacks methods)

~hud_highlightCurrentColumn = { |which|
    var w = (which ? \chainA).asSymbol;
    if(w == \chainA) { drawSolidA.value } { drawSolidB.value };
};

~hud_showExpectation = { |text, secs = 0| setStatus.value(text, secs) };

~hud_updateTextField = { |keySym, valueText|
    var k = keySym.asSymbol;
    if(k == \state) { setStatus.value(valueText.asString, 0) }
    { /* ignore other keys for now; extend later if needed */ };
};

~hud_setOperations = { |itemsArray| setChoices.value(itemsArray) };

////////////////////////////////////////////////////////////
// 4) Keep overlays in place on window resize
attachResize = {
    var resizeFunc;
    resizeFunc = {
        relayoutOverlays.value;
        nil
    };
    win.onResize = { resizeFunc.value };
};

////////////////////////////////////////////////////////////
// 5) Go
ensureOverlays.value;
attachResize.value;
"PerfHUD_CompatAdapter installed: uses ~hud_* helpers (solid A/B + status + choices).".postln;
)

===== troubleshooting/02_ForceMeters_FromBuses.scd =====
// 02_ForceMeters_FromBuses.scd
// v0.1.1
// MD 20250928-1935

(
// Purpose
// - Bypass older meter paths. Tap Ndef buses directly and send on "/md/levels_bus".
// - Correct parsing: SendReply => msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R.
// Style
// - var-first; no server.sync; server ops in Server.default.bind.

var makeTapDefOnce, installBusTaps, installHudReceiver, aBus, bBus, tBus;

makeTapDefOnce = {
    SynthDef(\md_busTap2, { |inBus=0, rate=24, replyID=2001|
        var sig, aL, aR;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).clip(0, 1);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [aL, aR], replyID);
    }).add;
    "🔧 SynthDef \\md_busTap2 installed.".postln;
};

installBusTaps = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, aBus, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, bBus, \rate, 24, \replyID, 2002]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, tBus, \rate, 24, \replyID, 1001]);
        "📡 Bus taps active (A=2001 / B=2002 / Test=1001).".postln;
    });
};

installHudReceiver = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        var id, l, r;
        if(msg.size < 5) { nil } {
            id = msg[2].asInteger;         // 2001 / 2002 / 1001
            l  = msg[3].asFloat.clip(0,1); // left
            r  = msg[4].asFloat.clip(0,1); // right
            ~md_levelsById.put(id, [l, r]);
            ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] listening /md/levels_bus (key=md_levels_hud; ids 2001/2002/1001)".postln;
};

makeTapDefOnce.value;
installBusTaps.value;
installHudReceiver.value;
"✅ Forced bus meters installed; HUD bridged to dict.".postln;
)

===== troubleshooting/02A_Sanity_Wire_ChainA.scd =====
// 02A_Sanity_Wire_ChainA.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Ensure a real, steady signal reaches Chain A’s bus; keep Chain B silent.
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainA) <<> Ndef(\testmelody);  // Chain A <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainA).play;   // run A
        Ndef(\chainB).stop;   // keep B off for clarity
    });
    "🔗 Wired: testmelody -> chainA; chainA is playing (B is stopped).".postln;
};

link.value;
start.value;
)

===== troubleshooting/02A_Sanity_Wire_ChainB.scd =====
// 02A_Sanity_Wire_ChainB.scd
// v0.1.0
// MD 20250929-1010

(
// Purpose
// - Route the same centered pulse source to chainB and play B (A can remain on).
// Style
// - var-first; server ops in Server.default.bind.

var link, start;

link = {
    Ndef(\chainB) <<> Ndef(\testmelody);   // Chain B <- test source
};

start = {
    Server.default.bind({
        Ndef(\chainB).play;                // run B
        // (leave A as-is; you can stop it if you want: Ndef(\chainA).stop)
    });
    "🔗 Wired: testmelody -> chainB; chainB is playing.".postln;
};

link.value;
start.value;
)

===== troubleshooting/02B_ForceMeters_FromBuses_dB.scd =====
// 02B_ForceMeters_FromBuses_dB.scd
// v0.1.2
// MD 20250929-0838

(
// Purpose
// - Replace bus taps with server-side dB-mapped meters (−60 dB -> 0.0, 0 dB -> 1.0).
// - Keep using the existing /md/levels_bus receiver (ids: 2001=A, 2002=B, 1001=test).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, replaceBusTaps_dB, aBus, bBus, tBus;

minDB = -60;  // raise to -48 or -42 if you want hotter bars

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);  // avoid -inf
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046;                           // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);                            // clamp to floor
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);              // map -60..0 -> 0..1
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);           // gentle smoothing
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "🔧 SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

replaceBusTaps_dB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, tBus, \rate, 24, \replyID, 1001, \floorDB, minDB]);
    });
    ("📡 Bus taps replaced with dB mapping (floor = " ++ minDB.asString ++ " dB).").postln;
};

makeTapDefOnce.value;
replaceBusTaps_dB.value;
"✅ 02B dB taps active; HUD continues on /md/levels_bus (md_levels_hud).".postln;
)

===== troubleshooting/02B_HUD_AB_StrictAOnly copy.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.3
// MD 20250929-1153

(
var gui, applySolidA;

gui = ~gui;

applySolidA = {
    // Prefer GridDemo API if present
    if(gui.notNil and: { gui.respondsTo(\highlightCurrentColumn) }) {
        gui.highlightCurrentColumn(\chainA);
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_highlightCurrentColumn.notNil) {
            ~hud_highlightCurrentColumn.(\chainA);
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0);
            };
        } {
            "02B: No HUD adapter (~hud_*) and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid highlight.
 - Optional: stop demo overlays/meters if those extensions are loaded.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, setSolidA;

gui = ~gui; // provided earlier in your run (01b_StartHere_NoReboot / HUD bring-up)

// do nothing if HUD missing
if(gui.isNil) { "02B_HUD_AB_StrictAOnly: ~gui is nil (skipping).".warn; ^nil; };

setSolidA = {
    // 1) Solid highlight on Chain A (GridDemo API)
    if(gui.respondsTo(\highlightCurrentColumn)) {
        gui.highlightCurrentColumn(\chainA);
    };

    // 2) Optional: stop demo visual drivers if present (extensions)
    if(gui.respondsTo(\testMeter_stop)) { gui.testMeter_stop };
    if(gui.respondsTo(\testMarker_clear)) { gui.testMarker_clear };

    // 3) Small confirmation in the status line
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0);
    };
};

// Schedule on AppClock to be safe for UI operations
AppClock.sched(0.0, { setSolidA.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd =====
//02B_HUD_AB_StrictAOnly_PerfHUDorGrid.scd
//v0.2.0
//MD 20250929-13:05

/* Purpose
   - Show Chain A as ACTIVE with a solid highlight in the current HUD.
   - Works with either GridDemo controller (~gui respondsTo \highlightCurrentColumn)
     or the PerfHUD window (~gui is a Window) by drawing an overlay.
Style
   - var-first; AppClock-only UI; no server.sync; idempotent; single-window policy.
*/

(
var ensureGui, useGridDemo, usePerfHUD, makeOverlay, drawSolidA, win;

ensureGui = {
    if(~gui.isNil) {
        // Grab whichever MagicDisplayGUI window exists (likely PerfHUD)
        ~gui = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
    };
    if(~gui.isNil) { "02B: No MagicDisplayGUI window found.".warn; };
    win = if(~gui.isKindOf(Window)) { ~gui } { ~gui.tryPerform(\window) };
    if(win.notNil) { AppClock.sched(0.00, { win.front.alwaysOnTop_(true); nil }) };
};

useGridDemo = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
        if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };   // stop any demo meter overlay if present
        if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
        if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        ^true
    };
    ^false
};

// Draws/updates a translucent overlay on left or right half of the window.
makeOverlay = { |w|
    var root, ov, aTint, bTint;
    root = w.tryPerform(\view);
    if(root.isNil) { ^nil };

    ov = w.getProperty(\md_overlay);
    if(ov.isNil) {
        ov = CompositeView(root);
        ov.name_("MD_OVERLAY");
        ov.resize = 5; // eLeft + eTop + eRight + eBottom
        w.setProperty(\md_overlay, ov);
    };

    // two half-width child views: left = A, right = B
    aTint = w.getProperty(\md_overlay_A);
    if(aTint.isNil) {
        aTint = CompositeView(ov); aTint.name_("MD_OVERLAY_A");
        w.setProperty(\md_overlay_A, aTint);
    };
    bTint = w.getProperty(\md_overlay_B);
    if(bTint.isNil) {
        bTint = CompositeView(ov); bTint.name_("MD_OVERLAY_B");
        w.setProperty(\md_overlay_B, bTint);
    };

    // lay out halves
    ov.bounds = root.bounds;
    aTint.bounds = Rect(0, 0, ov.bounds.width/2, ov.bounds.height);
    bTint.bounds = Rect(ov.bounds.width/2, 0, ov.bounds.width/2, ov.bounds.height);

    // gentle green & neutral tints
    aTint.background = Color(0.85, 1.0, 0.85, 0.50);
    bTint.background = Color(0.92, 0.92, 0.92, 0.00); // start hidden
    ov.front;

    // keep overlay aligned on resize
    if(w.onResize.isNil) {
        w.onResize = {
            var rb = root.bounds;
            ov.bounds = rb;
            aTint.bounds = Rect(0, 0, rb.width/2, rb.height);
            bTint.bounds = Rect(rb.width/2, 0, rb.width/2, rb.height);
        };
    };
    ^w
};

drawSolidA = { |w|
    var ov, aTint, bTint;
    ov = w.getProperty(\md_overlay);
    if(ov.isNil) { makeOverlay.(w) };
    aTint = w.getProperty(\md_overlay_A);
    bTint = w.getProperty(\md_overlay_B);
    if(aTint.notNil) { aTint.background = Color(0.85, 1.0, 0.85, 0.50) };
    if(bTint.notNil) { bTint.background = Color(0.92, 0.92, 0.92, 0.00) };
};

AppClock.sched(0.00, {
    ensureGui.value;
    if(~gui.isNil) { ^nil };
    if(useGridDemo.value.not) {
        // PerfHUD path
        if(win.notNil) {
            makeOverlay.(win);
            drawSolidA.(win);
        };
    };
    nil
});
)

===== troubleshooting/02B_HUD_AB_StrictAOnly_v0.1.4.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:05

/* Purpose
   - Force Chain A to display as ACTIVE with a solid, non-pulsing highlight.
   - Uses the HUD adapter if available (~hud_highlightCurrent), else tries GridDemo.
Style
   - var-first; AppClock UI; idempotent; no server.sync.
*/

(
var apply;

apply = {
    if(~hud_highlightCurrent.notNil) {
        ~hud_highlightCurrent.(\chainA);
        if(~hud_showExpectation.notNil) { ~hud_showExpectation.("HUD: Chain A ACTIVE (solid)", 0) };
    }{
        // Fallback for raw GridDemo controller if adapter missing
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
            if(~gui.respondsTo(\showExpectation)) { ~gui.showExpectation("HUD: Chain A ACTIVE (solid)", 0) };
        }{
            "02B: No HUD adapter and no GridDemo methods; nothing to do.".warn;
        };
    };
};

AppClock.sched(0.0, { apply.value; nil });
)

===== troubleshooting/02B_HUD_AB_StrictAOnly.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid (non‑pulsing) highlight.
 - If ~gui is nil, bring up GridDemo and set ~gui first (single window).
Style
 - var-first; AppClock UI; no server.sync; nil-safe responders; idempotent.
*/

(
var ensureGui, applySolidA;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

applySolidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
    };
    // Shut off any optional demo overlays if present (nil-safe)
    if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };
    if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
};

AppClock.sched(0.00, { ensureGui.value; applySolidA.value; nil });
)

===== troubleshooting/02B_HUD_Receiver_dB_Map.scd =====
// 02B_HUD_Receiver_dB_Map.scd
// v0.1.1
// MD 20250928-2050

(
// Purpose
// - Reinstall the HUD OSCdef to read the *linear* bus taps from "/md/levels_bus"
//   and convert them to a log/decibel-like visual scale on the *language* side.
// - No UGens here; only language methods (known-good): .ampdb, .max, arithmetic.
// - Mapping: floor = -60 dB -> 0.0, 0 dB -> 1.0 (adjust floor as needed).
// Style
// - var-first; no server.sync; UI/OSC on language side; no non-local returns.

var key, minDB, mapToMeter;

// ---- settings ----
key   = \md_levels_hud;  // the same key PerfHUD expects
minDB = -60.0;           // raise to -48 or -42 if you want hotter-looking bars

// ---- mapping function (language side) ----
mapToMeter = { |amp|
    var db, v;
    // guard tiny values to avoid -inf
    db = amp.max(1e-9).ampdb;    // amp -> dB (language method)
    db = db.max(minDB);          // clamp floor
    // map -60..0 dB -> 0..1
    v = (db - minDB) / (0 - minDB);
    v.clip(0, 1)
};

// ---- reinstall the OSCdef safely ----
if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
~md_lastMsgStamp = SystemClock.seconds.asFloat;

OSCdef(key, { |msg|
    // SendReply -> msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R
    var id, lAmp, rAmp, l, r;
    if(msg.size >= 5) {
        id   = msg[2].asInteger;
        lAmp = msg[3].asFloat;
        rAmp = msg[4].asFloat;
        l = mapToMeter.(lAmp);
        r = mapToMeter.(rAmp);
        ~md_levelsById.put(id, [l, r]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);

("[HUD] md_levels_hud reinstalled (dB map; floor = " ++ minDB.asString ++ " dB)").postln;
)

===== troubleshooting/02B_Taps_dB_NoTest_and_HUD.scd =====
// 02B_Taps_dB_NoTest_and_HUD.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose
// - Install server-side dB-mapped taps for Chain A and Chain B only (no "test").
// - Reinstall the HUD receiver to read "/md/levels_bus" and update dict keys:
//   2001 (A) and 2002 (B).
// Style
// - var-first; no server.sync; Server.default.bind; known-good UGens only.

var minDB, makeTapDefOnce, installBusTaps_dB_AB, installHudReceiver_AB, aBus, bBus;
minDB = -60;  // try -48 for hotter visuals

makeTapDefOnce = {
    SynthDef(\md_busTap_db, { |inBus=0, rate=24, replyID=2001, floorDB = -60|
        var sig, aL, aR, dbL, dbR, vL, vR, ln10;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).max(1e-9);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).max(1e-9);
        ln10 = 2.302585092994046; // constant
        dbL = 20 * (log(aL) / ln10);
        dbR = 20 * (log(aR) / ln10);
        dbL = max(dbL, floorDB);
        dbR = max(dbR, floorDB);
        vL  = (dbL - floorDB) / (0 - floorDB);
        vR  = (dbR - floorDB) / (0 - floorDB);
        vL  = LagUD.kr(vL.clip(0,1), 0.02, 0.12);
        vR  = LagUD.kr(vR.clip(0,1), 0.02, 0.12);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [vL, vR], replyID);
    }).add;
    "🔧 SynthDef \\md_busTap_db installed (server-side dB mapping).".postln;
};

installBusTaps_dB_AB = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;

        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };

        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, aBus, \rate, 24, \replyID, 2001, \floorDB, minDB]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, bBus, \rate, 24, \replyID, 2002, \floorDB, minDB]);
        "📡 Bus taps (dB) active for A/B only (floor=" ++ minDB.asString ++ " dB).".postln;
    });
};

installHudReceiver_AB = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        // SendReply => [ path, nodeID, replyID, L, R ]
        var id, l, r;
        if(msg.size >= 5) {
            id = msg[2].asInteger;          // 2001 or 2002
            if((id == 2001) or: { id == 2002 }) {
                l = msg[3].asFloat.clip(0,1);
                r = msg[4].asFloat.clip(0,1);
                ~md_levelsById.put(id, [l, r]);
                ~md_lastMsgStamp = SystemClock.seconds.asFloat;
            };
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] md_levels_hud listening on /md/levels_bus (A/B only).".postln;
};

makeTapDefOnce.value;
installBusTaps_dB_AB.value;
installHudReceiver_AB.value;
"✅ dB taps installed and HUD receiver set (A=2001, B=2002).".postln;
)

===== troubleshooting/02C_Testmelody_Level_Boost.scd =====
// 02C_Testmelody_Level_Boost.scd
// v0.1.0
// MD 20250928-2015
(
// Purpose: temporarily raise testmelody output so meters are clearly visible.
// Style: var-first; server ops in Server.default.bind.

var boost;
boost = {
    Server.default.bind({
        // Reinstall the same testmelody with a slightly higher amp (0.22 -> 0.40)
        Ndef(\testmelody, {
            var trig = Impulse.kr(2.4);
            var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
            var scale = [60, 62, 64, 67, 69];
            var f = Select.kr(sel, scale).midicps;
            var env = Decay2.kr(trig, 0.01, 0.35);
            var pan = LFNoise1.kr(0.35).range(-0.6, 0.6);
            Pan2.ar(SinOsc.ar(f) * env * 0.40, pan)  // <-- boosted
        });
    });
    "⬆️ testmelody amp boosted (0.40).".postln;
};
boost.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02E_Meter_Floor_Adjust.scd =====
// 02E_Meter_Floor_Adjust.scd
// v0.1.0
// MD 20250929-0912

(
// Purpose
// - Adjust the dB floor used by the md_busTap_db Synths on the fly.
// - Example sets floor to -48 dB (hotter visuals). Re-run with -60 to restore.
// Style
// - var-first; server ops in Server.default.bind.

var setFloorDB;

setFloorDB = { |floorDB = -48|
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.set(\floorDB, floorDB) };
        if(~md_busTapB.notNil) { ~md_busTapB.set(\floorDB, floorDB) };
        if(~md_busTapT.notNil) { ~md_busTapT.set(\floorDB, floorDB) };
    });
    ("📏 Meter floor set to " ++ floorDB.asString ++ " dB").postln;
};

// Try -48 for a start, or -42 if you want it hotter:
setFloorDB.(-48);
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming copy.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.0
// MD 20250929-1121

/* Purpose
   - Write demo "system state", "choices", and "incoming" text into the existing HUD window.
   - Use the GUI's public API if available:
       showExpectation(String, Int)
       updateTextField(\state | \choices | \lastCommand, String)
   - No server changes; AppClock-only for UI.
   - var-first; lowercase; no server.sync.
*/

(
var g, have, pushStatus, pushChoices, pushIncoming;

g = ~system.notNil.if({ ~system.statusDisplay }, { nil }); // prefer your system GUI if present
have = { |selector| g.notNil and: { g.respondsTo(selector) } };

pushStatus = {
    var text;
    text = "State: serverRunning=true, activeChain=A (demo)\nGroups=(true,true)";
    if(have.(\updateTextField)) { g.updateTextField(\state, text) };
    if(have.(\showExpectation)) { g.showExpectation("System ready — demo text injected", 0) };
};

pushChoices = {
    var txt;
    txt = "Choices:\nFret 7: delay\nFret 9: chorus\nFret 11: reverb\nFret 13: drive";
    if(have.(\updateTextField)) { g.updateTextField(\choices, txt) };
};

pushIncoming = {
    var txt;
    txt = "Incoming: key:a • key:b • key:r (rebuild)";
    if(have.(\updateTextField)) { g.updateTextField(\lastCommand, txt) };
};

// Defer UI calls to AppClock
{
    pushStatus.();
    pushChoices.();
    pushIncoming.();
}.defer;

"[*] 02F: demo HUD text pushed (state/choices/incoming)".postln;
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.2.scd =====
//////////////////////////////////////////////////////////////
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.2
// MD 20250929-1120

/* Purpose
 - Write demo text to the HUD (state / choices / incoming).
 - Uses the public GridDemo API: showExpectation/updateTextField/setOperations.
Style
 - var-first, AppClock for UI, no server.sync, nil-safe responders.
*/

(
var gui, pushStateAndChoices;

gui = ~gui; // should be set by your earlier HUD bring-up step

if(gui.isNil) { "02F_HUD: ~gui is nil (skipping).".warn; ^nil; };

pushStateAndChoices = {
    // 0) (Optional) ensure the Choices panel exists (extension is nil-safe)
    if(gui.respondsTo(\ensureChoicesPanel)) { gui.ensureChoicesPanel };

    // 1) Top status / state line
    if(gui.respondsTo(\updateTextField)) {
        gui.updateTextField(\state, "Mode: treeNav · A=ACTIVE");
    } {
        if(gui.respondsTo(\showExpectation)) {
            gui.showExpectation("Mode: treeNav · A=ACTIVE", 0);
        };
    };

    // 2) Choices list (each line = “fret → name”)
    if(gui.respondsTo(\setOperations)) {
        gui.setOperations([
            "fret 3 → add",      // example entries; replace with your actual current node’s options
            "fret 5 → timebased",
            "fret 7 → modulation",
            "fret 9 → filter"
        ]);
    };

    // 3) “Incoming” (GridDemo doesn’t have a dedicated box; use status line)
    if(gui.respondsTo(\showExpectation)) {
        gui.showExpectation("Incoming: demo-key:a · demo-key:r", 0);
    };
};

// Defer to AppClock for UI safety
AppClock.sched(0.0, { pushStateAndChoices.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.3.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.3
// MD 2025-09-29 12:35

(
var gui, pushHUD;

gui = ~gui;

pushHUD = {
    var choicesLines;
    choicesLines = [
        "fret 3 → add",
        "fret 5 → timebased",
        "fret 7 → modulation",
        "fret 9 → filter"
    ];

    // Prefer GridDemo API
    if(gui.notNil and: { gui.respondsTo(\updateTextField) or: { gui.respondsTo(\showExpectation) } }) {
        if(gui.respondsTo(\updateTextField)) {
            gui.updateTextField(\state, "Mode: treeNav · A=ACTIVE");
        } {
            gui.showExpectation("Mode: treeNav · A=ACTIVE", 0);
        };
        if(gui.respondsTo(\setOperations)) {
            gui.setOperations(choicesLines);
        } {
            // fallback to status if no choices panel in that class
            gui.showExpectation("Choices:\n" ++ choicesLines.join("\n"), 0);
        };
    } {
        // PerfHUD + adapter
        if(~hud_updateTextField.notNil) {
            ~hud_updateTextField.(\state, "Mode: treeNav · A=ACTIVE");
        } { if(~hud_showExpectation.notNil) { ~hud_showExpectation.("Mode: treeNav · A=ACTIVE", 0) } };
        if(~hud_setOperations.notNil) {
            ~hud_setOperations.(choicesLines);
        } {
            if(~hud_showExpectation.notNil) {
                ~hud_showExpectation.("Choices:\n" ++ choicesLines.join("\n"), 0);
            };
        };
    };
};

AppClock.sched(0.0, { pushHUD.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming_v0.1.4.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Write demo text to the HUD via the overlay helpers created by 02H:
   • STATE line
   • CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
 - Assumes 02H_GridDemo_MinHUD_Overlay.scd has already run in this session.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    // If overlay is missing for any reason, create it on the fly:
    if(~gui.isNil or: { ~gui.tryPerform(\window).isNil }) {
        // fall back to GridDemo and create overlay
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    // If helper funcs don’t exist yet, synthesize the minimal overlay now:
    if(~hud_setState.isNil or: { ~hud_setChoices.isNil }) {
        // create a tiny overlay inline (same as 02H but shorter)
        var host, r, panel, stateBox, choicesBox, pad = 8, width = 360, height = 220, titleH = 18;

        host = ~gui.tryPerform(\window).tryPerform(\view);
        r = host.bounds;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.30);
        panel.bounds = Rect(r.width - (width + 12), 12, width, height);

        StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
            .stringColor_(Color(1,1,1,0.8))
            .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color.white)
            .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
            .font_(Font("Monaco", 11))
            .background_(Color(0,0,0,0.10))
            .stringColor_(Color(0.95,0.95,0.95))
            .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ——— Actual demo content push ———
    ~hud_setState.("Mode: treeNav · A=ACTIVE");
    ~hud_setChoices.([
        "fret 3 → add",
        "fret 5 → timebased",
        "fret 7 → modulation",
        "fret 9 → filter"
    ]);
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.5
// MD 2025-09-29 13:28 BST

/* Purpose
 - Write demo text to the HUD via overlay helpers created by 02H/02M:
   • STATE line
   • CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    var host, overlay;

    // Ensure ~gui and overlay exist
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });

    if(overlay.isNil) {
        // run 02H inline if needed (minimal version)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;
        r = host.bounds; width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ——— Actual content push ———
    (~hud_setState !? { ~hud_setState.("Mode: treeNav · A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 → add",
            "fret 5 → timebased",
            "fret 7 → modulation",
            "fret 9 → filter"
        ])
    });
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.0.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.0
// MD 20250929-1310

/* Purpose
   - Add a small overlay HUD panel (STATE + CHOICES) on top of GridDemo,
     without using GridDemo's internal ivars/methods (which are erroring in your build).
   - Export two helpers: ~hud_setState.(textString), ~hud_setChoices.([lines]).
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

// 1) Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

// 2) Remove any previous overlay if re-running
killOld = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

// 3) Create a small overlay panel at top-right
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds; // Rect
    width  = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30); // transparent dark
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    // 3a) Export helpers
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

// 4) Front and banner
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.1.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Add a small overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo’s ivars or buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
};

mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox, titleH, pad, width, height;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360; height = 220; pad = 8; titleH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 12, width, height);

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 13))
        .stringColor_(Color(1,1,1,0.8))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state line)")
        .font_(Font("Monaco", 12))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));

    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay).") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay_v0.1.2.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo’s private ivars or its buggy helpers.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

/* Ensure a single MagicDisplayGUI window and that ~gui is the GridDemo controller */
ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

/* Remove any previous overlay if re-running */
killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

/* Create overlay at top-right (compact; draws above other widgets) */
mkOverlay = {
    var host, r, panel, title, stateBox, choicesBox;
    var pad, width, height, titleH, stateH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 320;          // narrower to avoid covering A/B headers
    height = 170;         // shorter; room for 5–7 lines
    pad = 8;
    titleH = 16;
    stateH = 18;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.28);         // translucent dark
    panel.decorator = FlowLayout(panel.bounds, 0@0, 0@0); // keeps children stable
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front; // ensure on top
    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.82))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateBox = TextView(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color.white)
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesBox = TextView(panel)
        .string_("(choices)")
        .editable_(false)
        .font_(Font("Monaco", 10))
        .background_(Color(0,0,0,0.10))
        .stringColor_(Color(0.93,0.93,0.93))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + pad)
        ));

    // Export helpers:
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, { stateBox.string = textString.asString; nil });
    };
    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = s; nil });
    };

    positionTopRight = { arg margin = 10;
        var rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

/* Re-anchor overlay on window resize */
hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = {
            (~hud_moveTopRight !? { ~hud_moveTopRight.(10) });
        };
    };
};

/* Bring to front and seed banner */
frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.3
// MD 2025-09-29 13:42 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo’s privates. Uses StaticText for guaranteed visibility.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

mkOverlay = {
    var host, r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360;                       // room for multi-line CHOICES
    height = 190;                      // compact but readable
    pad = 8;
    titleH = 16;
    stateH = 18;
    lineH = 14;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front;

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateLabel = StaticText(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.95))
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesLabel = StaticText(panel)
        .string_("CHOICES:")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH));

    choicesBox = StaticText(panel)
        .string_("(choices)")
        .align_(\topLeft)
        .font_(Font("Monaco", 10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6 + lineH + 2,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
        ));

    // ——— Helpers (exported) ———
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, {
            stateLabel.string = textString.asString;
            nil
        });
    };

    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, {
            choicesBox.string = s.size > 0 ? s : "—";
            nil
        });
    };

    positionTopRight = { arg margin = 10;
        var rb;
        rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = { (~hud_moveTopRight !? { ~hud_moveTopRight.(10) }) };
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
    (~hud_setChoices !? { ~hud_setChoices.(["(no choices yet)"]) });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar_v0.1.0.scd =====
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.0
// MD 20250929-1258

/* Purpose
   - Attach tiny A/B bus meters to your existing taps (A=2001, B=2002)
     so GridDemo can display a moving meter bar via its TestMeter extension.
   - Then show a small horizontal "debug meter" inside the right panel, driven by /ampA.
Style
   - var-first; AppClock UI; Server.default.bind for server ops; no server.sync; idempotent.
*/

(
var aBus, bBus, mkMeters, showBar, killOld, ensureGui;

aBus = 2001;  // from your tap step (see console)
bBus = 2002;  // from your tap step (see console)

/* 0) Ensure we have a GridDemo GUI controller (non-pulsing)
      If you prefer PerfHUD for this run, skip this ensure block.
*/
ensureGui = {
    if(~gui.isNil) {
        // keep only one MagicDisplayGUI window
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

/* 1) Clean previous meter synths if we re-run */
killOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

/* 2) Create meter synths that publish /ampA and /ampB
      MagicDisplay already defines SynthDefs \busMeterA / \busMeterB (class init).
      We just need to instantiate them on our tap busses.
*/
mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // → sends /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // → sends /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

/* 3) Show a small moving meter bar in GridDemo (right panel, near 'eff:')
      Uses GridDemo’s TestMeter extension (if present). Safe if absent.
*/
showBar = {
    if(~gui.notNil and: { ~gui.respondsTo(\testMeter_attach) }) {
        // show chain A level; change to \B to view next chain
        ~gui.testMeter_attach(\A);
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensureGui.value;
killOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar.scd =====
//////////////////////////////////////////////////////////////
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.1
// MD 20250929-13:02
/* Purpose
   - Attach meter Synths to tap busses (A=2001, B=2002), emitting /ampA,/ampB.
//  - Display a small moving bar inside GridDemo (right panel) via TestMeter ext.
Style
   - var-first; Server.default.bind for synths; AppClock for UI; no server.sync.
*/

(
var aBus, bBus, mkMeters, stopOld, showBar, ensure;

aBus = 2001;  bBus = 2002;

ensure = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

stopOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // → /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // → /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

showBar = {
    if(~gui.respondsTo(\testMeter_attach)) {
        ~gui.testMeter_attach(\A);   // or \B to view NEXT
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensure.value;
stopOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.0.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.0
// MD 20250929-13:10

/* Purpose
   - Show a simple horizontal meter bar driven by your existing taps (A=2001, B=2002).
   - Avoid GridDemo TestMeter extension (which warns and OOC-returns in your build).
   - Instantiates \busMeterA / \busMeterB Synths if needed and listens to /ampA or /ampB.
Style
   - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, ensureSynths, killOld, mkBar, ampKey, oscKey;

aBus = 2001;  bBus = 2002;
whichChain = \A; // change to \B if you want to view NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        if(host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).not) {
            // bring up overlay if missing
            "02M: Overlay missing; creating…".postln;
            thisProcess.interpreter.executeFile(
                Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd"
            )
        };
    };
};

killOld = {
    // free previous synths + OSCdefs + view if re-running
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        // Define/instantiate lightweight bus meters (MagicDisplay provides the SynthDefs)
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };

    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    // OSC driver (choose /ampA or /ampB)
    ampKey = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey = ("mdg_simple_" ++ ampKey.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampKey);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters_v0.1.1.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.1
// MD 2025-09-29 13:20 BST

/* Purpose
 - Display a simple horizontal meter bar in the overlay, driven by your existing taps.
 - Uses MagicDisplay’s \busMeterA/\busMeterB SynthDefs (SendReply → /ampA,/ampB).
 - Avoids GridDemo’s TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain, ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, ampPath, oscKey;

aBus = 2001;  // your tap buses (confirmed by console)
bBus = 2002;
whichChain = \A; // change to \B if you prefer watching NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, hasOverlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    hasOverlay = host.notNil and: { host.children.any({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }) };
    if(hasOverlay.not) {
        // create overlay on the spot
        (
            var r, panel, title, stateBox, choicesBox, titleH, pad, width, height;
            r = host.bounds; width = 360; height = 220; pad = 8; titleH = 18;
            panel = CompositeView(host).name_("MDG_MINHUD");
            panel.background = Color(0,0,0,0.30);
            panel.bounds = Rect(r.width - (width + 12), 12, width, height);
            title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 13))
                   .stringColor_(Color(1,1,1,0.8)).bounds_(Rect(pad, pad, width - 2*pad, titleH));
            stateBox = TextView(panel).string_("(state line)").font_(Font("Monaco", 12))
                       .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                       .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, 22));
            choicesBox = TextView(panel).string_("(choices)").editable_(false)
                         .font_(Font("Monaco", 11)).background_(Color(0,0,0,0.10))
                         .stringColor_(Color(0.95,0.95,0.95))
                         .bounds_(Rect(pad, pad + titleH + 4 + 22 + 6, width - 2*pad, height - (titleH + 4 + 22 + 6 + pad)));
            ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
            ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                                AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        );
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w = uv.bounds.width, val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    ~mdg_meterView = bar;

    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Display a simple horizontal meter bar in the MIN-HUD overlay, driven by your taps.
 - Uses MagicDisplay’s \busMeterA/\busMeterB SynthDefs (SendReply → /ampA,/ampB).
 - Avoids GridDemo’s TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain;
var ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, startOsc;

aBus = 2001;            // confirmed by your taps step
bBus = 2002;
whichChain = \A;        // set to \B to watch NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        // Create overlay quickly (same geometry as 02H)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;

        r = host.bounds;
        width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        ~hud_moveTopRight = { arg margin = 10;
            AppClock.sched(0.0, { panel.bounds = Rect(r.width - (width + margin), margin, width, height); panel.front; nil })
        };
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

startOsc = {
    var ampPath, oscKey;
    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; startOsc.value; nil });
    nil
});
)

===== troubleshooting/02M_GridDemo_SimpleMeters_FromOSC.scd =====
// 02M_GridDemo_SimpleMeters_FromOSC.scd
// v0.2.0
// MD 2025-09-29 13:42 BST

/* Purpose
 - Show a simple horizontal meter bar in the MIN-HUD overlay, driven directly by existing OSC taps.
 - Listens to any of these (whichever arrives first will drive the bar): /md/levels_gui, /md/levels, /ampA, /ampB.
 - Defaults to CURRENT (A). Set whichChain = \B to monitor NEXT instead.
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var whichChain, ensureGui, ensureOverlay, killOld, mkBar, startListeners, parseMsg, pickVal;

whichChain = \A;   // change to \B if you want NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        "02M: creating overlay (02H inline)".postln;
        thisProcess.interpreter.executeFile(Platform.userHomeDir +/+ "02H_GridDemo_MinHUD_Overlay.scd");
    };
};

killOld = {
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free; ~mdg_meterOSC_A = nil };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free; ~mdg_meterOSC_B = nil };
    if(~mdg_meterView.notNil)  { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 16;  // thicker bar

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

// Extract a normalized 0..1 value from a variety of message shapes
pickVal = { arg msg, wantB = false;
    var floats, vL, vR, v;
    // Common shapes:
    //  - ['/ampA', node, l, r] or ['/ampB', node, l, r]
    //  - ['/md/levels_gui', ..., lA, rA, lB, rB] (varies by sender)
    //  - ['/md/levels', ..., numbers...]         (varies by sender)
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        // Heuristic: last 4 floats are usually [lA, rA, lB, rB] (sanitised)
        if(floats.size >= 4) {
            if(wantB.not) {
                vL = floats.at(floats.size - 4);
                vR = floats.at(floats.size - 3);
            }{
                vL = floats.at(floats.size - 2);
                vR = floats.at(floats.size - 1);
            };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            // Fallback: mean of all floats
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startListeners = {
    var wantB, pathA1, pathA2, pathB1, pathB2, chainLabel;
    wantB = (whichChain == \B);
    chainLabel = (wantB.not).if({ "A" }, { "B" });

    pathA1 = (wantB.not).if({ '/ampA' }, { '/ampB' });
    pathA2 = (wantB.not).if({ '/md/levels_gui' }, { '/md/levels_gui' }); // we filter in pickVal
    pathB1 = (wantB.not).if({ '/ampA' }, { '/ampB' });  // both defs update same var
    pathB2 = (wantB.not).if({ '/md/levels' }, { '/md/levels' });

    // Free any previous listeners
    if(~mdg_meterOSC_A.notNil) { ~mdg_meterOSC_A.free };
    if(~mdg_meterOSC_B.notNil) { ~mdg_meterOSC_B.free };

    // Listener 1: /ampA or /ampB
    ~mdg_meterOSC_A = OSCdef(("mdg_meter_" ++ pathA1.asString).asSymbol, { |msg|
        var raw, sm;
        raw = pickVal.(msg, wantB);
        sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        ~mdg_meterVal = sm;
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, pathA1);

    // Listener 2: /md/levels_gui and /md/levels
    ~mdg_meterOSC_B = OSCdef(("mdg_meter_mix").asSymbol, { |msg|
        var raw, sm;
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            raw = pickVal.(msg, wantB);
            sm  = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            ~mdg_meterVal = sm;
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // nil path: catch-all, we'll filter inside
    // Note: if the catch-all is too broad, change to two OSCdef with explicit paths.
    ("02M: meter listening for chain " ++ chainLabel ++ " on /ampA/B + /md/levels(_gui)").postln;
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    mkBar.value;
    startListeners.value;
    nil
});
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd =====
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap.scd =====
// 02S_AssertStereo_ChainAB_and_Retap.scd
// v0.1.0
// MD 20250929-0948

(
// Purpose
// - Force chainA/chainB to allocate *stereo* busses, then rewire A and reattach dB taps.
// - Clears stale 1001 (“test”) dict entry so HUD only shows A/B.
// Style
// - var-first; server ops in Server.default.bind.

var makeStereoBusses, rewireA, restartTaps, clearOldTestDict;

makeStereoBusses = {
    Server.default.bind({
        // Force stereo allocation by setting explicit stereo sources first
        Ndef(\chainA, { Silent.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { Silent.ar(2) }); Ndef(\chainB).ar(2);
        // Materialize bus width
        Ndef(\chainA).play;
        Ndef(\chainB).stop;
    });
    "🛠️ Stereo busses asserted for chainA/chainB.".postln;
};

rewireA = {
    // Keep your exact operator
    Ndef(\chainA) <<> Ndef(\testmelody);
    "🔗 Rewired: testmelody -> chainA.".postln;
};

restartTaps = {
    // Reinstall dB taps using existing SynthDef \md_busTap_db
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainA).bus.index, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainB).bus.index, \rate, 24, \replyID, 2002]);
    });
    "📡 dB taps restarted on asserted stereo busses (A/B).".postln;
};

clearOldTestDict = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_levelsById.removeAt(1001);  // remove “test” so HUD can’t mirror it
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
};

makeStereoBusses.value;
rewireA.value;
restartTaps.value;
clearOldTestDict.value;

"✅ Stereo confirmed, taps reattached. Expect both A bars moving, B near zero.".postln;
)

===== troubleshooting/03_Sanity_Beep.scd =====
// 03_Sanity_Beep.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose: Prove server + audio device are OK (audible 1-second beep).
// Style: var-first; no server.sync.

var playBeep;

playBeep = {
    if(s.serverRunning.not) { s.boot; s.waitForBoot({ "🔁 Server booted for beep.".postln; }) };
    {
        var env = Env.perc(0.005, 0.9).ar(doneAction:2);
        var sig = SinOsc.ar(880) * 0.1 * env;
        Out.ar(0, sig.dup);
    }.play;
    "🔊 Beep should be audible for ~1s.".postln;
};

playBeep.();
)

===== troubleshooting/04_Probes.scd =====
// 04_Probes.scd
// v0.1.0
// MD 20250928-1948

(
// A — Dict snapshot used by the HUD (expect values < 1.0, changing)
var d = ~md_levelsById ? IdentityDictionary.new;
[1001, 2001, 2002].collect({ |k| [k, d[k]] }).postln;
)

(
// B — Log a few /md/levels_bus messages (expect id, then two floats < 1.0)
~probeCount = 0;
if(OSCdef.all.at(\probe_levels_bus).notNil) { OSCdef(\probe_levels_bus).free };
OSCdef(\probe_levels_bus, { |msg|
    var id=msg[2], l=msg[3].asFloat, r=msg[4].asFloat;
    ("[bus] id=" ++ id.asString ++ " l=" ++ l.round(0.003) ++ " r=" ++ r.round(0.003)).postln;
    ~probeCount = (~probeCount ? 0) + 1;
    if(~probeCount >= 12) { OSCdef(\probe_levels_bus).free; "~probe done".postln; };
    nil
}, "/md/levels_bus", recvPort: NetAddr.langPort);
"probe armed /md/levels_bus".postln;
)

===== troubleshooting/98_PerfHUD_Triage_UIOnly.scd =====
// 98_PerfHUD_Triage_UIOnly.scd
// v0.1.0
// MD 2025-09-29 15:30 BST

/* Purpose
 - ZERO-OSC triage: prove we can paint + animate inside the PerfHUD window.
 - Draws a top RED banner, two wide bars near bottom; animates bars via AppClock.
 - Helpers:
     ~ui_wiggle_start.(\A or \B)   // start animation, tint active half
     ~ui_wiggle_stop.()            // stop + remove our overlays
Style
 - var-first; AppClock-only; idempotent; no server.sync; known-good SC API only.
*/

(
var findHudWin, findHost, debugPrintWindows, removeOverlays, makeBanner, makeBars, makeTint, startAnim, stopAnim;

// 0) enumerate windows for sanity
debugPrintWindows = {
    var names;
    names = Window.allWindows.collect({ |w| w.tryPerform(\name) ? "<unnamed>" });
    ("[triage] Windows: " ++ names).postln;
};

// 1) find the MagicDisplayGUI window and its host view
findHudWin = {
    var win;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    win
};

findHost = {
    var win, host, r;
    win = findHudWin.();
    if(win.isNil) { "[triage] MagicDisplayGUI window not found.".warn; ^nil };
    host = win.tryPerform(\view);
    r = host.tryPerform(\bounds);
    ("[triage] Host bounds: " ++ (r ? "<nil>")).postln;
    host
};

// 2) remove our overlays if present
removeOverlays = {
    var host;
    host = findHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["TRI_BANNER","TRI_BAR_A","TRI_BAR_B","TRI_TINT_A","TRI_TINT_B"].includes(n)
        }).do(_.remove);
    };
    if(~tri_task.notNil) { ~tri_task.stop; ~tri_task = nil };
    ~tri_valA = 0.0;
    ~tri_valB = 0.0;
};

// 3) big red banner at top (instant visual proof)
makeBanner = {
    var host, r, banner;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds;
    banner = UserView(host);
    banner.name = "TRI_BANNER";
    banner.bounds = Rect(0, 0, r.width, 18);
    banner.background = Color(1.0, 0.2, 0.2, 0.75); // red translucent
    banner.front;
    host.window.onResize = {
        var r2 = host.bounds;
        banner.bounds = Rect(0, 0, r2.width, 18);
        banner.refresh;
    };
    "[triage] Banner shown (top).".postln;
};

// 4) two wide bars near bottom (A green, B blue)
makeBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 12; h = 16; gap = 10;
    w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(30);
    yA = (yB - h - gap).max(10);

    barA = UserView(host);
    barA.name = "TRI_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.12);
    barA.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    barB = UserView(host);
    barB.name = "TRI_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.12);
    barB.drawFunc = { |uv|
        var wpx, v;
        wpx = uv.bounds.width;
        v = (~tri_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    host.window.onResize = {
        var r2, w2, yA2, yB2;
        r2 = host.bounds;
        w2 = (r2.width - (2*pad)).max(50);
        yB2 = (r2.height - pad - h).max(30);
        yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
    "[triage] Bars created (bottom).".postln;
};

// 5) translucent tint on left or right half to mark ACTIVE
makeTint = { arg which = \A;
    var host, r, midX, tintA, tintB;
    host = findHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old
    host.children.select({ |v|
        var n = v.tryPerform(\name) ? "";
        ["TRI_TINT_A","TRI_TINT_B"].includes(n)
    }).do(_.remove);

    tintA = UserView(host);
    tintA.name = "TRI_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18);

    tintB = UserView(host);
    tintB.name = "TRI_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    host.window.onResize = {
        var r2 = host.bounds, mx = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx, r2.height);
        tintB.bounds = Rect(mx, 0, r2.width - mx, r2.height);
        tintA.refresh; tintB.refresh;
    };
    ("[triage] Active tint → " ++ which.asString).postln;
};

// 6) animation (triangle wave) — no OSC, UI-only
startAnim = { arg which = \A;
    var host, dt, t;
    host = findHost.(); if(host.isNil) { ^nil };

    removeOverlays.();
    makeBanner.();
    makeBars.();
    makeTint.(which);

    dt = 1/30; t = 0.0;
    ~tri_task = Task({
        loop {
            var a = (t % 1.0);   // 0..1 triangle
            var b = 1.0 - a;
            ~tri_valA = a;
            ~tri_valB = b;
            // refresh our bars only
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if((n == "TRI_BAR_A") or: { n == "TRI_BAR_B" }) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.6);
        }
    }).play(AppClock);

    "[triage] UI-only animation started.".postln;
};

stopAnim = {
    removeOverlays.();
    "[triage] UI-only animation stopped.".postln;
};

// Export helpers
~ui_wiggle_start = { arg which = \A; AppClock.sched(0.0, { debugPrintWindows.value; startAnim.(which); nil }) };
~ui_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };

"[triage] Ready: use ~ui_wiggle_start.(\\A) / ~ui_wiggle_stop.()".postln;
)

===== troubleshooting/99_HUD_GridDemo_OneShot.scd =====
// 99_HUD_GridDemo_OneShot.scd
// v0.1.1
// MD 2025-09-29 14:05 BST

/* Purpose
 - One-shot HUD bring-up for GridDemo (non-pulsing), replacing multiple files:
   • close old MagicDisplayGUI windows, bring up GridDemo, set ~gui
   • solid A highlight
   • overlay at top-right with STATE + CHOICES (StaticText only; guaranteed visible)
   • thicker moving meter bar driven by OSC taps (/ampA, /ampB, /md/levels_gui, /md/levels)
   • push demo STATE/CHOICES text
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns in closures.
Run
 - Run after audio/tap steps (e.g., after 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd).
 - To monitor NEXT (B) instead of CURRENT (A), set wantB = true below.
*/

(
var wantB;
var closeWindows, makeGridDemo, ensureReady, solidA, buildOverlay, pushDemoText;
var addMeterBar, startOscDefs, stopOldOscDefs, parseVal, retry;

// ===== CONFIG =====
wantB = false;  // false = monitor CURRENT (A); true = monitor NEXT (B)

// ===== HELPERS =====

closeWindows = {
    Window.allWindows
    .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
    .do(_.close);
};

makeGridDemo = {
    ~gui = MagicDisplayGUI_GridDemo.new;         // controller (not a Window)
    if(~gui.respondsTo(\window)) {
        ~gui.window.front.alwaysOnTop_(true);
    };
};

ensureReady = { arg triesLeft = 20, thenDo = { } ;
    // Wait until ~gui.window.view is non-nil and has a Rect bounds
    AppClock.sched(0.03, {
        var win, host, ok;
        win = ~gui.tryPerform(\window);
        host = win.tryPerform(\view);
        ok = host.notNil and: { host.bounds.notNil };
        if(ok) { thenDo.value(host); nil } {
            if(triesLeft <= 0) { "99: window/view not ready; giving up.".warn; nil } {
                ensureReady.value(triesLeft - 1, thenDo);
            }
        }
    });
};

solidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) { ~gui.highlightCurrentColumn(\chainA) };
};

buildOverlay = { arg host;
    var r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    // Kill any old overlay
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);

    // Layout numbers (kept simple & safe)
    r = host.bounds;
    width = 360; height = 190;
    pad = 8; titleH = 16; stateH = 18; lineH = 14;

    panel = CompositeView(host);
    panel.name = "MDG_MINHUD";
    panel.background = Color(0,0,0,0.30);
    // no .border or decorators (avoids internal draw quirks)
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.front;

    title = StaticText(panel);
    title.string = "MIN-HUD";
    title.font   = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.85);
    title.bounds = Rect(pad, pad, width - 2*pad, titleH);

    stateLabel = StaticText(panel);
    stateLabel.string = "(state)";
    stateLabel.font   = Font("Monaco", 11);
    stateLabel.stringColor = Color(1,1,1,0.95);
    stateLabel.bounds = Rect(pad, pad + titleH + 4, width - 2*pad, stateH);

    choicesLabel = StaticText(panel);
    choicesLabel.string = "CHOICES:";
    choicesLabel.font   = Font("Monaco", 11);
    choicesLabel.stringColor = Color(1,1,1,0.85);
    choicesLabel.bounds = Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH);

    choicesBox = StaticText(panel);
    choicesBox.string = "(choices)";
    choicesBox.font   = Font("Monaco", 10);
    choicesBox.stringColor = Color(0.95,0.95,0.95);
    choicesBox.bounds = Rect(
        pad,
        pad + titleH + 4 + stateH + 6 + lineH + 2,
        width - 2*pad,
        height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
    );

    // Export helpers
    ~hud_setState = { arg s;
        AppClock.sched(0.0, { stateLabel.string = s.asString; nil });
    };
    ~hud_setChoices = { arg lines;
        var txt;
        txt = (lines ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, { choicesBox.string = (txt.size > 0).if({ txt }, { "—" }); nil });
    };

    // Re-anchor after any resize
    if(~gui.respondsTo(\window)) {
        ~gui.window.onResize = {
            var rb = host.bounds;
            panel.bounds = Rect(rb.width - (width + 12), 10, width, height);
            panel.front;
        };
    };

    // Create thicker meter bar at bottom of the overlay
    addMeterBar.value(panel);
};

addMeterBar = { arg overlay;
    var bnds, pad, h, bar;

    bnds = overlay.bounds; pad = 8; h = 16;

    // Remove any previous bar if re-running
    overlay.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_SIMPLE_METER" }).do(_.remove);

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.10);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
    ~mdg_meterVal  = 0.0;
};

stopOldOscDefs = {
    if(~mdg_meterOSC_amp.notNil) { ~mdg_meterOSC_amp.free; ~mdg_meterOSC_amp = nil };
    if(~mdg_meterOSC_lvl.notNil) { ~mdg_meterOSC_lvl.free; ~mdg_meterOSC_lvl = nil };
};

parseVal = { arg msg, wantNext;
    var floats, vL, vR, v;
    floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
    if(msg[0] == '/ampA' or: { msg[0] == '/ampB' }) {
        vL = (floats.size > 2).if({ floats[2] }, { 0.0 });
        vR = (floats.size > 3).if({ floats[3] }, { vL });
        v  = ((vL + vR) * 0.5).clip(0, 1);
        ^v;
    };
    if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
        if(floats.size >= 4) {
            if(wantNext.not) { vL = floats.at(floats.size - 4); vR = floats.at(floats.size - 3) }
            { vL = floats.at(floats.size - 2); vR = floats.at(floats.size - 1) };
            v = ((vL + vR) * 0.5).clip(0, 1);
            ^v;
        }{
            v = (floats.size > 0).if({ floats.mean.clip(0,1) }, { 0.0 });
            ^v;
        };
    };
    ^0.0;
};

startOscDefs = {
    var wantNext, ampPath;
    wantNext = wantB;

    stopOldOscDefs.value;

    // 1) Prefer /ampA or /ampB if present (bus meters)
    ampPath = (wantNext.not).if({ '/ampA' }, { '/ampB' });
    ~mdg_meterOSC_amp = OSCdef(("mdg_meter_" ++ ampPath.asString).asSymbol, { |msg|
        var raw = parseVal.(msg, wantNext);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);

    // 2) Also listen to /md/levels_gui and /md/levels explicitly
    ~mdg_meterOSC_lvl = OSCdef(\mdg_meter_levels_mux, { |msg|
        if(msg[0] == '/md/levels_gui' or: { msg[0] == '/md/levels' }) {
            var raw = parseVal.(msg, wantNext);
            ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (raw * 0.3);
            AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
        };
    }, nil); // catch all; we filter inside
    ("99: meter listening for chain " ++ (wantNext.if({ "B" }, { "A" })) ++ " on /ampA/B + /md/levels(_gui)").postln;
};

pushDemoText = {
    (~hud_setState !? { ~hud_setState.("Mode: treeNav · A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 → add",
            "fret 5 → timebased",
            "fret 7 → modulation",
            "fret 9 → filter"
        ])
    });
};

// ===== RUN (guarded sequence) =====

AppClock.sched(0.00, { closeWindows.value; nil });
AppClock.sched(0.08, {
    makeGridDemo.value;
    solidA.value;
    ensureReady.value(20, { arg host;
        buildOverlay.value(host);
        // Give layout a breath, then meters + text
        AppClock.sched(0.06, {
            addMeterBar.value(host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }));
            startOscDefs.value;
            pushDemoText.value;
            nil
        });
        nil
    });
    nil
});
)

===== troubleshooting/99_PerfHUD_BringUp_OneShot.scd =====
// 99_PerfHUD_BringUp_OneShot.scd
// v0.1.0
// MD 2025-09-29 14:25 BST

/* Purpose
 - Bring up (or focus) the PerfHUD window reliably with minimal moving parts.
 - Verify that meter data is arriving via OSC for a couple of seconds.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
   (so taps are armed and /md/levels(_gui)/ampA/ampB are flowing).
*/

(
var perfHudPath, ensurePerfHUD, waitForWindow, startProbe, stopProbe;

// Path as seen in your logs
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// 1) Ensure PerfHUD is loaded; DO NOT close existing windows (avoid flicker/races)
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD…".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing…".postln;
    };
};

// 2) Wait for the MagicDisplayGUI window, bring to front + always-on-top
waitForWindow = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        if(win.notNil) {
            win.front.alwaysOnTop_(true);
            ~perfHUDWin = win; // publish for convenience
            thenDo.value(win);
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not found; giving up.".warn; nil }{
                waitForWindow.value(triesLeft - 1, thenDo);
            }
        }
    });
};

// 3) Brief OSC probe: confirm meter messages are arriving; auto-stops
startProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\perfHUD_probe, { |msg|
        var path = msg[0];
        if(
            path == '/md/levels'
            or: { path == '/md/levels_gui' }
            or: { path == '/ampA' }
            or: { path == '/ampB' }
        ) {
            ("[levels] " ++ path ++ " · size=" ++ msg.size).postln;
        };
    }, nil);
    "99: Probing /md/levels(_gui) & /ampA/B for 2 seconds…".postln;
    AppClock.sched(2.0, { stopProbe.value; nil });
};

stopProbe = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: Probe stopped.".postln;
};

// —— RUN —— //
AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, { waitForWindow.value(40, { startProbe.value }); nil });
)

===== troubleshooting/99_PerfHUD_FixAndVerify_OneShot.scd =====
// 99_PerfHUD_FixAndVerify_OneShot.scd
// v0.2.0
// MD 2025-09-29 14:32 BST

/* Purpose
 - One-shot: make the existing PerfHUD window show MOVING METERS, highlight ACTIVE chain,
   and prove pane text updates, without closing windows or touching audio routing.
 - Bridges /md/levels → also emit /md/levels_gui + /ampA + /ampB on the language port,
   so PerfHUD will update regardless of which path it is listening to internally.
 - Writes demo text via common GUI hooks (if exposed by PerfHUD’s compat shim).
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; nil-safe; no caret-returns.
Run
 - Run AFTER: 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd (taps armed).
Flip
 - Set wantB=true to highlight NEXT (B) instead of CURRENT (A).
*/

(
var wantB;
var perfHudPath, ensurePerfHUD, waitForGui, setHighlight, pushDemoText;
var installBridges, freeBridges, bridgeLevelsToGuiAndAmp, mkLocalSender, probeStart, probeStop;

// ===== CONFIG =====
wantB = false; // false = highlight A; true = highlight B

// ===== PATH to PerfHUD script (from your logs) =====
perfHudPath = (
    Platform.userExtensionDir
    ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting"
    ++ "/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd"
).standardizePath;

// ===== HELPERS =====

mkLocalSender = {
    var addr;
    addr = NetAddr("127.0.0.1", NetAddr.langPort);
    ^addr
};

// 1) Ensure PerfHUD exists; DO NOT close existing GUI (avoid flicker/race).
ensurePerfHUD = {
    var existing;
    existing = Window.allWindows.detect({ |w|
        (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    });
    if(existing.isNil) {
        if(File.exists(perfHudPath)) {
            "99: Loading PerfHUD…".postln;
            perfHudPath.load;
        }{
            ("99: PerfHUD file not found:\n" ++ perfHudPath).warn;
        };
    }{
        "99: PerfHUD already present; focusing…".postln;
        existing.front.alwaysOnTop_(true);
    };
};

// 2) Wait until a GUI handle is usable.
//    PerfHUD usually installs a ~gui compat shim; if not, we still proceed with window only.
waitForGui = { arg triesLeft = 40, thenDo = { } ;
    AppClock.sched(0.05, {
        var win, ok;
        win = Window.allWindows.detect({ |w|
            (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        });
        // Accept either ~gui controller (preferable) or at least the window
        ok = (win.notNil) and: { (~gui.notNil) or: { true } };
        if(ok) {
            if(~gui.isNil) {
                // Try to capture a compat controller if PerfHUD exposed one (harmless if not)
                ~gui = ~gui ?? { nil };
            };
            win.front.alwaysOnTop_(true);
            thenDo.value;
            nil
        }{
            if(triesLeft <= 0) { "99: PerfHUD window not ready; giving up.".warn; nil }
            { waitForGui.value(triesLeft - 1, thenDo) }
        }
    });
};

// 3) Highlight ACTIVE chain (default A). If compat shim exposes highlightCurrentColumn, use it.
setHighlight = {
    var targetSym;
    targetSym = (wantB.not).if({ \chainA }, { \chainB });
    if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
        ~gui.highlightCurrentColumn(targetSym);
        ("99: highlight set via GUI method → " ++ targetSym.asString).postln;
    }{
        // fallback: post only; we avoid direct view hacking in PerfHUD for safety
        ("99: highlight method not found (GUI compat shim missing?) — expected " ++ targetSym.asString).warn;
    };
};

// 4) Push DEMO TEXT: try showExpectation → updateTextField → setOperations (if present).
pushDemoText = {
    var stateText, lines;
    stateText = (wantB.not).if({ "Mode: test · ACTIVE=A" }, { "Mode: test · ACTIVE=B" });
    lines = ["fret 3 → add", "fret 5 → timebased", "fret 7 → modulation", "fret 9 → filter"];

    if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
        ~gui.showExpectation(stateText, 0);
        "99: showExpectation OK".postln;
    }{
        if(~gui.notNil and: { ~gui.respondsTo(\updateTextField) }) {
            ~gui.updateTextField(\state, stateText);
            "99: updateTextField(:state) OK".postln;
        }{
            "99: No text API found on GUI (skipping)".warn;
        };
    };
    if(~gui.notNil and: { ~gui.respondsTo(\setOperations) }) {
        ~gui.setOperations(lines);
        "99: setOperations OK".postln;
    }{
        "99: setOperations not available (skipping choices text)".postln;
    };
};

// 5) Bridge /md/levels → also emit /md/levels_gui and /ampA/B so PerfHUD meters move.
freeBridges = {
    if(~osc_bridge_levels.notNil) { ~osc_bridge_levels.free; ~osc_bridge_levels = nil };
    if(~osc_bridge_gui.notNil)    { ~osc_bridge_gui.free; ~osc_bridge_gui    = nil };
};
bridgeLevelsToGuiAndAmp = {
    var out, lastPrint;
    var routeA, routeB;

    out = mkLocalSender.value;
    lastPrint = 0.0;

    // Helper to emit ampA/ampB from 4 floats [lA, rA, lB, rB]
    routeA = { arg lA = 0.0, rA = 0.0; out.sendMsg('/ampA', 0, lA, rA) };
    routeB = { arg lB = 0.0, rB = 0.0; out.sendMsg('/ampB', 0, lB, rB) };

    // Bridge from /md/levels → duplicate as /md/levels_gui and /ampA/B
    ~osc_bridge_levels = OSCdef(\md_bridge_levels, { |msg, time, addr, recvPort|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // Emit a straight pass-through for GUI path (same payload except the path)
        out.sendMsg('/md/levels_gui', *floats);

        // Try to extract last 4 floats as [lA, rA, lB, rB]; fallback to mean pairs if shorter
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };
        routeA.value(lA.clip(0,1), rA.clip(0,1));
        routeB.value(lB.clip(0,1), rB.clip(0,1));

        // Throttled console confirmation
        if((SystemClock.seconds - lastPrint) > 0.50) {
            ("99: bridged levels → GUI + ampA/B   A=(" ++ lA.round(0.01) ++ "," ++ rA.round(0.01)
              ++ ")  B=(" ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")").postln;
            lastPrint = SystemClock.seconds;
        };
    }, '/md/levels');

    // Also, if someone else sends /md/levels_gui only, mirror to ampA/B as well.
    ~osc_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            routeA.value(lA.clip(0,1), rA.clip(0,1));
            routeB.value(lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: bridges installed (levels → gui + ampA/B)".postln;
};

// 6) Short probe: print any arriving meter messages for visibility (auto-stop)
probeStart = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    ~osc_probe = OSCdef(\md_probe_any, { |msg|
        var p = msg[0];
        if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/ampA' } or: { p == '/ampB' }) {
            ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
        };
    }, nil);
    "99: probe: watching /md/levels(_gui) & /ampA/B for 2s…".postln;
    AppClock.sched(2.0, { probeStop.value; nil });
};
probeStop = {
    if(~osc_probe.notNil) { ~osc_probe.free; ~osc_probe = nil };
    "99: probe stopped.".postln;
};

// 7) Uninstall bridges if you need to revert
~hud_fix_stop = {
    freeBridges.value;
    probeStop.value;
    "99: bridges and probe removed.".postln;
};

// ===== RUN (guarded) =====

AppClock.sched(0.00, { ensurePerfHUD.value; nil });
AppClock.sched(0.10, {
    waitForGui.value(40, {
        setHighlight.value;
        pushDemoText.value;
        freeBridges.value;
        installBridges.value;  // forward-declare call — see below
        probeStart.value;
        nil
    });
    nil
});

// We bind the bridge installer late to avoid forward-ref warnings in some editors
installBridges = { bridgeLevelsToGuiAndAmp.value };
)

===== troubleshooting/99_PerfHUD_MetersFromBusses_v0.1.0.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.0
// MD 2025-09-29 15:18 BST

(
var aBus, bBus;
var mkDefs, startMeters, uiNudge;

aBus = 2001;  // your tap buses
bBus = 2002;

mkDefs = {
    Server.default.bind({
        SynthDef(\md_levels4_from_busses, { arg inA=2001, inB=2002, rate=24;
            var a, b, la, ra, lb, rb, t;
            a  = In.ar(inA, 2);
            b  = In.ar(inB, 2);
            la = Amplitude.ar(a[0], 0.01, 0.20).clip(0, 1);
            ra = Amplitude.ar(a[1], 0.01, 0.20).clip(0, 1);
            lb = Amplitude.ar(b[0], 0.01, 0.20).clip(0, 1);
            rb = Amplitude.ar(b[1], 0.01, 0.20).clip(0, 1);
            t  = Impulse.kr(rate);
            SendReply.kr(t, '/md/levels_gui', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/md/levels_bus', A2K.kr([la, ra, lb, rb]));
            SendReply.kr(t, '/ampA', A2K.kr([la, ra]));
            SendReply.kr(t, '/ampB', A2K.kr([lb, rb]));
        }).add;
    });
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeters = {
    if(~md_levelsSynth.notNil) { ~md_levelsSynth.free; ~md_levelsSynth = nil };
    Server.default.bind({
        ~md_levelsSynth = Synth(\md_levels4_from_busses, [\inA, aBus, \inB, bBus, \rate, 24]);
    });
    ("99: Started md_levels4_from_busses on A=" ++ aBus ++ "  B=" ++ bBus).postln;
};

uiNudge = {
    AppClock.sched(0.10, {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B taps", 0);
        };
        nil
    });
};

mkDefs.value;
AppClock.sched(0.05, { startMeters.value; uiNudge.value; nil });
)

===== troubleshooting/99_PerfHUD_MetersFromBusses.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.1
// MD 2025-09-29 15:22 BST
(
/* Purpose
   - Bridge two 2-ch AUDIO buses (A and B) into the PerfHUD UI via OSC:
       • '/md/levels_gui'  → linear amplitudes (0..1)  [A L, A R, B L, B R]
       • '/md/levels_db'   → dBFS values (≈ -inf..0)   [A L, A R, B L, B R]
       • '/ampA', '/ampB'  → linear pairs for legacy listeners
   - Provide optional test pattern (fixed values) to prove the UI is controllable.
   - Optionally print a few lines of dB to the console to validate input sanity.

Style
   - var-first everywhere; descriptive lowercase names; no single-letter locals.
   - Server.default.bind for server ops; AppClock for UI; no server.sync; no non-local returns.
*/

var busIndexA, busIndexB;
var attackSeconds, releaseSeconds, updateRateHz;
var useTestPattern, testValueAL, testValueAR, testValueBL, testValueBR;
var printDbLinesCount;

var installSynthDefinitions, startMeterBridge, nudgeHudOnce, installDbConsolePrinter;

// --- Configuration (edit these if needed) ------------------------------------
busIndexA        = 2001;        // your A-tap bus index (2 channels expected)
busIndexB        = 2002;        // your B-tap bus index (2 channels expected)
attackSeconds    = 0.01;        // Amplitude.kr attack time
releaseSeconds   = 0.20;        // Amplitude.kr release time
updateRateHz     = 24;          // OSC update rate for GUI

useTestPattern   = false;       // set true to drive meters with fixed values
testValueAL      = 0.25;        // A left (linear 0..1)
testValueAR      = 0.50;        // A right
testValueBL      = 0.75;        // B left
testValueBR      = 0.50;        // B right

printDbLinesCount = 6;          // number of dB lines to print to console (0 disables)

// --- Definitions --------------------------------------------------------------
installSynthDefinitions = {
    var synthAdder;

    synthAdder = {
        // Two-bus (stereo+stereo) → linear + dB, with optional test pattern
        SynthDef(\md_levels4_from_busses, {
            arg inBusA = 2001, inBusB = 2002, updatesPerSecond = 24,
                ampAttack = 0.01, ampRelease = 0.20,
                enableTestPattern = 0,
                patternAL = 0.25, patternAR = 0.50, patternBL = 0.75, patternBR = 0.50;

            var inputStereoA, inputStereoB;
            var ampLinearAL, ampLinearAR, ampLinearBL, ampLinearBR;
            var linearAL, linearAR, linearBL, linearBR;
            var dbAL, dbAR, dbBL, dbBR;
            var updateTrigger;
            var minLinearFloor;

            // Read 2 channels from each bus
            inputStereoA = In.ar(inBusA, 2);
            inputStereoB = In.ar(inBusB, 2);

            // Measure linear amplitude at control rate
            ampLinearAL = Amplitude.kr(inputStereoA[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearAR = Amplitude.kr(inputStereoA[1], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBL = Amplitude.kr(inputStereoB[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBR = Amplitude.kr(inputStereoB[1], ampAttack, ampRelease).clip(0.0, 1.0);

            // Select measured vs. test pattern
            linearAL = Select.kr(enableTestPattern, [ampLinearAL, patternAL]);
            linearAR = Select.kr(enableTestPattern, [ampLinearAR, patternAR]);
            linearBL = Select.kr(enableTestPattern, [ampLinearBL, patternBL]);
            linearBR = Select.kr(enableTestPattern, [ampLinearBR, patternBR]);

            // Convert to dB (guard the floor to avoid -inf)
            minLinearFloor = 1e-7;
            dbAL = (max(linearAL, minLinearFloor)).log10 * 20.0;
            dbAR = (max(linearAR, minLinearFloor)).log10 * 20.0;
            dbBL = (max(linearBL, minLinearFloor)).log10 * 20.0;
            dbBR = (max(linearBR, minLinearFloor)).log10 * 20.0;

            // Tick and send
            updateTrigger = Impulse.kr(updatesPerSecond);

            // Linear for GUI
            SendReply.kr(updateTrigger, '/md/levels_gui', [linearAL, linearAR, linearBL, linearBR]);

            // dB for console or dB-aware GUIs
            SendReply.kr(updateTrigger, '/md/levels_db',  [dbAL, dbAR, dbBL, dbBR]);

            // Legacy: per-chain linear pairs
            SendReply.kr(updateTrigger, '/ampA', [linearAL, linearAR]);
            SendReply.kr(updateTrigger, '/ampB', [linearBL, linearBR]);
        }).add;
    };

    Server.default.bind(synthAdder);
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeterBridge = {
    var freeOld, startNew;

    freeOld = {
        if(~md_levelsSynth.notNil) {
            ~md_levelsSynth.free;
            ~md_levelsSynth = nil;
        };
    };

    startNew = {
        Server.default.bind({
            ~md_levelsSynth = Synth(
                \md_levels4_from_busses,
                [
                    \inBusA,          busIndexA,
                    \inBusB,          busIndexB,
                    \updatesPerSecond, updateRateHz,
                    \ampAttack,        attackSeconds,
                    \ampRelease,       releaseSeconds,
                    \enableTestPattern, (useTestPattern.if({ 1 }, { 0 })),
                    \patternAL,        testValueAL,
                    \patternAR,        testValueAR,
                    \patternBL,        testValueBL,
                    \patternBR,        testValueBR
                ]
            );
        });
        ("99: Started md_levels4_from_busses on A=" ++ busIndexA
            ++ "  B=" ++ busIndexB
            ++ "  testPattern=" ++ useTestPattern).postln;
    };

    freeOld.();
    startNew.();
};

nudgeHudOnce = {
    var doIt;

    doIt = {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B buses", 0);
        };
        nil
    };

    AppClock.sched(0.10, doIt);
};

installDbConsolePrinter = {
    var oscKeyName, linesRemaining;

    oscKeyName     = \md_levels_db_console_printer;
    linesRemaining = printDbLinesCount.max(0).asInteger;

    // Optional: print a few dB lines then auto-stop
    if(linesRemaining > 0) {
        OSCdef(oscKeyName, { arg message;
            var dbLeftA, dbRightA, dbLeftB, dbRightB, lineText;

            if(message.size >= 5) {
                // ['/md/levels_db', nodeID, replyID, dB_AL, dB_AR, dB_BL, dB_BR] (nodeID/replyID vary by build)
                dbLeftA   = message[3].round(0.1);
                dbRightA  = message[4].round(0.1);
                dbLeftB   = message[5].round(0.1);
                dbRightB  = message[6].round(0.1);

                lineText = "[dB]  A: L=" ++ dbLeftA  ++ " dB  R=" ++ dbRightA
                         ++ "   |   B: L=" ++ dbLeftB ++ " dB  R=" ++ dbRightB;
                lineText.postln;

                linesRemaining = linesRemaining - 1;
                if(linesRemaining <= 0) {
                    OSCdef(oscKeyName).free;
                    "[dB] console printer finished.".postln;
                };
            };
        }, '/md/levels_db');
    };
};

// --- Run sequence -------------------------------------------------------------
installSynthDefinitions.();
installDbConsolePrinter.();               // prints a few lines if printDbLinesCount > 0
AppClock.sched(0.05, {
    startMeterBridge.();
    nudgeHudOnce.();
    nil
});
)

===== troubleshooting/99_PerfHUD_MetersNow_v2.scd =====
// 99_PerfHUD_MetersNow_v2.scd
// v0.2.1
// MD 2025-09-29 14:55 BST

/* Purpose
 - Make PerfHUD meters MOVE by bridging your real level messages to the paths PerfHUD reads,
   after SANITIZING payloads (strip bus IDs / counters; normalize to 0..1).
 - Listens on: /md/levels AND /md/levels_gui
 - Emits to : /md/levels_bus  (and mirrors to /ampA, /ampB)
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe; verbose console for verification.
*/

(
var out, freeAll, startBridge, stopBridge, extract4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean previous bridges
freeAll = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
};

// 2) dB → 0..1 using a floor (default -48 dB mapped to 0)
normDb = { arg dbVal, floorDb = -48.0;
    var x = dbVal ? floorDb;
    x = x.clip(floorDb, 0.0);
    ^((x - floorDb) / (0.0 - floorDb))  // 0..1
};

// 3) Extract the last 4 meaningful floats [lA,rA,lB,rB] from a float list.
//    - Prefer values already in 0..1
//    - Else accept dB-ish (-120..+6) and convert via normDb
//    - Ignore obvious bus IDs / counters (>= 2.0 and not dB-range)
extract4 = { arg floatsIn;
    var f, tail4, useDb, vA1, vA2, vB1, vB2, floats01, floatsDbRange;

    f = (floatsIn ? []).collect(_.asFloat);

    // 3a) Try to find a **last** window of 4 floats already within 0..1
    floats01 = f.select({ |x| x.isNumber and: { (x >= 0.0) and: (x <= 1.0) } });
    if(floats01.size >= 4) {
        tail4 = floats01.keepLast(4);
        ^tail4; // already 0..1
    };

    // 3b) Else try dB-like values (e.g., -48..0 or up to +6)
    floatsDbRange = f.select({ |x| x.isNumber and: { (x >= -120.0) and: (x <= 6.0) } });
    if(floatsDbRange.size >= 4) {
        tail4 = floatsDbRange.keepLast(4);
        vA1 = normDb.(tail4[0]); vA2 = normDb.(tail4[1]);
        vB1 = normDb.(tail4[2]); vB2 = normDb.(tail4[3]);
        ^[vA1, vA2, vB1, vB2];
    };

    // 3c) Last resort: take **any** floats, drop obviously huge values (>= 2.0),
    //     then if still not enough, pad with zeros.
    tail4 = f.reject({ |x| x >= 2.0 }).keepLast(4);
    tail4 = (tail4 ++ Array.fill((4 - tail4.size).max(0), { 0.0 })).keepLast(4);
    // clip to 0..1 to be safe
    ^tail4.collect({ |x| x.clip(0.0, 1.0) });
};

// 4) Start the sanitizing bridge
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v2 = OSCdef(\md_bridge_levels_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);  // [lA,rA,lB,rB] normalized 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        // Emit to PerfHUD-friendly paths
        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels → levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui_v2 = OSCdef(\md_bridge_gui_v2, { |msg|
        var floats, chosen, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        chosen = extract4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        postThrottle.value("99v2: /md/levels_gui → levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels_gui');

    "99v2: BRIDGE active (sanitized → levels_bus + ampA/B)".postln;
};

stopBridge = {
    if(~md_bridge_levels_v2.notNil) { ~md_bridge_levels_v2.free; ~md_bridge_levels_v2 = nil };
    if(~md_bridge_gui_v2.notNil)    { ~md_bridge_gui_v2.free;    ~md_bridge_gui_v2    = nil };
    "99v2: BRIDGE stopped.".postln;
};

// Run
freeAll.value;
startBridge.value;
)

===== troubleshooting/99_PerfHUD_MetersNow_v3.scd =====
// 99_PerfHUD_MetersNow_v3.scd
// v0.3.0
// MD 2025-09-29 15:05 BST

/* Purpose
 - Make PerfHUD meters move by sanitizing level messages before forwarding:
   • Listen:  /md/levels   and  /md/levels_gui
   • Emit  :  /md/levels_bus   (and mirror to /ampA, /ampB)
 - Sanitizer rules (known-good SC only, no non-existent methods):
   1) Prefer the last 4 floats in 0..1
   2) Else prefer the last 4 floats in dB-ish range [-120..+6], map to 0..1 (floor = -48 dB)
   3) Else drop floats >= 2.0 (IDs/counters), take last 4, clip to 0..1
Style
 - var-first; AppClock-only scheduling; no server.sync; idempotent; nil-safe; conservative logging.
*/

(
var out, freeBridges, startBridges, stopBridges, sanitize4, normDb, lastPost;

// 0) Local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean any previous bridges
freeBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
};

// 2) dB → 0..1 with floor
normDb = { arg dbVal, floorDb = -48.0;
    var x;
    x = (dbVal ? floorDb);
    x = x.clip(floorDb, 0.0);
    // linear from floorDb..0 dB → 0..1
    ((x - floorDb) / (0.0 - floorDb))
};

// 3) Get the **last** 4 usable floats
sanitize4 = { arg floatsIn;
    var f, i, count, res, v, dbCand, last4FromDb, raw, startIndex, endIndex;

    // Defensive copy of floats
    f = (floatsIn ? []).collect(_.asFloat);

    // (A) Prefer the last 4 in 0..1
    res = Array.new;
    i = f.size - 1;
    while({ i >= 0 and: { res.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= 0.0) and: (v <= 1.0) }) {
            res = res.add(v);
        };
        i = i - 1;
    });
    if(res.size >= 4) {
        res = res.reverse; // we collected backwards
        ^res;
    };

    // (B) Else, try last 4 in dB-ish range [-120..+6] → map to 0..1
    dbCand = Array.new; i = f.size - 1;
    while({ i >= 0 and: { dbCand.size < 4 } }, {
        v = f.at(i);
        if(v.isNumber and: { (v >= -120.0) and: (v <= 6.0) }) {
            dbCand = dbCand.add(v);
        };
        i = i - 1;
    });
    if(dbCand.size >= 4) {
        dbCand = dbCand.reverse;
        last4FromDb = dbCand.collect({ arg x; normDb.(x) });
        ^last4FromDb;
    };

    // (C) Last resort: drop obvious IDs/counters (>= 2.0), take last 4, clip 0..1
    raw = f.select({ arg x; x.isNumber and: { x < 2.0 } });
    if(raw.size >= 4) {
        startIndex = (raw.size - 4).max(0);
        endIndex   = raw.size - 1;
        res = raw.copyRange(startIndex, endIndex).collect({ arg x; x.clip(0.0, 1.0) });
        ^res;
    }{
        // Not enough candidates: pad with zeros
        res = raw.collect({ arg x; x.clip(0.0, 1.0) });
        while({ res.size < 4 }, { res = res.add(0.0) });
        ^res;
    };
};

// 4) Bridges: listen → sanitize → forward
startBridges = {
    var throttle;

    throttle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.60) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels_v3 = OSCdef(\md_bridge_levels_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);

        // for visibility, show the numeric tail we saw (up to last 6 floats)
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats); // [lA,rA,lB,rB] in 0..1
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels tail=" ++ rawTail
            ++ "  → bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels');

    ~md_bridge_gui_v3 = OSCdef(\md_bridge_gui_v3, { |msg|
        var floats, chosen, lA, rA, lB, rB, startIndex, endIndex, rawTail;

        floats = msg.select({ arg x; x.isNumber }).collect(_.asFloat);
        startIndex = (floats.size - 6).max(0);
        endIndex   = floats.size - 1;
        rawTail = (floats.size > 0).if({
            floats.copyRange(startIndex, endIndex)
        }, { [] });

        chosen = sanitize4.(floats);
        lA = chosen[0]; rA = chosen[1]; lB = chosen[2]; rB = chosen[3];

        out.sendMsg('/md/levels_bus', lA, rA, lB, rB);
        out.sendMsg('/ampA', 0, lA, rA);
        out.sendMsg('/ampB', 0, lB, rB);

        throttle.value(("99v3: /md/levels_gui tail=" ++ rawTail
            ++ "  → bus A=(" ++ lA.round(0.02) ++ "," ++ rA.round(0.02) ++ ")"
            ++ " B=(" ++ lB.round(0.02) ++ "," ++ rB.round(0.02) ++ ")"));
    }, '/md/levels_gui');

    "99v3: BRIDGE active (sanitized → /md/levels_bus + /ampA/B)".postln;
};

stopBridges = {
    if(~md_bridge_levels_v3.notNil) { ~md_bridge_levels_v3.free; ~md_bridge_levels_v3 = nil };
    if(~md_bridge_gui_v3.notNil)    { ~md_bridge_gui_v3.free;    ~md_bridge_gui_v3    = nil };
    "99v3: BRIDGE stopped.".postln;
};

// Run
freeBridges.value;
startBridges.value;
)

===== troubleshooting/99_PerfHUD_MetersNow.scd =====
// 99_PerfHUD_MetersNow.scd
// v0.1.0
// MD 2025-09-29 14:40 BST

/* Purpose
 - Make PerfHUD meters MOVE immediately without touching the GUI or audio routing.
 - Step 1 (2s): emit a visible ramp to /md/levels_bus and /ampA/B (proof meters react).
 - Step 2 (continuous): bridge your real /md/levels & /md/levels_gui to /md/levels_bus (+ /ampA/B).
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe.
*/

(
var out, freeAll, startProof, stopProof, startBridge, stopBridge, lastPost;

// 0) local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean up any previous helpers
freeAll = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    if(~md_probe_perf.notNil)    { ~md_probe_perf.free;    ~md_probe_perf    = nil };
    if(~md_proof_task.notNil)    { ~md_proof_task.stop;    ~md_proof_task    = nil };
};

// 2) SHORT PROOF: drive a ramp so you SEE the meters move now
startProof = {
    var t = 0.0, dt = 1/24, secs = 2.0, steps = (secs / dt).round(1);
    var stepCount = 0, ramp;
    ramp = {
        // 0..1 triangle for A, inverse for B (obvious visual motion)
        var a = ( (stepCount % 24) / 24 );
        var b = 1.0 - a;
        out.sendMsg('/md/levels_bus', a, a, b, b);  // [lA, rA, lB, rB]
        out.sendMsg('/ampA', 0, a, a);
        out.sendMsg('/ampB', 0, b, b);
        stepCount = stepCount + 1;
    };
    ~md_proof_task = Task({
        steps.do({
            ramp.value;
            dt.wait;
        });
    }).play(AppClock);
    "99: PROOF running for 2s → watch meters MOVE now…".postln;
};

stopProof = {
    if(~md_proof_task.notNil) { ~md_proof_task.stop; ~md_proof_task = nil };
    "99: PROOF stopped.".postln;
};

// 3) BRIDGE real levels → /md/levels_bus (+ mirror to /ampA/B)
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels = OSCdef(\md_bridge_levels, { |msg|
        var floats, lA, rA, lB, rB;

        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // heuristics: last 4 floats are [lA,rA,lB,rB]; fallback if fewer
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };

        // forward to paths PerfHUD commonly consumes
        out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
        out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
        out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));

        postThrottle.value("99: bridged → levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
            out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
            out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: BRIDGE active (levels → levels_bus + ampA/B).".postln;
};

stopBridge = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    "99: BRIDGE stopped.".postln;
};

// 4) Optional: tiny probe (prints any level/amp paths for 2s)
~md_probe_perf = OSCdef(\md_probe_perf, { |msg|
    var p = msg[0];
    if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/md/levels_bus' } or: { p == '/ampA' } or: { p == '/ampB' }) {
        ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
    };
}, nil);

// RUN
freeAll.value;
startProof.value;
AppClock.sched(2.05, { stopProof.value; startBridge.value; nil });
)

===== troubleshooting/99_PerfHUD_UIOnly_Wiggle_Toggle.scd =====
// 99_PerfHUD_UIOnly_Wiggle_Toggle.scd
// v0.1.0
// MD 2025-09-29 15:22 BST

/* Purpose
 - Pure GUI-side diagnostic: animate two meter bars (A/B) inside the PerfHUD window
   WITHOUT OSC, to prove the window can update; also tint ACTIVE column and show test text.
 - Provides helpers:
     ~hud_wiggle_start.(\A or \B)   // start animation, choose active column
     ~hud_wiggle_stop.()            // stop & remove overlays
     ~hud_text.("state text", ["choice1", "choice2"])  // show sample texts
Style
 - var-first; AppClock-only; idempotent; nil-safe; no server.sync; no caret-returns in closures.
*/

(
var findHudHost, removeOverlays, mkBars, mkTint, mkText, startAnim, stopAnim;

// --- find the MagicDisplayGUI host view (PerfHUD window) ---
findHudHost = {
    var win, host;
    win = Window.allWindows.detect({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") });
    host = win.tryPerform(\view);
    ^host
};

// --- remove our overlays if present (safe to call anytime) ---
removeOverlays = {
    var host = findHudHost.();
    if(host.notNil) {
        host.children.select({ |v|
            var n = v.tryPerform(\name) ? "";
            ["WGL_BAR_A", "WGL_BAR_B", "WGL_TINT_A", "WGL_TINT_B", "WGL_TEXT"].includes(n)
        }).do(_.remove);
    };
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
};

// --- create two bars near the bottom of the window ---
mkBars = {
    var host, r, pad, h, gap, w, yA, yB, barA, barB;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD host not found.".warn; ^nil };
    r = host.bounds; pad = 12; h = 14; gap = 8; w = (r.width - (2*pad)).max(50);
    yB = (r.height - pad - h).max(10);
    yA = (yB - h - gap).max(10);

    // A
    barA = UserView(host);
    barA.name = "WGL_BAR_A";
    barA.bounds = Rect(pad, yA, w, h);
    barA.background = Color(0,0,0,0.10);
    barA.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valA ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.85, 0.35, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barA.front;

    // B
    barB = UserView(host);
    barB.name = "WGL_BAR_B";
    barB.bounds = Rect(pad, yB, w, h);
    barB.background = Color(0,0,0,0.10);
    barB.drawFunc = { |uv|
        var wpx = uv.bounds.width, v = (~wgl_valB ? 0.0).clip(0,1);
        Pen.fillColor = Color(0.20, 0.55, 0.95, 0.95);
        Pen.fillRect(Rect(0, 0, (wpx * v).max(1), h));
    };
    barB.front;

    // keep re-anchored on resize
    host.window.onResize = {
        var r2 = host.bounds;
        var w2 = (r2.width - (2*pad)).max(50);
        var yB2 = (r2.height - pad - h).max(10);
        var yA2 = (yB2 - h - gap).max(10);
        barA.bounds = Rect(pad, yA2, w2, h);
        barB.bounds = Rect(pad, yB2, w2, h);
        barA.refresh; barB.refresh;
    };
};

// --- tint ACTIVE column (large translucent rect on left or right half) ---
mkTint = { arg which = \A;
    var host, r, leftRect, rightRect, tintA, tintB, midX;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; midX = r.width * 0.5;

    // clear old tints
    host.children.select({ |v| ["WGL_TINT_A","WGL_TINT_B"].includes(v.tryPerform(\name) ? "") }).do(_.remove);

    tintA = UserView(host); tintA.name = "WGL_TINT_A";
    tintA.bounds = Rect(0, 0, midX, r.height);
    tintA.background = Color(0.85, 1.0, 0.85, 0.18); // soft green

    tintB = UserView(host); tintB.name = "WGL_TINT_B";
    tintB.bounds = Rect(midX, 0, r.width - midX, r.height);
    tintB.background = Color(0.85, 1.0, 0.85, 0.18);

    // show only the chosen one
    tintA.visible = (which == \A);
    tintB.visible = (which == \B);
    tintA.front; tintB.front;

    // keep on resize
    host.window.onResize = {
        var r2 = host.bounds, mx2 = r2.width * 0.5;
        tintA.bounds = Rect(0, 0, mx2, r2.height);
        tintB.bounds = Rect(mx2, 0, r2.width - mx2, r2.height);
        tintA.refresh; tintB.refresh;
    };
};

// --- small text block (state + choices) in top-right as a demo ---
mkText = { arg stateStr = "HUD UI-test", choices = #["choice A","choice B"];
    var host, r, pad, w, h, title, body, panel, s;

    host = findHudHost.(); if(host.isNil) { ^nil };
    r = host.bounds; pad = 8; w = 280; h = 120;

    // clear previous
    host.children.select({ |v| (v.tryPerform(\name) ? "") == "WGL_TEXT" }).do(_.remove);

    panel = CompositeView(host).name_("WGL_TEXT");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (w + 12), 12, w, h);
    panel.front;

    title = StaticText(panel);
    title.string = stateStr.asString;
    title.font = Font("Monaco", 12);
    title.stringColor = Color(1,1,1,0.9);
    title.bounds = Rect(pad, pad, w - 2*pad, 18);

    s = choices.collect(_.asString).join("\n");
    body = StaticText(panel);
    body.string = (s.size > 0).if({ s }, { "—" });
    body.font = Font("Monaco", 10);
    body.stringColor = Color(0.95,0.95,0.95);
    body.align = \topLeft;
    body.bounds = Rect(pad, pad + 22, w - 2*pad, h - (pad + 22 + pad));

    // keep anchored
    host.window.onResize = {
        var r2 = host.bounds;
        panel.bounds = Rect(r2.width - (w + 12), 12, w, h);
        panel.front;
    };
};

// --- animation task (no OSC; just wiggle locally) ---
startAnim = { arg active = \A;
    var host, barA, barB, t = 0.0, dt = 1/30;

    host = findHudHost.(); if(host.isNil) { "wiggle: HUD not found".warn; ^nil };

    // build overlays
    mkBars.();
    mkTint.(active);

    // drive values
    if(~wgl_task.notNil) { ~wgl_task.stop; ~wgl_task = nil };
    ~wgl_task = Task({
        loop {
            // simple triangle → obvious motion
            var a = (t % 1.0);
            var b = 1.0 - a;
            ~wgl_valA = a;
            ~wgl_valB = b;
            // refresh our bars
            host.children.do({ |v|
                var n = v.tryPerform(\name) ? "";
                if(["WGL_BAR_A","WGL_BAR_B"].includes(n)) { v.refresh };
            });
            dt.wait;
            t = t + (dt * 0.5); // slow-ish
        }
    }).play(AppClock);
};

stopAnim = {
    removeOverlays.();
};

// export helpers
~hud_wiggle_start = { arg which = \A; AppClock.sched(0.0, { startAnim.(which); nil }) };
~hud_wiggle_stop  = { AppClock.sched(0.0, { stopAnim.(); nil }) };
~hud_text = { arg state="HUD UI-test", choices = #[]; AppClock.sched(0.0, { mkText.(state, choices); nil }) };

"PerfHUD UI-only wiggle helpers ready: ~hud_wiggle_start.(\\A or \\B), ~hud_wiggle_stop.(), ~hud_text.(state, choices)".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck_GUI.scd =====
// Accept_Meters_QuickCheck_GUI.scd
// v0.1.0  MD 2025-09-26 16:10 BST

(
var key, counts, lastGA, lastGB, lastGT;
counts = IdentityDictionary[ 32001 -> 0, 32002 -> 0, 31001 -> 0 ];
lastGA = [0.0, 0.0]; lastGB = [0.0, 0.0]; lastGT = [0.0, 0.0];

key = \md_levels_gui_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };

OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 32001) { counts.put(32001, counts[32001] + 1); lastGA = [l, r] };
    if(id == 32002) { counts.put(32002, counts[32002] + 1); lastGB = [l, r] };
    if(id == 31001) { counts.put(31001, counts[31001] + 1); lastGT = [l, r] };
    nil
}, "/md/levels_gui", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), line;
    if(d.notNil) { d.free };
    line = "[ACCEPT_GUI] GA=" ++ counts[32001].asString ++ " " ++ lastGA.asString
        ++ "  GB=" ++ counts[32002].asString ++ " " ++ lastGB.asString
        ++ "  GT=" ++ counts[31001].asString ++ " " ++ lastGT.asString;
    line.postln;
    nil
});

"[ACCEPT_GUI] counting /md/levels_gui for 0.5 s…".postln;
)

===== troubleshooting/Accept_Meters_QuickCheck.scd =====
// Accept_Meters_QuickCheck.scd
// v0.1.0  MD 2025-09-26 15:58 BST

/* Purpose
   Lightweight acceptance: count /md/levels for 0.5 s and print one line.
*/

(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), okLine;
    if(d.notNil) { d.free };
    okLine = "[ACCEPT] A=" ++ counts[2001].asString ++ " " ++ lastA.asString
           ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
           ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString;
    okLine.postln;
    nil
});
"[ACCEPT] counting /md/levels for 0.5 s…".postln;
)

===== troubleshooting/Bridge_mdlevels_to_ampAB.scd =====
// Bridge_mdlevels_to_ampAB.scd
// v0.1.0
// MD 2025-09-26 12:43 BST

/* Purpose
   Bridge /md/levels to /ampA and /ampB so the HUD meters animate regardless of
   which responder is currently active in the window code.
   - replyID 2001 -> /ampA
   - replyID 2002 -> /ampB
*/

(
var senderAddr, installBridge;

senderAddr = NetAddr("127.0.0.1", NetAddr.langPort);

installBridge = {
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };  // idempotent

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };  // guard

        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // Relay to whichever responders the HUD already has
        if(replyId == 2001) { senderAddr.sendMsg("/ampA", 0, -1, leftVal, rightVal) };
        if(replyId == 2002) { senderAddr.sendMsg("/ampB", 0, -1, leftVal, rightVal) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installBridge.();
"[/md/levels] -> [/ampA,/ampB] bridge installed.".postln;
)

===== troubleshooting/Bridge_Meters_Universal.scd =====
// Bridge_Meters_Universal.scd
// v0.1.0
// MD 2025-09-26 12:58 BST

/* Purpose / Style
   Make HUD meters move regardless of whether it listens to /md/levels or /ampA,/ampB.
   - Auto-discovers receiver ports for /ampA,/ampB responders and relays /md/levels to them.
   - Also updates the language-side model (~md_levelsById) from /ampA,/ampB (reverse path).
   - Idempotent: re-running replaces previous bridge.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(
var allDefs, ampPorts, collectAmpPorts, installMdToAmp, installAmpToModel, postSummary;

allDefs = OSCdef.all;

collectAmpPorts = {
    var ports;
    ports = IdentitySet.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == "/ampA" or: { pathValue == "/ampB" }) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            ports.add(portValue);
        };
    });
    // Always include langPort as a fallback
    ports.add(NetAddr.langPort);
    ports.asArray
};

installMdToAmp = { arg portArray;
    var existing;
    existing = OSCdef.all.at(\md_levels_bridge);
    if(existing.notNil) { existing.free };

    OSCdef(\md_levels_bridge, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        var sendAddrs;

        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);

        // multicast to every port the HUD is listening on
        sendAddrs = portArray.collect({ arg portNum; NetAddr("127.0.0.1", portNum) });

        if(replyId == 2001) { sendAddrs.do({ arg na; na.sendMsg("/ampA", 0, -1, leftVal, rightVal) }) };
        if(replyId == 2002) { sendAddrs.do({ arg na; na.sendMsg("/ampB", 0, -1, leftVal, rightVal) }) };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
};

installAmpToModel = {
    var ensureDict;
    ensureDict = { ~md_levelsById = ~md_levelsById ? IdentityDictionary.new };

    // /ampA -> model[2001]
    if(OSCdef.all.at(\ampA_to_model).notNil) { OSCdef.all.at(\ampA_to_model).free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1); // guard
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    if(OSCdef.all.at(\ampB_to_model).notNil) { OSCdef.all.at(\ampB_to_model).free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        ensureDict.();
        leftVal  = (msg.size >= 4).if({ msg[2] ? 0; msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        nil
    }, "/ampB", recvPort: NetAddr.langPort);
};

postSummary = { arg portsArray;
    var msg;
    msg = "Universal meter bridge active. ampA/ampB multicast ports: " ++ portsArray.asString;
    msg.postln;
};

// Main
ampPorts = collectAmpPorts.();
installMdToAmp.(ampPorts);
installAmpToModel.();
postSummary.(ampPorts);
)

===== troubleshooting/Diag_0G_ALT_CreateGridGuiAndBind.scd =====
// Diag_0G_ALT_CreateGridGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:25 BST
/* Purpose / Style
   Purpose: Avoid the PerfHUD 'base_' crash by bringing up the GridDemo GUI instead.
            Bind CommandManager.display to the created GUI object and return → a Window.
   Style:   var-first; descriptive lowercase variable names; no server.sync; single MagicDisplayGUI window.
*/

(
var system_ref, cmd_mgr, gui_obj, window_list, gui_window;

system_ref = ~system;
if(system_ref.isNil) {
    // Construct LivePedalboardSystem with default path resolver (nil) and do the standard bring-up
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;  // server + pedalboard + command system (GUI may still be nil if PerfHUD crashed earlier)
};

// Close any existing MagicDisplayGUI windows to avoid duplicates
~system.closeExistingMagicDisplayWindows;

// Explicitly create the safe GridDemo GUI (bypass PerfHUD file loading)
gui_obj = MagicDisplayGUI_GridDemo.new;  // known-good fallback window class in your codebase

// Bind CommandManager.display if needed
cmd_mgr = ~system.commandManager;
if(cmd_mgr.notNil and: { cmd_mgr.display.isNil }) {
    cmd_mgr.display = gui_obj;
    "MD0G_ALT: bound CommandManager.display to GridDemo".postln;
};

// Bring the MagicDisplayGUI window to front and RETURN it
window_list = Window.allWindows;
gui_window = window_list.detect({ arg w;
    var title_string;
    title_string = w.tryPerform(\name);
    title_string.notNil and: { title_string.asString.beginsWith("MagicDisplayGUI") }
});
if(gui_window.notNil) { gui_window.front };
gui_window  // → a Window (final expression)
)

===== troubleshooting/Diag_0G_CreateGuiAndBind.scd =====
// Diag_0G_CreateGuiAndBind.scd
// v0.1.0
// MD 2025-09-26 17:05 BST

/* Purpose / Style
   Purpose: Ensure a single MagicDisplayGUI window exists, bind it to CommandManager.display,
            and return → a Window (final expression).
   Style:   var-first; descriptive lowercase variable names (≥3 chars); no server.sync; AppClock implied.
*/

(
var systemRef, guiWindow, cmdMgr;

systemRef = ~system;
if(systemRef.isNil) {
    // If system doesn’t exist yet, construct with default path resolver.
    ~system = LivePedalboardSystem.new(nil);         // uses your resolveTreePath  (known-good)
    ~system.bringUpAll;
};

// Bring up (or refresh) the single GUI window
~system.closeExistingMagicDisplayWindows;
guiWindow = ~system.bringUpMagicDisplayGUI;          // sets statusDisplay inside LivePedalboardSystem

// Bind CommandManager.display to the GUI object if needed
cmdMgr = ~system.commandManager;
if(cmdMgr.notNil and: { cmdMgr.display.isNil } and: { ~system.statusDisplay.notNil }) {
    cmdMgr.display = ~system.statusDisplay;
    "MD0G: bound CommandManager.display to statusDisplay".postln;
};

// Final expression → a Window (per your rule)
guiWindow
)

===== troubleshooting/Diag_1_CheckDisplayBinding.scd =====
// Diag_1_CheckDisplayBinding.scd
// v0.1.0
// MD 2025-09-26 16:55 BST
/* Purpose / Style
   Purpose: Check that CommandManager.display points to the current MagicDisplayGUI object.
            If not, bind it safely (no GUI calls are made here).
   Style:   var-first; descriptive lowercase variable names (>=3 chars); no server.sync.
*/

(
var systemRef, cmdMgr, guiRef, displayBefore, didBind;

systemRef = ~system;
if(systemRef.isNil) { "⚠️ ~system is nil; run your bring-up first.".warn; ^nil };

cmdMgr = systemRef.commandManager;
guiRef = systemRef.statusDisplay;

displayBefore = if(cmdMgr.notNil) { cmdMgr.display } { nil };
"MDSTEP1: before → display.isNil=%  gui.isNil=%".format(displayBefore.isNil, guiRef.isNil).postln;

// Bind only if we have both objects and display is nil
didBind = false;
if(cmdMgr.notNil and: { guiRef.notNil } and: { displayBefore.isNil }) {
    cmdMgr.display = guiRef;
    didBind = true;
    "MDSTEP1: bound CommandManager.display to system.statusDisplay".postln;
};

"MDSTEP1: after  → display.isNil=%  didBind=%".format(cmdMgr.display.isNil, didBind).postln;
nil
)

===== troubleshooting/Diag_2_LevelsSniffer.scd =====
// Diag_2_LevelsSniffer_FIXED.scd
// v0.1.2
// MD 2025-09-26 17:25 BST

/* Purpose / Style
   Purpose: Confirm that /md/levels messages arrive from stable taps (A=2001, B=2002).
            Prints compact values every second.
   Style:   var-first; descriptive lowercase names; AppClock; no server.sync; no single-letter variable names.
*/

(
var ensure_stable_taps, install_listener, start_reporter;
var values_by_id, last_stamp_seconds, reporter_routine;

// Share dictionary with any overlays; create if missing
values_by_id = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = values_by_id;
last_stamp_seconds = SystemClock.seconds.asFloat;

// Reinstall sanitised/smoothed taps to /md/levels with IDs 2001/2002
ensure_stable_taps = {
    if(~system.notNil) {
        ~system.installStableMeters;   // known-good installer in your codebase
        "MD2: stable taps reinstalled (IDs 2001/2002).".postln;
    } {
        "MD2: ~system is nil; cannot reinstall taps.".warn;
    };
};

// Listener updating ~md_levelsById (guard NaN and non-numbers; clip to [0,1])
install_listener = {
    var osc_key;
    osc_key = \md_levels_sniffer_fixed;
    if(OSCdef.all.at(osc_key).notNil) { OSCdef.all.at(osc_key).free };
    OSCdef(osc_key, { arg osc_message;
        var reply_id, left_value, right_value, safe_left, safe_right, now_seconds;
        var left_is_bad, right_is_bad;

        if(osc_message.size >= 5) {
            reply_id   = osc_message[2];
            left_value  = osc_message[3];
            right_value = osc_message[4];

            left_is_bad  = (left_value.isNumber.not)  or: { left_value.isNaN };
            right_is_bad = (right_value.isNumber.not) or: { right_value.isNaN };

            safe_left  = left_is_bad.if({ 0.0 }, { left_value.clip(0, 1) });
            safe_right = right_is_bad.if({ 0.0 }, { right_value.clip(0, 1) });

            values_by_id.put(reply_id, [safe_left, safe_right]);
            now_seconds = SystemClock.seconds.asFloat;
            last_stamp_seconds = now_seconds;
        };
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "MD2: /md/levels sniffer installed.".postln;
};

// 1 Hz reporter
start_reporter = {
    if(reporter_routine.notNil) { reporter_routine.stop };
    reporter_routine = Routine({
        var keep_running;
        keep_running = true;
        while({ keep_running }, {
            var pair_a, pair_b, text_a, text_b;
            pair_a = values_by_id.at(2001) ? [0, 0];
            pair_b = values_by_id.at(2002) ? [0, 0];
            text_a = "A(L,R)=(" ++ pair_a[0].round(0.01) ++ "," ++ pair_a[1].round(0.01) ++ ")";
            text_b = "B(L,R)=(" ++ pair_b[0].round(0.01) ++ "," ++ pair_b[1].round(0.01) ++ ")";
            ("MD2: " ++ text_a ++ "  " ++ text_b).postln;
            1.0.wait;
        });
    }).play(AppClock);
};

ensure_stable_taps.();
install_listener.();
start_reporter.();
nil
)

===== troubleshooting/Diag_3_AttachInlineOverlay.scd =====
// Diag_3_AttachInlineOverlay.scd
// v0.1.0
// MD 2025-09-26 16:55 BST

/* Purpose / Style
   Purpose: Attach a small overlay view inside the existing MagicDisplayGUI window that visualises
            /md/levels (A=2001 bottom half; B=2002 top half). Uses the sniffer’s dictionary.
   Style:   var-first; descriptive lowercase variable names; AppClock; no server.sync.
*/

(
var hudWindow, overlayView, leftPadPixels, viewWidthPixels, viewHeightPixels, refreshRoutine;

hudWindow = Window.allWindows.detect({ arg winRef;
    var titleString;
    titleString = winRef.tryPerform(\name);
    titleString.notNil and: { titleString.asString.beginsWith("MagicDisplayGUI") }
});

if(hudWindow.isNil) { "⚠️ MDSTEP3: No MagicDisplayGUI window; run your bring-up.".warn; ^nil };

leftPadPixels    = 8;
viewWidthPixels  = 22;
viewHeightPixels = 86;

overlayView = UserView(hudWindow, Rect(leftPadPixels, leftPadPixels, viewWidthPixels, viewHeightPixels));
overlayView.background_(Color.clear);

overlayView.drawFunc_({ arg viewRef;
    var valuesA, valuesB, aLeft, aRight, bLeft, bRight, halfHeight, halfWidth;
    valuesA = ~md_levelsById.at(2001) ? [0, 0];
    valuesB = ~md_levelsById.at(2002) ? [0, 0];

    aLeft  = valuesA[0]; aRight = valuesA[1];
    bLeft  = valuesB[0]; bRight = valuesB[1];

    halfHeight = viewRef.bounds.height / 2;
    halfWidth  = viewRef.bounds.width  / 2;

    // A (bottom half) — green left, blue right
    Pen.fillColor = Color(0.35, 0.9, 0.35);
    Pen.addRect(Rect(0,        halfHeight - (halfHeight * aLeft),  halfWidth, halfHeight * aLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95);
    Pen.addRect(Rect(halfWidth, halfHeight - (halfHeight * aRight), halfWidth, halfHeight * aRight)); Pen.fill;

    // B (top half) — subtle tint
    Pen.fillColor = Color(0.35, 0.9, 0.35).blend(Color.white, 0.15);
    Pen.addRect(Rect(0,        viewRef.bounds.height - (halfHeight * bLeft),  halfWidth, halfHeight * bLeft));  Pen.fill;
    Pen.fillColor = Color(0.35, 0.6, 0.95).blend(Color.white, 0.15);
    Pen.addRect(Rect(halfWidth, viewRef.bounds.height - (halfHeight * bRight), halfWidth, halfHeight * bRight)); Pen.fill;
});

// refresh on AppClock
refreshRoutine = Routine({
    var keepRunning;
    keepRunning = true;
    while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
        overlayView.refresh;
        0.15.wait;
    });
}).play(AppClock);

"MDSTEP3: inline overlay attached (top-left)".postln;
overlayView
)

===== troubleshooting/Diag_B_DebugTaps_AmplitudeVsVisual.scd =====
// Diag_B_DebugTaps_AmplitudeVsVisual.scd
// v0.1.0
// MD 2025-09-26 17:45 BST

/* Purpose / Style
   Purpose: Add debug taps (non-intrusive) on chainA/chainB that SendReply both the raw amplitude and
            the mapped visual value to /md/levels_dbg with reply IDs 42001 (A) and 42002 (B).
            Then print one line/second with (ampLeft, ampRight) and (visLeft, visRight), so we can
            see if unity (1.0) appears at the Amplitude stage or in the mapping/transport.
   Style:   var-first; descriptive lowercase variable names (>=3 chars); Server.default.bind; no server.sync.
*/

(
// ---- 1) Install debug taps (server side, pass-through audio intact)
var install_debug_taps;

install_debug_taps = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // chainA → replyID 42001
        Ndef(\chainA).filter(\mdDebugTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // DO NOT overwrite vis_left/vis_right with CheckBadValues result;
            // we only call it for side-effect logging.
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            // Send both raw amplitude and final visual as 4 floats
            // payload: [ampLeft, ampRight, visLeft, visRight]
            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42001);

            in_sig
        });

        // chainB → replyID 42002
        Ndef(\chainB).filter(\mdDebugTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });

            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);

            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels_dbg",
                [amp_left, amp_right, vis_left, vis_right], 42002);

            in_sig
        });
    });
    "MDDBG: debug taps installed (/md/levels_dbg; A=42001, B=42002).".postln;
};

install_debug_taps.();
nil
)

// ---- 2) Install compact, 1 Hz debug listener (language side; prints one line per second)
(
// Shared dictionary so we can read and format values
var dbg_values_by_id, dbg_listener_key, dbg_reporter_routine;

dbg_values_by_id = ~md_levels_dbg ? IdentityDictionary.new;
~md_levels_dbg = dbg_values_by_id;

// Listener
dbg_listener_key = \md_levels_dbg_sniffer;
if(OSCdef.all.at(dbg_listener_key).notNil) { OSCdef.all.at(dbg_listener_key).free };
OSCdef(dbg_listener_key, { arg osc_message;
    var reply_id, amp_left, amp_right, vis_left, vis_right;
    var valid_payload;

    valid_payload = (osc_message.size >= 7); // addr, timeTag, id, v0, v1, v2, v3 → size >= 7
    if(valid_payload) {
        reply_id  = osc_message[2];
        amp_left  = osc_message[3];
        amp_right = osc_message[4];
        vis_left  = osc_message[5];
        vis_right = osc_message[6];

        // Minimal guards
        amp_left  = (amp_left.isNumber  and: { amp_left .isNaN.not })  .if({ amp_left  .clip(0,1) }, { 0.0 });
        amp_right = (amp_right.isNumber and: { amp_right.isNaN.not })  .if({ amp_right .clip(0,1) }, { 0.0 });
        vis_left  = (vis_left.isNumber  and: { vis_left .isNaN.not })  .if({ vis_left  .clip(0,1) }, { 0.0 });
        vis_right = (vis_right.isNumber and: { vis_right.isNaN.not })  .if({ vis_right .clip(0,1) }, { 0.0 });

        dbg_values_by_id.put(reply_id, [amp_left, amp_right, vis_left, vis_right]);
    };
    nil
}, "/md/levels_dbg", recvPort: NetAddr.langPort);
"MDDBG: /md/levels_dbg sniffer installed.".postln;

// Reporter
if(~md_levels_dbg_reporter.notNil) { ~md_levels_dbg_reporter.stop };
~md_levels_dbg_reporter = Routine({
    var keep_running;
    keep_running = true;
    while({ keep_running }, {
        var a_vals, b_vals, text_a, text_b;
        a_vals = dbg_values_by_id.at(42001) ? [0,0,0,0];
        b_vals = dbg_values_by_id.at(42002) ? [0,0,0,0];

        text_a = "A amp=("
            ++ a_vals[0].round(0.01) ++ "," ++ a_vals[1].round(0.01)
            ++ ") vis=("
            ++ a_vals[2].round(0.01) ++ "," ++ a_vals[3].round(0.01) ++ ")";

        text_b = "B amp=("
            ++ b_vals[0].round(0.01) ++ "," ++ b_vals[1].round(0.01)
            ++ ") vis=("
            ++ b_vals[2].round(0.01) ++ "," ++ b_vals[3].round(0.01) ++ ")";

        ("MDDBG: " ++ text_a ++ "   " ++ text_b).postln;
        1.0.wait;
    });
}).play(AppClock);

nil
)

===== troubleshooting/Diag_Meters_BringUp_And_Verify.scd =====
// Diag_Meters_BringUp_And_Verify.scd
// v0.1.2
// MD 2025-09-26 14:31 BST

/* Purpose / Style
   Re-install inline taps (A/B + testmelody), then verify /md/levels traffic
   with a short counter. Prints a concise PASS/FAIL line with counts + last values.
   - var-first, descriptive lowercase, AppClock-only, no server.sync.
   - Pass-through taps (return 'in'); generated audio only.
*/

(
var ensureSources, installTapsOnce, installTapsRobust, verifyTraffic, postSummary;
var packetCounts, lastAPair, lastBPair, lastTPair, verifySeconds;

verifySeconds = 0.6;

packetCounts = IdentityDictionary[
    2001 -> 0,   // A
    2002 -> 0,   // B
    1001 -> 0    // testmelody probe
];

lastAPair = [0.0, 0.0];
lastBPair = [0.0, 0.0];
lastTPair = [0.0, 0.0];

ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // keep sinks alive
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
    });
};

installTapsOnce = { arg rateHz = 18;
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A
        Ndef(\chainA).filter(\mdTapA, nil);
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B
        Ndef(\chainB).filter(\mdTapB, nil);
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (always present for diagnostics)
        Ndef(\testmelody).filter(\mdTapT, nil);
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
};

installTapsRobust = {
    var passIndex, passCount;
    passIndex = 0; passCount = 3;
    AppClock.sched(0.0, {
        installTapsOnce.(18);
        passIndex = passIndex + 1;
        if(passIndex < passCount) { 0.20 } { nil }  // re-run every 200ms, 3 passes
    });
    "[Diag] Inline taps installed (A=2001, B=2002, T=1001) with 3-pass rearm.".postln;
};

verifyTraffic = {
    var defKey;
    defKey = \md_levels_diag_count;

    if(OSCdef.all.at(defKey).notNil) { OSCdef.all.at(defKey).free };

    OSCdef(defKey, { arg msg;
        var replyId, leftVal, rightVal, currentCount;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat;
        rightVal = msg[4].asFloat;

        if(replyId == 2001) {
            currentCount = packetCounts[2001] ? 0;
            packetCounts.put(2001, currentCount + 1);
            lastAPair = [leftVal, rightVal];
        };
        if(replyId == 2002) {
            currentCount = packetCounts[2002] ? 0;
            packetCounts.put(2002, currentCount + 1);
            lastBPair = [leftVal, rightVal];
        };
        if(replyId == 1001) {
            currentCount = packetCounts[1001] ? 0;
            packetCounts.put(1001, currentCount + 1);
            lastTPair = [leftVal, rightVal];
        };

        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    AppClock.sched(verifySeconds, {
        var defObj;
        defObj = OSCdef.all.at(defKey);
        if(defObj.notNil) { defObj.free };
        postSummary.();
        nil
    });

    ("[Diag] Counting /md/levels for " ++ verifySeconds.asString ++ " s…").postln;
};

postSummary = {
    var aCount, bCount, tCount, message;
    aCount = packetCounts[2001] ? 0;
    bCount = packetCounts[2002] ? 0;
    tCount = packetCounts[1001] ? 0;

    message = "RESULT /md/levels  A=" ++ aCount.asString
        ++ "  B=" ++ bCount.asString
        ++ "  T=" ++ tCount.asString
        ++ "  lastA=" ++ lastAPair.asString
        ++ "  lastB=" ++ lastBPair.asString
        ++ "  lastT=" ++ lastTPair.asString;

    message.postln;
};

// run
ensureSources.();
installTapsRobust.();
verifyTraffic.();
)

===== troubleshooting/Diag_Meters_QuickProbe_A_B_T.scd =====
// Diag_Meters_QuickProbe_A_B_T.scd
// v0.1.0  MD 2025-09-26
(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_probe_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key);
    if(d.notNil) { d.free };
    ("RESULT A=" ++ counts[2001].asString ++ " " ++ lastA.asString
     ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
     ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString).postln;
    nil
});
"[Probe] counting /md/levels for 0.5 s…".postln;
)

===== troubleshooting/Diag_MeterWiring_Inspector.scd =====
// Diag_MeterWiring_Inspector.scd
(
var wantedPaths, allDefs, summary, listForPath, printEntry;
wantedPaths = ["/md/levels", "/ampA", "/ampB"];
allDefs = OSCdef.all;
listForPath = { arg pathString;
    var matches;
    matches = List.new;
    allDefs.keysValuesDo({ arg keySym, defObj;
        var pathValue, portValue;
        pathValue = defObj.tryPerform(\path);
        if(pathValue == pathString) {
            portValue = defObj.tryPerform(\recvPort) ? NetAddr.langPort;
            matches.add([keySym, portValue])
        };
    });
    matches
};
printEntry = { arg pathString, entries;
    (pathString ++ ": " ++ entries.size.asString ++ " listener(s)").postln;
    entries.do({ arg one;
        var keySym, portValue;
        keySym = one[0]; portValue = one[1];
        ("  key=" ++ keySym.asString ++ " port=" ++ portValue.asString).postln;
    });
};
"=== Meter Wiring Inspector ===".postln;
summary = wantedPaths.collect({ arg p; [p, listForPath.(p)] });
summary.do({ arg pair;
    var pathString, entries;
    pathString = pair[0]; entries = pair[1];
    printEntry.(pathString, entries);
});
)

===== troubleshooting/Feed_ChainA_TestTone_PlayChainA.scd =====
// Feed_ChainA_TestTone_PlayChainA.scd
// v0.1.0
// MD timestamp: 2025-09-26 19:40 GMT+1

/*
Purpose
- Generate a gentle test tone and feed it into Ndef(\chainA) using <<>.
- Also calls Ndef(\chainA).play so you can hear it through the default output.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var freq, amp, msg;

freq = 220;      // adjust if you prefer
amp  = 0.10;     // safe level

Server.default.bind({
    // signal generator
    Ndef(\testmelody, { var sig;
        sig = SinOsc.ar(freq ! 2) * amp;
        sig
    });

    // connect strictly per your rule (left <<> right)
    Ndef(\chainA) <<> Ndef(\testmelody);

    // make it audible (optional but useful for sanity)
    Ndef(\chainA).play;
});

msg = "[FEED] Ndef(\\chainA) <<> Ndef(\\testmelody), playing @ " ++ freq ++ " Hz, amp=" ++ amp;
msg.postln;
msg
)

===== troubleshooting/Fix_Meters_KnownGood.scd =====
// Fix_Meters_KnownGood.scd
// v0.1.0
// MD 2025-09-26 14:45 BST

/* Purpose / Style
   Minimal, known‑good meter bring‑up:
   1) Install a /md/levels receiver (-> ~md_levelsById, ~md_lastMsgStamp).
   2) Re-arm inline taps on chainA (2001), chainB (2002), testmelody (1001) via Ndef.filter.
   3) Heartbeat prints "last /md/levels: X s" every ~2s so we know it's alive.
   - var-first; descriptive lowercase names; AppClock-only; no server.sync; no '?:'.
   - Pass-through taps (return 'in'); *generated audio only*.
*/

(
var installReceiver, ensureSources, installTaps, startHeartbeat;
var rateHz, receiverKey, heartbeatRoutine;

rateHz = 18;
receiverKey = \md_levels_hud;

// ---------- 1) /md/levels receiver ----------
installReceiver = {
    var existing;
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;

    existing = OSCdef.all.at(receiverKey);
    if(existing.notNil) { existing.free };

    OSCdef(receiverKey, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);

    ("[HUD] /md/levels listener installed (key=" ++ receiverKey.asString ++ ")").postln;
};

// ---------- 2) Sources / sinks kept alive (no server.sync) ----------
ensureSources = {
    Server.default.bind({
        // test melody (generated only)
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, freq, env, pan, scale, indexSel;
                trig = Impulse.kr(2.2);
                scale = [60, 62, 64, 67, 69];
                indexSel = Demand.kr(trig, 0, Dwhite(0, scale.size, inf));
                freq = Select.kr(indexSel, scale).midicps;
                env = Decay2.kr(trig, 0.01, 0.40);
                pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
                Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
            });
        };
        Ndef(\testmelody).ar(2);

        // silent NEXT
        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks "awake" at audio rate (no audible change)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    "[Meters] sources/sinks ensured.".postln;
};

// ---------- 3) Inline taps via known-good Ndef.filter ----------
installTaps = {
    var rateClamped;
    rateClamped = rateHz.asInteger.clip(1, 60);

    Server.default.bind({
        // Chain A (replyID 2001)
        Ndef(\chainA).filter(\mdTapA, { arg in;
            var sig, aLeft, aRight;
            sig = in.isArray.if({ in }, { [in, in] });
            aLeft = Amplitude.kr(sig[0]).clip(0, 1);
            aRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [aLeft, aRight], 2001);
            in
        });

        // Chain B (replyID 2002)
        Ndef(\chainB).filter(\mdTapB, { arg in;
            var sig, bLeft, bRight;
            sig = in.isArray.if({ in }, { [in, in] });
            bLeft = Amplitude.kr(sig[0]).clip(0, 1);
            bRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [bLeft, bRight], 2002);
            in
        });

        // Test probe (replyID 1001)
        Ndef(\testmelody).filter(\mdTapT, { arg in;
            var sig, tLeft, tRight;
            sig = in.isArray.if({ in }, { [in, in] });
            tLeft = Amplitude.kr(sig[0]).clip(0, 1);
            tRight = Amplitude.kr(sig[1]).clip(0, 1);
            SendReply.kr(Impulse.kr(rateClamped), "/md/levels", [tLeft, tRight], 1001);
            in
        });
    });
    "[Meters] inline taps armed (A=2001, B=2002, T=1001).".postln;
};

// ---------- 4) Heartbeat (light) ----------
startHeartbeat = {
    var beatInterval, routine;
    beatInterval = 2.0;
    routine = Routine({
        var keepRunning, now, lastAge;
        keepRunning = true;
        while({ keepRunning }, {
            now = SystemClock.seconds.asFloat;
            lastAge = (now - (~md_lastMsgStamp ? now)).round(0.01);
            ("[Meters] last /md/levels: " ++ lastAge.asString ++ " s").postln;
            beatInterval.wait;
        });
    }).play(AppClock);
    routine
};

// Run steps
installReceiver.();
ensureSources.();
installTaps.();

// (Optional) start/refresh overlay drawing here if you added one earlier.

// Heartbeat so we know packets are arriving
heartbeatRoutine = startHeartbeat.();
)

===== troubleshooting/Fix_Taps_CheckBadValues_SideEffect.scd =====
// Fix_Taps_CheckBadValues_SideEffect.scd
// v0.1.0
// MD 2025-09-26 17:35 BST

/* Purpose / Style
   Purpose: Reinstall /md/levels taps for A/B so that CheckBadValues.kr is side-effect only
            (do not overwrite the visual signals). This should remove the constant 1.0 issue.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync.
*/

(
var reinstallOnce;

reinstallOnce = {
    Server.default.bind({
        var rate_hertz, floor_amp;
        rate_hertz = 24;
        floor_amp  = 1e-5;

        // ---- CHAIN A → replyID 2001
        Ndef(\chainA).filter(\mdVisTapA, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            // Log-like visual map then gentle smoothing; keep 0..1
            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            // Side-effect diagnostics only (do NOT assign result)
            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2001);
            in_sig  // pass-through audio
        });

        // ---- CHAIN B → replyID 2002
        Ndef(\chainB).filter(\mdVisTapB, { arg in_sig;
            var input_pair, amp_left, amp_right, map_left, map_right, vis_left, vis_right;

            input_pair = in_sig.isArray.if({ in_sig }, { [in_sig, in_sig] });
            amp_left   = Amplitude.kr(input_pair[0], 0.01, 0.20).clip(floor_amp, 1.0);
            amp_right  = Amplitude.kr(input_pair[1], 0.01, 0.20).clip(floor_amp, 1.0);

            map_left   = LinExp.kr(amp_left,  floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            map_right  = LinExp.kr(amp_right, floor_amp, 1.0, 0.0, 1.0).clip(0, 1);
            vis_left   = LagUD.kr(map_left,  0.02, 0.12).clip(0, 1);
            vis_right  = LagUD.kr(map_right, 0.02, 0.12).clip(0, 1);

            CheckBadValues.kr(vis_left,  id: 0, post: 0);
            CheckBadValues.kr(vis_right, id: 0, post: 0);

            SendReply.kr(Impulse.kr(rate_hertz), "/md/levels", [vis_left, vis_right], 2002);
            in_sig
        });
    });
    "MDTAPS: reinstalled /md/levels taps (A=2001, B=2002) with side-effect checks only.".postln;
};

reinstallOnce.();
nil
)

===== troubleshooting/INSTALL_AmpA_AmpB_Responders_Min.scd =====
// INSTALL_AmpA_AmpB_Responders_Min.scd
// v0.1.0
// MD 2025-09-29

(
var ensureModelReady, installAmpResponders, updatesToLog, logKeyA, logKeyB;

updatesToLog = 6;
logKeyA = \ampA_to_model_log_once;
logKeyB = \ampB_to_model_log_once;

ensureModelReady = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installAmpResponders = {
    var existingA, existingB;

    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };

    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };

    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear, logText;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;

        if(updatesToLog > 0) {
            logText = "[ampA_to_model] A: L=" ++ leftLinear.round(0.01)
                ++ "  R=" ++ rightLinear.round(0.01);
            logText.postln;
            updatesToLog = updatesToLog - 1;
            if(updatesToLog <= 0) { "ampA/B model logging done.".postln };
        };
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
};

ensureModelReady.();
installAmpResponders.();
)

===== troubleshooting/justMartin/MD_Test_OneDrive_RoundTrip.scd =====
// MD_Test_OneDrive_RoundTrip.scd
// v0.1.1
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose: Detect a OneDrive root, create a test folder, write a file, read it back, and print results.
            Works with ~/Library/CloudStorage/OneDrive-* and legacy ~/OneDrive* names.
   Style:   Single () block; VAR-FIRST in every closure; descriptive lowercase names; no server.sync; finite print.
*/

(
var postBanner, expandPath, listFolders, findOneDriveRoot, writeThenRead;
var cloudRoot, homeRoot, foundRoot, testFolderPath, testFilePath, timeStampText, resultPath;

// Header
postBanner = {
    var headerText;
    headerText = "=== MD_TEST_ONEDRIVE_ROUND_TRIP ===";
    headerText.postln;
};

// Expand helper
expandPath = { arg pathString;
    var pn;
    pn = PathName(pathString.standardizePath);
    pn.fullPath
};

// Folder list helper
listFolders = { arg directoryPath;
    var pn, entries, indexCount, indexLimit, outList, item;
    pn = PathName(directoryPath);
    if(pn.isFolder.not) { [] } {
        entries = pn.entries;
        indexCount = 0; indexLimit = entries.size; outList = [];
        while({ indexCount < indexLimit }, {
            item = entries[indexCount];
            if(item.isFolder) { outList = outList.add(item.fullPath) };
            indexCount = indexCount + 1;
        });
        outList
    }
};

// Root finder
findOneDriveRoot = {
    var roots, candidates, indexCount, indexLimit, pathItem, baseOk;
    roots = [];

    cloudRoot = expandPath.("~/Library/CloudStorage");
    candidates = listFolders.(cloudRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    homeRoot = expandPath.("~");
    candidates = listFolders.(homeRoot);
    indexCount = 0; indexLimit = candidates.size;
    while({ indexCount < indexLimit }, {
        pathItem = candidates[indexCount];
        baseOk = pathItem.asString.basename.beginsWith("OneDrive");
        if(baseOk) { roots = roots.add(pathItem) };
        indexCount = indexCount + 1;
    });

    if(roots.size > 0) { roots[0] } { nil }
};

// Writer/reader
writeThenRead = { arg folderPath;
    var okFolder, outFileName, outPath, readBackText;

    okFolder = PathName(folderPath).isFolder;
    if(okFolder.not) { File.mkdir(folderPath) };

    timeStampText = Date.getDate.stamp;
    outFileName = "sc_roundtrip_" ++ timeStampText ++ ".txt";
    outPath = folderPath ++ "/" ++ outFileName;

    File.use(outPath, "w", { arg fileRef; fileRef.write("Hello from SuperCollider at " ++ timeStampText) });
    readBackText = "";
    File.use(outPath, "r", { arg fileRef; readBackText = fileRef.readAllString });

    ("ODTEST: wrote " ++ outPath).postln;
    ("ODTEST: read  " ++ readBackText).postln;
    outPath
};

// —— run ————————————————————————————————————————————————————————————————
postBanner.();

foundRoot = findOneDriveRoot.();
if(foundRoot.isNil) {
    "⚠️ ODTEST: OneDrive root not found. Edit script to supply your OneDrive path explicitly.".warn;
    "   Example: set foundRoot = \"/Users/yourname/Library/CloudStorage/OneDrive-YourOrg\";".postln;
    resultPath = nil;
} {
    ("ODTEST: root = " ++ foundRoot).postln;
    testFolderPath = foundRoot ++ "/SC_MPB_Test";
    ("ODTEST: folder = " ++ testFolderPath).postln;
    resultPath = writeThenRead.(testFolderPath);
    "ODTEST: done.".postln;
};

// Final expression (so the block returns a value but uses no ^)
resultPath
)

===== troubleshooting/MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd =====
// MD_BringUp_GridDemo_FeedA_SaveMeters_OneDrive.scd
// v0.1.0
// MD 2025-09-26 19:12 BST

/* Purpose / Style
   Purpose:
     • Loud console headers; clean-boot bring-up.
     • Single MagicDisplayGUI GridDemo window; bind CommandManager.display if present.
     • Generated-audio test source Ndef(\testmelody) at modest level.
     • Feed chain A from testmelody using Ndef(left) <<> Ndef(right).
     • Raw amplitude taps on A/B → /md/levels (A=2001, B=2002).
     • Finite sniffer: print 6 lines (1 Hz) AND append to OneDrive log; auto-free listener.
     • Tiny overlay meters on the existing GUI (top-left) for ~4.5 s; auto-stop.
     • Final expression returns → a Window.
   Style:
     • Single () block; VAR-FIRST in EVERY block/closure; ≥3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock for GUI; known-good SC syntax only.
*/

(
var postBanner, findWindowByPrefix, ensureGridDemoWindow, freeOscIfPresent, stopRoutineIfPresent;
var serverRef, guiWindow, systemRef, commandManagerRef;
var oneDriveRoot, sessionFolderPath, logFilePath, timeStampText;
var oscKeyLevels, linesRemaining, overlayView, overlayTicksRemaining, overlayRoutine;
var valuesById;

// ——— loud header ——————————————————————————————————————————————————————————————
postBanner = {
    var headerText;
    headerText = "=== MD_BRINGUP_GRIDDEMO_FEEDA_SAVEMETERS_ONEDRIVE ===";
    headerText.postln;
};

// ——— helpers (VAR-FIRST in closures) ————————————————————————————————————————
findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, nameString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        nameString = windowRef.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var priorWin, guiObj, newWin;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)…".postln;
    priorWin = findWindowByPrefix.("MagicDisplayGUI");
    if(priorWin.notNil) {
        priorWin.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };
    guiObj = MagicDisplayGUI_GridDemo.new;
    systemRef = ~system;
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };
    newWin = findWindowByPrefix.("Magic
===== troubleshooting/MD_Check_Suite_Symlink.scd =====
// MD_Check_Suite_Symlink.scd
// v0.1.0
// MD 2025-09-26 19:55 BST

/* Purpose / Style
   Purpose: Report whether Extensions/LivePedalboardSuite is a symlink and, if so, where it points.
            This block is read-only (no filesystem changes).
   Style:   Single () block; VAR-FIRST in every closure; ≥3-char lowercase descriptive names;
            no single-letter locals; no server.sync; finite output; no non-local ^ in .scd.
*/

(
var postBanner, quotePath, extensionsDir, suiteExtPath, testCmd, isLinkExit, isSymlinkFlag;
var readCmd, pipeRef, linkTargetPath, expectedTargetPrefix, looksCorrectFlag;

postBanner = {
    var headerText;
    headerText = "=== MD_CHECK_SUITE_SYMLINK ===";
    headerText.postln;
};

quotePath = { arg rawPathString;
    var q;
    q = "\"" ++ rawPathString.asString ++ "\"";
    q
};

postBanner.();

// 1) Paths
extensionsDir = Platform.userExtensionDir.standardizePath;
suiteExtPath  = extensionsDir +/+ "LivePedalboardSuite";
("EXT: suite path = " ++ suiteExtPath).postln;

// 2) Is it a symlink? (exit=0 means yes)
testCmd = "[ -L " ++ quotePath.(suiteExtPath) ++ " ]";
isLinkExit = testCmd.unixCmd;
isSymlinkFlag = (isLinkExit == 0);
("EXT: is symlink? " ++ isSymlinkFlag.asString).postln;

// 3) If a symlink, read its target
linkTargetPath = "(not a symlink)";
if(isSymlinkFlag) {
    readCmd = "readlink " ++ quotePath.(suiteExtPath);
    pipeRef = Pipe.new(readCmd, "r");
    linkTargetPath = if(pipeRef.notNil) { pipeRef.getLine } { "(unavailable)" };
    if(pipeRef.notNil) { pipeRef.close };
};
("EXT: link target = " ++ linkTargetPath).postln;

// 4) Does the link target appear to live under OneDrive?
expectedTargetPrefix = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
looksCorrectFlag = isSymlinkFlag and: { linkTargetPath.asString.beginsWith(expectedTargetPrefix) };
("OD : target under OneDrive? " ++ looksCorrectFlag.asString).postln;

// Final note
if(isSymlinkFlag.not) {
    "NOTE: Extensions/LivePedalboardSuite is a real folder, not a link. We can convert it to a symlink safely.".postln;
} {
    "NOTE: Good — Extensions/LivePedalboardSuite is a symlink.".postln;
};

nil
)

===== troubleshooting/MD_MeterDiagnostics_Proof_Min.scd =====
// MD_MeterDiagnostics_Proof_Min.scd
// v0.1.1 (var-first everywhere; correct /md/levels format)
// MD timestamp: 2025-09-27 19:52 GMT+1

/*
Purpose (first principles)
- \const: set A to exact values (no audio), prove GUI path.
- \ramp: animate A deterministically (no audio), prove timing.
- \audio: feed a sine into chainA, compute expected RMS, print measured levels,
  send live values to /md/levels (A=2001, B=2002) and correlate with what you hear.

Style / Guard Rails
- Single () block; VAR-FIRST in all blocks/closures; no non-local returns; no server.sync.
- AppClock only for finite drivers; loud banners.
*/

(
var phase, server, sendToLang, banner, postLine, hz, secs, startWhen, endWhen, tickTask;
var constAL, constAR;
var testFreq, testAmp, expectedRMS;
var ensureProxy, attachTap, makeTaps;
var sendPair;

// ===== PHASE SELECTOR =====
phase = \const;  // change to \ramp or \audio and re-run the SAME block

// ===== COMMON UTILS (statements OK after var decls) =====
server     = Server.default;
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);
banner     = { arg text; ("[MDPROOF] " ++ text).postln; };
postLine   = { arg text; text.postln; };
hz         = 12;
secs       = 4.0;
startWhen  = thisThread.seconds;
endWhen    = startWhen + secs;

// We send messages matching your GUI/meter path:
// ['/md/levels', nodeID, replyID, L, R]  (replyIDs: A=2001, B=2002)
sendPair = { arg aLR, bLR;
    var aL, aR, bL, bR;
    aL = aLR[0]; aR = aLR[1]; bL = bLR[0]; bR = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

// ===== PHASE A params =====
constAL = 0.25;  // set any values 0..1 to prove exactness
constAR = 0.75;

// ===== PHASE C params =====
testFreq    = 220;
testAmp     = 0.20;                       // gentle
expectedRMS = (testAmp / (2.sqrt));       // RMS(sin) = A/√2

// ===== TAPS for PHASE C (server-side; var-first in closures) =====
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);

        // Correct: replyID is 4th arg; values are ONLY [L, R]
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// ===== DRIVER =====
(phase == \const).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE A: set A=(" ++ constAL ++ "," ++ constAR ++ "), B=(0,0) for " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now;
        now = thisThread.seconds;
        (now < taskEnd).if({
            sendPair.([constAL, constAR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE A done.");
            nil
        });
    });
});

(phase == \ramp).if({
    var taskStart, taskEnd;
    taskStart = thisThread.seconds;
    taskEnd = taskStart + secs;
    banner.("PHASE B: ramp A L:0→0.9, R:0.9→0 over " ++ secs ++ " s");
    tickTask = AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < taskEnd).if({
            t  = (now - taskStart) / secs;         // 0..1
            aL = (0.9 * t).clip(0.0, 0.9);         // rise
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);   // fall
            sendPair.([aL, aR], [0.0, 0.0]);
            (1.0 / hz)
        }, {
            banner.("PHASE B done.");
            nil
        });
    });
});

(phase == \audio).if({
    var spyStopAt;
    banner.("PHASE C: audio freq=" ++ testFreq ++ " Hz, amp=" ++ testAmp
        ++ "  (expected RMS≈" ++ expectedRMS.round(0.0001) ++ ")");

    Server.default.bind({
        var sig;
        sig = SinOsc.ar(testFreq ! 2) * testAmp;
        Ndef(\testmelody, { sig });
        Ndef(\chainA) <<> Ndef(\testmelody);
        Ndef(\chainA).play;
    });

    makeTaps.();

    spyStopAt = thisThread.seconds + 5.0;
    OSCdef(\mdSpyA, { arg msg, time, addr, port;
        var isA, l, r, line;
        isA = (msg.size >= 5) and: { msg[2] == 2001 };
        isA.if({
            l = msg[3].asFloat; r = msg[4].asFloat;
            line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
                ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.001);
            line.postln;
        });
    }, '/md/levels');

    AppClock.sched(5.0, {
        OSCdef(\mdSpyA).free;
        banner.("PHASE C done. Use Cleanup_ChainA_Unfeed later to stop audio.");
        nil
    });
});

"-> MD_MeterDiagnostics_Proof_Min scheduled.".postln;
)

===== troubleshooting/MD_Meters_D1_SpyAndRamp.scd =====
// MD_Meters_D1_SpyAndRamp.scd
// v0.1.0
// MD timestamp: 2025-09-28 09:55 GMT+1

/*
Purpose
- First principles: prove the sclang process receives /md/levels.
- Spy counts A (2001) and B (2002) messages for 3 s while we send a ramp.
- If counts > 0, OSC is fine and PerfHUD isn't listening to /md/levels.
- If counts == 0, messages aren't arriving (wrong port/shape).

Style / Guard Rails
- Single () block; VAR-FIRST everywhere; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendRamp, aCount, bCount, total, spy, startAt, endAt, banner;

hz         = 12;
secs       = 3.0;
aCount     = 0;
bCount     = 0;
total      = 0;
banner     = { arg text; ("[MD_D1] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// ---- Spy: capture ANY /md/levels messages and count A/B by replyID position ----
OSCdef(\md_levels_spy).free;
spy = OSCdef(\md_levels_spy, { arg msg, time, addr, port;
    var isA, isB;
    // Expect S1 standard: ['/md/levels', nodeID, replyID, L, R]
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isB = (msg.size >= 5) and: { msg[2] == 2002 };
    isA.if({ aCount = aCount + 1; });
    isB.if({ bCount = bCount + 1; });
    total = total + 1;
}, '/md/levels');

// ---- Known-good sender: S1 standard shape [0, replyID, L, R] ----
sendRamp = {
    var t, aL, aR, now, endSend;
    now = thisThread.seconds;
    endSend = now + secs;
    AppClock.sched(0.0, {
        var cur;
        cur = thisThread.seconds;
        (cur < endSend).if({
            t  = (cur - now) / secs;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
            sendToLang.sendMsg('/md/levels', 0, 2002, 0.0, 0.0); // B held at 0
            (1.0 / hz)
        }, {
            nil
        });
    });
};

banner.("Starting spy + ramp for " ++ secs ++ " s…");
startAt = thisThread.seconds;
endAt   = startAt + secs;

sendRamp.();

AppClock.sched(secs + 0.1, {
    OSCdef(\md_levels_spy).free;
    banner.("Spy summary: total=" ++ total
        ++ "  A(2001)=" ++ aCount
        ++ "  B(2002)=" ++ bCount);
    "-> MD_Meters_D1_SpyAndRamp done.".postln;
    nil
});
"-> MD_Meters_D1_SpyAndRamp scheduled."
)

===== troubleshooting/MD_Meters_D2_ListOSCdefs_ByPath.scd =====
// MD_Meters_D2_ListOSCdefs_ByPath.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:05 GMT+1

/*
Purpose
- Print all OSCdef listeners whose path mentions md/levels/meter.
- Confirms whether the PerfHUD window registered a listener and how it matches.
*/

(
var items, printOne;

items = List.new;

printOne = { arg keySym, def;
    var p, t, ps;
    p  = def.path;
    t  = def.argTemplate;
    ps = p ? "";
    ((ps.contains("md") or: { ps.contains("levels") or: { ps.contains("meter") } })).if({
        ("OSCdef " ++ keySym.asString
            ++ " : path=" ++ ps
            ++ "  template=" ++ (t ? nil).asString).postln;
        items.add(keySym);
    });
};

OSCdef.all.keysValuesDo { arg k, d; printOne.(k, d) };

("Found " ++ items.size ++ " OSCdef(s) matching 'md|levels|meter'").postln;
)

===== troubleshooting/MD_Meters_PhaseB_CompatProbe.scd =====
// MD_Meters_PhaseB_CompatProbe.scd
// v0.1.0
// MD timestamp: 2025-09-27 20:12 GMT+1

/*
Purpose
- Determine which /md/levels message shape your PerfHUD v0.5.4 consumes.
- Sends the same ramp in three 2s segments:
  A) S1 standard: ['/md/levels', nodeID=0, replyID=2001/2002, L, R]
  B) S0 legacy:  ['/md/levels', replyID=2001/2002, L, R]            // first arg after path is replyID
  C) S2 variant: ['/md/levels', nodeID=0, 0, replyID, L, R]         // mimics old SendReply misuse

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var hz, secsEach, sendToLang, banner, sendS1, sendS0, sendS2, startAt, segmentDur, schedSeg;

// Params
hz       = 12;      // updates per second
secsEach = 2.0;     // duration per segment (A/B/C)

// Utils
banner     = { arg text; ("[MD_COMPAT] " ++ text).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

// --- Three message shapes ---
sendS1 = { arg aL, aR, bL, bR;
    // S1 standard: ['/md/levels', 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, bL, bR);  // B
};

sendS0 = { arg aL, aR, bL, bR;
    // S0 legacy: ['/md/levels', 2001, L, R]
    sendToLang.sendMsg('/md/levels', 2001, aL, aR);     // A
    sendToLang.sendMsg('/md/levels', 2002, bL, bR);     // B
};

sendS2 = { arg aL, aR, bL, bR;
    // S2 variant: ['/md/levels', 0, 0, 2001, L, R]
    sendToLang.sendMsg('/md/levels', 0, 0, 2001, aL, aR);  // A
    sendToLang.sendMsg('/md/levels', 0, 0, 2002, bL, bR);  // B
};

// --- Scheduler for one segment with the given sender ---
schedSeg = { arg label, senderFunc;
    var segStart, segEnd;
    segStart = thisThread.seconds;
    segEnd   = segStart + secsEach;
    banner.("SEG " ++ label ++ " — ramp A: L 0→0.9, R 0.9→0 (" ++ secsEach ++ " s)");
    AppClock.sched(0.0, {
        var now, t, aL, aR;
        now = thisThread.seconds;
        (now < segEnd).if({
            t  = (now - segStart) / secsEach;
            aL = (0.9 * t).clip(0.0, 0.9);
            aR = (0.9 * (1 - t)).clip(0.0, 0.9);
            senderFunc.value(aL, aR, 0.0, 0.0);  // B kept at 0
            (1.0 / hz)
        }, {
            banner.("SEG " ++ label ++ " done.");
            nil
        });
    });
};

// --- Run the three segments back-to-back ---
AppClock.sched(0.0, { schedSeg.("A (S1 standard: [0,replyID,L,R])", sendS1); secsEach });
AppClock.sched(secsEach, { schedSeg.("B (S0 legacy: [replyID,L,R])",   sendS0); secsEach });
AppClock.sched(secsEach*2, { schedSeg.("C (S2 variant: [0,0,replyID,L,R])", sendS2); nil });

"-> MD_Meters_PhaseB_CompatProbe scheduled (6 s total).".postln;
)

===== troubleshooting/MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd =====
// MD_Meters_PhaseC_Audio_FIX_TapOnTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:27 GMT+1

/*
Purpose
- Audio proof with the tap attached to Ndef(\testmelody) (the generator),
  so measured levels are guaranteed non-zero and derived from the actual test signal.
- Sends /md/levels A=2001 from the tap; B stays untouched.

Style / Guard Rails
- Single () block; VAR-FIRST throughout; no non-local returns; no server.sync.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTapOnTest;

// params
hz = 12;
testFreq = 220;
testAmp  = 0.20;                       // gentle, audible
expectedRMS = (testAmp / (2.sqrt));    // ≈ 0.1414

banner = { arg text; ("[MD_A_AUDIO_FIX] " ++ text).postln; };

// ensure Ndefs exist (not strictly needed for \testmelody, kept for consistency)
ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

// attach tap directly on \testmelody (NOT \chainA)
attachTapOnTest = { arg replyID;
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID); // replyID=2001
        inSig
    });
};

// generate tone, feed chainA, and play (so you hear it)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    ensureProxy.(\chainA, 2);
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

attachTapOnTest.(2001);

// finite console monitor for correlation (5 s)
OSCdef(\mdSpyA_fix).free;
OSCdef(\mdSpyA_fix, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
        ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA_fix).free;
    banner.("done (audio keeps playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS≈" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio_FIX_TapOnTest scheduled."
)

===== troubleshooting/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd =====
// MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd
// v0.1.2
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose:
     • Loud console header + step banners so you can see it ran.
     • Clean-boot bring-up: server, single MagicDisplayGUI GridDemo window, modest-level test source.
     • Feed chain A from testmelody using your operator: Ndef(left) <<> Ndef(right).
     • Install simple raw Amplitude taps to /md/levels (A=2001, B=2002).
     • Print exactly 6 lines (1 Hz) and auto-stop; no console spam.
     • Final expression returns → a Window.
   Style:
     • Single () block; VAR-FIRST in every block/closure; ≥3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock-only for GUI; known-good SC syntax.
*/

(
var postBanner, freeOscIfPresent, stopRoutineIfPresent, findWindowByPrefix, ensureGridDemoWindow;
var serverRef, oscKeyLevels, reporterRoutine, linesRemaining, guiWindow, systemRef, commandManagerRef;

// —— header ————————————————————————————————————————————————————————————————
postBanner = {
    var headerText;
    headerText = "=== MD_MIN_BRINGUP_FEEDA_SIMPLEMETERS_GRIDDEMO ===";
    headerText.postln;
};

// —— helpers (VAR-FIRST inside closures) ————————————————————————————————
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MD: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineRef, labelString;
    var canStopRoutine;
    canStopRoutine = routineRef.notNil and: { routineRef.respondsTo(\stop) };
    if(canStopRoutine) { routineRef.stop; (labelString ++ ": stopped").postln };
};

findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, titleString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        titleString = windowRef.tryPerform(\name);
        if(titleString.notNil and: { titleString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            // do not use ^ ; just set foundWindow and let the closure return last expression
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var oldWindow, guiObj, newWindow;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)…".postln;

    oldWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(oldWindow.notNil) {
        oldWindow.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };

    guiObj = MagicDisplayGUI_GridDemo.new; // safe fallback GUI

    systemRef = ~system; // if user has a system object, bind display
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };

    newWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(newWindow.isNil) { "⚠️ GUI: no MagicDisplayGUI window found after creation".warn };
    newWindow
};

// —— run ————————————————————————————————————————————————————————————————
postBanner.();

// Server bring-up (allowed here)
serverRef = Server.default;
"STEP S: booting server…".postln;
serverRef.waitForBoot;
"STEP S: server booted".postln;

// GUI
guiWindow = ensureGridDemoWindow.();

// Source: testmelody (modest level; generated audio only)
"STEP SRC: defining Ndef(\\testmelody)…".postln;
Server.default.bind({
    Ndef(\testmelody, {
        var triggerCtl, freqCtl, envCtl, panCtl, midiScale, indexCtl, pairSig;
        triggerCtl = Impulse.kr(2.0);
        midiScale  = [60, 62, 64, 67, 69];
        indexCtl   = Demand.kr(triggerCtl, 0, Dwhite(0, midiScale.size, inf));
        freqCtl    = Select.kr(indexCtl, midiScale).midicps;
        envCtl     = Decay2.kr(triggerCtl, 0.01, 0.40);
        panCtl     = LFNoise1.kr(0.25).range(-0.6, 0.6);
        pairSig    = Pan2.ar(SinOsc.ar(freqCtl) * envCtl * 0.18, panCtl); // modest level
        pairSig
    });
    Ndef(\testmelody).ar(2);
});

// Feed chain A from testmelody (your operator)
"STEP FEED: using Ndef(left) <<> Ndef(right): A <<> testmelody".postln;
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
    Ndef(\chainA) <<> Ndef(\testmelody);
});

// Simple raw amplitude taps to /md/levels
"STEP TAPS: install raw amplitude taps (/md/levels A=2001, B=2002)…".postln;
oscKeyLevels = \md_levels_sniffer_finite;
freeOscIfPresent.(oscKeyLevels);

Server.default.bind({
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
        inSig
    });

    Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
        inSig
    });
});

// Finite 6-line sniffer (auto-free)
"STEP MTR: printing 6 lines (1 Hz) then auto-stop…".postln;
linesRemaining = 6;
OSCdef(oscKeyLevels, { arg oscMessage;
    var replyId, leftVal, rightVal, meterLabel, linesDone;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        meterLabel = if(replyId == 2001) { "A" } { if(replyId == 2002) { "B" } { replyId.asString } };
        ("MDMTR: " ++ meterLabel ++ " (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")").postln;

        linesRemaining = linesRemaining - 1;
        linesDone = linesRemaining <= 0;
        if(linesDone) {
            var oscRef2;
            oscRef2 = OSCdef.all.at(oscKeyLevels);
            if(oscRef2.notNil) { oscRef2.free; "MDMTR: listener freed.".postln };
        };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Bring GUI front and return → a Window
if(guiWindow.notNil) { guiWindow.front };
guiWindow  // → a Window
)

===== troubleshooting/MD_PerfHUD_LevelSubscriber.scd =====
// MD_PerfHUD_LevelSubscriber.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:15 GMT+1

/*
Purpose
- Populate ~md_levelsById (IdentityDictionary) from /md/levels messages so
  MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd can render meters.
- Also updates ~md_lastMsgStamp for the "last /md/levels age" display.

Message shapes handled
- Standard: ['/md/levels', nodeID, replyID, L, R]   (preferred)
- Legacy:   ['/md/levels', replyID, L, R]           (fallback)

Reply IDs used by the GUI (per file comments):
- A = 2001, B = 2002, test = 1001
*/

(
var ensureDict, putPair, banner, oscAny;

banner = { arg text; ("[MD_SUB] " ++ text).postln; };

// Ensure the shared dictionary exists (the GUI reads this)
ensureDict = {
    (~md_levelsById.isKindOf(IdentityDictionary)).if({
        // already OK
    }, {
        ~md_levelsById = IdentityDictionary.new;
        banner.("created ~md_levelsById");
    });
    ~md_lastMsgStamp = ~md_lastMsgStamp ? thisThread.seconds;
};

putPair = { arg id, l, r;
    var pair;
    pair = [ (l ? 0.0).asFloat, (r ? 0.0).asFloat ];
    ~md_levelsById[id] = pair;
    ~md_lastMsgStamp = thisThread.seconds;
};

// Clean prior instance (idempotent)
OSCdef(\md_levels_any).free;

ensureDict.();

// One listener that accepts both shapes and writes into ~md_levelsById
oscAny = OSCdef(\md_levels_any, { arg msg, time, addr, port;
    var id, l, r, sz;
    sz = msg.size;
    // Standard
    (sz >= 5).if({
        id = msg[2];
        l  = msg[3];
        r  = msg[4];
        putPair.(id, l, r);
    }, {
        // Legacy
        (sz == 4).if({
            id = msg[1];
            l  = msg[2];
            r  = msg[3];
            putPair.(id, l, r);
        }, {
            // ignore
        });
    });
}, '/md/levels');

banner.("listening on /md/levels → ~md_levelsById (A=2001, B=2002, test=1001)");
"-> MD_PerfHUD_LevelSubscriber ready"
)

===== troubleshooting/MD_PhaseC_Smoke_PlayTest_TapTest.scd =====
// MD_PhaseC_Smoke_PlayTest_TapTest.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:58 GMT+1

/*
Purpose
1) Force Ndef(\testmelody) to run by playing it directly.
2) Prove the tap executes by sending a constant 0.5 for 2s (meters must move).
3) Switch the tap to real Amplitude.kr for 3s and print measured vs expected RMS.
All updates go to /md/levels A=2001 (B untouched).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync; finite.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, now,
    installConstantTap, installAmplitudeTap, removeTap, spy, stopSpyAt;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ≈0.1414

banner = { arg text; ("[MD_SMOKE] " ++ text).postln; };

// 0) Ensure a fresh, running generator (play directly so the proxy surely runs)
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\testmelody).play; // <-- force run; independent of \chainA
});
banner.("testmelody playing @ " ++ testFreq ++ " Hz, amp=" ++ testAmp);

// helper: remove our tap cleanly
removeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig; inSig });
};

// 1) Tap variant A: constant 0.5 for 2s (meters must move)
installConstantTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var trig, l, r;
        trig = Impulse.kr(hz);
        l = 0.5; r = 0.5;
        SendReply.kr(trig, '/md/levels', [l, r], 2001);
        inSig
    });
    banner.("tap A: CONSTANT 0.5 for 2s (A should show ~0.5)");
};

// 2) Tap variant B: real amplitude for 3s (print measured vs expected)
installAmplitudeTap = {
    Ndef(\testmelody).filter(\proofTap, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], 2001);
        inSig
    });
    banner.("tap B: Amplitude.kr for 3s (console prints A_meas vs expected RMS)");
};

// Spy: show arriving values for A=2001 only
OSCdef(\mdSmokeSpy).free;
spy = OSCdef(\mdSmokeSpy, { arg msg;
    var isA, l, r;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        ("A_meas (L,R)=(" ++ l.round(0.003) ++ "," ++ r.round(0.003)
            ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.003)).postln;
    });
}, '/md/levels');

// Schedule: 0..2s constant 0.5, 2..5s amplitude, stop spy
now = thisThread.seconds;

AppClock.sched(0.0, { installConstantTap.(); 2.0 });
AppClock.sched(2.0, { installAmplitudeTap.(); 3.0 });
stopSpyAt = now + 5.0;
AppClock.sched(5.0, {
    removeTap.();
    OSCdef(\mdSmokeSpy).free;
    banner.("done (testmelody still playing; stop with MD_Cleanup_ChainA_Unfeed if needed).");
    nil
});

"-> MD_PhaseC_Smoke_PlayTest_TapTest scheduled."
)

===== troubleshooting/MD_Probe_Sources_Chain_RawAmp_AutoStop.scd =====
// MD_Probe_Sources_Chain_RawAmp_AutoStop.scd
// v0.1.0
// MD 2025-09-26 18:22 BST

/* Purpose / Style
   Purpose: Measure raw amplitudes directly at the source Ndef(\testmelody) and at the sink Ndef(\chainA)
            by creating two temporary probe Ndefs that read those proxies and SendReply their raw
            Amplitude.kr values to "/md/probe". A finite OSCdef prints exactly 6 lines and then removes
            itself and frees the probes. No GUI changes, no server.sync, single block.
   Style:   single () block; var-first in every closure; descriptive lowercase variable names (>=3 chars);
            AppClock-safe; returns nil.
*/

(
var ensureProbes, installSpy, startReporterAndCleanup;
var probeKeySource, probeKeyChain, spyKey, reporterRoutine, printCountRemaining;

// ---- configuration
printCountRemaining = 6;
probeKeySource = \md_probe_tm;    // probe for testmelody
probeKeyChain  = \md_probe_chain; // probe for chainA
spyKey         = \md_probe_spy;   // OSCdef key

// ---- 1) Create probes (server-side) that read from existing Ndefs and SendReply raw amplitudes
ensureProbes = {
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Server.default.bind({
        // Probe source: reads Ndef(\testmelody).ar(2)
        Ndef(probeKeySource, {
            var srcSig, ampLeft, ampRight;
            srcSig   = Ndef(\testmelody).ar(2);  // read directly from the source proxy
            ampLeft  = Amplitude.kr(srcSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(srcSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51001);
            Silent.ar(2) // silent synth (no audio output)
        }).play;  // ensure it runs on the server

        // Probe chainA: reads Ndef(\chainA).ar(2)
        Ndef(probeKeyChain, {
            var chainSig, ampLeft, ampRight;
            chainSig = Ndef(\chainA).ar(2);  // read directly from the sink proxy
            ampLeft  = Amplitude.kr(chainSig[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight = Amplitude.kr(chainSig[1], attackSec, releaseSec).clip(floorAmp, 1.0);
            SendReply.kr(Impulse.kr(rateHertz), "/md/probe", [ampLeft, ampRight], 51002);
            Silent.ar(2)
        }).play;
    });

    "MDPROBE: probes created (tm=51001, chainA=51002) → /md/probe".postln;
};

// ---- 2) Spy listener (finite) that prints exactly 6 lines then frees itself and the probes
installSpy = {
    if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

    OSCdef(spyKey, { arg oscMessage;
        var msgSize, replyId, leftVal, rightVal, lineText;

        msgSize = oscMessage.size;
        if(msgSize >= 5) {
            replyId = oscMessage[2];
            leftVal  = oscMessage[3];
            rightVal = oscMessage[4];

            // guard + clip to [0,1]
            leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
            rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

            lineText = case
            { replyId == 51001 } { "SRC \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { replyId == 51002 } { "A   \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" }
            { "ID " ++ replyId.asString ++ " \u2192 (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")" };

            ("MDPROBE: " ++ lineText).postln;

            printCountRemaining = printCountRemaining - 1;
            if(printCountRemaining <= 0) {
                var spyObj;
                spyObj = OSCdef.all.at(spyKey);
                if(spyObj.notNil) { spyObj.free; "MDPROBE: spy freed".postln };

                // free probes (server-side)
                Server.default.bind({
                    if(Ndef(probeKeySource).isPlaying) { Ndef(probeKeySource).free };
                    if(Ndef(probeKeyChain ).isPlaying) { Ndef(probeKeyChain ).free };
                });
                "MDPROBE: probes freed".postln;
            };
        };
        nil
    }, "/md/probe", recvPort: NetAddr.langPort);
    "MDPROBE: spy armed (6 lines)…".postln;
};

// ---- 3) Go
ensureProbes.();
installSpy.();
nil
)

===== troubleshooting/MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd =====
// MD_Reinstall_SimpleTaps_And_Sniff_AutoStop.scd
// v0.1.0
// MD 2025-09-26 17:55 BST

/* Purpose / Style
   Purpose: Replace current /md/levels taps with a *simple* version that sends raw Amplitude.kr values
            (no LinExp, no LagUD) for A/B sinks. Then install a finite sniffer that prints exactly
            6 lines (one per second) and auto-stops.
   Style:   var-first; descriptive lowercase variable names; Server.default.bind; no server.sync; AppClock.
*/

(
// ---- reinstall simple taps (server-side), replyIDs: A=2001, B=2002
var reinstallSimpleTaps;

reinstallSimpleTaps = {
    Server.default.bind({
        var rateHertz, attackSec, releaseSec, floorAmp;

        rateHertz  = 24;
        attackSec  = 0.01;
        releaseSec = 0.20;
        floorAmp   = 1e-5;

        // CHAIN A
        Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            // Send raw amplitudes (0..1)
            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
            inSig
        });

        // CHAIN B
        Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
            var inputPair, ampLeft, ampRight;

            inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
            ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
            ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);

            SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
            inSig
        });
    });
    "MDSIMPLE: raw amplitude taps installed (/md/levels; A=2001 B=2002).".postln;
};

reinstallSimpleTaps.();
nil
);

// ---- finite sniffer: prints exactly 6 lines and auto-stops
(
var valuesById, oscKey, remainingLines, reporterRoutine;

// Shared store
valuesById = ~md_levelsById ? IdentityDictionary.new;
~md_levelsById = valuesById;

// Finite cycles to print
remainingLines = 6;

// Clean previous finite sniffer (if any)
oscKey = \md_levels_sniffer_fixed;
if(OSCdef.all.at(oscKey).notNil) { OSCdef.all.at(oscKey).free };

// Listener: only update the dict; no console spam here
OSCdef(oscKey, { arg oscMessage;
    var replyId, leftVal, rightVal;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        // Guards + clip 0..1
        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        valuesById.put(replyId, [leftVal, rightVal]);
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Reporter: 1 Hz; prints 6 lines then stops and frees listener
reporterRoutine = Routine({
    var keepRunning;
    keepRunning = true;

    while({ keepRunning and: { remainingLines > 0 } }, {
        var pairA, pairB, textA, textB;

        pairA = valuesById.at(2001) ? [0, 0];
        pairB = valuesById.at(2002) ? [0, 0];

        textA = "A(L,R)=(" ++ pairA[0].round(0.01) ++ "," ++ pairA[1].round(0.01) ++ ")";
        textB = "B(L,R)=(" ++ pairB[0].round(0.01) ++ "," ++ pairB[1].round(0.01) ++ ")";

        ("MDSIMPLE: " ++ textA ++ "  " ++ textB).postln;

        remainingLines = remainingLines - 1;
        1.0.wait;
    });

    // Auto-clean: free listener and stop routine
    var oscObj;
    oscObj = OSCdef.all.at(oscKey);
    if(oscObj.notNil) { oscObj.free; "MDSIMPLE: listener freed.".postln };

    "MDSIMPLE: reporter finished.".postln;
}).play(AppClock);

nil
)

===== troubleshooting/MD_Spy_md_levels_RawAutoStop.scd =====
// MD_Spy_md_levels_RawAutoStop.scd
// v0.1.0
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Print the next 4 OSC messages received on "/md/levels" verbatim (with indices),
            then auto-free the listener so the console stays clean.
   Style:   single () block; var-first everywhere; descriptive lowercase names; no server.sync; returns nil.
*/

(
var spyKey, remainingCount, printOneMessage;

spyKey = \md_levels_spy_once;
remainingCount = 4;

// ensure previous spy is gone
if(OSCdef.all.at(spyKey).notNil) { OSCdef.all.at(spyKey).free };

// print helper (var-first inside closure)
printOneMessage = { arg messageArray;
    var sizeCount, indexPos, indexLimit, lineText;
    sizeCount = messageArray.size;
    ("MDSPY: size=" ++ sizeCount.asString).postln;
    indexPos = 0; indexLimit = sizeCount;
    while({ indexPos < indexLimit }, {
        lineText = ("  [" ++ indexPos.asString ++ "] = " ++ messageArray[indexPos].asString);
        lineText.postln;
        indexPos = indexPos + 1;
    });
};

OSCdef(spyKey, { arg oscMessage;
    var localCount, doneNow;
    localCount = remainingCount;
    printOneMessage.(oscMessage);
    remainingCount = remainingCount - 1;
    doneNow = remainingCount <= 0;
    if(doneNow) {
        var spyObj;
        spyObj = OSCdef.all.at(spyKey);
        if(spyObj.notNil) { spyObj.free; "MDSPY: freed".postln };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

"MDSPY: armed for 4 messages…".postln;
nil
)

===== troubleshooting/MD_Taps_Clear_All_FIXED.scd =====
// MD_Taps_Clear_All_FIXED.scd
// v0.1.1 (clear proxies instead of filter(..., nil))
// MD timestamp: 2025-09-28 10:52 GMT+1

/*
Purpose
- Remove all taps/filters by clearing proxies and recreating chainA as a 2‑ch audio proxy.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var msg;

Server.default.bind({
    // stop and clear any existing sources/filters/taps
    Ndef(\chainA).stop; Ndef(\chainA).clear; Ndef(\chainA).ar(2);
    Ndef(\chainB).stop; Ndef(\chainB).clear; Ndef(\chainB).ar(2);
    Ndef(\testmelody).stop; Ndef(\testmelody).clear;
});

msg = "[TAPS] cleared: chainA, chainB, testmelody — chainA re-created as 2ch.";
msg.postln;
msg
)

===== troubleshooting/MD_Taps_Clear_All.scd =====
// MD_Taps_Clear_All.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:45 GMT+1

/*
Purpose
- Remove any previously attached /md/levels taps on chainA/chainB/testmelody
  so only one producer drives A=2001 / B=2002.

Style
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var cleared;

Server.default.bind({
    // Remove known tap filter keys if present
    Ndef(\chainA).filter(\eodTapA, nil);
    Ndef(\chainB).filter(\eodTapB, nil);
    Ndef(\testmelody).filter(\proofTap, nil);
});

cleared = "[TAPS] cleared filters: chainA(\\eodTapA), chainB(\\eodTapB), testmelody(\\proofTap)";
cleared.postln;
cleared
)

===== troubleshooting/MODEL_Print_Amp_Model_Values.scd =====
// MODEL_Print_Amp_Model_Values.scd
// v0.1.1
// MD 2025-09-29

(
var linesRemaining, printOnce;

linesRemaining = 6;

printOnce = {
    var levelsA, levelsB, reportText;
    levelsA = ~md_levelsById.atFail(2001, { [0.0, 0.0] });
    levelsB = ~md_levelsById.atFail(2002, { [0.0, 0.0] });
    reportText = "model A=" ++ levelsA ++ "   B=" ++ levelsB;
    reportText.postln;

    linesRemaining = linesRemaining - 1;
    if(linesRemaining > 0) {
        AppClock.sched(0.5, { printOnce.(); nil });
    }{
        nil
    };
};

AppClock.sched(0.0, { printOnce.(); nil });
)

===== troubleshooting/obsolete/turnintooneplease copy.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"✅ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW — ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD’s window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ——— bring-up sequence ———

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your “-> a Window” acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd → -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB→0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/PerfHUD_Adhoc_MeterFix_Overlay.scd =====
// PerfHUD_Adhoc_MeterFix_Overlay.scd
// v0.1.0
// MD 2025-09-26 13:42 BST

/* Purpose / Style
   - Install a /md/levels listener (HUD-side) so meters have data.
   - Add a small overlay meter (top-left) to prove live updates right now.
   - var-first; descriptive lowercase vars; AppClock-only; no server.sync.
*/

(
var ensureModel, installHudResponder, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installHudResponder = {
    var existing;
    existing = OSCdef.all.at(\md_levels_hud);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_hud, { arg msg;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId  = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[HUD] /md/levels listener installed (key=md_levels_hud)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 84;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half, slightly lighter)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[HUD] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15; lastBeatTime = SystemClock.seconds.asFloat;
    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[HUD] meters tick; last /md/levels "
                    ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            0.15.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installHudResponder.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) { attachOverlay.(hudWindow); startRefresh.() } {
    "⚠️ No MagicDisplayGUI window found; bring up PerfHUD first.".warn;
};
)

===== troubleshooting/PERFHUD_Bus_Indices_Inspect.scd =====
// PERFHUD_Bus_Indices_Inspect.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, summaryText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

summaryText =
    "[bus indices] A=" ++ (hasBusA.if({ ~busA.index }, { "nil" })) ++
    "  B=" ++ (hasBusB.if({ ~busB.index }, { "nil" }));

summaryText.postln;
)

===== troubleshooting/PerfHUD_Diag_OverlayMeters.scd =====
// PerfHUD_Diag_OverlayMeters.scd
// v0.1.0
// MD 2025-09-26 13:12 BST

/* Purpose
   - Prove the meter data path & UI repaint with a non-intrusive overlay.
   - Installs a /md/levels receiver -> ~md_levelsById.
   - Adds a tiny overlay UserView that animates A/B bars (top-left).
   - Very light diagnostics: heartbeat every ~2 seconds.
*/

(
var ensureModel, installReceiver, findHudWindow, attachOverlay, startRefresh;
var hudWindow, overlayView, refreshRoutine, lastBeatTime;

ensureModel = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installReceiver = {
    var existing;
    existing = OSCdef.all.at(\md_levels_diag);
    if(existing.notNil) { existing.free };
    OSCdef(\md_levels_diag, { arg msg, time, addr, recvPort;
        var replyId, leftVal, rightVal;
        if(msg.size < 5) { ^nil };
        replyId = msg[2];
        leftVal  = msg[3].asFloat.clip(0, 1);
        rightVal = msg[4].asFloat.clip(0, 1);
        ~md_levelsById.put(replyId, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/md/levels", recvPort: NetAddr.langPort);
    "[Diag] /md/levels receiver installed (key=md_levels_diag)".postln;
};

findHudWindow = {
    Window.allWindows.detect({ arg w;
        var nameString;
        nameString = w.tryPerform(\name);
        nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }
    })
};

attachOverlay = { arg windowRef;
    var pad, width, height;
    pad = 8; width = 12; height = 80;
    overlayView = UserView(windowRef, Rect(pad, pad, width, height));
    overlayView.background_(Color.clear);
    overlayView.drawFunc_({ arg v;
        var aPair, bPair, aL, aR, bL, bR, h, halfW;
        var aEnergy, bEnergy, leftColor, rightColor;
        aPair = (~md_levelsById.at(2001) ? [0, 0]).collect(_.asFloat);
        bPair = (~md_levelsById.at(2002) ? [0, 0]).collect(_.asFloat);
        aL = aPair[0].clip(0, 1); aR = aPair[1].clip(0, 1);
        bL = bPair[0].clip(0, 1); bR = bPair[1].clip(0, 1);
        h = v.bounds.height; halfW = v.bounds.width/2;

        // A on bottom half, B on top half (thin overlay)
        leftColor  = Color(0.35, 0.9, 0.35);
        rightColor = Color(0.35, 0.6, 0.95);

        // A bars (bottom half)
        Pen.fillColor = leftColor;
        Pen.addRect(Rect(0, h/2 - (h/2 * aL), halfW, (h/2 * aL))); Pen.fill;
        Pen.fillColor = rightColor;
        Pen.addRect(Rect(halfW, h/2 - (h/2 * aR), halfW, (h/2 * aR))); Pen.fill;

        // B bars (top half)
        Pen.fillColor = leftColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(0, h - (h/2 * bL), halfW, (h/2 * bL))); Pen.fill;
        Pen.fillColor = rightColor.blend(Color.white, 0.15);
        Pen.addRect(Rect(halfW, h - (h/2 * bR), halfW, (h/2 * bR))); Pen.fill;
    });
    overlayView.visible = true;
    "[Diag] overlay meters attached (top-left)".postln;
};

startRefresh = {
    var beatInterval;
    beatInterval = 0.15;
    lastBeatTime = SystemClock.seconds.asFloat;

    refreshRoutine = Routine({
        var keepRunning, now;
        keepRunning = true;
        while({ keepRunning and: { hudWindow.notNil and: { hudWindow.isClosed.not } } }, {
            overlayView.refresh;
            now = SystemClock.seconds.asFloat;
            if((now - lastBeatTime) >= 2.0) {
                ("[Diag] meters tick; last /md/levels " ++ (now - (~md_lastMsgStamp ? now)).round(0.01) ++ " s").postln;
                lastBeatTime = now;
            };
            beatInterval.wait;
        });
    }).play(AppClock);
};

// bring it together
ensureModel.();
installReceiver.();
hudWindow = findHudWindow.();
if(hudWindow.notNil) {
    attachOverlay.(hudWindow);
    startRefresh.();
} {
    "⚠️ No MagicDisplayGUI window found; run the HUD first.".warn;
};
)

===== troubleshooting/PERFHUD_InlineTaps_On_ChainAB.scd =====
// PERFHUD_InlineTaps_On_ChainAB.scd
// v0.1.0
// MD 2025-09-29 15:26 BST

(
/* Purpose
   - Replace bus-based bridge (silent because no buses exist) with inline taps on Ndef(\chainA/\chainB).
   - Send linear amplitudes for PerfHUD via '/ampA' and '/ampB' (2 values each, L/R).
   - Also send dB readings via '/md/levels_db' with replyIDs A=2001, B=2002 for console sanity.
Style
   - var-first; descriptive lowercase variable names; Server.default.bind for server ops; AppClock for UI only.
   - No server.sync; no non-local returns; idempotent (re-running replaces the taps).
*/

var freeBusBridgeIfPresent, installInlineTaps, installDbSniffer, printLinesRemaining;
var attackSeconds, releaseSeconds, updateRateHz, minLinearFloor;
var oscKeyDb;

attackSeconds   = 0.01;
releaseSeconds  = 0.20;
updateRateHz    = 24;
minLinearFloor  = 1e-7;
printLinesRemaining = 6;
oscKeyDb = \perfHud_db_sniff;

// 1) Free the bus-bridge synth (if any), to avoid double feeds
freeBusBridgeIfPresent = {
    if(~md_levelsSynth.notNil) {
        ~md_levelsSynth.free;
        ~md_levelsSynth = nil;
        "99: Freed md_levels4_from_busses (bus bridge) — switching to inline taps.".postln;
    };
};

// 2) Install inline taps on chainA and chainB
installInlineTaps = {
    Server.default.bind({
        // chainA → '/ampA' (linear pair) and '/md/levels_db' (dB; replyID=2001)
        Ndef(\chainA).filter(\perfHudTapA, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            // normalize to a stereo pair (duplicate if mono)
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampA', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2001);

            // return audio unchanged
            localSignal
        });

        // chainB → '/ampB' (linear pair) and '/md/levels_db' (dB; replyID=2002)
        Ndef(\chainB).filter(\perfHudTapB, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampB', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2002);

            // return audio unchanged
            localSignal
        });
    });

    "99: Inline taps installed on chainA/chainB → '/ampA' & '/ampB' (+ dB on '/md/levels_db').".postln;
};

// 3) Short-lived dB console sniffer (6 lines total), then auto-free
installDbSniffer = {
    // clean any previous instance
    if(OSCdef(oscKeyDb).notNil) { OSCdef(oscKeyDb).free };

    OSCdef(oscKeyDb, { arg message;
        var replyId, dbLeft, dbRight, labelText;
        if(message.size >= 5) {
            replyId = message[2];
            dbLeft  = message[3].round(0.1);
            dbRight = message[4].round(0.1);
            labelText = "[dB inline " ++ replyId.asString ++ "] L=" ++ dbLeft ++ " dB  R=" ++ dbRight ++ " dB";
            labelText.postln;

            printLinesRemaining = printLinesRemaining - 1;
            if(printLinesRemaining <= 0) {
                OSCdef(oscKeyDb).free;
                "[dB inline] sniff done.".postln;
            };
        };
    }, '/md/levels_db');
};

// Execute
freeBusBridgeIfPresent.();
installInlineTaps.();
installDbSniffer.();
)

===== troubleshooting/PERFHUD_Repoint_MeterSynth_To_Buses.scd =====
// PERFHUD_Repoint_MeterSynth_To_Buses.scd
// v0.1.0
// MD 20250929-1518

(
var hasBusA, hasBusB, repointedText;

hasBusA = (~busA.notNil) && (~busA.respondsTo(\index));
hasBusB = (~busB.notNil) && (~busB.respondsTo(\index));

if(~md_levelsSynth.notNil) {
    if(hasBusA) { ~md_levelsSynth.set(\inBusA, ~busA.index) };
    if(hasBusB) { ~md_levelsSynth.set(\inBusB, ~busB.index) };
    repointedText = "99: md_levels4_from_busses repointed to inBusA=" ++
        (hasBusA.if({ ~busA.index }, { "unchanged" })) ++
        "  inBusB=" ++ (hasBusB.if({ ~busB.index }, { "unchanged" }));
    repointedText.postln;
}{
    "⚠️  md_levelsSynth not running; run 99_PerfHUD_MetersFromBusses.scd first.".warn;
}
)

===== troubleshooting/RMS_IsolatedHUD_BringUp.scd =====
// RMS_IsolatedHUD_BringUp.scd
//_v0.1.2
// MD 2025-09-29 19:10 BST

/* Purpose
   Show RMS (dB) at the *ends* of chainA and chainB in a NEW isolated window.
   - Reads Ndef(\chainA/\chainB) output busses directly: In.ar(bus, 2)
   - RMS per channel via RMS.ar(sig, 500)   // your spec
   - Convert to dBFS and map dB→0..1 for bar height (adjustable floor/top)
   - No shared OSC paths; no writes into existing HUD => zero interference

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops;
     no server.sync; no non-local returns. Returns '-> a Window'.
*/

(
var // calibration (live‑tweakable via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra headroom)
updateRateHz   =  15;

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no VLayout/HLayout pitfalls) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aL, aR, bL, bR;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aL = sigA[0];
            aR = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bL = sigB[0];
            bR = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (your spec)
            rmsAL = RMS.ar(aL, 500);
            rmsAR = RMS.ar(aR, 500);
            rmsBL = RMS.ar(bL, 500);
            rmsBR = RMS.ar(bR, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);
            // Private OSC: 4 dB values [A_L, A_R, B_L, B_R]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busA, busB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busA, \inBusB, busB, \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busA ++ "  B=" ++ busB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait briefly until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START**
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this block.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window
rmsWindow;
)

===== troubleshooting/RMS_IsolatedHUD.scd =====
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd → -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB→0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/Run_All_PerfHUD_RMS_Isolated.scd =====
// Run_All_PerfHUD_RMS_Isolated.scd
// v0.1.0
// MD 2025-09-29 19:40 BST

/* Purpose
   One-shot bring-up from a clean SC restart:
     1) 00_Reset_KnownClean_State.scd
     2) 01b_StartHere_NoReboot.scd
     3) 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
     4) 02D_TestSource_CenteredStereo_Pulsed.scd
     5) RMS_IsolatedHUD (new window): reads ends of chainA/chainB, RMS.ar(sig,500) → dB → meters

Style
   - var-first; descriptive lowercase names; AppClock for sequencing/GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. Returns '-> a Window' (the RMS window) at the end.
*/

(
var // config (paths and small timings)
    baseDir, fReset, fStartHere, fAssertStereo, fTestSource,
    smallPause, mediumPause, longPause,

    // helpers
    ensureBaseDir, executeFileOnce, scheduleSequence,

    // rms window block (self-contained)
    buildRmsIsolatedHud, // returns a Window
    finalWindow;

// --- configuration (adjust only if your file names differ) -------------------
smallPause  = 0.25;   // seconds between immediate steps
mediumPause = 0.60;   // seconds to allow bring-up to tick
longPause   = 1.00;   // seconds for heavier steps

// Derive the troubleshooting/ folder by default (assumes this file is saved there)
ensureBaseDir = {
    // If this script is saved as a file, we can use nowExecutingPath; otherwise ask user to set.
    var fromFile = thisProcess.nowExecutingPath;
    if(fromFile.notNil) {
        baseDir = PathName(fromFile).parentPath;  // should end with '/'
    }{
        // Fallback: try to guess a 'troubleshooting' folder relative to current documents dir.
        // If this fails on your setup, please SAVE this file in the 'troubleshooting/' folder
        // and re-run so nowExecutingPath is available.
        baseDir = PathName(thisProcess.platform.userAppSupportDir).parentPath ++ "troubleshooting";
        "[RunAll] Warning: nowExecutingPath is nil; guessing baseDir: ".post; baseDir.postln;
    };

    // File names expected to be in baseDir
    fReset       = baseDir ++ "00_Reset_KnownClean_State.scd";
    fStartHere   = baseDir ++ "01b_StartHere_NoReboot.scd";
    fAssertStereo= baseDir ++ "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd";
    fTestSource  = baseDir ++ "02D_TestSource_CenteredStereo_Pulsed.scd";
};

// Execute a file if it exists; prints a readable status line
executeFileOnce = { arg absolutePathString, labelString;
    var pathOk;
    pathOk = File.exists(absolutePathString);
    if(pathOk.not) {
        ("[RunAll] ⚠️ Missing file: " ++ absolutePathString).warn;
    }{
        ("[RunAll] === " ++ labelString ++ " ===").postln;
        thisProcess.interpreter.executeFile(absolutePathString);
    };
    pathOk
};

// Self-contained RMS window that reads ends of chainA/chainB, computes RMS.dB, displays 4 meters
buildRmsIsolatedHud = {
    var defaultFloorDb, defaultTopDb, updateRateHz;
    var rmsWindow, labelTitle, labelDbA, labelDbB;
    var meterAL, meterAR, meterBL, meterBR, updateRoutine;
    var currentDbAL, currentDbAR, currentDbBL, currentDbBR;
    var installSynthDef, startRmsSynthAtTail, stopRmsSynth;
    var oscKeyName, installRmsListener;
    var discoverBussesAndStart, getProxyBusInfo;
    var chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

    defaultFloorDb = -72.0;
    defaultTopDb   =   0.0;   // set to +3.0 for extra visual headroom at full scale
    updateRateHz   =  15;

    // allow live tuning (optional)
    ~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
    ~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

    rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

    labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
        .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
        .font_(Font("Helvetica", 13));

    meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
    meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

    StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
    StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
    StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
    StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

    labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
    labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

    currentDbAL = -140.0; currentDbAR = -140.0;
    currentDbBL = -140.0; currentDbBR = -140.0;

    installSynthDef = {
        Server.default.bind({
            SynthDef(\md_rms_isolated_from_busses, {
                arg inBusA = 0, inBusB = 0, fps = 15;
                var sigA, sigB, aLeft, aRight, bLeft, bRight;
                var rmsAL, rmsAR, rmsBL, rmsBR;
                var dbAL, dbAR, dbBL, dbBR;
                var tick, minLinear;

                sigA = In.ar(inBusA, 2);
                sigB = In.ar(inBusB, 2);

                aLeft  = sigA[0];
                aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
                bLeft  = sigB[0];
                bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

                // RMS per channel with 500 Hz smoothing (requested)
                rmsAL = RMS.ar(aLeft,  500);
                rmsAR = RMS.ar(aRight, 500);
                rmsBL = RMS.ar(bLeft,  500);
                rmsBR = RMS.ar(bRight, 500);

                // dBFS with guard
                minLinear = 1e-9;
                dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
                dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
                dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
                dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

                tick = Impulse.kr(fps);
                SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);  // private path for this window
            }).add;
        });
        "[RunAll/RMS] SynthDef \\md_rms_isolated_from_busses installed.".postln;
    };

    stopRmsSynth = {
        if(~rms_isolated_synth.notNil) {
            ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
            "[RunAll/RMS] previous synth stopped.".postln;
        };
    };

    // IMPORTANT: start at TAIL so we read busses *after* chains write to them
    startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
        AppClock.sched(0.20, {
            Server.default.bind({
                ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                    \inBusA, busIndexForA,
                    \inBusB, busIndexForB,
                    \fps, updateRateHz
                ]);
            });
            ("[RunAll/RMS] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
            nil
        });
    };

    // Listener to receive dB payload and update UI model
    oscKeyName = \md_rms_isolated_listener;
    installRmsListener = {
        var existing;
        existing = OSCdef.all.at(oscKeyName);
        if(existing.notNil) { existing.free };

        OSCdef(oscKeyName, { arg msg;
            if(msg.size >= 7) {
                currentDbAL = msg[3].asFloat;
                currentDbAR = msg[4].asFloat;
                currentDbBL = msg[5].asFloat;
                currentDbBR = msg[6].asFloat;
            };
            nil
        }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

        "[RunAll/RMS] listener installed (/md/rms_isolated_dB)".postln;
    };

    // AppClock ticker: dB → 0..1 mapping and UI updates
    updateRoutine = Routine({
        var waitSeconds, mapDbToUi, floorDbLive, topDbLive;
        waitSeconds = 1.0 / updateRateHz;
        mapDbToUi = { arg dbValue, floorDb, topDb; ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0) };

        while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
            floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
            topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

            meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
            meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
            meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
            meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

            labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
            labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

            waitSeconds.yield;
        };
    }).play(AppClock);

    // Discover Ndef(\chainA/\chainB) busses and start synth
    getProxyBusInfo = { arg chainSymbol;
        var proxy, busObject, info;
        proxy = Ndef(chainSymbol);
        busObject = proxy.bus;
        info = (
            symbol: chainSymbol,
            playing: proxy.isPlaying,
            numChannels: proxy.numChannels,
            busIndex: busObject.notNil.if({ busObject.index }, { nil })
        );
        info
    };

    discoverBussesAndStart = {
        triesLeft = 20;
        Routine({
            var resolved;
            resolved = false;
            while({ triesLeft > 0 and: { resolved.not } }) {
                chainAInfo = getProxyBusInfo.(\chainA);
                chainBInfo = getProxyBusInfo.(\chainB);
                busIndexA  = chainAInfo[\busIndex];
                busIndexB  = chainBInfo[\busIndex];

                if(busIndexA.notNil and: { busIndexB.notNil }) {
                    ("[RunAll/RMS] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                        ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                    installRmsListener.();
                    installSynthDef.();
                    stopRmsSynth.();
                    startRmsSynthAtTail.(busIndexA, busIndexB);
                    resolved = true;
                }{
                    if(triesLeft == 20) { "[RunAll/RMS] waiting for chainA/chainB busses...".postln };
                    0.25.wait; triesLeft = triesLeft - 1;
                };
            };

            if(resolved.not) {
                "⚠️ [RunAll/RMS] could not resolve busses (chains not playing?). Start a source and re-run this file.".warn;
            };
        }).play(AppClock);
    };

    // Cleanup when window closes
    rmsWindow.onClose_({
        if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
        if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
        if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
        "[RunAll/RMS] closed and cleaned up.".postln;
    });

    // Kick off discovery and return window
    discoverBussesAndStart.();
    rmsWindow
};

// Master sequence: execute your four scripts in order, then start the RMS window
scheduleSequence = {
    AppClock.sched(0.00, {
        ensureBaseDir.();
        executeFileOnce.(fReset, "00_Reset_KnownClean_State.scd");
        nil
    });

    AppClock.sched(longPause, {
        executeFileOnce.(fStartHere, "01b_StartHere_NoReboot.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause, {
        executeFileOnce.(fAssertStereo, "02S_AssertStereo_ChainAB_and_Retap_SAFE.scd");
        nil
    });

    AppClock.sched(longPause + mediumPause + smallPause, {
        executeFileOnce.(fTestSource, "02D_TestSource_CenteredStereo_Pulsed.scd");
        nil
    });

    // Start the isolated RMS HUD after bring-up + source have had a moment to run
    AppClock.sched(longPause + mediumPause + smallPause + longPause, {
        finalWindow = buildRmsIsolatedHud.();
        // Report and return
        "[RunAll] ✅ RMS_IsolatedHUD started.".postln;
        finalWindow;
    });
};

// Kick off the sequence and return the window when ready
scheduleSequence.();

// Return something immediately; the RMS window will be returned by the scheduled step.
// To see '-> a Window' in the post window after completion, re-select and run only the last line:
// finalWindow;
)

===== troubleshooting/startheres/Finish_WriteStatus_SaveToOneDrive.scd =====
// Finish_WriteStatus_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Write an end-of-session status snapshot to OneDrive and return the file path.

What it records
- Timestamp, SC version, platform, sampleRate, server status, window count,
  suite path (under Extensions), and this file's location if available.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no non-local returns.
*/

(
var server, dirPath, pathName, stamp, filePath, writeLine, f, suitePath, windowCount, scVer, platformInfo;
var herePath;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";
dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
pathName = PathName(dirPath);
stamp = Date.getDate.stamp.replace($:, $_);
filePath = dirPath +/+ ("status_" ++ stamp ++ ".txt");
scVer = Main.scVersionString;
platformInfo = Platform.name.asString ++ " " ++ Platform.architecture.asString;
windowCount = Window.allWindows.size;
herePath = thisProcess.nowExecutingPath ? "<interactive>";

pathName.isFolder.if({ }, { pathName.mkdirAll; });

writeLine = { arg txt; f.write(txt ++ Char.nl); };

f = File(filePath, "w");
writeLine.("=== MPB EOD STATUS SNAPSHOT ===");
writeLine.("timestamp: " ++ stamp);
writeLine.("sc_version: " ++ scVer);
writeLine.("platform: " ++ platformInfo);
writeLine.("server_running: " ++ server.serverRunning);
writeLine.("server_sampleRate: " ++ server.sampleRate);
writeLine.("windows_open: " ++ windowCount);
writeLine.("suite_path: " ++ suitePath);
writeLine.("script_path: " ++ herePath);
f.close;

("[EOD] wrote " ++ filePath).postln;
filePath
)

===== troubleshooting/startheres/MD_Cleanup_ChainA_Unfeed.scd =====
// MD_Cleanup_ChainA_Unfeed.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Stop audio; clear and recreate Ndef(\chainA) so the pedalboard can drive it again.
*/

(
var done;
Server.default.bind({
    Ndef(\chainA).stop;
    Ndef(\chainA).clear;
    Ndef(\chainA).ar(2);
});
done = "Cleaned chainA—pedalboard can drive it again.";
done.postln;
done
)

===== troubleshooting/startheres/MD_Meters_PhaseA_Const.scd =====
// MD_Meters_PhaseA_Const.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Drive meters to exact values A=(0.25, 0.75), B=(0, 0) for 4s via /md/levels.

Style / Guard Rails
- Single () block; VAR-FIRST; finite; no server.sync.
*/

(
var hz, secs, sendToLang, sendPair, aL, aR, bL, bR, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_CONST] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);  // A
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);  // B
};

aL = 0.25; aR = 0.75; bL = 0.0; bR = 0.0;
startAt = thisThread.seconds; endAt = startAt + secs;

banner.("A=(" ++ aL ++ "," ++ aR ++ "), B=(0,0) for " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now;
    now = thisThread.seconds;
    (now < endAt).if({
        sendPair.([aL, aR], [bL, bR]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseA_Const scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseB_Ramp.scd =====
// MD_Meters_PhaseB_Ramp.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Animate A for 4s: L ramps 0→0.9, R ramps 0.9→0. B stays 0.
*/

(
var hz, secs, sendToLang, sendPair, startAt, endAt, banner, task;

hz = 12;
secs = 4.0;
banner = { arg text; var t; t = text; ("[MD_A_RAMP] " ++ t).postln; };
sendToLang = NetAddr("127.0.0.1", NetAddr.langPort);

sendPair = { arg aLR, bLR;
    var a0, a1, b0, b1;
    a0 = aLR[0]; a1 = aLR[1]; b0 = bLR[0]; b1 = bLR[1];
    sendToLang.sendMsg('/md/levels', 0, 2001, a0, a1);
    sendToLang.sendMsg('/md/levels', 0, 2002, b0, b1);
};

startAt = thisThread.seconds; endAt = startAt + secs;

banner.("Ramp A L:0→0.9, R:0.9→0 over " ++ secs ++ " s");
task = AppClock.sched(0.0, {
    var now, t, aL, aR;
    now = thisThread.seconds;
    (now < endAt).if({
        t = (now - startAt) / secs;          // 0..1
        aL = (0.9 * t).clip(0.0, 0.9);       // rise
        aR = (0.9 * (1 - t)).clip(0.0, 0.9); // fall
        sendPair.([aL, aR], [0.0, 0.0]);
        (1.0 / hz)
    }, {
        banner.("done.");
        nil
    });
});
"-> MD_Meters_PhaseB_Ramp scheduled."
)

===== troubleshooting/startheres/MD_Meters_PhaseC_Audio.scd =====
// MD_Meters_PhaseC_Audio.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Feed a sine into Ndef(\chainA), attach taps that SendReply /md/levels (A=2001, B=2002).
- Print expected RMS (A/√2) and measured A levels in console for 5s.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTap, makeTaps;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ≈0.1414 for 0.2

banner = { arg text; var t; t = text; ("[MD_A_AUDIO] " ++ t).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);  // replyID in 4th arg (correct)
        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// Feed test tone and play
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

makeTaps.();

OSCdef(\mdSpyA).free;  // ensure clean
OSCdef(\mdSpyA, { arg msg;
    var isA, l, r, line;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };  // replyID position
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
            ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.001);
        line.postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA).free;
    banner.("done (audio still playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS≈" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio scheduled."
)

===== troubleshooting/startheres/Meters_Sanity_6Lines_SaveToOneDrive.scd =====
// Meters_Sanity_6Lines_SaveToOneDrive.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Subscribe to /md/levels taps (A=2001, B=2002), sample 3 times, and print exactly 6 lines:
  "MDMTR: A (L,R)=(x.xx,y.yy)" then "MDMTR: B (L,R)=(x.xx,y.yy)" per sample.
- Save the 6 lines to OneDrive: ~/Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test/md_meters_<stamp>.txt
- Finite; auto-stops; cleans responders.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns.
- AppClock used for timing only; finite duration.
*/

(
var aLevels, bLevels, lines, sampleIndex, maxSamples, appTask, startTime;
var dirPath, pathName, filePath, stamp, makeDir;
var oscA, oscB, formatLine, writeFile, printLine;
var levelsUpdatedA, levelsUpdatedB;

aLevels = [0.0, 0.0];
bLevels = [0.0, 0.0];
levelsUpdatedA = false;
levelsUpdatedB = false;

lines = List.new;
sampleIndex = 0;
maxSamples = 3;
startTime = thisThread.seconds;

dirPath = Platform.userHomeDir +/+ "Library/CloudStorage/OneDrive-TheOpenUniversity/SC_MPB_Test";
stamp = Date.getDate.stamp.replace($:, $_); // safe for file names
pathName = PathName(dirPath);
filePath = dirPath +/+ ("md_meters_" ++ stamp ++ ".txt");

makeDir = {
    pathName.isFolder.if({ }, { pathName.mkdirAll; });
};

formatLine = { arg label, lr;
    var l, r;
    l = (lr[0] ? 0.0).asFloat.max(0.0);
    r = (lr[1] ? 0.0).asFloat.max(0.0);
    ("MDMTR: " ++ label ++ " (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001) ++ ")")
};

printLine = { arg text; text.postln; };

writeFile = {
    var f;
    makeDir.();
    f = File(filePath, "w");
    lines.do { arg ln; f.write(ln ++ Char.nl) };
    f.close;
    ("[MDMTR] wrote " ++ filePath).postln;
    filePath
};

// OSC responders: expect messages like /md/levels, id, ... , L, R.
// We match on reply id and pull the last two floats if present.
oscA = OSCdef(\mdLevelsA, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        aLevels = [l, r];
        levelsUpdatedA = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2001]);

oscB = OSCdef(\mdLevelsB, { arg msg, time, addr, recvPort;
    var vals, l, r;
    (msg.size >= 4).if({
        vals = msg.copyRange( (msg.size-2), (msg.size-1) );
        l = vals[0].asFloat;
        r = vals[1].asFloat;
        bLevels = [l, r];
        levelsUpdatedB = true;
    });
}, '/md/levels', recvPort:nil, srcID:nil, argTemplate:[2002]);

appTask = AppClock.sched(0.1, {
    var doOne;
    doOne = {
        var lineA, lineB;
        lineA = formatLine.("A", aLevels);
        lineB = formatLine.("B", bLevels);
        printLine.(lineA);
        printLine.(lineB);
        lines.add(lineA);
        lines.add(lineB);
        sampleIndex = sampleIndex + 1;
        levelsUpdatedA = false;
        levelsUpdatedB = false;
    };

    (sampleIndex < maxSamples).if({
        doOne.();
        0.6
    }, {
        OSCdef(\mdLevelsA).free;
        OSCdef(\mdLevelsB).free;
        writeFile.();
        nil
    })
});
"MDMTR: starting 3× sampling (A=2001, B=2002)…".postln;
filePath
)

===== troubleshooting/startheres/StartHere_CleanBoot_GridOrPerfHUD.scd =====
// StartHere_CleanBoot_GridOrPerfHUD.scd
// v0.1.0
// MD timestamp: 2025-09-26 16:13 GMT+1

/*
Purpose
- Clean boot pathway that brings up PerfHUD (guarded) and, if it fails, falls back to GridDemo.
- Ensures taps are running via LivePedalboardSystem-Taps_Stable.sc.
- Returns -> a Window (PerfHUD if healthy, otherwise Grid).

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock use is inside called files only; this wrapper remains finite.
- Loud console banners; prefer existing files; safe operations via Server.default.bind.
*/

(
var server, suitePath, stopDiagPath, perfhudPath, tapsPath, gridPath, gridMinPath;
var windowResult, banner, runFile, fallbackDone, fallbackWindow;

server = Server.default;
suitePath = Platform.userExtensionDir +/+ "LivePedalboardSuite";

stopDiagPath = suitePath +/+ "utilities/MD_Stop_All_MeterDiagnostics.scd";
perfhudPath  = suitePath +/+ "MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
/*tapsPath     = suitePath +/+ "LivePedalboardSystem/LivePedalboardSystem-Taps_Stable.sc";*/
tapsPath = suitePath +/+ "troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd";

gridPath     = suitePath +/+ "MagicPedalboard/MagicDisplayGUI_GridDemo.sc";
gridMinPath  = suitePath +/+ "utilities/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd";

banner = { arg text; ("[MPB-START] " ++ text).postln; };

runFile = { arg filePath;
    var exists, result;
    exists = File.exists(filePath);
    exists.if({
        ("[RUN] " ++ filePath).postln;
        result = thisProcess.interpreter.executeFile(filePath);
        ("[OK ] " ++ filePath).postln;
    }, {
        ("[MISS] " ++ filePath).warn;
        result = nil;
    });
    result
};

banner.("Clean boot begin — ensuring server and quiescent diagnostics…");

server.boot;
server.waitForBoot({
    Server.default.bind({
        server.initTree;
        server.defaultGroup.freeAll;
    });
});

runFile.(stopDiagPath);

banner.("PerfHUD bring-up (guarded) …");
windowResult = runFile.(perfhudPath);

// Always start taps; if missing, we still continue to Grid fallback.
runFile.(tapsPath);

// If PerfHUD did not return a Window, fall back to Grid.
(windowResult.isKindOf(Window)).if({
    banner.("PerfHUD window active — returning PerfHUD.");
    windowResult
}, {
    banner.("PerfHUD did not yield a Window — falling back to Grid…");
    fallbackDone = false;
    fallbackWindow = runFile.(gridPath);
    (fallbackWindow.isKindOf(Window)).if({
        fallbackDone = true;
        banner.("GridDemo is active — returning Grid window.");
        fallbackWindow
    }, {
        // Try minimal grid bring-up
        fallbackWindow = runFile.(gridMinPath);
        (fallbackWindow.isKindOf(Window)).if({
            fallbackDone = true;
            banner.("Minimal GridDemo is active — returning Grid window.");
            fallbackWindow
        }, {
            // As a last resort, create a tiny placeholder window so we still return -> a Window.
            banner.("All bring-up files missing or failed — creating placeholder window.");
            Window("MagicDisplayGUI (Placeholder)", Rect(120, 120, 480, 260)).front;
        });
    });
});
)

===== troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd =====

===== troubleshooting/Taps_Stable_Runtime_Shim.scd =====
// Taps_Stable_Runtime_Shim.scd
// v0.1.1 (fix SendReply replyID position)
// MD timestamp: 2025-09-27 19:35 GMT+1

/*
Purpose
- Publish /md/levels with replyID in proper slot (msg[2]) so listeners match A=2001 / B=2002.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var server, rateHz, attachTap, ensureProxy, banner;

server = Server.default;
rateHz = 12;

banner = { arg text; ("[TAPS] " ++ text).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var sig, chans, l, r, ampL, ampR, trig;
        sig = inSig;
        chans = sig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l }); // mono -> duplicate
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(rateHz);

        // *** Correct: replyID is the 4th arg, values exclude replyID
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        sig
    });
};

Server.default.bind({
    ensureProxy.(\chainA, 2);
    ensureProxy.(\chainB, 2);
    attachTap.(\chainA, \eodTapA, 2001);
    attachTap.(\chainB, \eodTapB, 2002);
});

banner.("Taps active (/md/levels) — A=2001, B=2002 at " ++ rateHz ++ " Hz.");
"-> Taps_Stable_Runtime_Shim ready".postln;
Window.allWindows.detect({ |w| w.name.asString.beginsWith("MagicDisplayGUI") }) ? nil;
)

===== troubleshooting/turnintooneplease.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"✅ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW — ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD’s window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ——— bring-up sequence ———

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your “-> a Window” acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd → -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB→0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/WorkingSequence_20250929-1649.scd =====
// WorkingSequence_20250929-1649.scd

/*
We have proof of principle working with these:

00_Reset_KnownClean_State.scd
03_Sanity_Beep.scd
01b_StartHere_NoReboot.scd
02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
PERFHUD_InlineTaps_On_ChainAB.scd
INSTALL_AmpA_AmpB_Responders_Min.scd <-- key


*/
===== utilities/ControlLogVerbosity.scd =====
// ControlLogVerbosity.sc
// v1
// MD 20250923-0835

// error = 0
// warn = 1
// info = 2
// debug = 3
// trace = 4

MDMiniLogger.get.setverbosity(2);
===== utilities/DEMO20250923_FIXED.scd =====
// DEMO20250923_FIXED.scd
// v0.2.0
// MD 2025-09-23 10:46 BST

/* Purpose
 - Run the 2025-09-23 demo steps while updating MagicDisplayGUI at each step.
 - Uses ~nav_handleFret from the SimNav patch (Fix 1) so the GUI shows choices
   and "Apply → ..." on leaf selections.
Style
 - var-first; AppClock-only; no server.sync; one MagicDisplayGUI window.
*/

(
var steps, gap, i, runStep, schedNext;

if(~system.isNil) { "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil };
if(~nav_handleFret.isNil) { "⚠️ Load SimNav_Bridge_ApplyLeafPayload_FIX.scd first".warn; ^nil };

// Your original script, now paced:
steps = [
    // Add delay → /add/delay
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 1) }, // add
    { ~nav_handleFret.(4, 1) }, // delay (leaf → applies)

    // Switch → /switch
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 3) }, // switch (leaf → applies)

    // Bypass delay ON
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 2) }, // bypass
    { ~nav_handleFret.(4, 1) }, // delay
    { ~nav_handleFret.(3, 2) }, // on (leaf)

    // Bypass delay OFF
    { ~nav_handleFret.(6,10) },
    { ~nav_handleFret.(5, 2) },
    { ~nav_handleFret.(4, 1) },
    { ~nav_handleFret.(3, 3) }, // off (leaf)

    // Set source testmelody → /setSource/testmelody
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 4) }, // setSource
    { ~nav_handleFret.(4, 1) }  // testmelody (leaf)
];

// pacing
gap = 0.55;
i = 0;
runStep = { steps[i].value; i = i + 1; if(i < steps.size) { schedNext.() } };
schedNext = { AppClock.sched(gap, { runStep.(); nil }) };

// kick off and ensure GUI is showing something
~nav_reset.();
AppClock.sched(0.0, { runStep.(); nil });
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay → /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf → applies)


//Switch → /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf → applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody → /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Editor_AddCommands_Branch_Canonical.scd =====
// Editor_AddCommands_Branch_Canonical.scd
// v0.1.7
// MD 20250923-0956

(
/*
Purpose
- Ensure a minimal 'commands' branch exists in the canonical CommandTree JSON used by LivePedalboardSystem.
- Set each leaf's payload under 'commands' to a canonical path string ("/verb/arg/...").
- Uses only known-good methods; no caret returns; var-first at top-level.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPath, tree, ok, proceed;
var findChildByName, ensureChildUnder, ensurePath;
var commandsNode, printSampleLeaves, showFirstN;
var setCanonicalPayloads, buildPathsDown, buildPathFromSegments, rootCmd, count;

// ── entry banner ─────────────────────────────────────────────────────────────
"──────────────────────────────────────────────────────────────────────────────".postln;
"Editor_AddCommands_Branch_Canonical: ENTER".postln;

// ── canonical JSON path (LivePedalboardSuite) ────────────────────────────────
jsonPath = Platform.userExtensionDir
  ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
("JSON path → " ++ jsonPath).postln;

// ── load tree ────────────────────────────────────────────────────────────────
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPath);
("import ok → " ++ ok).postln;
proceed = ok;

// ── helpers (only stable fields/methods) ─────────────────────────────────────
findChildByName = { |parentNode, childName|
  var wanted, found;
  wanted = childName.asString;
  found = nil;
  parentNode.children.do({ |c|
    if(c.name.asString == wanted) { found = c };
  });
  found
};

ensureChildUnder = { |parentNode, childName, fretNumber|
  var existing, created, fret;
  fret = fretNumber ? 1;
  existing = findChildByName.(parentNode, childName);
  if(existing.notNil) {
    existing
  }{
    created = tree.addNode(parentNode.id, childName.asString, fret);
    if(created.isNil) { ("⚠️ addNode failed for " ++ childName).postln };
    created
  }
};

ensurePath = { |names, frets|
  var node, i, count, name, fret;
  node = tree.root;
  i = 0; count = names.size;
  while({ i < count }, {
    name = names[i];
    fret = frets[i] ? 1;
    node = ensureChildUnder.(node, name, fret);
    i = i + 1;
  });
  node
};

showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new;
  i = 0;
  while({ i < lim }, {
    out.add(listIn[i]);
    i = i + 1;
  });
  out.asArray
};

// ── do the work only if load succeeded ───────────────────────────────────────
if(proceed) {
  // 1) ensure 'commands' branch + minimal leaves (idempotent)
  ensurePath.( ["commands"], [10] );
  ensurePath.( ["commands","add","delay"],            [10,1,1] );
  ensurePath.( ["commands","bypass","delay","on"],    [10,2,1,2] );
  ensurePath.( ["commands","bypass","delay","off"],   [10,2,1,3] );
  ensurePath.( ["commands","switch"],                 [10,3] );
  ensurePath.( ["commands","setSource","testmelody"], [10,4,1] );

  // 2) normalize payloads and tag depths
  tree.assignPayloads;     // payload := name where missing
  tree.root.tagByDepth(0);

  // 2b) set canonical path strings for each 'commands' leaf ("/verb/arg/...")
  buildPathFromSegments = { |segs|
    var out, i, lim;
    out = "";
    i = 0; lim = segs.size;
    while({ i < lim }, {
      out = out ++ "/" ++ segs[i];
      i = i + 1;
    });
    out
  };

  setCanonicalPayloads = {
    rootCmd = findChildByName.(tree.root, "commands");
    if(rootCmd.isNil) {
      "⚠️ cannot set payloads: 'commands' missing.".postln;
    }{
      count = 0;
      buildPathsDown = { |node, segs|
        if(node.isLeaf) {
          node.payload = buildPathFromSegments.(segs);
          count = count + 1;
        }{
          node.children.do({ |child|
            var nextSegs;
            nextSegs = segs.copy;
            nextSegs.add(child.name.asString);
            buildPathsDown.(child, nextSegs);
          });
        }
      };
      // seed with immediate children of 'commands'
      rootCmd.children.do({ |child|
        buildPathsDown.(child, [child.name.asString]);
      });
      ("set canonical payloads on " ++ count ++ " leaf/leaves under 'commands'").postln;
    };
  };

  setCanonicalPayloads.();

  // 3) save back to the canonical file
  tree.exportJSONFile(jsonPath);
  ("✅ Updated commands branch in → " ++ jsonPath).postln;

  // 4) sample a few payloads under 'commands' (sanity)
  commandsNode = findChildByName.(tree.root, "commands");
  if(commandsNode.isNil) {
    "⚠️ 'commands' node not found after ensure-path (unexpected).".postln;
  }{
    printSampleLeaves = {
      var visit, payloads;
      payloads = List.new;
      visit = { |n|
        if(n.isLeaf) {
          payloads.add((n.payload ?? n.name).asString);
        }{
          n.children.do(visit);
        }
      };
      visit.(commandsNode);
      ("sample payloads: " ++ showFirstN.(payloads, 8).asString).postln;
    };
    printSampleLeaves.();
  };
}{
  ("❌ Failed to load " ++ jsonPath ++ " (no changes made)").postln;
};

// ── exit banner ──────────────────────────────────────────────────────────────
"Editor_AddCommands_Branch_Canonical: EXIT".postln;
"──────────────────────────────────────────────────────────────────────────────".postln;
)

===== utilities/Fallback_Diag_OneShot.scd =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("⚠️ Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("⚠️ ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("⚠️ pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("⚠️ pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk → present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter → " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect → " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("⚠️ pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("⚠️ pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("⚠️ pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("⚠️ pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("⚠️ bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("⚠️ verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify …");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " → " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("… tick → next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("⚠️ pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/FallbackDemo_ManualSequence.scd =====
// FallbackDemo_ManualSequence
// v0.1.3
// MD 20250923

// Purpose:
// - Apply a fixed sequence of canonical commands to MagicPedalboardNew.
// - Uses AppClock for scheduling; no Routine or Task.
// - Follows Martin's SC style: var-first, descriptive names, no server.sync, AppClock-only GUI ops.

(


var canonicalCommands, commandIndex, commandDelay;
var applyCommand, runNextCommand;
var pedalboardRef, bypassState;

canonicalCommands = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

commandIndex = 0;
commandDelay = 0.6;
pedalboardRef = if(~system.notNil) { ~system.pedalboard } { nil };

applyCommand = { |canonicalPath|
    ("[FallbackDemo] apply → " ++ canonicalPath).postln;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, ~system.statusDisplay);
    } {
        if(pedalboardRef.isNil) {
            ("[FallbackDemo] pedalboard is nil; skipping " ++ canonicalPath).warn;
            nil;
        } {
            if(canonicalPath == "/add/delay") {
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(\delay);
                };
            } {
            if(canonicalPath == "/switch") {
                if(pedalboardRef.respondsTo(\switchChain)) {
                    pedalboardRef.switchChain(0.12);
                };
            } {
            if(canonicalPath == "/bypass/delay/on") {
                bypassState = true;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
            if(canonicalPath == "/bypass/delay/off") {
                bypassState = false;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
                ("[FallbackDemo] unhandled command: " ++ canonicalPath).warn;
            }}}};
        };
    };
};

runNextCommand = {
    if(commandIndex >= canonicalCommands.size) {
        ("[FallbackDemo] done.").postln;
        nil;
    } {
        applyCommand.(canonicalCommands[commandIndex]);
        commandIndex = commandIndex + 1;

        AppClock.sched(commandDelay, {
            runNextCommand.();
            nil;
        });
    };
};

runNextCommand.();
)

===== utilities/GUI_QuickFix_Choices_Contrast.scd =====
// GUI_QuickFix_Choices_Contrast.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   Improve legibility of the "Choices" panel immediately (runtime).
   Style: var-first; AppClock-only; no server.sync.
*/

(
var displayRef, choicesPanelView, choicesTitleView, choicesTextView, canDo;

displayRef = ~system ? nil;
if(displayRef.isNil or: { ~system.statusDisplay.isNil }) {
  "⚠️ No status display found; bring-up first.".warn; ^nil;
};
displayRef = ~system.statusDisplay;

displayRef.queueUi({
  choicesPanelView = displayRef.tryPerform(\choicesPanel);
  choicesTitleView = displayRef.tryPerform(\choicesTitle);
  choicesTextView  = displayRef.tryPerform(\choicesText);

  if(choicesPanelView.notNil and: { choicesPanelView.respondsTo(\background_) }) {
    choicesPanelView.background_(Color(0.12, 0.12, 0.12));
  };
  if(choicesTitleView.notNil and: { choicesTitleView.respondsTo(\stringColor_) }) {
    choicesTitleView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  if(choicesTextView.notNil and: { choicesTextView.respondsTo(\stringColor_) }) {
    choicesTextView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  nil
});
)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "❌ Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "❌ Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Inspect_CommandTree_Under_Chain.scd =====
// Inspect_CommandTree_Under_Chain.scd
// v0.1.0
// MD 20250923--1255

/* Purpose
   Print child names (with frets) under "chain"; also prints under "add" if present.
   Helps confirm the live tree route to "delay".
   Style
   - var-first; descriptive variable names; no server.sync.
*/

(
var environmentReady, commandManager, commandTree, chainNode, addNode;
var listChildren, findChildByName;

environmentReady = (~system.notNil) and: { ~system.commandManager.notNil };
if(environmentReady.not) { "⚠️ Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn; ^nil };

commandManager = ~system.commandManager;
commandTree    = commandManager.tree;

listChildren = { |nodeRef, labelText|
  var childrenArray, childLines;
  if(nodeRef.isNil) { ("[INSPECT] " ++ labelText ++ ": <nil>").postln; ^nil };
  childrenArray = nodeRef.children ? [];
  if(childrenArray.isEmpty) {
    ("[INSPECT] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[INSPECT] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil
};

findChildByName = { |parentNode, childNameString|
  if(parentNode.isNil) { ^nil };
  ^parentNode.getChildByName(childNameString.asString);
};

// 1) under "chain"
chainNode = commandTree.root.getChildByName("chain");
listChildren.(chainNode, "Children under [chain]");

// 2) under "chain → add" (if present)
addNode = findChildByName.(chainNode, "add");
if(addNode.notNil) { listChildren.(addNode, "Children under [chain → add]") };
)

===== utilities/Install_LightweightMeterPrinters.scd =====
// Install_LightweightMeterPrinters.scd
// v0.1
// MD 20250923-1556

/* Purpose
   Quiet console printers for '/ampA' and '/ampB' that print only non-zero-ish values.
*/

(
var threshold, freeIfExists;

threshold = 0.02;

freeIfExists = { |defName|
  var existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

freeIfExists.(\_meterA_dbg);
freeIfExists.(\_meterB_dbg);

OSCdef(\_meterA_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterA] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampA');

OSCdef(\_meterB_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterB] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampB');

"✅ Lightweight printers installed (non-zero only).".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "❌ Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("✅ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QuietProxyMeters_Core.scd =====
// Install_QuietProxyMeters_Core.scd
// v0.1
// MD 20250923-1610

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) using .filter:
   - Low-rate sampling with Impulse.kr.
   - Threshold gate from UGens (no Boolean 'or:').
   - Sends '/ampA' '/ampB' only when above threshold.
   - No console prints by default.

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold;
var ensureProxyAudio, installOrReplaceTap, installForProxy;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyAudio = { |proxyName|
  Server.default.bind({
    Ndef(proxyName).ar(2); // ensure 2ch audio-rate proxy exists
  });
};

installOrReplaceTap = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampLeft, ampRight, ampMax, tick, gate;

      // robust channel fetch
      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0.0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // per-channel level followers
      ampLeft  = Amplitude.kr(leftIn, 0.01, 0.15);
      ampRight = Amplitude.kr(rightIn, 0.01, 0.15);
      ampMax   = ampLeft.max(ampRight);     // <- UGen-safe combine

      // low-rate tick and gate when above threshold (UGen compare)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (ampMax > postThreshold); // 0 or tick

      // emit values only when above threshold
      SendReply.kr(gate, oscPath, [ampLeft, ampRight]);

      // pass-through audio unchanged
      inSig
    });
  });
};

installForProxy = { |proxyName, oscPath|
  ensureProxyAudio.(proxyName);
  installOrReplaceTap.(proxyName, oscPath);
};

installForProxy.(\chainA, '/ampA');
installForProxy.(\chainB, '/ampB');

"✅ Quiet proxy taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"✅ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/MD_EOD_Status_Snapshot_FIXED.scd =====
// MD_EOD_Status_Snapshot_FIXED.scd
// v0.1.1
// MD 2025-09-26 16:56 BST

/* Purpose / Style
   Purpose: Record where SC is loading LivePedalboardSuite from and write a status file to OneDrive.
   Style:   Single () block; var-first in all closures; ≥3-char lowercase descriptive names;
            no single-letter locals; no non-local ^; finite output.
*/

(
var postBanner, writeStatus, isSymlink, readLinkTarget;
var extensionsDir, extSuitePath, odRootPath, statusFolderPath, outFilePath, linkTargetText, isLink, exitCode;

// ---- header ----
postBanner = {
    var headerText;
    headerText = "=== MD_EOD_STATUS_SNAPSHOT (FIXED) ===";
    headerText.postln;
};

// ---- helpers (var-first inside closures) ----
isSymlink = { arg pathString;
    var testCmd, code, flag;
    testCmd = "[ -L \"" ++ pathString ++ "\" ]";
    code = testCmd.unixCmd;        // 0 if symlink, non-zero otherwise
    flag = (code == 0);
    flag
};

readLinkTarget = { arg pathString;
    var pipeRef, cmd, line;
    cmd = "readlink \"" ++ pathString ++ "\"";
    pipeRef = Pipe.new(cmd, "r");
    if(pipeRef.isNil) { "(unavailable)" } {
        line = pipeRef.getLine ? "(unavailable)";
        pipeRef.close;
        line
    }
};

writeStatus = { arg folderPath, bodyText;
    var ensureFolderOk, fileName, fullPath;
    ensureFolderOk = PathName(folderPath).isFolder;
    if(ensureFolderOk.not) { File.mkdir(folderPath) };
    fileName = "sc_status_" ++ Date.getDate.stamp ++ ".txt";
    fullPath = folderPath +/+ fileName;
    File.use(fullPath, "w", { arg fileRef; fileRef.write(bodyText) });
    ("EOD: wrote " ++ fullPath).postln;
    fullPath
};

// ---- run ----
postBanner.();

extensionsDir  = Platform.userExtensionDir.standardizePath;
extSuitePath   = extensionsDir +/+ "LivePedalboardSuite";
("EXT: " ++ extSuitePath).postln;

isLink = isSymlink.(extSuitePath);
if(isLink) {
    linkTargetText = readLinkTarget.(extSuitePath);
} {
    linkTargetText = "(not a symlink)";
};
("EXT: target = " ++ linkTargetText).postln;

// OneDrive folder we’re using today
odRootPath = "/Users/martindupras/Library/CloudStorage/OneDrive-TheOpenUniversity";
statusFolderPath = odRootPath +/+ "SC_MPB_Test";

outFilePath = writeStatus.(statusFolderPath,
    "EOD snapshot at " ++ Date.getDate.stamp
    ++ "\nExtensions dir         = " ++ extensionsDir
    ++ "\nSuite path             = " ++ extSuitePath
    ++ "\nSuite link target      = " ++ linkTargetText
    ++ "\n"
);

// final expression (implicit return; no ^ in .scd)
outFilePath
)

===== utilities/MD_Stop_All_MeterDiagnostics.scd =====
// MD_Stop_All_MeterDiagnostics.scd
// v0.1.1
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Quiet the console by freeing known OSCdef listeners and stopping any reporter routines
            we may have created during diagnostics. Safe to run multiple times. Auto-stops.
   Style:   single () block; var-first everywhere; descriptive lowercase names; AppClock-only where used;
            no server.sync; no single-letter locals; returns nil.
*/

(
var freeOscIfPresent, stopRoutineIfPresent, freedCount, oscKeys, indexCount, indexLimit;
var reporterStoppedCount, oscObj, routineRef;

// —— helpers (var-first in closures)
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MDSTOP: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineVar, labelString;
    var canStop;
    canStop = routineVar.notNil and: { routineVar.respondsTo(\stop) };
    if(canStop) { routineVar.stop; (labelString ++ ": stopped").postln };
};

// —— free known listeners (only if present)
freedCount = 0;
oscKeys = [
    \md_levels_sniffer_fixed,    // finite/continuous sniffers
    \md_levels_inline,           // overlay listener (if any)
    \md_levels_dbg_sniffer,      // debug taps listener
    \md_levels_gui_listener,     // if we created a GUI-only listener
    \md_levels_hud               // HUD listener (optional – remove if you want it kept)
];
indexCount = 0; indexLimit = oscKeys.size;
while({ indexCount < indexLimit }, {
    var keySym, exists;
    keySym = oscKeys[indexCount];
    exists = OSCdef.all.at(keySym).notNil;
    if(exists) { freeOscIfPresent.(keySym); freedCount = freedCount + 1 };
    indexCount = indexCount + 1;
});

// —— stop known reporter routines (only if present)
reporterStoppedCount = 0;
stopRoutineIfPresent.(~md_levels_dbg_reporter, "md_levels_dbg_reporter"); reporterStoppedCount = reporterStoppedCount + 1;
stopRoutineIfPresent.(~md_simple_reporter,     "md_simple_reporter");     reporterStoppedCount = reporterStoppedCount + 1;

// —— clear diagnostic dictionaries (safe)
~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
~md_levels_dbg = ~md_levels_dbg ? IdentityDictionary.new;

("MDSTOP: freed=" ++ freedCount.asString
 ++ " stopped=" ++ reporterStoppedCount.asString).postln;
nil
)

===== utilities/Meters_Diagnostic_Bootstrap_FIX.scd =====
// Meters_Diagnostic_Bootstrap_FIX.scd
// v0.1.1
// MD 20250923-1543

/* Purpose
   - Ensure bus meter SynthDefs exist (defines them via MagicDisplay.ensureMeterDefs(2) if needed).
   - Instantiate meter readers on Ndef(\chainA) and Ndef(\chainB) buses.
   - Install console debug printers for '/ampA' and '/ampB' using correct OSCdef.free pattern.

   Style
   - var-first; Server.default.bind for server ops; AppClock-safe UI; no server.sync.
*/

(
var serverRef, statusDisplayRef, chainABusIndex, chainBBusIndex, metersGroupId;
var ensureMeterDefsExist, installDebugPrinters, freeIfExists;

serverRef        = Server.default;
statusDisplayRef = (~system ? nil).notNil.if({ ~system.statusDisplay }, { nil });

ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "ℹ️ Defining meter synths (busMeterA/busMeterB).".postln;
    MagicDisplay.ensureMeterDefs(2); // should be idempotent in your codebase
  };
};

freeIfExists = { |defName|
  var existingDef;
  existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

installDebugPrinters = {
  // Avoid duplicates by
===== utilities/Meters_QuickCheck_And_Enable.scd =====
// Meters_QuickCheck_And_Enable.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - Ensure meter SynthDefs exist (busMeterA/B).
   - Attach meter readers to Ndef(\chainA/\chainB) buses.
   - Print incoming values to console (quick sanity).
   - Re-enable GUI meters if the display supports it.

   Style
   - var-first; Server.default.bind for server ops; no server.sync.
*/

(
var serverRef, displayRef, chainABusIndex, chainBBusIndex, metersGroup;
var ensureMeterDefsExist, installConsolePrinters;

serverRef  = Server.default;
displayRef = ~system ? nil;

// --- helpers ---
ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "⚠️ Meter SynthDefs missing — defining now via MagicDisplay.ensureMeterDefs(2)".postln;
  };
  MagicDisplay.ensureMeterDefs(2); // idempotent
};

installConsolePrinters = {
  // avoid duplicates
  OSCdef.remove(\_meterA_dbg);
  OSCdef.remove(\_meterB_dbg);
  OSCdef(\_meterA_dbg, { |oscMessage| ("[meterA] " ++ oscMessage[3..].asString).postln }, '/ampA');
  OSCdef(\_meterB_dbg, { |oscMessage| ("[meterB] " ++ oscMessage[3..].asString).postln }, '/ampB');
};

// --- server work ---
Server.default.bind({
  ensureMeterDefsExist.value;

  // ensure both chain proxies are realized at audio-rate
  Ndef(\chainA).ar(2);
  Ndef(\chainB).ar(2);
  chainABusIndex = Ndef(\chainA).bus.index;
  chainBBusIndex = Ndef(\chainB).bus.index;

  metersGroup = Group.head(serverRef.defaultGroup);

  // spawn readers (safe to re
===== utilities/MIDI_Input_Tests_20250922.scd =====
// MIDI_Input_Tests_20250922.scd
// Run these step by step

// STEP A — canonical bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);   // nil -> class default tree path
    ~system.bringUpAll;
}.defer;
)


// STEP B — Refresh and connect MIDI at the SC level (safe anytime)
(
MIDIClient.restart;     // re-scan devices (good after hot-plug)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"✅ SC MIDI inputs refreshed & connected.".postln;
)



// STEP C — Inspect manager + the symbol names you can bind
(
var mi;

mi = ~system.commandManager.midiManager;

"—— Device symbols → UIDs (from MIDIInputManager) ——".postln;
mi.listDeviceSymbols;   // prints "Symbol: \NAME  → UID: 1234..."

"—— Pretty device listing ——".postln;
mi.listDevices;         // prints the connected devices it sees
)


// STEP D — Bind nanoKEY2 and IAC "to SC" to handlers
(
var mi = ~system.commandManager.midiManager;

// nanoKEY2 -> FootController (so notes 36/38/40/41 switch idle/prog/queue/send)
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);

// IAC "to SC" -> Guitar handler (so notes become frets during PROG mode)
mi.bindDevice(\MD_IAC_to_SC, mi.guitarHandler);

// Show current bindings (srcID → symbol → handler)
"—— Bound handlers (srcID → symbol → handler) ——".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect { |k| mi.deviceUIDs[k] == srcID } ? \UNKNOWN;
    ("  " ++ srcID ++ "  →  " ++ sym ++ "  →  " ++ handler.class.name).postln;
};
)


// Option 1
MIDIdef.trace(true);   // start tracing all MIDI events
// Press a nanoKEY2 key (or send a note to IAC "to SC") — you should see noteOn/off
// When done:
MIDIdef.trace(false);

// Option 2:
// Install once; re-evaluate if you hot-plug (it rebuilds the map)
(
var buildMap;
~midiLog_srcFilter = nil;  // e.g. set to \nanoKEY2_KEYBOARD to filter (optional)
~midiLog_chanFilter = nil; // e.g. set to 1 to filter (optional)
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name)
            .replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%"
                .format(sym, chan, num, val)).postln;
        };
    };
});

// quick refresh if you hot-plug:
~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

// stop logger if needed:
~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k| MIDIdef(k).free };
    "[MIDI-LOG] stopped".postln;
};

"[MIDI-LOG] ACTIVE — press nanoKEY2 or send to IAC".postln;
)


===== utilities/MIDI_Input_Tests2_20250922.scd =====
//MIDI_Input_Tests2_20250922.scd

// 0) Bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
}.defer;
)


// 1) Refresh MIDI in SC and connect all sources
(
MIDIClient.restart;     // re-scan devices (safe after hot-plugging)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"✅ SC MIDI inputs refreshed & connected.".postln;
)


// 2) See the symbols your app uses and their UIDs
(
var mi = ~system.commandManager.midiManager;
"—— Device symbols → UIDs (from MIDIInputManager) ——".postln;
mi.listDeviceSymbols;
"—— Pretty device listing ——".postln;
mi.listDevices;
)


// 3) Bind nanoKEY2 -> FootController; IAC 'to SC' -> Guitar
(
var mi = ~system.commandManager.midiManager;
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);
mi.bindDevice(\MD_IAC_to_SC,      mi.guitarHandler);

// Print bound table (srcID → symbol → handler)
"—— Bound handlers (srcID → symbol → handler) ——".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect({ |k| mi.deviceUIDs[k] == srcID }) ? \UNKNOWN;
    ("  " ++ srcID ++ "  →  " ++ sym ++ "  →  " ++ handler.class.name).postln;
};
)

MIDIdef.trace(true);   // enable global trace
// press keys on nanoKEY2 or send notes to IAC "to SC"
MIDIdef.trace(false);

// 4B) Install raw taps (noteOn/noteOff/cc)
(
var mkLabel, fns;

mkLabel = { |src|
    var ep = MIDIClient.sources.detect({ |e| e.uid == src });
    if(ep.notNil) { (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_") } { "uid:" ++ src }
};

~midiTap_remove.(); // remove any previous tap safely (defined below)

// keep references so we can remove cleanly
~midiTap_fns = IdentityDictionary[
    \noteOn  -> MIDIIn.addFuncTo(\noteOn,  { |src, chan, num, vel| ("[RAW] noteOn  src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \noteOff -> MIDIIn.addFuncTo(\noteOff, { |src, chan, num, vel| ("[RAW] noteOff src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \control -> MIDIIn.addFuncTo(\control, { |src, chan, num, val| ("[RAW] cc     src=%  ch=%  num=%  val=%".format(mkLabel.(src), chan, num, val)).postln; })
];

~midiTap_remove = {
    if(~midiTap_fns.notNil) {
        ~midiTap_fns.keysValuesDo { |k, fn| if(fn.notNil) { MIDIIn.removeFuncFrom(k, fn) } };
        ~midiTap_fns = nil;
        "[RAW] taps removed".postln;
    } {
        // noop
    };
};

"[RAW] taps installed — press nanoKEY2 or send to IAC".postln;
)


// 4C) Minimal logger (noteOn/off & CC), with map refresh helper
(
var buildMap;
~midiLog_srcFilter = nil;
~midiLog_chanFilter = nil;
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k|
        var def = MIDIdef(k);
        if(def.notNil) { def.free };
    };
    "[MIDI-LOG] stopped".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%".format(sym, chan, num, val)).postln;
        };
    };
});

"[MIDI-LOG] ACTIVE — press nanoKEY2 or send to IAC".postln;
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "🔎 [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"✅ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "🛑 [MIDI-LOG] stopped.".postln;
};
)

===== utilities/MIDI_Log_RefreshAndConnect.scd =====
// MIDI_Log_RefreshAndConnect.scd
// v0.1.0
// MD 20250922-1422

/*
Purpose
- If you plugged devices while SC was running, restart the MIDI client,
  reconnect all inputs, and refresh the logger's source map.
- Also clears any logger filters so you see everything.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

(
var announce;

announce = { |title| ("[MIDI-LOG] " ++ title).postln };

MIDIClient.restart;           // re-scan devices (idempotent & safe)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

~midiLog_srcFilter = nil;     // show all sources
~midiLog_chanFilter = nil;    // show all channels

if(~midiLog_refresh.isKindOf(Function)) {
    ~midiLog_refresh.();      // rebuild the uid->label map used by the logger
    announce.("sources remapped.");
} {
    announce.("note: logger not installed yet; run MIDI_Log_Console.scd first.");
};

// quick device listing
"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };
"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"✅ [MIDI-LOG] refresh complete — play/send something to see messages.".postln;
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "⚠️ Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "🧹 Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("📥 Command added: " ++ canonicalPathString).postln;
("📦 Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Quick_SetSource_Testmelody.scd =====
// Quick_SetSource_Testmelody.scd
// v0.1.0  MD 2025-09-26
(
var systemRef, cmRef, cb;
systemRef = ~system; if(systemRef.isNil) { "⚠️ ~system is nil; bring-up first.".warn; ^nil };
cmRef = systemRef.commandManager; if(cmRef.isNil) { "⚠️ CommandManager is nil.".warn; ^nil };
cb = cmRef.queueExportCallback;
if(cb.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    cb = cmRef.queueExportCallback;
};
if(cb.isKindOf(Function)) {
    cb.value("/commands/setSource/testmelody");  // from your tree: commands → setSource → testmelody
    "[SetSource] '/commands/setSource/testmelody' sent.".postln;
} {
    "⚠️ queueExportCallback missing.".warn;
};
)

===== utilities/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "⚠️ ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "⚠️ CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "⚠️ queueExportCallback missing.".warn };
)

===== utilities/Rearm_Attach_Probes_AfterBringUp.scd =====
// Rearm_Attach_Probes_AfterBringUp.scd
// v0.1.0  MD 2025-09-26
(
var baseTrouble, runIfExists;
baseTrouble = Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/troubleshooting";
runIfExists = { arg leaf;
    var p = (baseTrouble ++ "/" ++ leaf).standardizePath;
    if(File.exists(p)) { p.load } { ("⚠️ missing " ++ leaf).warn };
};

AppClock.sched(0.10, { runIfExists.("MagicDisplayGUI_Reenable_FilterMeters_V0.3.12.scd"); nil });
AppClock.sched(0.20, { runIfExists.("MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd"); nil });
AppClock.sched(0.30, { runIfExists.("MagicDisplayGUI_ResetReceiver_v0.3.11.scd"); nil });
"[Rearm] bus/probe helpers scheduled.".postln;
)

===== utilities/Report_ChainPlayFlags.scd =====
// Report_ChainPlayFlags.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Print whether Ndef(\chainA) and Ndef(\chainB) are playing.
   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var isChainAPlaying, isChainBPlaying;

isChainAPlaying = Ndef(\chainA).isPlaying;
isChainBPlaying = Ndef(\chainB).isPlaying;

("[PLAY] chainA=" ++ isChainAPlaying ++ "  chainB=" ++ isChainBPlaying).postln;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "⚠️ Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok → " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply → " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) → child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" → "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] → " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf — print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager’s builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X → Name" lines for the GUI’s Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI’s expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager’s builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply → " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready — use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply → " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "⚠️ Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok → " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready — call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long → short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long → short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain → add → delay        (preferred if present)
       (b) chain → add → timebased → delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> → /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> → /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path→ " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) → still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

===== utilities/Test_MagicPedalboard_MIDI_Simulation.scd =====
// Test_MagicPedalboard_MIDI_Simulation.scd
// v0.1.1
// MD 20250922-18-15

/*
Purpose
- Simulate MIDI input sequences for MagicPedalboard system testing.
- Each test step is labeled and commented with expected GUI/behavior.
- Allows repeatable, device-free testing and can be bundled with the suite.

Style
- var-first; lowercase; AppClock-only; no server.sync; clear comments.
*/

// --- Device UIDs: update these to match your system ---
var nanoUID = 302172822;    // nanoKEY2_KEYBOARD
var iacUID  = 1339807908;   // MD_IAC_to_SC

// --- Helper: fire a sequence of steps ---
~fireMidiSequence = { |steps|
    Routine({
        steps.do { |step|
            var src, chan, note, vel, dur, comment;
            src = step[0]; chan = step[1]; note = step[2];
            vel = step[3]; dur = step[4]; comment = step[5];
            ("[TEST] " ++ comment).postln;
            MIDIIn.doNoteOnAction(src, chan, note, vel);
            (dur ? 0.5).wait;
            MIDIIn.doNoteOffAction(src, chan, note, 0);
            0.1.wait;
        }
    }).play(AppClock);
};

// --- Test Sequence 1: Add Delay and Send ---
~test_add_delay = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 → enter PROG mode"],
    [iacUID,  0, 41, 100, 0.5, "Step 2: IAC string 6 → select /add"],
    [iacUID,  1, 45, 100, 0.5, "Step 3: IAC string 5 → select /delay"],
    [nanoUID, 0, 40, 100, 0.5, "Step 4: nanoKEY2 E2 → queue path"],
    [nanoUID, 0, 41, 100, 0.5, "Step 5: nanoKEY2 F2 → send path"]
];

// --- Test Sequence 2: Switch Chain ---
/*~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 → enter PROG mode"],
    [iacUID,  0, 48, 100, 0.5, "Step 2: IAC string 6 → select /switch"],
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 → queue /switch"],
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 → send /switch"]
];*/
~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 → enter PROG mode"], // enter prog mode
    [iacUID,  0, 43, 100, 0.5, "Step 2: IAC string 6 → select /switch"], // pitch 43 = base 40 + fret 3
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 → queue /switch"],   // queue
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 → send /switch"]     // send
];



// --- To run a test sequence ---
~fireMidiSequence.(~test_add_delay);
// ~fireMidiSequence.(~test_switch_chain); // ← uncomment to run this one

// --- Add more sequences below as needed ---

===== utilities/Verify_Baseline_CurrentAudible_NextSilent.scd =====
// Verify_Baseline_CurrentAudible_NextSilent.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Verify that CURRENT’s sink is the audible one and NEXT’s sink is silent (Option A).
   - Posts a clear PASS/FAIL with details.

   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var systemReady, pedalboardRef;
var currentSinkSymbol, nextSinkSymbol;
var isChainAPlaying, isChainBPlaying;
var currentIsAudible, nextIsSilent;
var summaryText;

// guards
systemReady = ~system.notNil;
if(systemReady.not) {
    "⚠️ ~system is nil. Run Start_LivePedalboardSystem.scd (Option B) first.".postln;
};

// proceed only if ready
if(systemReady) {
    pedalboardRef = ~system.pedalboard;

    // sink symbols at the heads of CURRENT/NEXT
    currentSinkSymbol = pedalboardRef.effectiveCurrent[0];  // \chainA or \chainB
    nextSinkSymbol    = pedalboardRef.effectiveNext[0];     // \chainB or \chainA

    // live flags (do not change any routing)
    isChainAPlaying = Ndef(\chainA).isPlaying;
    isChainBPlaying = Ndef(\chainB).isPlaying;

    // interpret flags relative to CURRENT/NEXT
    currentIsAudible =
        ((currentSinkSymbol == \chainA) and: { isChainAPlaying })
        or: { (currentSinkSymbol == \chainB) and: { isChainBPlaying } };

    nextIsSilent =
        ((nextSinkSymbol == \chainA) and: { isChainAPlaying.not })
        or: { (nextSinkSymbol == \chainB) and: { isChainBPlaying.not } };

    if(currentIsAudible and: { nextIsSilent }) {
        "✅ Baseline OK: CURRENT is audible; NEXT is silent.".postln;
    }{
        summaryText =
            "⚠️ Baseline mismatch — "
            ++ "CURRENT=" ++ currentSinkSymbol.asString
            ++ " NEXT=" ++ nextSinkSymbol.asString
            ++ " | chainA=" ++ isChainAPlaying
            ++ " chainB=" ++ isChainBPlaying;
        summaryText.postln;
    };
};
)

