// MagicDisplayGUI_Meters_Draw_Ext.sc
// v0.3.0  â€” MD 2025-09-24 23:10 BST
/*
Purpose
- Provide enableMeters(flag=true) without ivars; draw A/B bars inside meterStrip : UserView
  driven by /reply messages from SendReply.kr labels "/ampA" and "/ampB".
Style
- Class extension only; var-first; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    // per-window state in a global dictionary keyed by window.identityHash (no ivars)
    md_meterState {
        var bag, key, dict;
        bag = ~md_meterState ? IdentityDictionary.new;
        key = this.window.identityHash;
        dict = bag[key] ? IdentityDictionary.new;
        bag[key] = dict;
        ~md_meterState = bag;
        ^dict
    }

    md_installMeterUserView {
        var state, host, setup;
        state = this.md_meterState;
        host  = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        setup = {
            var uv, ownUV, w, h, y;
            uv = state[\uv];
            ownUV = state[\own];

            if(uv.isNil) {
                uv = meterStrip;  // preferred: your class has meterStrip : UserView
                if(uv.isNil) {
                    // fallback: create a narrow strip at bottom
                    w = host.bounds.width; h = host.bounds.height; y = h - 46;
                    uv = UserView(host);
                    uv.bounds_(Rect(8, y, w - 16, 38));
                    ownUV = true;
                };
                uv.background_(Color(0.12, 0.12, 0.12));
                uv.drawFunc_({ |view|
                    var st, vw, vh, a, b, barW, barH, leftX, rightX, midY, titleY;
                    st = this.md_meterState;
                    vw = view.bounds.width;  vh = view.bounds.height;
                    a = (st[\valA] ? 0.0).clip(0, 1);
                    b = (st[\valB] ? 0.0).clip(0, 1);

                    barW = ((vw * 0.45) - 40);
                    if(barW < 80) { barW = 80 };
                    barH = (vh * 0.40);
                    leftX  = 24;
                    rightX = (vw * 0.50) + 24;
                    midY   = (vh * 0.30);
                    titleY = (vh * 0.18);

                    Pen.color = Color(0.85, 0.85, 0.85);
                    Pen.stringAtPoint("A", Point(leftX - 18, titleY));
                    Pen.stringAtPoint("B", Point(rightX - 18, titleY));

                    Pen.color = Color(0.30, 0.90, 0.30); // A green
                    Pen.addRect(Rect(leftX,  midY, barW * a, barH)); Pen.fill;

                    Pen.color = Color(0.30, 0.60, 0.90); // B blue
                    Pen.addRect(Rect(rightX, midY, barW * b, barH)); Pen.fill;
                });
                state[\uv]  = uv;
                state[\own] = if(ownUV.isNil) { false } { ownUV };
                uv.refresh;
            };
        };

        AppClock.sched(0.0, { setup.value; nil });
        ^this
    }

    enableMeters { arg flag = true;
        var state, idStr, oscNameA, oscNameB, install, remove;

        state    = this.md_meterState;
        idStr    = this.window.identityHash.asString;
        oscNameA = ("md_ampA_" ++ idStr).asSymbol;
        oscNameB = ("md_ampB_" ++ idStr).asSymbol;

        remove = {
            var oa, ob, uv;
            oa = OSCdef(oscNameA); if(oa.notNil) { oa.free };
            ob = OSCdef(oscNameB); if(ob.notNil) { ob.free };
            state[\valA] = 0.0; state[\valB] = 0.0;
            uv = state[\uv]; if(uv.notNil) { uv.refresh };
            state[\enabled] = false;
        };

        install = {
            var uv;
            this.md_installMeterUserView;
            uv = state[\uv];

            // /reply payload from SendReply.kr is: [ <nodeID>, <label>, <values...> ]
            OSCdef(oscNameA, { arg msg;
                var label, a, b, mean;
                label = msg[2].asString;
                if((label == "/ampA") || (label == "ampA")) {
                    a = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
                    b = (msg.size > 4).if({ msg[4] }, { a }).asFloat; // mono-safe
                    mean = ((a + b) * 0.5).clip(0, 1);
                    state[\valA] = mean;
                    AppClock.sched(0.0, { if(uv.notNil) { uv.refresh }; nil });
                };
            }, '/reply');

            OSCdef(oscNameB, { arg msg;
                var label, a, b, mean;
                label = msg[2].asString;
                if((label == "/ampB") || (label == "ampB")) {
                    a = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
                    b = (msg.size > 4).if({ msg[4] }, { a }).asFloat;
                    mean = ((a + b) * 0.5).clip(0, 1);
                    state[\valB] = mean;
                    AppClock.sched(0.0, { if(state[\uv].notNil) { state[\uv].refresh }; nil });
                };
            }, '/reply');

            state[\enabled] = true;
        };

        AppClock.sched(0.0, { if(flag) { install.value } { remove.value }; nil });
        ^this
    }
}
