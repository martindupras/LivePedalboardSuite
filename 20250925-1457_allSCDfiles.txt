===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"üóÇ CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "‚úÖ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("‚úÖ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("üóë Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("‚ö†Ô∏è Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "üíæ Tree saved to versioned file.".postln;
} {
    "‚ö†Ô∏è No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "‚úÖ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "‚ùå Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("‚úÖ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"üíæ Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandNode test.scd =====
(
// Set a fixed random seed for reproducibility
thisThread.randSeed = 12345;

// Global node counter and limit
~nodeLimit = 50;
~nodeCount = 1;
~fixedChildren = 3;

// Create root node
~root = MDCommandNode.new("root", 0);

// Breadth-first queue
~nodeQueue = List[~root];

// Build tree
while {
    (~nodeQueue.notEmpty and: { ~nodeCount < ~nodeLimit })
} {
    var parent = ~nodeQueue.removeAt(0);
    ("Adding " ++ ~fixedChildren ++ " children to " ++ parent.name).postln;

    ~fixedChildren.do {
        if (~nodeCount < ~nodeLimit) {
            var childName = parent.name ++ "_" ++ ~nodeCount;
            var child = MDCommandNode.new(childName, ~nodeCount);
            parent.addChild(child);
            ~nodeQueue.add(child);
            ("Created node: " ++ child.name ++ " | Total nodes: " ++ ~nodeCount).postln;
            ~nodeCount = ~nodeCount + 1;
        };
    };
};

// Print tree
"Generated Tree Structure:".postln;
~root.printTreePretty("", true);

// Check integrity
"Running integrity check...".postln;
~root.checkIntegrity;

// Count total nodes
~countNodes = { |node|
    var count = 1;
    node.children.do { |c|
        count = count + ~countNodes.(c);
    };
    ^count;
};

("‚úÖ Total nodes in tree: " ++ ~countNodes.(~root)).postln;
"Tree printed.".postln;
"end".postln;
)


b = MDCommandTree("root", 0);

===== CommandTree/MDCommandNodeTest20250731.scd =====
(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 3);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 11);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 7);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 5);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 11);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 11);


// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;

)



/////////////////////
/// BUILD A TREE - older version.
/////////////////////

(
// Setup
var tree, root, lvl1A, lvl1B, lvl2A, lvl2B, lvl3A, lvl3B, lvl3C;
var printSummary;

// üå± Initialize tree and root
tree = MDCommandTree.new("root", 0, 1);
root = tree.root;

// üß© Level 1
lvl1A = tree.addNode(root.id, "Branch A", 2);
lvl1B = tree.addNode(root.id, "Branch B", 3);

// üß© Level 2
lvl2A = tree.addNode(lvl1A.id, "SubBranch A1", 4);
lvl2B = tree.addNode(lvl1B.id, "SubBranch B1", 5);

// üß© Level 3
lvl3A = tree.addNode(lvl2A.id, "Twig A1a", 6);
lvl3B = tree.addNode(lvl2A.id, "Twig A1b", 7);
lvl3C = tree.addNode(lvl2B.id, "Twig B1a", 8);

// üè∑Ô∏è Tag depth from root
tree.root.tagByDepth(0);

// üìã Node Summary
printSummary = {
    tree.nodeMap.values.do { |node|
        (node.name ++ " ‚Üí depthTag: " ++ node.depthTag ++ ", getDepth: " ++ node.getDepth).postln;
    };
};

// üñºÔ∏è Print results
printSummary.();
tree.printTreePretty;

tree.getNodeByName("Twig A1b").printPathToRoot;

)

===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// üìã Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " ‚Üí").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/test_circularSaves20250826.scd =====
// test_circularSaves20250826.scd
// MD



(
// Step 1: Load the latest saved tree version
~tree = MDCommandTree.new("root");
~loaded = ~tree.loadLatestVersion;

if (~loaded) {
    "Latest tree loaded.".postln;
    "Tree before modification:".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è No saved tree found. Starting with empty tree.".postln;
};
)

(
// Step 2: Save current version for comparison
~originalJSON = ~tree.saver.latestVersion;
)

(
// Step 3: Modify the tree
~newNode = ~tree.addNode(0, "NewNode", 99);

if (~newNode.notNil) {
    "New node added.".postln;
    ~tree.printTreePretty;
} {
    "‚ö†Ô∏è Failed to add new node.".postln;
};
)

(
// Step 4: Save the modified tree as a new version
~tree.saveVersioned;
)

(
// Step 5: Compare original and new JSON
~newJSON = ~tree.saver.latestVersion;

if (~originalJSON != ~newJSON) {
    "Change confirmed: tree content has been updated.".postln;
} {
    "‚ö†Ô∏è No change detected between versions.".postln;
};
)













// (
// // Step 1: Create a new tree
// ~tree = MDCommandTree.new("root");
//
// // Step 2: Add some nodes
// ~tree.addNode(0, "A", 1);
// ~tree.addNode(1, "B", 2);
// ~tree.addNode(2, "C", 3);
// "‚úÖ Nodes added.".postln;
// ~tree.printTreePretty;
// )
//
// (
// // Step 3: Save the tree using CircularFileSave
// ~tree.saveVersioned;
// )
//
// (
// // Step 4: List saved versions
// ~tree.listSavedVersions;
// )
//
// (
// // Step 5: Load the latest saved version
// ~tree.loadLatestVersion;
// )
//
// (
// // Step 6: Print the tree to confirm it was restored
// "‚úÖ Tree after loading latest version:".postln;
// ~tree.printTreePretty;
// )

===== CommandTree/testCircularSave_20250819.scd =====
// Create a saver
~saver = CircularFileSave.new("myTree");

// Save a version
~saver.saveVersion("This is version " ++ Date.getDate.stamp);

// List saved versions
~saver.listVersions;

// Load a specific version
~saver.loadVersion(0).postln;

===== CommandTree/Tests/TestLogging_CommandBuilder.scd =====
TestLogging_CommandBuilder.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var jsonPath, tree, builder;

MDMiniLogger.get.setverbosity(3); // DEBUG

jsonPath = Platform.userExtensionDir ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
tree = MDCommandTree.new("root");
tree.importJSONFile(jsonPath);

builder = MDCommandBuilder.new(tree);
builder.printChildren;
builder.navigateByName(nil, "SomeChildName"); // INFO/WARN depending on your tree
builder.resetNavigation;
builder.printfretPath;
)

===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path ‚Üí " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) ‚Äî informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic ‚Äî print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' ‚Üí " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported ‚Üí " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("‚ö†Ô∏è Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== CommandTree/Tests/TestLogging_FullBringUp.scd =====
TestLogging_FullBringUp.scd
v0.1.0
MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


(
var lps;
MDMiniLogger.get.setverbosity(2); // INFO

lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;

// Switch to DEBUG if you want more detail for a moment
MDMiniLogger.get.setverbosity(3);

lps.commandManager.setStatus("Sanity check: status via MDMiniLogger");
)

===== CommandTree/TestUserDisplay.scd =====
(
~displayTest = UserDisplay.new;

~displayTest.display(\state, "üß≠ State: treeNav");
~displayTest.display(\queue, "üìã Queue: audio ‚Üí noise ‚Üí 100");
~displayTest.display(\lastCommand, "üïò Last Command: 100");
~displayTest.display(\choices, "üéö Choices:\nFret 7: noise\nFret 9: oscillators");
)

===== CommandTree/testVerbosity.scd =====
// temp

(
// üß™ Set verbosity level to 0 (errors only)
Verbosity.setLevel(0);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 2 (up to input/output)
Verbosity.setLevel(2);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");

"---".postln;

// üß™ Set verbosity level to 4 (everything)
Verbosity.setLevel(4);
Verbosity.postIf(0, "üî¥ Level 0: Errors only");
Verbosity.postIf(1, "üü† Level 1: Actions");
Verbosity.postIf(2, "üü° Level 2: Input/Output");
Verbosity.postIf(3, "üîµ Level 3: Object reporting");
Verbosity.postIf(4, "üü£ Level 4: Everything");
)

Verbosity.help;
===== Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd =====
// Sim_MIDIInput_Emulator_For_TreeNav.scd
// v0.1.2
// MD 20250924-1510
/*
Purpose
- Emulate hardware control of your system:
  ‚Ä¢ FOOT controller: mode changes (idle/prog/queue/send).
  ‚Ä¢ MIDI GUITAR: string/fret ‚Üí channel/pitch ‚Üí tree navigation.
- Keep everything in ONE file; evaluate section-by-section.

Style
- var-first in every block/closure; lowercase methods; no server.sync.
- Works with your current LivePedalboardSystem, CommandManager, and adapter bridge.
- Generated audio only (no SoundIn); Option A exclusivity remains enforced by your bring-up.
*/

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [0] Bring-up (idempotent): system + GUI + MagicPedalboard + adapter bridge
//    Evaluate once after a fresh compile (or re-run to refresh).
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var needNew, systemRef;

// If an older system exists, shut it down cleanly.
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) {
    ~system.shutdownAll;
};

// Create (or reuse) the LivePedalboardSystem and bring everything up.
needNew = (~system.isNil);
if(needNew) {
    systemRef = LivePedalboardSystem.new(nil); // nil ‚Üí class default JSON path resolver
    ~system = systemRef;
};

~system.bringUpAll;          // server + GUI + pedalboard + command system + meters
~system.installAdapterBridge; // queueExportCallback routes SHORT canonicals to MPB via adapter

// Convenience handles
~cm  = ~system.commandManager;
~mm  = ~cm.midiManager;
~mpb = ~system.pedalboard;
~gui = ~system.statusDisplay;

"‚úÖ System is up. (~system, ~cm, ~mm, ~mpb, ~gui)".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [1] Emulation helpers (define once)
//    These call your actual handlers‚Äîno MIDI devices required.
//    FOOT MAPPING (noteOn): 36‚Üí\idle, 38‚Üí\prog, 40‚Üí\queue, 41‚Üí\send
//    GUITAR MAPPING (channels 0..5 ‚Üí strings 6..1) with bases [40,45,50,55,59,64]
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var ensure, bases;

// Basic guard so we don't call handlers before bring-up.
ensure = {
    var ok;
    ok = ~system.notNil
     and: { ~system.commandManager.notNil }
     and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "‚ö†Ô∏è Run section [0] (bring-up) first.".warn };
    ok
};

// E A D G B E (low‚Üíhigh), per your GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40,  // chan 0 ‚Üí string 6 (E2)
    1 -> 45,  // chan 1 ‚Üí string 5 (A2)
    2 -> 50,  // chan 2 ‚Üí string 4 (D3)
    3 -> 55,  // chan 3 ‚Üí string 3 (G3)
    4 -> 59,  // chan 4 ‚Üí string 2 (B3)
    5 -> 64   // chan 5 ‚Üí string 1 (E4)
];

// FOOT: emulate pressing a foot button (note number).
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    // channel is irrelevant for FootControllerHandler; value = note number.
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);
};

// Foot shortcuts
~toIdle  = { ~fc.(36) };  // idle
~toProg  = { ~fc.(38) };  // prog (tree navigation)
~toQueue = { ~fc.(40) };  // queue (enqueue current canonical)
~toSend  = { ~fc.(41) };  // send  (export & apply queue via bridge)

// GUITAR: emulate ‚Äúplay fret‚Äù on given string (1..6).
// Computes channel = 6 - string, pitch = base + fret; calls your GuitarMIDIHandler.
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "‚ö†Ô∏è Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Convenience alias for navigation (string,fret)
~nav = { arg s, f; ~gm.(s, f) };

// Peek: print the builder‚Äôs path and the canonical short form (e.g., "/add/delay").
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);
    ("‚Ä¢ long=" ++ long ++ "  |  canonical=" ++ short).postln;
};

// Optional: show available choices in GUI (if present)
~refreshChoices = {
    if(~system.notNil) { ~system.commandManager.updateDisplay };
};
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [2] Scenario A ‚Äî Add delay to NEXT via guitar nav, then switch
//    Top-level/children/grandchildren frets per your mapping:
//    string 6 fret 1 ‚Üí "audio", string 5 fret 5 ‚Üí "timebased", string 4 fret 3 ‚Üí "delay"
//    Then queue (note 40) and send (note 41) ‚Üí adapter applies "/add/delay"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();           // enter navigation mode
~refreshChoices.();   // optional UI refresh
~nav.(6, 1);          // 6/1 ‚Üí audio
~nav.(5, 5);          // 5/5 ‚Üí timebased
~nav.(4, 3);          // 4/3 ‚Üí delay
~showNav.();          // should report canonical "/add/delay"
~toQueue.();          // enqueue
~toSend.();           // apply via adapter
done = true;
"‚úÖ Scenario A complete (add delay, then you can use Scenario B to switch).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [3] Scenario B ‚Äî Switch chain from top-level ‚Äúswitch‚Äù
//    string 6 fret 5 ‚Üí "switch" ‚Üí queue ‚Üí send
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 5);      // top-level "switch"
~showNav.();      // should be "/switch"
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario B complete (switch with guarded crossfade).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [4] Scenario C ‚Äî Bypass: chain ‚Üí bypass ‚Üí delay ‚Üí on
//    Adjust frets if your JSON uses slightly different grandchildren numbers.
//    Example: 6/3="chain", 5/9="bypass", 4/3="delay", 3/3="on"
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
(
var done;
~toProg.();
~nav.(6, 3);   // "chain"
~nav.(5, 9);   // "bypass"
~nav.(4, 3);   // "delay"
~nav.(3, 3);   // "on"    // change to actual fret if needed
~showNav.();
~toQueue.();
~toSend.();
done = true;
"‚úÖ Scenario C complete (bypass delay ON).".postln;
)

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// [5] Quick extras
//    ‚Ä¢ Re-run [2] then [3] to hear the effect.
//    ‚Ä¢ To bypass OFF, redo [4] but pick ‚Äú‚Ä¶/off‚Äù as per your tree‚Äôs leaf fret.
//    ‚Ä¢ Inspect the current queue at any time:
//        ~system.commandManager.midiManager.queue.commandList.postln;
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

===== LivePedalboardSystem/CommandTreeStructureDiagram.scd =====
// updated 20250922-2147

root
‚îú‚îÄ‚îÄ audio (string 6, fret 1)
‚îÇ   ‚îú‚îÄ‚îÄ source      (string 5, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ testmelody (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ sine       (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ noise      (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ timebased   (string 5, fret 5)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ delay     (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ multitap  (string 3, fret 3)
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ pingpong  (string 3, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ chorus    (string 4, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ modulation (string 5, fret 7)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tremolo   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phaser    (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ flanger   (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ filter (string 5, fret 9)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lowpass   (string 4, fret 3)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ highpass  (string 4, fret 5)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bandpass  (string 4, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ reverb (string 5, fret 11)
‚îÇ   ‚îî‚îÄ‚îÄ drive  (string 5, fret 13)

‚îú‚îÄ‚îÄ chain (string 6, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ add         (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ remove      (string 5, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ swap        (string 5, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ bypass      (string 5, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ clear       (string 5, fret 11)
‚îÇ   ‚îú‚îÄ‚îÄ setsource   (string 5, fret 13)
‚îÇ   ‚îî‚îÄ‚îÄ print       (string 5, fret 15)

‚îú‚îÄ‚îÄ switch (string 6, fret 5)
‚îÇ   ‚îú‚îÄ‚îÄ crossfade         (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ crossfade_custom  (string 5, fret 5)

‚îú‚îÄ‚îÄ preset (string 6, fret 7)
‚îÇ   ‚îú‚îÄ‚îÄ save        (string 5, fret 3)
‚îÇ   ‚îî‚îÄ‚îÄ load        (string 5, fret 5)

‚îú‚îÄ‚îÄ system (string 6, fret 9)
‚îÇ   ‚îú‚îÄ‚îÄ reset       (string 5, fret 3)
‚îÇ   ‚îú‚îÄ‚îÄ healthcheck (string 5, fret 5)
‚îÇ   ‚îî‚îÄ‚îÄ status      (string 5, fret 7)
===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue‚Üíadapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ‚Üê ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil ‚Üí class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;



	    ~system.installAdapterBridge;         // ‚Üê MUST be before enableAutoMeters


	    // *** NEW: inline meter taps + post-switch auto-reinstall + GUI re-arm
    ~system.enableAutoMeters(18, 0.35);
    }.defer;
)


===== LivePedalboardSystem/Tests/Demo_Today_Playbook_FallbackOnly.scd =====
// Demo_Today_Playbook_FallbackOnly.scd
// v0.1.3
// MD 2025-09-22 23:45 BST

/* Purpose
   - Hardware-independent fallback to demonstrate MagicPedalboardNew.
   - Applies canonical commands in sequence, EVEN IF hardware is connected.
   - If your adapter (~ct_applyOSCPathToMPB) is present, it is used; otherwise
     this script calls MagicPedalboardNew methods directly for /add, /setSource,
/switch, /bypass commands.
   - Uses generated audio only (no SoundIn) and enforces Option A exclusivity.

   Style
   - tilde vars ok at top level; var-first in every function/closure.
   - lowercase method names; no server.sync; Server.default.bind for Ndef ops.
   - AppClock-only UI updates; no caret returns in deferred closures.
*/

(

var gapSeconds, playlistA, playlistB,
    systemReady, pedalboardReady,
    logMessage, showGuiHint,
    ensureGeneratedSources,
    tryEnsureAdapter, adapterAvailable, applyViaAdapter,
    applyDirectToPedalboard, applyOneCommand,
    runPlaylist, stopPlaylist, startGeneration;

"[FALLBACK] entered".postln;
thisProcess.nowExecutingPath.postln;  // helps confirm you ran the right file

// ‚îÄ‚îÄ settings ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
gapSeconds = 0.60;
playlistA  = [ "/add/delay", "/switch" ];
playlistB  = [ "/bypass/delay/on", "/bypass/delay/off", "/switch" ];

// ‚îÄ‚îÄ guards ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
systemReady     = ~system.notNil;
pedalboardReady = systemReady and: { ~system.pedalboard.notNil };


if(systemReady.not) {
    "‚ö†Ô∏è  Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B)".warn;
    ^nil;
};

// ‚îÄ‚îÄ logging + GUI hint ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
logMessage = { |text| ("[FALLBACK] " ++ text).postln };
showGuiHint = { |text|
    var canShow;
    canShow = (~system.notNil)
        and: { ~system.statusDisplay.notNil }
        and: { ~system.statusDisplay.respondsTo(\showExpectation) };
    if(canShow) { ~system.statusDisplay.showExpectation(text, 0) };
};

// ‚îÄ‚îÄ audio sources + option A exclusivity ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
ensureGeneratedSources = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
/*            Ndef(\testmelody, {
                var trig, frequencySeq, freq, env, pan;
                trig         = Impulse.kr(3.2);
                frequencySeq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq         = Demand.kr(trig, 0, frequencySeq);
                env          = Decay2.kr(trig, 0.01, 0.35);
                pan          = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });*/

			Ndef(\testmelody, {
    var trig, freq, env, pan, scale, idx;
    trig = Impulse.kr(2.2); // relaxed tempo
    scale = [60, 62, 64, 67, 69]; // C major pentatonic
    idx = Demand.kr(trig, 0, Dwhite(0, scale.size, inf)); // returns control-rate index
    freq = Select.kr(idx, scale).midicps; // safe indexing
    env = Decay2.kr(trig, 0.01, 0.4);
    pan = LFNoise1.kr(0.3).range(-0.7, 0.7);
    Pan2.ar(SinOsc.ar(freq) * env * 0.2, pan)
});

        };
        Ndef(\testmelody).ar(2);

        if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });

    if(~mpb.notNil) {
        ~mpb.setSourceCurrent(\testmelody);
        ~mpb.setSource(\testmelody);
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
    };
};

// ‚îÄ‚îÄ try to use your adapter (~ct_applyOSCPathToMPB) if available ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tryEnsureAdapter = {
    var scriptFolderPath, candidateNames, found;
    if(~ct_applyOSCPathToMPB.notNil) { ^true };

    scriptFolderPath = PathName(thisProcess.nowExecutingPath).pathOnly;
    candidateNames = [
        "adapter_CommandTree_to_MagicPedalboard.scd",
        "adapter_commandtree_to_magicpedalboard.scd"
    ];
    found = candidateNames.detect({ |leaf|
        var fullPath = scriptFolderPath +/+ leaf;
        File.exists(fullPath).if({ fullPath.load; true }, { false })
    });

    (~ct_applyOSCPathToMPB.notNil)
};
adapterAvailable = tryEnsureAdapter.();

applyViaAdapter = { |canonicalPath|
    var guiRef;
    guiRef = ~system.statusDisplay;
    // signature from your existing adapter: (path, mpb, gui)
    ~ct_applyOSCPathToMPB.(canonicalPath, ~system.pedalboard, guiRef);
};

// ‚îÄ‚îÄ direct mapping for the demo verbs if adapter is absent ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyDirectToPedalboard = { |canonicalPath|
    var pathSegments, verbName, effectSymbol, sourceSymbol,
        onOffString, bypassState, pedalboardRef;

    pedalboardRef = ~system.pedalboard;
    if(pedalboardRef.isNil) { logMessage.("pedalboard missing"); ^nil };

    pathSegments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(pathSegments.size == 0) { ^nil };
    verbName = pathSegments[0].asString;

    switch(verbName,

        "add", {
            if(pathSegments.size >= 2) {
                effectSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(effectSymbol);
                }{
                    logMessage.("no pedalboard.add; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /add path: " ++ canonicalPath);
            };
        },

        "setSource", {
            if(pathSegments.size >= 2) {
                sourceSymbol = pathSegments[1].asSymbol;
                if(pedalboardRef.respondsTo(\setSource)) {
                    pedalboardRef.setSource(sourceSymbol);
                }{
                    logMessage.("no pedalboard.setSource; skipped: " ++ canonicalPath);
                };
            }{
                logMessage.("bad /setSource path: " ++ canonicalPath);
            };
        },

        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                pedalboardRef.switchChain(0.12);
            }{
                logMessage.("no pedalboard.switchChain; skipped: " ++ canonicalPath);
            };
        },

        "bypass", {
            if(pathSegments.size >= 3) {
                effectSymbol = pathSegments[1].asSymbol;
                onOffString  = pathSegments[2].asString.toLower;
                bypassState  = (onOffString == "on") or: { onOffString == "true" } or: { onOffString == "1" };
                // for demo: act on CURRENT; your adapter usually controls NEXT
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(effectSymbol, bypassState);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        pedalboardRef.bypass(effectSymbol, bypassState);
                    }{
                        logMessage.("no pedalboard.bypass; skipped: " ++ canonicalPath);
                    };
                };
            }{
                logMessage.("bad /bypass path: " ++ canonicalPath);
            };
        },

        { // default
            logMessage.("unhandled verb: " ++ verbName ++ " (path=" ++ canonicalPath ++ ")");
        }
    );
};

// ‚îÄ‚îÄ unified apply: prefer adapter; fall back to direct mapping ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
applyOneCommand = { |canonicalPath|

    "DEBUG: applyOneCommand called with %".format(canonicalPath).postln;

    logMessage.("apply ‚Üí " ++ canonicalPath);
    if(adapterAvailable) { applyViaAdapter.(canonicalPath) } { applyDirectToPedalboard.(canonicalPath) };
    if(~procHud_update.notNil) { ~procHud_update.() }; // optional HUD refresh
};

// ‚îÄ‚îÄ sequenced playlist runner (AppClock; cancel-safe via generation id) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
runPlaylist = { |listOfCanonicalPaths, gap = 0.6|
    var myGeneration, indexCounter, totalCount, stepOnce, scheduleNext;

    // bump global generation to cancel older chains
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    myGeneration = ~fallback_gen;

    indexCounter = 0;
    totalCount   = listOfCanonicalPaths.size;

    stepOnce = {
        if(~fallback_gen != myGeneration) { ^nil }; // cancelled
        applyOneCommand.( listOfCanonicalPaths[indexCounter] );
        indexCounter = indexCounter + 1;
        if(indexCounter < totalCount) { scheduleNext.() } { logMessage.("done.") };
    };

    scheduleNext = {
        var delaySeconds;
        delaySeconds = gap ? 0.6;
        AppClock.sched(delaySeconds, {
            if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
        });
    };

    AppClock.sched(0.0, {
        if(~fallback_gen == myGeneration) { stepOnce.() } { nil }
    });

    ^myGeneration;
};

// ‚îÄ‚îÄ hard stop utility ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
stopPlaylist = {
    ~fallback_gen = (~fallback_gen ? 0) + 1;
    logMessage.("stopped.");
};

// ‚îÄ‚îÄ go ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
showGuiHint.(
    "Fallback-only demo (adapter=" ++ adapterAvailable ++ "):\n" ++
    "A: " ++ playlistA.asString ++ "\n" ++
    "B: " ++ playlistB.asString
);
ensureGeneratedSources.();
startGeneration = runPlaylist.(playlistA, gapSeconds);

// queue playlist B after A with a tail margin
AppClock.sched((playlistA.size * gapSeconds + 1.0).max(1.0), {
    if(~fallback_gen == startGeneration) {
        runPlaylist.(playlistB, gapSeconds);
    };
    nil
});
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail_Delayed.scd =====
// Fallback_Acceptance_PassFail_Delayed.scd
// v0.1.3
// MD 20250923-1534


/*
Purpose
- Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
- Verify A XOR B only AFTER crossfade settles (avoid false FAIL during fade).
- Extra diagnostics: print plan.size, first path, and every step index.
Style
- var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.
- Generated audio only; Option A enforced if available.
*/

(
var say, trace, assertXorAfter;
var ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne;
var plan, idx, gap, settle, runStep, kickOff;

/* logging helpers */
say   = { |msg| ("[ACCEPT] " ++ msg).postln };
trace = { |msg| ("[TRACE] "  ++ msg).postln };

/* delayed assertion to avoid crossfade overlap */
assertXorAfter = { |expectA, expectB, label, delaySeconds|
    var doCheck, delay;
    delay = delaySeconds ? 0.35; // default settle > 0.12 crossfade
    doCheck = {
        var a, b, okFlag, tag;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        okFlag = (a == expectA) and: { b == expectB };
        tag = if(okFlag) { "PASS" }{ "FAIL" };
        (tag ++ " ‚Äî " ++ label ++ " (A=" ++ a ++ " B=" ++ b ++ ")").postln;
    };
    AppClock.sched(delay, { doCheck.value; nil });
};

/* guards */
ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)"); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

/* ensure generated sources & Option A */
ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

/* application modes */
applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

/* plan: Events with optional verify on switch */
plan = [
    ( idx: 1, total: 5, path: "/add/delay" ),
    ( idx: 2, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: false, expectB: true,  label: "after first switch" ),
    ( idx: 3, total: 5, path: "/bypass/delay/on" ),
    ( idx: 4, total: 5, path: "/bypass/delay/off" ),
    ( idx: 5, total: 5, path: "/switch",           verifyDelay: 0.35, expectA: true,  expectB: false, label: "after second switch" )
];

/* extra instrumentation to confirm the plan really exists */
trace.("plan.size = " ++ plan.size);
if(plan.size > 0) {
    trace.("plan[0].path = " ++ plan[0][\path].asString);
} {
    say.("‚ö†Ô∏è plan is empty ‚Äî aborting to avoid a no-op run."); ^nil;
};

idx    = 0;
gap    = 0.60;
settle = 0.35;

/* run one step, then re-schedule next */
runStep = {
    var step, path, haveVerify, label, eA, eB, vd;
    if(idx >= plan.size) { say.("done."); ^nil; };

    step = plan[idx];
    trace.("step " ++ step[\idx] ++ " / " ++ step[\total]);

    path = step[\path].asString;
    applyOne.value(path);

    haveVerify = step.includesKey(\verifyDelay);
    if(haveVerify) {
        vd   = step[\verifyDelay] ? settle;
        eA   = step[\expectA];
        eB   = step[\expectB];
        label= step[\label].asString;
        assertXorAfter.value(eA, eB, label, vd);
        AppClock.sched(vd.max(gap), { idx = idx + 1; runStep.value; nil });
    }{
        AppClock.sched(gap, { idx = idx + 1; runStep.value; nil });
    };
};

/* go */
ensureSources.value;
kickOff = {
    var scheduled;
    trace.("scheduling kickoff in 0.03s on AppClock‚Ä¶");
    scheduled = AppClock.sched(0.03, { runStep.value; nil });
    ("[TRACE] AppClock.sched ‚Üí " ++ scheduled.asString).postln;
};
kickOff.value;
)

===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 ‚Äî 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " ‚Äî " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("‚ö†Ô∏è Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply ‚Üí " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct ‚Üí " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation‚Äôs audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through ‚Äúprocessor‚Äù that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) ‚Üí short delay ‚Üí mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through ‚Äúprocessor‚Äù you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== MagicPedalboard/Adapter_UIHook_Install.scd =====
// Adapter_UIHook_Install.scd
// v0.2.0
// MD 20250918-20:10 BST

/* Purpose
   - Wrap ~ct_applyOSCPathToMPB to call ~procHud_update after each token apply.
   - No behavior change to your adapter's logic.

   Style
   - var-first; lowercase; AppClock for UI calls; no server.sync.
*/

(
var wrap;

if(~ct_applyOSCPathToMPB.isNil) {
    "[UIHOOK] ~ct_applyOSCPathToMPB is nil; load the adapter file first.".warn;
    ^nil
};

if(~ct_applyOSCPathToMPB_orig.isNil) {
    ~ct_applyOSCPathToMPB_orig = ~ct_applyOSCPathToMPB;
};

wrap = { arg pathString, mpb, gui;
    var result;
    result = ~ct_applyOSCPathToMPB_orig.(pathString, mpb, gui);
    if(~procHud_update.notNil) {
        AppClock.sched(0.0, { ~procHud_update.(); nil });
    };
    result
};

~ct_applyOSCPathToMPB = wrap;
"[UIHOOK] adapter UI hook installed".postln;
)

===== MagicPedalboard/bootstrap_audio_and_fx_min.scd =====
// bootstrap_audio_and_fx_min.scd
// v0.1

(
Server.default.boot;
Server.default.bind({
    // Musical test source (stereo) ‚Äì guaranteed audibility
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f    = Demand.kr(trig, 0, seq);
        var env  = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
        Pan2.ar(tone, pan)
    });
    Ndef(\testmelody).ar(2);

    // Minimal \delay (stereo) ‚Äì matches your style using \in.ar
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig    = \in.ar(2);
        var delayed= CombC.ar(sig, 2.0, time.clip(0.01, 2.0),
                              time * (fb.clip(0.0, 0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\delay).ar(2);
});
)

===== MagicPedalboard/demo_apply_after_fix.scd =====
// demo_apply_after_fix.scd
// v0.1
// MD 20250916-1031

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Adapter must be present
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your JSON with payloads/verbs)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// Sequence: add delay -> switch -> bypass on -> bypass off -> switch
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_hotfix.scd =====
// demo_commandtree_apply_hotfix.scd
// v0.1
// MD 20250916-1020

(
var log;

log = { arg m; ("[DEMO] " ++ m).postln };

// Ensure adapter is loaded; if not, evaluate adapter_commandtree_to_magicpedalboard.scd
if(~ct_sendAndApply.isNil) {
    "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
};

// Reload CommandManager (imports your updated JSON with payloads)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// 1) add delay on NEXT
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch to hear delay on CURRENT
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON ‚Üí OFF ‚Üí final switch
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_apply_now.scd =====
// demo_commandtree_apply_now.scd
// v0.2
// MD 20250916-1003

(
var ensureAudio, ensureGui, ensurePedalboard, ensureAdapter, log;

// simple logger
log = { arg messageString; ("[DEMO] " ++ messageString).postln };

// A) Audio: boot + musical internal source (stereo)
ensureAudio = {
    Server.default.boot;
    Server.default.bind({
        Ndef(\testmelody, {
            var trig, seq, f, env, tone, panPos;
            trig = Impulse.kr(3.2);
            seq  = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
            f    = Demand.kr(trig, 0, seq);
            env  = Decay2.kr(trig, 0.01, 0.35);
            tone = SinOsc.ar(f) * env * 0.25;
            panPos = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
            Pan2.ar(tone, panPos)
        });
        Ndef(\testmelody).ar(2);

        // lightweight FX (safe to re-run)
        Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
            var sig = \in.ar(2);
            var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
            XFade2.ar(sig, delayed, (mix.clip(0,1) * 2 - 1))
        });
        Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
            var sig = \in.ar(2);
            var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
            DelayC.ar(sig, 0.1, mod)
        });
    });
};

// B) GUI: your runner guarantees one window + PROBE FRAME
ensureGui = {
    ~md_bootProbeScenario.();
};

// C) Pedalboard + GUI binding (reuse if present)
ensurePedalboard = {
    if(~gui.isNil) { ~gui = MagicDisplayGUI.new() };
    if(~pedalboard.isNil) { ~pedalboard = MagicPedalboardNew.new(~gui) };
    ~pedalboard.setSource(\testmelody);
    ~pedalboard.switchChain(0.12);
};

// D) Adapter presence
ensureAdapter = {
    if(~ct_sendAndApply.isNil) {
        "[DEMO] Please evaluate adapter_commandtree_to_magicpedalboard.scd first.".warn;
    };
};

// ---- run prep ----
ensureAudio.value;
ensureGui.value;
ensurePedalboard.value;
ensureAdapter.value;

// E) Reload CommandManager (imports updated myTree.json automatically)
~cm = CommandManager.new;
log.("CommandManager reloaded.");

// F) Drive actions via queue + SEND + adapter

// 1) add delay
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\add);
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) switch (make it CURRENT, audible)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) bypass delay ON, then OFF, then switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Inspect (also drives GUI detailed view)
~pedalboard.printChains;
)

===== MagicPedalboard/demo_commandtree_milestone.scd =====
// demo_commandtree_milestone.scd
// v0.1
// MD 20250916-0852

(
// ---- A) Audio source + basic FX (no server.sync, safe to re-run) ----
Server.default.boot;  // boot if not already

// Ensure an internal musical test source (stereo) as \testmelody
Server.default.bind({
    Ndef(\testmelody, {
        var trig = Impulse.kr(3.2);
        var seq = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
        var f  = Demand.kr(trig, 0, seq);
        var env = Decay2.kr(trig, 0.01, 0.35);
        var tone = SinOsc.ar(f) * env * 0.25;
        Pan2.ar(tone, ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6))
    });
    Ndef(\testmelody).ar(2);
});

// Optional: simple FX defaults (if not already defined elsewhere)
Server.default.bind({
    Ndef(\delay, { |in, time=0.45, fb=0.35, mix=0.5|
        var sig = \in.ar(2);
        var delayed = CombC.ar(sig, 2.0, time.clip(0.01, 2.0), time * (fb.clip(0,0.95) * 6 + 0.1));
        XFade2.ar(sig, delayed, mix.clip(0,1) * 2 - 1)
    });
    Ndef(\chorus, { |in, rate=0.8, depth=0.008, base=0.020|
        var sig = \in.ar(2);
        var mod = base.clip(0.0, 0.05) + (SinOsc.kr(rate.clip(0.1,5), 0, depth.clip(0.0,0.02)));
        DelayC.ar(sig, 0.1, mod)
    });
});

// ---- B) Bring up your single GUI window (runner you already have) ----
~md_bootProbeScenario.();   // ensures one MagicDisplayGUI window + PROBE FRAME
// ---- C) Ensure pedalboard & bind GUI as display if not already done ----
~gui = ~gui ?? { MagicDisplayGUI.new() };         // class builds window on AppClock internally
~pedalboard = ~pedalboard ?? { MagicPedalboardNew.new(~gui) };
~pedalboard.setSource(\testmelody);               // audible source
~pedalboard.switchChain(0.12);                    // fade in CURRENT

// ---- D) CommandManager (imports ~/CommandTreeSavefiles/myTree.json) ----
~cm = ~cm ?? { CommandManager.new };              // uses your importer path
// If you edited myTree.xml, convert to JSON now (uncomment):
// ~ct_convertXmlToJson.("~/myTree.xml", "~/CommandTreeSavefiles/myTree.json");
// ~cm = CommandManager.new;  // reinit to re-import
// ---- E) Demo sequence using your queue + SEND and the adapter ----
// 1) Add delay to NEXT (your current XML tokens may just be "delay"; adapter maps it to add/delay)
~cm.midiManager.queue.clear;
~cm.midiManager.queue.enqueueCommand(\delay);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 2) Switch to hear it (CURRENT <- NEXT)
~cm.midiManager.queue.enqueueCommand(\switch);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// 3) Bypass delay ON (then OFF), then switch again
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\on);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

// Optional: turn bypass OFF and switch back
~cm.midiManager.queue.enqueueCommand(\bypass);
~cm.midiManager.queue.enqueueCommand(\delay);
~cm.midiManager.queue.enqueueCommand(\off);
~ct_sendAndApply.(~cm, ~pedalboard, ~gui);

~pedalboard.printChains;   // posts and drives GUI detail view
)

===== MagicPedalboard/demo_commandtree_preformed_queues.scd =====
// demo_commandtree_preformed_queues.scd
// v0.2
// MD 20250916-1048

(
var log, makeCMIfNeeded, enqueueTokensFromPath, playlist, indexCounter, totalCount;

log = { arg msg; ("[DEMO] " ++ msg).postln };

makeCMIfNeeded = {
    if(~cm.isNil) { ~cm = CommandManager.new; log.("CommandManager created and JSON imported."); };
};

enqueueTokensFromPath = { arg cm, pathString;
    var tokens, tokenCounter, tokenTotal, one;
    // convert "/verb/arg1/arg2" into a token list on the cm queue
    tokens = pathString.asString.split($/).reject({ arg oneToken; oneToken.isEmpty }).collect({ arg s; s.asSymbol });
    cm.midiManager.queue.clear;
    tokenCounter = 0; tokenTotal = tokens.size;
    while({ tokenCounter < tokenTotal }, {
        one = tokens[tokenCounter];
        cm.midiManager.queue.enqueueCommand(one);
        tokenCounter = tokenCounter + 1;
    });
    log.("enqueued: " ++ tokens);
};

// A small playlist of fully-formed queues, like the tree would send
// (You can add "/commands/..." variants too; adapter strips the prefix.)

playlist = [
    "/setSource/testmelody",  // <‚Äî Ensure NEXT isn't Silent
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

/*playlist = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];*/

indexCounter = 0; totalCount = playlist.size;

~demo_next = {
    var path;
    makeCMIfNeeded.value;
    if(indexCounter >= totalCount) {
        log.("playlist complete.");
    }{
        path = playlist[indexCounter];
        enqueueTokensFromPath.(~cm, path);
        ~ct_sendAndApply.(~cm, ~pedalboard, ~gui);
        log.("applied: " ++ path);
        indexCounter = indexCounter + 1;
        ~pedalboard.printChains;
    };
};

~demo_restart = {
    indexCounter = 0;
    log.("playlist reset.");
};
)

===== MagicPedalboard/Demo_Install_MinProcessors.scd =====
// Demo_Install_MinProcessors.scd
// v0.1.0
// MD 2025-09-18 11:58 BST

/* Purpose
   - Install a minimal, safe stereo \delay processor so chains like
     [chainX, delay, testmelody] are AUDIBLE.
   - Generated audio only; processors read from \in.ar(2); no SoundIn.
   - Idempotent; safe to re-run.

   Style
   - var-first in every function/closure; lowercase method names.
   - No server.sync; wrap server ops in Server.default.bind.
   - JITLib connections elsewhere MUST use Ndef(left) <<> Ndef(right).
*/

(
var installDelay;
installDelay = {
    Server.default.bind({
        // Simple feedback delay. Reads from \in.ar(2) per project policy.
        Ndef(\delay, {
            var inSig, maxDelay, time, fb, mix, wet;
            inSig    = \in.ar(2);              // <- policy: processors read from \in.ar(defaultNumChannels)
            maxDelay = 1.0;
            time     = (\time.kr(0.25)).clip(0.0, maxDelay);
            fb       = (\fb.kr(0.25)).clip(0.0, 0.95);
            mix      = (\mix.kr(0.35)).clip(0.0, 1.0);
            wet      = DelayC.ar(inSig + (LocalIn.ar(2) * fb), maxDelay, time);
            LocalOut.ar(wet);
            XFade2.ar(inSig, wet, (mix * 2) - 1) * 0.9
        });
        // Pin stereo/audio-rate bus shape (authoritative shape)
        Ndef(\delay).mold(2, \audio);
    });
    "[MINPROC] Installed \\delay (stereo)".postln;
};
installDelay.();
)

===== MagicPedalboard/Diag_BusChannel_Map.scd =====
// Diag_BusChannel_Map.scd
// v0.1
// MD 20250917-1154
//
// Purpose: Post bus rate + channel count for every Ndef in CURRENT and NEXT
//          effective lists; helps catch mono nodes causing "2‚Üí1 wrap".
// Style: tilde vars, var-first, lowercase names, no server.sync,
//        server ops inside Server.default.bind.

(
var log, reportList;

log = { arg s; ("[BUS]" ++ " " ++ s).postln };

reportList = { arg label, listSyms;
    var rows;
    rows = listSyms.collect({ arg k;
        var b = Ndef(k).bus;
        var rate = (b.notNil).if({ b.rate }, { \unknown });
        var ch   = (b.notNil).if({ b.numChannels }, { -1 });
        var play = Ndef(k).isPlaying;
        [k, rate, ch, play]
    });
    (label ++ " = " ++ rows.asString).postln;
};

~mpb.printChains;  // also drives your GUI detail view
reportList.("CURRENT", ~mpb.effectiveCurrent);
reportList.("NEXT   ", ~mpb.effectiveNext);
)

===== MagicPedalboard/docs and references/cheatsheet.scd =====
// cheatsheet.cd
// MD 20250913-1037

// Inspect
~pedalboard.printChains;            // or use your display adaptor

// Build NEXT non-destructively
~pedalboard.add(\delay);
~pedalboard.bypass(\delay, true);
~pedalboard.swap(1, 2);

// Go live with a short crossfade
~pedalboard.switchChain(0.1);

// Adjust CURRENT temporarily
~pedalboard.bypassAtCurrent(1, false);

// Change sources
~pedalboard.setSource(\ts1);
~pedalboard.setSourceCurrent(\ts2);

// Panic-safe reset
~pedalboard.reset;

===== MagicPedalboard/docs and references/usingLibraryWithMagicPedalboard.scd =====
// usingLibraryWithMagicPedalboard.scd
// MD 20250915-0914


(
// If you‚Äôve loaded MagicProcessorLibrary_defs.scd already:
~procLib.ensureMany([\ts0, \delay, \tremolo, \reverb, \chorus, \drive], 2);

// Then (re)build your pedalboard chains knowing those symbols resolve:
~pedalboard.reset;
~pedalboard.add(\delay);
~pedalboard.switchChain(0.1);
)

===== MagicPedalboard/editor_commandtree_add_demo_verbs.scd =====
// editor_commandtree_add_demo_verbs.scd
// v0.3
// MD 20250916-0957

(
var jsonPath, saveFolder, savePrefix;
var ensureChildUnder, ensurePath, rootNode, commandsNode;

// paths
jsonPath   = "/Users/martindupras/CommandTreeSavefiles/myTree.json".standardizePath;
saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

// load
~tree = MDCommandTree.new;
if (~tree.importJSONFile(jsonPath)) {
    "‚úÖ Loaded tree for editing.".postln;
} {
    "‚ùå Failed to load tree JSON".warn; ^nil;
};

// helpers
ensureChildUnder = { arg parentNode, childName, fretNumber;
    var existingNode, createdNode;
    existingNode = parentNode.getChildByName(childName);
    if (existingNode.notNil) {
        existingNode
    } {
        createdNode = ~tree.addNode(parentNode.id, childName, fretNumber);
        if (createdNode.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
        createdNode
    }
};

ensurePath = { arg pathArray, fretArray;
    var currentNode, stepIndex, childName, fretNumber, pathSize;
    currentNode = ~tree.root;
    pathSize = pathArray.size;
    stepIndex = 0;
    while({ stepIndex < pathSize }, {
        childName = pathArray[stepIndex];
        fretNumber = fretArray[stepIndex] ? 1;
        currentNode = ensureChildUnder.(currentNode, childName, fretNumber);
        stepIndex = stepIndex + 1;
    });
    currentNode
};

// ---- add demo verbs (idempotent) ----
rootNode = ~tree.root;
commandsNode = ensureChildUnder.(rootNode, "commands", 10);

// commands/add/<proc>
ensurePath.(["commands","add","delay"],   [10,1,1]);
ensurePath.(["commands","add","chorus"],  [10,1,2]);
ensurePath.(["commands","add","reverb"],  [10,1,3]);
ensurePath.(["commands","add","tremolo"], [10,1,4]);

// commands/bypass/<proc>/<on|off>
ensurePath.(["commands","bypass","delay","on"],  [10,2,1,2]);
ensurePath.(["commands","bypass","delay","off"], [10,2,1,3]);

// commands/switch
ensurePath.(["commands","switch"], [10,3]);

// commands/setSource/<src>
ensurePath.(["commands","setSource","testmelody"], [10,4,1]);

// set payloads == names (simple, visible)
~tree.assignPayloads;
~tree.printTreePretty;

// save using custom exporter (preserves payloads in JSON)
~ct_writeJsonWithPayloads.(~tree, jsonPath, true, saveFolder, savePrefix);
)

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd =====
// MagicDisplayGUI_GridDemo_Ext_ContrastFix.scd
// v0.1.0
// MD 2025-09-24 23:55 BST

/*
Purpose
- Ensure the Choices panel uses light text on a dark background.
Style
- Class extension only; var-first; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  fixChoicesContrast { arg fg = Color(0.96,0.96,0.96), bg = Color(0.12,0.12,0.12,0.92);
    var apply;
    apply = {
      if(choicesPanel.notNil) { choicesPanel.background = bg };
      if(choicesTitle.notNil) { choicesTitle.stringColor = fg };
      if(choicesText.notNil)  { choicesText.stringColor  = fg };
    };
    AppClock.sched(0.0, { apply.value; nil });
    ^this
  }

  // Keep existing behavior but guarantee readable \choices text
  updateTextField { arg box, msg;
    var doIt;
    doIt = {
      if(box == \choices) {
        if(choicesText.notNil) {
          choicesText.string = msg.asString;
          choicesText.stringColor = Color(0.96,0.96,0.96);  // light text
          if(choicesTitle.notNil) { choicesTitle.stringColor = Color(0.96,0.96,0.96) };
        };
      }{
        if(expectationView.notNil) {
          expectationView.string = "[" ++ box.asString ++ "] " ++ msg.asString;
        };
      };
    };
    AppClock.sched(0.0, { doIt.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_Meters.scd =====
// MagicDisplayGUI_GridDemo_Ext_Meters.scd
// v0.3.0
// MD 2025-09-24 23:56 BST

/*
Purpose
- Provide enableMeters(true): listen to /ampA and /ampB (from SendReply.kr)
  and draw two moving bars in meterStrip.
Style
- Class extension only; var-first; AppClock for UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

  enableMeters { arg on = true;
    var state, setupUI, install, remove;

    // Simple per-window state (no ivars added)
    state = (
      valA: 0.0,   // 0..1 (A bar)
      valB: 0.0,   // 0..1 (B bar)
      rxA:  nil,   // OSCdef handles
      rxB:  nil
    );

    setupUI = {
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds, pad = 8, w = b.width - (pad*2), h = b.height;
          var barH = ((h - (pad*2) - 4)/2).clip(8,14);
          var top1 = pad, top2 = pad + barH + 4;
          var a = state[\valA].clip(0,1), bb = state[\valB].clip(0,1);

          // backgrounds
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top1, w, barH)); Pen.fill;
          Pen.color = Color(0.2,0.2,0.2,0.15); Pen.addRect(Rect(pad, top2, w, barH)); Pen.fill;

          // dynamic fills
          Pen.color = Color(0.20, 0.70, 0.20); Pen.addRect(Rect(pad, top1, w * a,  barH)); Pen.fill;  // A
          Pen.color = Color(0.20, 0.40, 0.90); Pen.addRect(Rect(pad, top2, w * bb, barH)); Pen.fill;  // B

          // border
          Pen.color = Color.gray(0.5); Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
        };
      };
    };

    install = {
      setupUI.value;

      // IMPORTANT: these paths must match the ones used in SendReply.kr
      state[\rxA] = OSCdef(\mdAmpA, { |msg|
        // SendReply places floats after some metadata; first value is msg[3]
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        // quick smoothing
        state[\valA] = (state[\valA] * 0.7) + (max(l, r) * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampA');

      state[\rxB] = OSCdef(\mdAmpB, { |msg|
        var l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        var r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        var mean = ((l + r) * 0.5).clip(0,1);
        state[\valB] = (state[\valB] * 0.7) + (mean * 0.3);
        AppClock.sched(0.0, { if(meterStrip.notNil){ meterStrip.refresh }; nil });
      }, '/ampB');
    };

    remove = {
      if(state[\rxA].notNil) { state[\rxA].free; state[\rxA] = nil };
      if(state[\rxB].notNil) { state[\rxB].free; state[\rxB] = nil };
      if(meterStrip.notNil) {
        meterStrip.drawFunc = { |view|
          var b = view.bounds;
          Pen.color = Color.gray(0.7);
          Pen.strokeRect(Rect(0.5,0.5,b.width-1,b.height-1));
        };
        meterStrip.refresh;
      };
    };

    AppClock.sched(0.0, { if(on) { install.value } { remove.value }; nil });
    ^this
  }
}

===== MagicPedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects ‚Äì same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== MagicPedalboard/Manage_MagicDisplayGUI_Singleton.scd =====
// Manage_MagicDisplayGUI_Singleton.scd
// v0.1
// MD 20250917-1230
//
// Purpose: Close any existing MagicDisplayGUI windows and spawn one fresh GUI,
//          then (optionally) create/recreate ~mpb bound to that GUI.
// Style: tilde vars, var-first, lowercase names, AppClock for GUI ops.
//        no server.sync; server ops should happen elsewhere.

(
var closeExisting, createNew;

closeExisting = {
    AppClock.sched(0.0, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            (w.name ? "").asString.beginsWith("MagicDisplayGUI")
        });
        wins.do({ arg w; w.close });
        nil
    });
};

createNew = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI.new;
        ~mpb = MagicPedalboardNew.new(~gui);
        nil
    });
};

closeExisting.value;
createNew.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_CloseRecreateBind_GUI_GridDemo.scd =====
// MPBTest_CloseRecreateBind_GUI_GridDemo.scd
// v0.1.0
// MD 20250920-1919
(
var closeExisting, createGrid, bindAndFill;

/*closeExisting = {
    AppClock.sched(0.00, {
        var wins;
        wins = Window.allWindows.select({ arg w;
            var nm = w.tryPerform(\name) ? "";
            nm.asString.beginsWith("MagicDisplayGUI")
        });
        wins.do(_.close);
        nil
    });
};*/

closeExisting = {
    AppClock.sched(0.00, {
        var windowList;

        windowList = Window.allWindows.select({ arg w;
            var nameString;
            nameString = w.tryPerform(\name) ? "";
            nameString.asString.beginsWith("MagicDisplayGUI")
        });

        windowList.do({ arg w; w.close });
        nil
    });
};

createGrid = {
    AppClock.sched(0.05, {
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
        nil
    });
};

bindAndFill = {
    AppClock.sched(0.10, {
        if(~mpb.notNil and: { ~gui.notNil }) {
            ~mpb.setDisplay(~gui);
            ~gui.enableMeters(false);
            ~gui.enableMeters(true);
            ~mpb.printChains;
            ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
        }{
            "[REBIND] ~mpb or ~gui missing".warn;
        };
        nil
    });
};

closeExisting.value;
createGrid.value;
bindAndFill.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_FreshBootBringUp_Now.scd =====
// MPBTest_FreshBootBringUp_Now.scd
// v0.1.1
// MD 20250920-1642

(
var s, startBoot, afterBoot, waitDown, doFreshBoot;

s = Server.default;

afterBoot = {
    AppClock.sched(0.00, {
        ~bring = MPBTest_BringUp.new(true, 2, 0.40, true); // use loud test source & publish tildes
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false); ~gui.enableMeters(true) };
        nil
    })
};

startBoot = {
    s.doWhenBooted({ afterBoot.value });
    if(s.serverRunning.not) { s.boot };
};

waitDown = {
    if(s.serverRunning.not) { startBoot.value; nil } {
        AppClock.sched(0.05, waitDown)
    }
};

doFreshBoot = {
    if(s.serverRunning) {
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) { ~gui.enableMeters(false) };
        s.quit;
        AppClock.sched(0.05, waitDown);
    }{
        startBoot.value;
    };
};

doFreshBoot.value;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_RebindAndFillGUI.scd =====
// MPBTest_RebindAndFillGUI.scd
// v0.1.0
// MD 20250920-1919

(
var need;

// 0) Precondition: we want ~mpb and ~gui alive
need = (~mpb.notNil) && (~gui.notNil);
if(need.not) {
    "[REBIND] need ~mpb and ~gui; run MPBTest_BringUp first.".warn;
    ^nil;
};

// 1) If the GUI was created after MPB, bind it now
if(~mpb.display.isNil or: { ~mpb.display !== ~gui }) {
    ~mpb.setDisplay(~gui);
    "[REBIND] bound ~gui to ~mpb".postln;
};

// 2) Make sure it‚Äôs in front (and visible)
AppClock.sched(0.02, {
    var w;
    w = ~gui.tryPerform(\window);
    if(w.notNil) { w.front; w.alwaysOnTop_(true) };
    nil
});

// 3) Reattach meters (guards inside GUI)
AppClock.sched(0.04, {
    ~gui.enableMeters(false);
    ~gui.enableMeters(true);
    nil
});

// 4) Fill the chains view now
AppClock.sched(0.06, {
    ~mpb.printChains; // drives showChainsDetailed when a display is bound
    // highlight current column for good measure
    ~gui.highlightCurrentColumn(~mpb.effectiveCurrent[0]);
    nil
});
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Record_WorkingState.scd =====
// MPBTest_Record_WorkingState.scd
// v0.1.1
// MD 20250920-1930

(
var now, stamp, docDir, mdPath, jsonPath, mkDir;
var s, o, outDev, sr, blk, scv, lines, md, js;
var v_mpbtest_bring, v_mpbtest_scen, v_mpbtest_suites, v_mpbtest_assert;
var v_mpb, v_md, v_mdgui, v_mdgrid;
var fileList, classPaths;

/*// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930
docDir = PathName(thisProcess.nowExecutingPath ?? thisProcess.cwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;*/

// 0) Paths & timestamp
now   = Date.getDate.stamp; // "2025-09-20_19:30:15"
stamp = now.replace(":", "").replace("_", "-").keep(15); // e.g. 2025-09-20-1930

// Use script location if available, else current working directory
docDir = PathName(thisProcess.nowExecutingPath ? File.getcwd).pathOnly
    .standardizePath
    .split($/)
    .drop(-2) // climb out of Scripts/
    .addAll(["MPBTest","docs"])
    .join($/).standardizePath;


mkDir = { |p|
    var pn = PathName(p);
    if(pn.isFolder.not) {
        File.mkdir(p);
    };
};


// 1) Ensure docs dir
mkDir.(docDir);

// 2) Environment
s  = Server.default;
o  = s.options;
outDev = o.outDevice ? "default";
sr  = s.sampleRate ? 0;
blk = o.blockSize;
/*scv = Main.scVersionString ? Main.scVersion;*/
/*scv = Platform.version.asString;*/
scv = thisProcess.interpreter.version;


// 3) Versions
v_mpbtest_bring  = (MPBTest_BringUp.respondsTo(\version)).if({ MPBTest_BringUp.version },{ "unknown" });
v_mpbtest_scen   = (MPBTest_Scenario.respondsTo(\version)).if({ MPBTest_Scenario.version },{ "unknown" });
v_mpbtest_suites = (MPBTest_AcceptanceSuites.respondsTo(\version)).if({ MPBTest_AcceptanceSuites.version },{ "unknown" });
v_mpbtest_assert = (MPBTest_Assertions.respondsTo(\version)).if({ MPBTest_Assertions.version },{ "unknown" });

v_mpb    = (MagicPedalboardNew.respondsTo(\version)).if({ MagicPedalboardNew.version },{ "unknown" });
v_md     = (MagicDisplay.respondsTo(\version)).if({ MagicDisplay.version },{ "unknown" });
v_mdgui  = (MagicDisplayGUI.respondsTo(\version)).if({ MagicDisplayGUI.version },{ "unknown" });
v_mdgrid = (MagicDisplayGUI_GridDemo.respondsTo(\version)).if({ MagicDisplayGUI_GridDemo.version },{ "unknown" });

// 4) Class file paths (confirm there‚Äôs only one of each)
classPaths = Class.allClasses
    .select({ |c| ["MPBTest_BringUp","MPBTest_Scenario","MPBTest_AcceptanceSuites","MPBTest_Assertions"].includes(c.name.asString) })
    .collect(_.filenameSymbol.asString);

// 5) Chain snapshot
~mpb = ~mpb ?? { nil };
fileList = if(~mpb.notNil, {
    var effC = ~mpb.effectiveCurrent, effN = ~mpb.effectiveNext;
    [
        "CURRENT=" ++ effC.asString,
        "NEXT   =" ++ effN.asString,
        "[PLAY] A=" ++ Ndef(\chainA).isPlaying ++ " B=" ++ Ndef(\chainB).isPlaying
    ]
}, { ["no ~mpb"] });

// 6) Write Markdown + JSON
mdPath   = docDir +/+ ("WorkingState_" ++ stamp ++ ".md");
jsonPath = docDir +/+ ("WorkingState_" ++ stamp ++ ".json");

// Markdown
md = String.new;
md = md
++ "# MagicPedalboard ‚Äì Working State (" ++ stamp ++ ")\n\n"
++ "## Versions\n"
++ "- MPBTest_BringUp: "   ++ v_mpbtest_bring  ++ "\n"
++ "- MPBTest_Scenario: "  ++ v_mpbtest_scen   ++ "\n"
++ "- MPBTest_AcceptanceSuites: " ++ v_mpbtest_suites ++ "\n"
++ "- MPBTest_Assertions: "++ v_mpbtest_assert ++ "\n"
++ "- MagicPedalboardNew: "++ v_mpb ++ "\n"
++ "- MagicDisplay: "      ++ v_md  ++ "\n"
++ "- MagicDisplayGUI: "   ++ v_mdgui  ++ "\n"
++ "- MagicDisplayGUI_GridDemo: " ++ v_mdgrid ++ "\n\n"
++ "## Environment\n"
++ "- sclang: " ++ scv ++ "\n"
++ "- output device: " ++ outDev ++ "\n"
++ "- sample rate: " ++ sr ++ "\n"
++ "- block size: " ++ blk ++ "\n\n"
++ "## Class Files\n- " ++ classPaths.join("\n- ") ++ "\n\n"
++ "## Chain Snapshot\n- " ++ fileList.join("\n- ") ++ "\n";

File.writeText(mdPath, md);

// JSON (minimal)
js = (
    timestamp: stamp,
    versions: (
        MPBTest_BringUp: v_mpbtest_bring, MPBTest_Scenario: v_mpbtest_scen,
        MPBTest_AcceptanceSuites: v_mpbtest_suites, MPBTest_Assertions: v_mpbtest_assert,
        MagicPedalboardNew: v_mpb, MagicDisplay: v_md,
        MagicDisplayGUI: v_mdgui, MagicDisplayGUI_GridDemo: v_mdgrid
    ),
    environment: (
        sclang: scv, outDevice: outDev, sampleRate: sr, blockSize: blk
    ),
    classFiles: classPaths
).asCompileString;

File.writeText(jsonPath, js);

("[RECORD] wrote\n- " ++ mdPath ++ "\n- " ++ jsonPath).postln;
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== MagicPedalboard/old but good/Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd =====
// Test_MagicPedalboardNew_v0_15_3_GUI_Operations.scd
// MD 20250912-1527

// Visual ops list + expectation + 3s countdown + embedded meters
// Strict var-first; no server.sync; safe resets; no double /n_free


(
s.waitForBoot({
    var preflightCleanup;
    var makeSourcesAndProcessors;
    var m, gui, setHear;
    var ops, doStep;

    // 0) Preflight (avoid double free: only clear Ndefs)
    preflightCleanup = {
        var needPopProxySpace;
        "[-] Preflight: clearing Ndefs & ProxySpaces‚Ä¶".postln;

        Ndef.all.keysValuesDo({ arg keySym, proxyRef;
            var exists;
            exists = proxyRef.notNil;
            if(exists) {
                proxyRef.clear; // no proxy.stop here ‚Üí avoids duplicate /n_free
            };
        });

        if(ProxySpace.respondsTo(\all)) {
            ProxySpace.all.keysValuesDo({ arg serverRef, proxySpace;
                var existsPS;
                existsPS = proxySpace.notNil;
                if(existsPS) { proxySpace.clear };
            });
        };

        needPopProxySpace = currentEnvironment.notNil and: { currentEnvironment.class.name == "ProxySpace" };
        if(needPopProxySpace) {
            currentEnvironment.pop;
        };

        s.initTree;
        s.defaultGroup.freeAll;
        "== Preflight done ==".postln;
    };
    preflightCleanup.();

    // 1) Sources / processors
    makeSourcesAndProcessors = {
        var alreadyThere;
        alreadyThere = false;

        Ndef(\ts0,   { Silent.ar(2) });
        Ndef(\tsSaw, { Saw.ar(200, 0.18) ! 2 });
        Ndef(\tsSine,{ SinOsc.ar(333, 0, 0.22) ! 2 });
        Ndef(\tsDust,{ Dust.ar(2000) ! 2 });

        Ndef(\tremolo, { arg rate = 4, depth = 0.8;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
        });

        Ndef(\lofi, { arg bits = 6, rate = 6000;
            var inputSignal;
            inputSignal = \in.ar(2);
            Decimator.ar(inputSignal, rate, bits)
        });

        Ndef(\atten, { arg gain = 0.25;
            var inputSignal;
            inputSignal = \in.ar(2);
            inputSignal * gain
        });
    };
    makeSourcesAndProcessors.();

    // 2) Pedalboard + GUI
    m = MagicPedalboardNew.new;
    gui = MagicDisplayGUI.new(1);
    m.setDisplay(gui);

    // known baseline
    m.reset;
    m.setSourceCurrent(\ts0);
    m.setSource(\ts0);
    m.clearChain;
    m.switchChain(0.1);
    m.clearChain;
    m.switchChain(0.1);

    gui.enableMeters(true);

    setHear = { arg textString, seconds = 0;
        gui.showExpectation(textString, seconds);
    };

    // 3) Ops (labels + actions)
    ops = Array.new;

    ops = ops.add((
        label: "Make CURRENT audible (Saw)",
        action: {
            var note;
            note = "CURRENT: plain Saw tone. Moderate level, stable pitch.";
            setHear.(note, 3);
            m.setSourceCurrent(\tsSaw);
            m.playCurrent;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Tremolo; then crossfade switch",
        action: {
            var note;
            note = "Switch to Saw with Tremolo (deep). You should hear strong amplitude modulation.";
            setHear.(note, 3);
            m.setSource(\tsSaw);
            m.add(\tremolo);
            m.bypass(\tremolo, false);
            m.switchChain(0.10);
        }
    ));

    ops = ops.add((
        label: "Sweep Tremolo rate 2‚Üí12 Hz then back",
        action: {
            var ratesUp, ratesDown;
            setHear.("Rate sweep on CURRENT tremolo.", 0);
            ratesUp = (2..12);
            ratesDown = ratesUp.reverse;
            ratesUp.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
            ratesDown.do({ arg rateValue; Ndef(\tremolo).set(\rate, rateValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Toggle CURRENT tremolo bypass",
        action: {
            var note;
            note = "Bypass tremolo (plain Saw), then re-enable.";
            setHear.(note, 3);
            m.bypassCurrent(\tremolo, true);  0.5.wait;
            m.bypassCurrent(\tremolo, false); 0.5.wait;
        }
    ));

    ops = ops.add((
        label: "Prepare NEXT: add Atten + Lofi; swap; crossfade switch",
        action: {
            var note;
            note = "Attenuated + crushed Saw after switch.";
            setHear.(note, 3);
            m.addAt(\atten, 1);
            m.addAt(\lofi, 2);
            m.swap(1, 2);
            m.switchChain(0.12);
        }
    ));

    ops = ops.add((
        label: "Sweep Lofi params (bits 4..10, rate 4k..12k)",
        action: {
            var bitsSeq, rateSeq;
            setHear.("Lofi bits + rate sweeps.", 0);
            bitsSeq = (4..10);
            bitsSeq.do({ arg bitsValue; Ndef(\lofi).set(\bits, bitsValue); 0.2.wait; });
            rateSeq = Array.series(17, 4000, 500);
            rateSeq.do({ arg srValue; Ndef(\lofi).set(\rate, srValue); 0.2.wait; });
        }
    ));

    ops = ops.add((
        label: "Return to silence (NEXT‚Üí\\ts0) and crossfade",
        action: {
            var note;
            note = "Silence after switch.";
            setHear.(note, 3);
            m.setSource(\ts0);
            m.clearChain;
            m.switchChain(0.10);
        }
    ));

    // bind (GUI queues until UI exists)
    gui.setOperations(ops.collect({ arg x; x[\label] }));

    doStep = { arg indexToRun;
        var entry;
        entry = ops[indexToRun];
        if(entry.notNil) {
            Routine({
                entry[\action].value;
            }).play(SystemClock);
        };
    };

    gui.setNextAction({ arg indexToRun;
        doStep.(indexToRun);
    });

    gui.showExpectation("Press 'Next' to begin. The action runs after a 3-second visual countdown.", 0);
});
)

===== MagicPedalboard/QuickRestore_AudioAndExclusive.scd =====
// QuickRestore_AudioAndExclusive.scd
// v0.2
// MD 20250917-1338
//
// Purpose: If audio is quiet, rebuild class-managed wiring (uses Ndef(left) <<> Ndef(right))
//          and re-enforce Option A. No sink-source overwrites.

(
var log; log = { arg s; ("[RESTORE] " ++ s).postln };

if(~mpb.isNil) { "[RESTORE] ~mpb is nil".warn; ^nil };

Server.default.bind({
    ~mpb.rebuildUnbound(~mpb.currentChain);   // internally uses Ndef(left) <<> Ndef(right)
    ~mpb.rebuildUnbound(~mpb.nextChain);
});
~mpb.playCurrent;
~mpb.enforceExclusiveCurrentOptionA(0.1);

AppClock.sched(0.25, {
    var a = Ndef(\chainA).isPlaying, b = Ndef(\chainB).isPlaying;
    ("[RESTORE] [PLAY] A=% B=%".format(a, b)).postln;
    nil
});
)

===== MagicPedalboard/retargetMeters.scd =====
(
// retargetMeters.scd
// v0.1
// MD 20250916

var ensureAudioRateAndReloadMeters, hasGui;

ensureAudioRateAndReloadMeters = {
    hasGui = (~gui.notNil) and: { ~gui.isKindOf(MagicDisplayGUI) };

    // Turn meters off to free Synths/OSCdefs cleanly
    if(hasGui) { ~gui.enableMeters(false) };

    // Ensure sinks are audio-rate proxies (2 channels)
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // Turn meters back on; will now bind to the audio buses
    if(hasGui) { ~gui.enableMeters(true) };

    "[meters] reattached to audio-rate buses".postln;
};

ensureAudioRateAndReloadMeters.();
)

===== MagicPedalboard/switchDelayCheck.scd =====
// switchDelayCheck.scd
// v0.1
// MD 20250916

(
// Goal: add \delay to NEXT, switch with a crossfade, and confirm audio continues on CURRENT.

// --- Preconditions: GUI + MPB exist; audibleSanity.scd already run today. ---

var log, cleanupDirectPlays, prepStatus, addDelayToNext, doSwitch, afterSwitchCheck, recoverIfSilent;

log = { arg m; ("[switchDelay] " ++ m).postln };

cleanupDirectPlays = {
    // ensure no direct-to-out play is active for the generator
    if(Ndef(\testmelody).isPlaying) { Ndef(\testmelody).stop; log.("stopped direct \\testmelody") };
};

prepStatus = {
    ~mpb.printChains;
    ("[before] A=%  B=%"
        .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
};

addDelayToNext = {
    ~mpb.clearChain;            // keep NEXT minimal before adding
    ~mpb.add(\delay);           // add to NEXT
    ~mpb.printChains;
};

doSwitch = {
    ~mpb.switchChain(0.12);     // short crossfade; CURRENT <-> NEXT
};

afterSwitchCheck = {
    AppClock.sched(0.35, {
        ~mpb.printChains;
        ("[after]  A=%  B=%"
            .format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
        nil
    });
};

// If for any reason we went silent, rebuild connections & enforce CURRENT-only play.
// (Equivalent to your enforceExclusiveCurrentNow utilities)
recoverIfSilent = {
    AppClock.sched(0.60, {
        var curEff, curSink;
        curEff = ~mpb.effectiveCurrent;
        curSink = curEff[0];
        Server.default.bind({
            ~mpb.rebuildUnbound(~mpb.currentChain);
            ~mpb.rebuildUnbound(~mpb.nextChain);
            // enforce exclusive current
            if(curSink == \chainA) {
                if(Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                if(Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
            }{
                if(Ndef(\chainA).isPlaying) { Ndef(\chainA).stop };
                if(Ndef(\chainB).isPlaying.not) { Ndef(\chainB).play(numChannels: 2) };
            };
        });
        log.("reconnect enforced, currentEff=" ++ curEff);
        nil
    });
};

// --- run steps ---
cleanupDirectPlays.value;
prepStatus.value;
addDelayToNext.value;
doSwitch.value;
afterSwitchCheck.value;
recoverIfSilent.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ByBusIndices_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optional Final) probes using your stereo BUS INDICES.
   - A uses replyID 2001, B uses 2002, Final uses 2101.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain stereo bus base index (e.g., 16)
busB = -1;      // TODO: set to your B chain stereo bus base index (e.g., 24)
busFinal = -1;  // optional final mix stereo bus base index (e.g., 32)

ok = true;

if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13.scd
// v0.3.13
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter filters to avoid duplicate /md/levels.
   - Announce everything in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, aResult, bResult, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.13 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, def1, def2;

    ok2 = true;

    // mono probe
    def1 = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // silent synth
        Silent.ar(1).mute;
    }).add;

    // stereo probe
    def2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        Silent.ar(2).mute;
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any in-proxy meter/tap filters to identity (no duplicate SendReply)
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Collect Ndef info: exists, playing, bus index, channel count, group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2; // default to stereo if unknown
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, tagSym, outVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            // Free previous probe if any
            freeIfPlaying.value(thisProcess.interpreter.getVar(outVarSym));

            // Ensure a fresh group placed after the Ndef's group
            grp = Group.after(groupTarget);

            // Attach appropriate probe
            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            // Publish references
            thisProcess.interpreter.setVar(tagSym, grp);
            thisProcess.interpreter.setVar(outVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

// Ensure our probe SynthDefs exist
ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, ~md_probeGroupA, ~md_probeA);
attachAfterNdef.value(bInfo, 2002, ~md_probeGroupB, ~md_probeB);

("Attach_ProbesAfterNdefs: done.").postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14.scd
// v0.3.14
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (handles 1ch or 2ch).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announces itself in the console so logs show what ran and in what order.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyMeters,
    detectInfo, attachAfterNdef, freeIfPlaying,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.14 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe (no Out, just SendReply)
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output; silent by design
    }).add;

    // stereo probe (no Out, just SendReply)
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output; silent by design
    }).add;

    ok2;
};

neutralizeInProxyMeters = {
    var ok2;

    ok2 = true;

    // Overwrite any prior filters (meter/tap) to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Gather Ndef info: existence, playing, bus index, channel count (clamped 1..2), and group
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group *after* the Ndef's group and attach the proper probe synth
attachAfterNdef = { |info, replyID, groupVarSym, synthVarSym|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        s.bind({
            freeIfPlaying.value(thisProcess.interpreter.getVar(synthVarSym));
            thisProcess.interpreter.setVar(synthVarSym, nil);

            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };

            thisProcess.interpreter.setVar(groupVarSym, grp);
            thisProcess.interpreter.setVar(synthVarSym, synth);
        });

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Make sure our base routing (toHardware + default test probe) exists WITHOUT killing Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy meters/taps
neutralizeInProxyMeters.value;

// Detect chains
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes *after* Ndef groups (ordering-safe)
attachAfterNdef.value(aInfo, 2001, \~md_probeGroupA, \~md_probeA);
attachAfterNdef.value(bInfo, 2002, \~md_probeGroupB, \~md_probeB);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd
// v0.3.15
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (mono or stereo).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announce actions in console so logs clearly show what ran.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyFilters,
    detectInfo, freeIfPlaying, attachAfterNdef,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe: reads 1 channel, sends a single float
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output
    }).add;

    // stereo probe: reads 2 channels, sends an array of two floats
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output
    }).add;

    ok2;
};

neutralizeInProxyFilters = {
    var ok2;

    ok2 = true;

    // Overwrite prior filters/taps to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Inspect an Ndef and report (exists, playing, bus index, channel count, group)
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group AFTER the Ndef's group and attach the proper probe synth.
// Uses setter closures to store references in ~vars (no reflection).
attachAfterNdef = { |info, replyID, setGroupFunc, setSynthFunc, freeOldSynthFunc|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        // free the previous synth if any (quietly)
        freeOldSynthFunc.value;

        s.bind({
            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };
        });

        setGroupFunc.value(grp);
        setSynthFunc.value(synth);

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Ensure our base routing exists WITHOUT clearing your Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy filters/taps
neutralizeInProxyFilters.value;

// Detect chains (prints status)
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes AFTER the Ndef groups (ordering-safe)
attachAfterNdef.value(
    aInfo, 2001,
    { |g| ~md_probeGroupA = g },            // set group
    { |sy| ~md_probeA = sy },               // set synth
    { freeIfPlaying.value(~md_probeA); ~md_probeA = nil }  // free old synth if any
);

attachAfterNdef.value(
    bInfo, 2002,
    { |g| ~md_probeGroupB = g },
    { |sy| ~md_probeB = sy },
    { freeIfPlaying.value(~md_probeB); ~md_probeB = nil }
);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd =====
// MagicDisplayGUI_Attach_TapsForNdefs_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - For JITLib chains Ndef(\chainA) and Ndef(\chainB), install .filter taps
     that mirror their outputs to private 2ch busses for metering.
   - Attach probes to those busses (replyID 2001 for A, 2002 for B).
   - Provides a removal helper for the taps and busses.

   Style
   - var-first in every block; no non-local returns (^).
   - Uses .filter as you prefer; does not alter chain sound (passes input through).
*/

(
var setupBusTaps, removeBusTaps;

setupBusTaps = {
    var ok, haveA, haveB;

    ok = true;
    haveA = false;
    haveB = false;

    // preflight: Ndefs must exist
    if (Ndef(\chainA).notNil) { haveA = true; } { "Ndef(\\chainA) not found.".postln; };
    if (Ndef(\chainB).notNil) { haveB = true; } { "Ndef(\\chainB) not found.".postln; };

    if (haveA.not and: { haveB.not }) {
        "Neither chainA nor chainB found; nothing to attach.".postln;
    } {
        // free previous busses if any
        if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
        if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

        // allocate new private 2ch busses
        ~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
        ~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

        // install taps using .filter; each tap writes to its bus, then passes input through
        if (haveA) {
            Ndef(\chainA).filter(\mdProbeTapA, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busA.index, outSig);
                outSig
            });
        };
        if (haveB) {
            Ndef(\chainB).filter(\mdProbeTapB, { |in|
                var outSig;
                outSig = in;
                Out.ar(~md_busB.index, outSig);
                outSig
            });
        };

        // attach probes to those busses
        if (~md_attachProbesAB.notNil) {
            ~md_attachProbesAB.value(
                busA: (if (haveA) { ~md_busA.index } { -1 }),
                busB: (if (haveB) { ~md_busB.index } { -1 })
            );
            ("Attached A bus=" ++ (if (haveA) { ~md_busA.index.asString } { "none" })
             ++ " B bus=" ++ (if (haveB) { ~md_busB.index.asString } { "none" })).postln;
        } {
            "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
        };
    };

    ok;
};

removeBusTaps = {
    var ok;

    ok = true;

    // remove taps if present
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).removeFilter(\mdProbeTapA);
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).removeFilter(\mdProbeTapB);
    };

    // free private busses
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    ok;
};

// ---------- run setup now ----------
setupBusTaps.value;

// Later, to remove taps + free busses:
// removeBusTaps.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd =====
// MagicDisplayGUI_Attach_ToBuses_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A/B (and optionally Final) probes by BUS INDICES you provide.
   - Leaves the window unchanged; meters switch to A/B once replies arrive.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var busA, busB, busFinal, ok;

busA = -1;      // TODO: set to your A chain bus index (stereo base index)
busB = -1;      // TODO: set to your B chain bus index (stereo base index)
busFinal = -1;  // optional: set to your final mix bus index

ok = true;

// sanity check
if (~md_attachProbesAB.isNil) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    if (busA >= 0 or: { busB >= 0 }) {
        ~md_attachProbesAB.value(busA: busA, busB: busB);
        ("Attached A=" ++ busA.asString ++ " B=" ++ busB.asString).postln;
    } {
        "Set busA/busB indices first (both -1 means skip).".postln;
    };

    if (busFinal >= 0) {
        ~md_attachProbeFinal.value(bus: busFinal);
        ("Attached Final=" ++ busFinal.asString).postln;
    } {
        "Final bus not set; skipping.".postln;
    };
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd =====
// MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Fix "sound but meters not moving" by:
     * ensuring OUR routing non-destructively
     * reinstalling receiver
     * auto-attaching A(2001)/B(2002) probes to Ndef buses
     * printing quick status
   - Assumes your chains are Ndef(\chainA) and Ndef(\chainB) and are PLAYING.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, detectBusIndex, aIdx, bIdx, reinstallReceiver, postStatus;

("MagicDisplayGUI_Fix_MetersNoMovement_v0.3.10.scd").postln;
ok = true;

if (~md_ensureRouting.isNil or: { ~md_attachProbesAB.isNil }) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure our bus/groups/probe exist without killing your Ndefs
    ~md_ensureRouting.value;

    // reinstall receiver safely
    reinstallReceiver = {
        var existing;
        existing = OSCdef(\md_levels);
        if (existing.notNil) { existing.free; };
        ~md_levelsById = IdentityDictionary.new;
        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = Main.elapsedTime;

        OSCdef(
            \md_levels,
            { |msg, time, addr, recvPort|
                var nodeId, replyId, count, i, outArray;

                nodeId = 0;
                replyId = 0;
                count = 0;
                i = 0;
                outArray = nil;

                if (msg.size >= 3) {
                    nodeId = msg[1].asInteger;
                    replyId = msg[2].asInteger;
                    count = msg.size - 3;
                    outArray = Array.newClear(count);
                    i = 0;
                    while { i < count } {
                        outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                        i = i + 1;
                    };
                    ~md_levelsById[replyId] = outArray;
                    ~levels = outArray;
                    ~md_lastLevelAt = Main.elapsedTime;
                };
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );

        true;
    };

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid when proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    postStatus = {
        var keys, msg;
        keys = ~md_levelsById.keys.asArray.sort;
        msg = "Active replyIDs: " ++ keys.asString;
        msg.postln;
        if (~md_levelsById[2001].notNil) { ("A: " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B: " ++ ~md_levelsById[2002].asString).postln; };
    };

    reinstallReceiver.value;

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected Ndef buses ‚Üí A=" ++ aIdx.asString ++ "  B=" ++ bIdx.asString).postln;

    // attach probes directly to those buses (skip -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // small delayed status check (allow first /md/levels to arrive)
    AppClock.sched(0.5, {
        postStatus.value;
        nil;
    });
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd =====
// MagicDisplayGUI_HUD_AddLabels_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Add simple HUD labels inside the existing MagicDisplayGUI A/B window.
   - Top-left anchored, no FlowLayout; read-only labels for the demo.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, win, content, hudTitle, hudA, hudB;

ok = true;

win = ~mdGui_window;

if (win.isNil) {
    "No MagicDisplayGUI window found. Open MagicDisplayGUI_New_Window_AB_v0.3.7.scd first.".postln;
} {
    content = win.view;

    // Title HUD
    hudTitle = StaticText(content, Rect(16, 0, 400, 12));
    hudTitle.string = "HUD: A=replyID 2001 | B=replyID 2002 | fallback=test 1001";
    hudTitle.stringColor = Color.gray(0.8);
    hudTitle.background = Color.clear;
    hudTitle.align = \left;

    // Chain labels (editable here if you want different names)
    hudA = StaticText(content, Rect(16, 24, 200, 12));
    hudA.string = "A: Ndef(\\chainA)";
    hudA.stringColor = Color.gray(0.8);
    hudA.background = Color.clear;
    hudA.align = \left;

    hudB = StaticText(content, Rect(292, 24, 200, 12));
    hudB.string = "B: Ndef(\\chainB)";
    hudB.stringColor = Color.gray(0.8);
    hudB.background = Color.clear;
    hudB.align = \left;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.1.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.1.scd
// v0.3.1
// MD timestamp: 2025-09-25

/* Purpose
   - Fast way to remove GUI, OSC receiver, synths, groups, bus; leave server running clean.
*/

(
var ok;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// Receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Synths
if (~md_testSynth.notNil) { ~md_testSynth.free; ~md_testSynth = nil; };
if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };

// Groups
if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

s.defaultGroup.freeAll;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.5.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Close GUI, free OSC receiver, clear server nodes/bus, and reset state.
   - Silent and idempotent: safe to run multiple times; no 'Node not found' noise.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, hadServer;

ok = true;

// GUI
if (~mdGui_ticker.notNil) { ~mdGui_ticker.stop; ~mdGui_ticker = nil; };
if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };

// OSC receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// Server nodes (only if server running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
}

// Bus
if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };

// State
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// ensure final expression is a simple boolean
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Cleanup_v0.3.6.scd =====
// MagicDisplayGUI_New_Cleanup_v0.3.6.scd
// v0.3.6
// MD timestamp: 2025-09-25

/* Purpose
   - Close MagicDisplayGUI windows, stop GUI ticker, free OSC receiver.
   - Clear server default group (if running), free private bus, reset state vars.
   - Silent and idempotent; final expression is 'true' (never returns a Window).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, hadServer, windows, i, w, nameString;

ok = true;

// stop GUI ticker if present
if (~mdGui_ticker.notNil) {
    ~mdGui_ticker.stop;
    ~mdGui_ticker = nil;
};

// close any MagicDisplayGUI windows (explicitly; this does not return the window)
windows = Window.allWindows;
i = 0;
while { i < windows.size } {
    w = windows[i];
    nameString = w.name.asString;
    if (nameString.beginsWith("MagicDisplayGUI")) {
        w.close;
    };
    i = i + 1;
};

// free OSC receiver if present
if (OSCdef(\md_levels).notNil) {
    OSCdef(\md_levels).free;
};

// clear server nodes (only if server is running)
hadServer = s.serverRunning;
if (hadServer) {
    s.bind({
        s.defaultGroup.freeAll;
    });
};

// free private bus if allocated
if (~md_mixBus.notNil) {
    ~md_mixBus.free;
    ~md_mixBus = nil;
};

// nil any cached node/bus references
~md_testSynth = nil;
~md_probe = nil;
~md_toHardware = nil;
~md_srcGroup = nil;
~md_meterGroup = nil;
~md_outGroup = nil;

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = 0.0;

// final value: simple boolean (prevents '-> a Window')
true;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot the server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create a private bus, groups, relay-to-hardware and a level probe.
   - Install an OSC receiver bound to '/md/levels' (matches SendReply).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probe reads a private bus; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // Close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // Reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = 0.0;
    ~md_testSynth = nil;
    ~md_probe = nil;
    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // Reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // Test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // Relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // Level probe (2ch fixed) ‚Üí '/md/levels'
    // Message format: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// Install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// Create routing (fresh bus + fresh groups + relay + probe). Clears default group first.
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // Clear any stale nodes from previous runs
        s.defaultGroup.freeAll;

        // Fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // Fresh groups in strict order: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // Relay and probe (safe even without source)
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // No source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    // Always rebuild routing to avoid stale groups after a server reboot
    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // Clean everything (leave server running)
    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  OSC: listening on /md/levels".postln;

    ok;
};

// ---------- Run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
// ~md_ensureRouting.value;
// ~md_reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create private mix bus, groups, relay-to-hardware, and default test probe.
   - Install OSC receiver bound to '/md/levels' supporting multiple replyIDs (test=1001, A=2001, B=2002, final=2101).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup,
       ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probes read buses; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_levelsById = IdentityDictionary.new;
    ~md_lastLevelAt = 0.0;

    ~md_testSynth = nil;
    ~md_probe = nil;      // default test probe (replyID 1001)
    ~md_probeA = nil;     // replyID 2001
    ~md_probeB = nil;     // replyID 2002
    ~md_probeFinal = nil; // replyID 2101

    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // level probe (2ch fixed) ‚Üí '/md/levels'
    // message: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_levelsById = IdentityDictionary.new;
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~md_levelsById[replyId] = outArray;
                ~levels = outArray; // mirror for 2‚Äëmeter UIs
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// create routing (fresh bus + fresh groups + relay + default test probe)
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // clear any stale nodes
        s.defaultGroup.freeAll;

        // fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // groups: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // relay + default test probe
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // clear specialized probes
        ~md_probeA = nil;
        ~md_probeB = nil;
        ~md_probeFinal = nil;

        // no source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // attach two probes to external buses (A and B)
    ~md_attachProbesAB = { |busA = -1, busB = -1|
        var ok2;

        ok2 = true;

        s.bind({
            if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
            if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };

            if (busA >= 0) {
                ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, busA, \replyID, 2001]);
            };
            if (busB >= 0) {
                ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, busB, \replyID, 2002]);
            };
        });

        ok2;
    };

    // attach one probe to a final mix bus
    ~md_attachProbeFinal = { |bus = -1|
        var ok2;

        ok2 = true;

        s.bind({
            if (~md_probeFinal.notNil) { ~md_probeFinal.free; ~md_probeFinal = nil; };
            if (bus >= 0) {
                ~md_probeFinal = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, bus, \replyID, 2101]);
            };
        });

        ok2;
    };

    ~md_detachAllProbes = {
        var ok2;

        ok2 = true;

        s.bind({
            if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
            if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };
            if (~md_probeFinal.notNil) { ~md_probeFinal.free; ~md_probeFinal = nil; };
            if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
        });

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_levelsById = IdentityDictionary.new;
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_probeA = nil;
        ~md_probeB = nil;
        ~md_probeFinal = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  Probes: ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes".postln;
    "  OSC: listening on /md/levels (multi-replyID)".postln;

    ok;
};

// ---------- run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value; ~md_stopTestSource.value;
// ~md_attachProbesAB.value(busA: <idx>, busB: <idx>);
// ~md_attachProbeFinal.value(bus: <idx>);
// ~md_detachAllProbes.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.7.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window with FOUR meters:
       A-L, A-R (replyID 2001), B-L, B-R (replyID 2002)
     and fall back to the default test probe (replyID 1001) if A/B not attached.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        labelA, aLeft, aRight, aDbL, aDbR,
        labelB, bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî A/B Window (v0.3.7)";

    window = Window.new(titleString, Rect(60, 60, 560, 260), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // A section
    labelA = StaticText(content, Rect(16, 12, 240, 22));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    // B section
    labelB = StaticText(content, Rect(292, 12, 240, 22));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    barWidth = 26;
    barHeight = 160;

    // A meters
    aLeft  = LevelIndicator(content, Rect(40,  44, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    aLeft.warning = (-6).dbamp; aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(32, 210, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(92, 210, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(316, 44, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(376, 44, barWidth, barHeight));
    bLeft.warning = (-6).dbamp; bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(308, 210, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(368, 210, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age
    statusA = StaticText(content, Rect(180, 44, 100, 18));
    statusA.string = "A rx: ‚Äî";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, 44, 100, 18));
    statusB.string = "B rx: ‚Äî";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // test controls (optional)
    startButton = Button(content, Rect(180, 80, 100, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    stopButton = Button(content, Rect(180, 114, 100, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbL, aDbR, bDbL, bDbR,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbL = ampToDbString.value(aL);
            aDbR = ampToDbString.value(aR);
            bDbL = ampToDbString.value(bL);
            bDbR = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbL; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbR; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbL; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbR; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.8.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.8.scd
// v0.3.8
// MD timestamp: 2025-09-25

/* Purpose
   - Four-meter A/B window with non-overlapping labels and a bit more vertical space.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).
   - No FlowLayout; fixed rects (top-left anchored).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; known-good SC syntax.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        hudTop, labelA, labelB,
        aLeft, aRight, aDbL, aDbR,
        bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight,
        xA, xB, yTop, yMeters, yDb, yButtons;

    // geometry constants (avoid overlap)
    xA = 40;     // left column x
    xB = 316;    // right column x
    yTop = 8;    // top HUD
    yMeters = 68;
    yDb = 236;
    yButtons = 72;

    barWidth = 26;
    barHeight = 160;

    titleString = "MagicDisplayGUI ‚Äî A/B Window (v0.3.8)";

    window = Window.new(titleString, Rect(60, 60, 600, 290), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // HUD line (single small strip ABOVE the A/B labels)
    hudTop = StaticText(content, Rect(16, yTop, 560, 16));
    hudTop.string = "HUD: A=replyID 2001 | B=replyID 2002 | fallback=test 1001";
    hudTop.stringColor = Color.gray(0.8);
    hudTop.background = Color.clear;
    hudTop.align = \left;

    // A/B section labels (moved down to avoid HUD)
    labelA = StaticText(content, Rect(16, yTop + 20, 260, 18));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    labelB = StaticText(content, Rect(292, yTop + 20, 260, 18));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    // A meters
    aLeft  = LevelIndicator(content, Rect(xA, yMeters, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(xA + 60, yMeters, barWidth, barHeight));
    aLeft.warning = (-6).dbamp;  aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(xA - 8, yDb, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(xA + 52, yDb, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(xB, yMeters, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(xB + 60, yMeters, barWidth, barHeight));
    bLeft.warning = (-6).dbamp;  bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(xB - 8, yDb, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(xB + 52, yDb, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age readouts (placed beside columns, not on top of labels)
    statusA = StaticText(content, Rect(180, yMeters, 110, 18));
    statusA.string = "A rx: ‚Äî";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, yMeters, 110, 18));
    statusB.string = "B rx: ‚Äî";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // Test controls (optional)
    startButton = Button(content, Rect(180, yButtons + 36, 110, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok2;
        ok2 = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok2;
    };

    stopButton = Button(content, Rect(180, yButtons + 72, 110, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok2;
        ok2 = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok2;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok2;
        ok2 = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok2;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbLStr, aDbRStr, bDbLStr, bDbRStr,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbLStr = ampToDbString.value(aL);
            aDbRStr = ampToDbString.value(aR);
            bDbLStr = ampToDbString.value(bL);
            bDbRStr = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbLStr; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbRStr; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbLStr; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbRStr; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.2.scd =====
// MagicDisplayGUI_New_Window_v0.3.2.scd
// v0.3.2
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call ~md_startTestSource / ~md_stopTestSource.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.2.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_v0.3.5.scd =====
// MagicDisplayGUI_New_Window_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window (closes prior ones with that prefix).
   - AppClock-only ticker updates LevelIndicators from ~levels.
   - Start/Stop buttons call robust API (~md_startTestSource / ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString,
        levelLeft, levelRight, labelLeft, labelRight, labelTitle,
        startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Window (v0.3.5)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus, /md/levels)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    startButton = Button(content, Rect(200, 44, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;  // auto-heals routing if server rebooted
        } {
            "Start function (~md_startTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, 80, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd first.".postln;
        };
        ok;
    };

    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) { ~mdGui_levelLeft.value = leftVal; };
            if (~mdGui_levelRight.notNil) { ~mdGui_levelRight.value = rightVal; };
            if (~mdGui_labelLeft.notNil) { ~mdGui_labelLeft.string = leftDb; };
            if (~mdGui_labelRight.notNil) { ~mdGui_labelRight.string = rightDb; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_QuickPeek_Levels.scd =====
// MagicDisplayGUI_NewPath_QuickPeek_Levels.scd
// v0.1.0
// MD timestamp: 2025-09-25

/* Purpose
   - Print ~levels a few times to verify updates.
   - No top-level 'var'; local vars are inside the Routine function.

   Style
   - var-first inside the Routine; no non-local returns (^).
*/

~md_levelsPeek = Routine({
    var i;
    i = 0;
    12.do {
        ("~levels now: " ++ ~levels.asString).postln;
        0.25.wait;
    };
}).play(AppClock);

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd =====
// MagicDisplayGUI_NewPath_Step1_Patch_OSC_ReceiverFix.scd
// v0.2.2
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall the /reply receiver for level updates with explicit recvPort.
   - Keep updating ~levels and record a heartbeat time (~md_lastLevelAt) for GUI status.
   - Non-invasive: does not touch groups/synths/busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; known-good SC syntax.
*/

(
var reinstallReceiver;

reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var tag, count, i, outArray;

            tag = msg[2];
            count = 0;
            i = 0;
            outArray = nil;

            if (tag == "/md/levels") {
                count = msg.size - 3;
                outArray = Array.newClear(count);
                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };
                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/reply',
        recvPort: NetAddr.langPort  // explicit
    );

    true;
};

"Reinstalling /reply receiver...".postln;
reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd =====
// MagicDisplayGUI_NewPath_Step1_PatchC_OSC_Receiver_mdlevels.scd
// v0.2.4
// MD timestamp: 2025-09-25

/* Purpose
   - Bind OSC receiver to '/md/levels' (matches SendReply in the probe SynthDef).
   - Parse values at indices 3..end and update ~levels and ~md_lastLevelAt.
   - No top-level 'var' declarations to avoid parse errors.

   Style
   - var-first inside function bodies; no non-local returns (^).
   - descriptive lowercase variable names; known-good SC syntax.
*/

(
// remove any previous receiver
if (OSCdef(\md_levels).notNil) { OSCdef(\md_levels).free; };

// reset shared state
~levels = [0.0, 0.0];
~md_lastLevelAt = Main.elapsedTime;

// Expected message from SendReply:
// [ '/md/levels', nodeID, replyID, val1, val2, ... ]
OSCdef(
    \md_levels,
    { |msg, time, addr, recvPort|
        var nodeId, replyId, count, i, outArray;

        nodeId = 0;
        replyId = 0;
        count = 0;
        i = 0;
        outArray = nil;

        if (msg.size >= 3) {
            nodeId = msg[1].asInteger;
            replyId = msg[2].asInteger;

            count = msg.size - 3;
            outArray = Array.newClear(count);

            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };

            ~levels = outArray;
            ~md_lastLevelAt = Main.elapsedTime;
        };
    },
    '/md/levels',
    recvPort: NetAddr.langPort
);
"Patch C installed: listening on /md/levels".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd =====
// MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd
// v0.2.1
// MD timestamp: 2025-09-25
/* Purpose
   - Cleanly (re)initialize the audio server tree, build a generated-only test signal path,
     and install a level probe that reports channel levels via /reply.
   - Publish public tilde helpers (~md_startTestSource, ~md_stopTestSource, ~md_cleanup) for GUI use.
   - Use compile-time channel counts (2ch) in SynthDefs.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; no server.sync; server ops wrapped in s.bind where relevant.
   - generated audio only; probe reads a private bus.
*/

(
var prepareServerAndDefs, setupRouting, installOscReceiver, definePublicAPI, startStartupSequence;

prepareServerAndDefs = {
    var ok;
    ok = true;

    s.waitForBoot({
        var def_testSource, def_toHardware2, def_levelProbe2;

        s.initTree;
        s.defaultGroup.freeAll;

        ~levels = [0.0, 0.0];

        // Test source: stereo beeps
        def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.20|
            var trig, freqSeq, sig, env, stereo;
            trig = Impulse.kr(2);
            freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
            env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
            sig = SinOsc.ar(freqSeq) * env;
            stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
            Out.ar(outBus, stereo * amp);
        }).add;

        // Relay to hardware (fixed 2ch)
        def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
            var sig;
            sig = In.ar(inBus, 2);
            Out.ar(0, sig);
        }).add;

        // Level probe (fixed 2ch) ‚Üí /reply
        def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, sendID = 1001|
            var sig, amps, ticker;
            sig = In.ar(inBus, 2);
            amps = Amplitude.kr(sig, 0.01, 0.30);
            ticker = Impulse.kr(20);
            SendReply.kr(ticker, "/md/levels", amps, sendID);
        }).add;
    });

    ok;
};

setupRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        ~md_mixBus = Bus.audio(s, 2);

        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \sendID, 1001]);

        ~md_testSynth = nil;
    });

    ok;
};

installOscReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];

    OSCdef(\md_levels, { |msg, time, addr, recvPort|
        var tag, count, i, outArray;

        tag = msg[2];
        count = 0;
        i = 0;
        outArray = nil;

        if (tag == "/md/levels") {
            count = msg.size - 3;
            outArray = Array.newClear(count);
            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };
            ~levels = outArray;
        };
    }, '/reply');

    true;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_startTestSource = {
        var ok2;
        ok2 = true;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.20]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        if (~md_probe.notNil) {
            ~md_probe.free;
            ~md_probe = nil;
        };

        if (~md_toHardware.notNil) {
            ~md_toHardware.free;
            ~md_toHardware = nil;
        };

        if (~md_outGroup.notNil) {
            ~md_outGroup.free;
            ~md_outGroup = nil;
        };
        if (~md_meterGroup.notNil) {
            ~md_meterGroup.free;
            ~md_meterGroup = nil;
        };
        if (~md_srcGroup.notNil) {
            ~md_srcGroup.free;
            ~md_srcGroup = nil;
        };

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        s.defaultGroup.freeAll;

        ok2;
    };

    ok;
};

startStartupSequence = {
    var ok;

    ok = true;

    "Step 1: preparing server + defs...".postln;
    prepareServerAndDefs.value;

    "Step 1: setting up routing (bus, groups, probe)...".postln;
    setupRouting.value;

    "Step 1: installing OSC receiver...".postln;
    installOscReceiver.value;

    // ‚úÖ Publish the API so Step 2 can call it
    "Step 1: defining public API...".postln;
    definePublicAPI.value;

    "Step 1: ready. Use ~md_startTestSource.value to begin audio.".postln;

    ok;
};

// ---------- run ----------
startStartupSequence.value;

// Tips:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd =====
// MagicDisplayGUI_NewPath_Step2_Patch_StatusLabel.scd
// v0.2.3
// MD timestamp: 2025-09-25

/* Purpose
   - Add a status label showing seconds since last level message ('rx age').
   - Helps confirm receiver is live.

   Style
   - var-first inside function bodies; no non-local returns (^).
*/

(
if (~mdGui_window.notNil) {
    var content, statusLabel;

    content = ~mdGui_window.view;

    statusLabel = StaticText(content, Rect(200, 120, 180, 18));
    statusLabel.string = "rx age: ‚Äî";
    statusLabel.stringColor = Color.gray(0.85);
    statusLabel.background = Color.clear;
    statusLabel.align = \left;

    ~mdGui_status = statusLabel;

    // start an AppClock updater (store it so we can stop later)
    ~mdGui_statusTicker = Routine({
        var running, age, lastAt;

        running = true;
        while { running } {
            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_status.notNil) {
                ~mdGui_status.string = "rx age: " ++ age.asString ++ " s";
            };

            0.2.yield;
            running = (~mdGui_window.notNil);
        };
    }).play(AppClock);

    "Status label installed.".postln;
} {
    "Open the MagicDisplayGUI window first, then run this patch.".postln;
};
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd =====
// MagicDisplayGUI_NewPath_Step2_WindowAndTicker.scd
// v0.2.0
// MD timestamp: 2025-09-25
/* Purpose
   - Build a robust single-window GUI that follows the window patterns you used in MagicPedalboard-WindowDisplayExamples:
     * one window whose name starts with "MagicDisplayGUI"
     * no FlowLayout
     * AppClock-only refresh loop
     * LevelIndicators for meters
   - Buttons call the public Step 1 tilde helpers (~md_startTestSource, ~md_stopTestSource).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; LevelIndicator values in [0..1].
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

buildWindow = {
    var window, content, titleString, levelLeft, levelRight, labelLeft, labelRight, labelTitle, buttonRowY, startButton, stopButton, barWidth, barHeight;

    titleString = "MagicDisplayGUI ‚Äî New Path (Step 2)";

    window = Window.new(titleString, Rect(60, 60, 420, 220), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // title
    labelTitle = StaticText(content, Rect(16, 12, 388, 22));
    labelTitle.string = "Magic Display (AppClock meters, private bus)";
    labelTitle.stringColor = Color.white;
    labelTitle.background = Color.clear;
    labelTitle.align = \left;

    // level bars
    barWidth = 26;
    barHeight = 140;

    levelLeft = LevelIndicator(content, Rect(40, 44, barWidth, barHeight));
    levelLeft.warning = (-6).dbamp;
    levelLeft.critical = (-3).dbamp;

    levelRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    levelRight.warning = (-6).dbamp;
    levelRight.critical = (-3).dbamp;

    // db readouts
    labelLeft = StaticText(content, Rect(36, 190, 60, 18));
    labelLeft.string = "-inf dB";
    labelLeft.stringColor = Color.gray(0.85);
    labelLeft.background = Color.clear;
    labelLeft.align = \center;

    labelRight = StaticText(content, Rect(96, 190, 60, 18));
    labelRight.string = "-inf dB";
    labelRight.stringColor = Color.gray(0.85);
    labelRight.background = Color.clear;
    labelRight.align = \center;

    // control buttons (call Step 1 helpers if present)
    buttonRowY = 44;

    startButton = Button(content, Rect(200, buttonRowY, 180, 28));
    startButton.states = [["Start Test Source", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) {
            ~md_startTestSource.value;
        } {
            "Start function (~md_startTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    stopButton = Button(content, Rect(200, buttonRowY + 36, 180, 28));
    stopButton.states = [["Stop Test Source", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) {
            ~md_stopTestSource.value;
        } {
            "Stop function (~md_stopTestSource) not found. Run Step 1 first.".postln;
        };
        ok;
    };

    // store references for the ticker
    ~mdGui_levelLeft = levelLeft;
    ~mdGui_levelRight = levelRight;
    ~mdGui_labelLeft = labelLeft;
    ~mdGui_labelRight = labelRight;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30; // ~30 Hz

    tickerRoutine = Routine({
        var running, leftVal, rightVal, leftDb, rightDb, levelArray;

        running = true;

        while { running } {
            levelArray = ~levels;

            leftVal = clampOrDefault.value(levelArray, 0, 0.0);
            rightVal = clampOrDefault.value(levelArray, 1, 0.0);

            leftDb = ampToDbString.value(leftVal);
            rightDb = ampToDbString.value(rightVal);

            if (~mdGui_levelLeft.notNil) {
                ~mdGui_levelLeft.value = leftVal;
            };
            if (~mdGui_levelRight.notNil) {
                ~mdGui_levelRight.value = rightVal;
            };
            if (~mdGui_labelLeft.notNil) {
                ~mdGui_labelLeft.string = leftDb;
            };
            if (~mdGui_labelRight.notNil) {
                ~mdGui_labelRight.string = rightDb;
            };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) {
        ~mdGui_window.close;
        ~mdGui_window = nil;
    };
    ok;
};

// ---------- run ----------
mdGuiOpen.value;

// Later: mdGuiClose.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd =====
// MagicDisplayGUI_OSC_TraceAndReport_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Trace /md/levels briefly and then print active replyIDs with current values.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^).
*/

(
var postStatus;

"=== RUN MagicDisplayGUI_OSC_TraceAndReport_v0.3.11 ===".postln;

postStatus = {
    var keys, msg;
    keys = if (~md_levelsById.notNil) { ~md_levelsById.keys.asArray.sort } { [] };
    msg = "Active replyIDs: " ++ keys.asString;
    msg.postln;
    if (~md_levelsById.notNil) {
        if (~md_levelsById[2001].notNil) { ("A (2001): " ++ ~md_levelsById[2001].asString).postln; };
        if (~md_levelsById[2002].notNil) { ("B (2002): " ++ ~md_levelsById[2002].asString).postln; };
        if (~md_levelsById[1001].notNil) { ("Test (1001): " ++ ~md_levelsById[1001].asString).postln; };
    };
};

OSCFunc.trace(true);
AppClock.sched(1.0, {
    var ok;
    ok = true;
    OSCFunc.trace(false);
    postStatus.value;
    ok;
});
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd =====
// MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Replace ~md_ensureRouting with a NON-DESTRUCTIVE version:
     * does NOT call s.defaultGroup.freeAll
     * only creates/repairs OUR groups/bus/probes if missing or not playing
   - Keeps your Ndefs and any other nodes intact.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var safeEnsure;

("MagicDisplayGUI_Patch_SaferEnsure_v0.3.10.scd").postln;

safeEnsure = {
    var ok, needBus, needGroups, needRelay, needProbe, defaultGroup;

    ok = true;

    if (s.serverRunning.not) {
        s.boot;
        s.waitForBoot({
            var ok2;
            ok2 = true;
            s.initTree;
            ok2;
        });
    };

    defaultGroup = s.defaultGroup;

    // bus
    needBus = (~md_mixBus.isNil);

    // groups
    needGroups = (
        ~md_srcGroup.isNil or: { ~md_meterGroup.isNil } or: { ~md_outGroup.isNil } or: {
            (~md_srcGroup.notNil and: { ~md_srcGroup.isPlaying.not })
            or: (~md_meterGroup.notNil and: { ~md_meterGroup.isPlaying.not })
            or: (~md_outGroup.notNil and: { ~md_outGroup.isPlaying.not })
        }
    );

    // relay + default probe
    needRelay = (~md_toHardware.isNil or: { ~md_toHardware.isPlaying.not });
    needProbe = (~md_probe.isNil or: { ~md_probe.isPlaying.not });

    s.bind({
        // bus
        if (needBus) {
            if (~md_mixBus.notNil) { ~md_mixBus.free; ~md_mixBus = nil; };
            ~md_mixBus = Bus.audio(s, 2);
        };

        // groups in strict order
        if (needGroups) {
            if (~md_outGroup.notNil) { ~md_outGroup.free; ~md_outGroup = nil; };
            if (~md_meterGroup.notNil) { ~md_meterGroup.free; ~md_meterGroup = nil; };
            if (~md_srcGroup.notNil) { ~md_srcGroup.free; ~md_srcGroup = nil; };

            ~md_srcGroup = Group.head(defaultGroup);
            ~md_meterGroup = Group.after(~md_srcGroup);
            ~md_outGroup = Group.after(~md_meterGroup);

            // force re-create relay/probe after new groups
            needRelay = true;
            needProbe = true;
        };

        if (needRelay) {
            if (~md_toHardware.notNil) { ~md_toHardware.free; ~md_toHardware = nil; };
            ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        };

        if (needProbe) {
            if (~md_probe.notNil) { ~md_probe.free; ~md_probe = nil; };
            ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);
        };
    });

    ok;
};

// replace the old ensure with the safe one
~md_ensureRouting = {
    var ok;
    ok = true;
    safeEnsure.value;
    ok;
};

"Patched ~md_ensureRouting to be non-destructive.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd =====
// MagicDisplayGUI_Reenable_FilterMeters_v0.3.12.scd
// v0.3.12
// MD timestamp: 2025-09-25

/* Purpose
   - Install .filter meters *inside* Ndef(\chainA) and Ndef(\chainB):
       * compute Amplitude.kr on the proxy signal
       * SendReply.kr directly to '/md/levels' with replyIDs 2001/2002
       * return the input signal unchanged (no audio change)
   - Neutralize any previous tap filters (bus mirroring) by overwriting them to identity.
   - Free any old external probe synths/busses used for taps; they are no longer needed.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables; known-good SC syntax.
*/

(
var hasA, hasB, attackTime, releaseTime, updateRateHz,
    installMeterFor, neutralizeTap, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_FilterMeters_v0.3.12 ===".postln;

hasA = (Ndef(\chainA).notNil);
hasB = (Ndef(\chainB).notNil);

attackTime = 0.01;
releaseTime = 0.30;
updateRateHz = 20;

// overwrite old bus-mirror taps to identity (safe if they don't exist)
neutralizeTap = { |name, key|
    var proxy, canFilter;
    proxy = Ndef(name);
    canFilter = false;
    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|  // identity pass-through
                var outSig;
                outSig = inputSig;
                outSig
            });
        };
    };
};

// install the actual meter filter (no bus, direct SendReply)
installMeterFor = { |name, replyID, key|
    var proxy, canFilter, ok;
    proxy = Ndef(name);
    canFilter = false;
    ok = true;

    if (proxy.notNil) {
        canFilter = proxy.respondsTo(\filter);
        if (canFilter) {
            proxy.filter(key, { |inputSig|
                var amps, ticker, outSig;
                amps = Amplitude.kr(inputSig, attackTime, releaseTime);
                ticker = Impulse.kr(updateRateHz);
                SendReply.kr(ticker, "/md/levels", amps, replyID);
                outSig = inputSig; // no audio change
                outSig
            });
            (("Installed meter on " ++ name.asString) ++ " (replyID " ++ replyID.asString ++ ").").postln;
        } {
            (name.asString ++ ": .filter not supported; skipped.").postln;
        };
    } {
        (name.asString ++ " not found; skipped.").postln;
    };

    ok;
};

// neutralize any prior tap keys used before (safe no-ops if absent)
neutralizeTap.value(\chainA, \mdProbeTapA);
neutralizeTap.value(\chainB, \mdProbeTapB);

// install in-proxy meters (distinct keys so they are idempotent)
if (hasA) { installMeterFor.value(\chainA, 2001, \mdMeterA); };
if (hasB) { installMeterFor.value(\chainB, 2002, \mdMeterB); };

// free old external probe synths/busses (from the tap approach)
freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

freeIfPlaying.value(~md_probeA);  ~md_probeA = nil;
freeIfPlaying.value(~md_probeB);  ~md_probeB = nil;

if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

"Installed in-proxy meters; removed external probes/tap busses.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.10.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.10.scd
// v0.3.10
// MD timestamp: 2025-09-25

/* Purpose
   - Make A/B meters move reliably by reinstating .filter taps on Ndef(\chainA/\chainB).
   - Mirror audio to private stereo busses, then attach A(2001)/B(2002) probes to those busses.
   - Non-destructive: does not modify chain sound; taps return 'in'.

   Style
   - var-first in every block; no non-local returns (^).
*/

(
var ok, haveA, haveB, tapBusA, tapBusB;

("MagicDisplayGUI_Reenable_Taps_v0.3.10.scd").postln;

ok = true;
haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

// (re)allocate private tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// install/overwrite taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes to tap busses (free stale ones first)
s.bind({
    if (~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil; };
    if (~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil; };

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
    };
});

("A probe -> inBus " ++ tapBusA.asString).postln;
("B probe -> inBus " ++ tapBusB.asString).postln;

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Reenable_Taps_v0.3.11.scd =====
// MagicDisplayGUI_Reenable_Taps_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall .filter taps on Ndef(\chainA/\chainB) to mirror audio to private 2ch busses.
   - Attach probes A(2001) and B(2002) to those busses.
   - Quiet stale frees; print nodeIDs of created probes.
   - Announces itself in the console.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables.
*/

(
var haveA, haveB, tapBusA, tapBusB, newProbeA, newProbeB, freeIfPlaying;

"=== RUN MagicDisplayGUI_Reenable_Taps_v0.3.11 ===".postln;

haveA = (Ndef(\chainA).notNil);
haveB = (Ndef(\chainB).notNil);

~md_ensureRouting.value;

freeIfPlaying = { |node|
    var ok;
    ok = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok;
};

// fresh tap busses
if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

~md_busA = if (haveA) { Bus.audio(s, 2) } { nil };
~md_busB = if (haveB) { Bus.audio(s, 2) } { nil };

tapBusA = if (~md_busA.notNil) { ~md_busA.index } { -1 };
tapBusB = if (~md_busB.notNil) { ~md_busB.index } { -1 };

// (re)install taps (identity pass-through + mirror to tap bus)
if (haveA) {
    Ndef(\chainA).filter(\mdProbeTapA, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusA, outSig);
        outSig
    });
    ("Tap A -> bus " ++ tapBusA.asString).postln;
} {
    "Ndef(\\chainA) not found; A tap skipped.".postln;
};

if (haveB) {
    Ndef(\chainB).filter(\mdProbeTapB, { |in|
        var outSig;
        outSig = in;
        Out.ar(tapBusB, outSig);
        outSig
    });
    ("Tap B -> bus " ++ tapBusB.asString).postln;
} {
    "Ndef(\\chainB) not found; B tap skipped.".postln;
};

// attach probes (free stale ones only if playing)
s.bind({
    freeIfPlaying.value(~md_probeA);
    ~md_probeA = nil;

    freeIfPlaying.value(~md_probeB);
    ~md_probeB = nil;

    newProbeA = nil;
    newProbeB = nil;

    if (tapBusA >= 0) {
        ~md_probeA = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusA, \replyID, 2001]);
        newProbeA = ~md_probeA;
    };
    if (tapBusB >= 0) {
        ~md_probeB = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, tapBusB, \replyID, 2002]);
        newProbeB = ~md_probeB;
    };
});

if (newProbeA.notNil) { ("A probe nodeID: " ++ newProbeA.nodeID.asString).postln; } { "A probe not created.".postln; };
if (newProbeB.notNil) { ("B probe nodeID: " ++ newProbeB.nodeID.asString).postln; } { "B probe not created.".postln; };

"Re-enable taps: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_ResetReceiver_v0.3.11.scd =====
// MagicDisplayGUI_ResetReceiver_v0.3.11.scd
// v0.3.11
// MD timestamp: 2025-09-25

/* Purpose
   - Reinstall OSC receiver on '/md/levels' and reset ~md_levelsById / ~levels / ~md_lastLevelAt.
   - Announces itself in the console with a header.

   Style
   - var-first; no non-local returns (^); descriptive lowercase variables.
*/

(
var existing;

"=== RUN MagicDisplayGUI_ResetReceiver_v0.3.11 ===".postln;

existing = OSCdef(\md_levels);
if (existing.notNil) { existing.free; };

~md_levelsById = IdentityDictionary.new;
~levels = [0.0, 0.0];
~md_lastLevelAt = Main.elapsedTime;

OSCdef(
    \md_levels,
    { |msg, time, addr, recvPort|
        var nodeId, replyId, count, i, outArray;

        nodeId = 0;
        replyId = 0;
        count = 0;
        i = 0;
        outArray = nil;

        if (msg.size >= 3) {
            nodeId = msg[1].asInteger;
            replyId = msg[2].asInteger;

            count = msg.size - 3;
            outArray = Array.newClear(count);

            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };

            ~md_levelsById[replyId] = outArray;
            ~levels = outArray;
            ~md_lastLevelAt = Main.elapsedTime;
        };
    },
    '/md/levels',
    recvPort: NetAddr.langPort
);

"Receiver: /md/levels (OK)".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.8.scd
// v0.3.8
// MD timestamp: 2025-09-25
/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if playing).
   - Attach A (replyID 2001) and B (replyID 2002) probes directly to those busses.
   - Remove previously-installed .filter taps and free their private busses (if present).
   - Non-invasive: does not change your chain sound.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var detectBusIndex, aIdx, bIdx, ok, hadBringUp;

ok = true;
hadBringUp = (~md_attachProbesAB.notNil);

if (hadBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus; // valid if the proxy has produced output (ideally playing)
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // attach probes directly to A/B buses (even if one is -1, the helper skips it)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // remove taps if they exist (safe if none present)
    if (Ndef(\chainA).notNil) { Ndef(\chainA).removeFilter(\mdProbeTapA); };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).removeFilter(\mdProbeTapB); };

    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps removed (if present).".postln;
};

ok;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd =====
// MagicDisplayGUI_SwitchTo_DetectedBusAttach_v0.3.9.scd
// v0.3.9
// MD timestamp: 2025-09-25

/* Purpose
   - Auto-detect Ndef(\chainA/\chainB) audio bus base indices (if present).
   - Ensure routing (bus/groups) exists even after a server reboot.
   - Attach A (2001) and B (2002) probes directly to those busses.
   - Neutralize any prior .filter taps (identity pass-through) and free their private busses.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; known-good SC syntax.
*/

(
var ok, haveBringUp, detectBusIndex, aIdx, bIdx, neutralizeTap;

ok = true;
haveBringUp = (~md_attachProbesAB.notNil);

if (haveBringUp.not) {
    "Bring-up not loaded. Run MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd first.".postln;
} {
    // ensure routing exists (rebuilds groups/bus/probe if server rebooted)
    ~md_ensureRouting.value;

    detectBusIndex = { |name|
        var proxy, idx, busObj;
        proxy = Ndef(name);
        idx = -1;
        busObj = nil;
        if (proxy.notNil) {
            busObj = proxy.bus;   // valid when the proxy has produced output
            if (busObj.notNil) { idx = busObj.index; };
        };
        idx;
    };

    neutralizeTap = { |name, key|
        var proxy, canFilter;
        proxy = Ndef(name);
        canFilter = false;
        if (proxy.notNil) {
            canFilter = proxy.respondsTo(\filter);
            if (canFilter) {
                // Overwrite any existing tap with identity to stop extra Out.ar
                proxy.filter(key, { |in| in });
            };
        };
    };

    aIdx = detectBusIndex.value(\chainA);
    bIdx = detectBusIndex.value(\chainB);

    ("Detected buses: chainA=" ++ aIdx.asString ++ " chainB=" ++ bIdx.asString).postln;

    // Attach probes directly (skips -1 safely)
    ~md_attachProbesAB.value(busA: aIdx, busB: bIdx);

    // Neutralize taps (works in all versions; no removeFilter needed)
    neutralizeTap.value(\chainA, \mdProbeTapA);
    neutralizeTap.value(\chainB, \mdProbeTapB);

    // Free the private tap busses if they exist
    if (~md_busA.notNil) { ~md_busA.free; ~md_busA = nil; };
    if (~md_busB.notNil) { ~md_busB.free; ~md_busB = nil; };

    "Switched to direct attach on detected buses; taps neutralized and tap busses freed.".postln;
};

ok;
)

===== MagicPedalboard/utils_mpb_force_reconnect.scd =====
// utils_mpb_force_reconnect.scd
// v0.2
// MD 20250916-1057

(
~mpb_forceReconnect = { arg pedalboard;
    var log, connectPair, reconnectList, effCur, effNext, sinkCur, sinkNext, indexCounter, lastIndex;

    log = { arg txt; ("[FIX] " ++ txt).postln };

    connectPair = { arg leftKey, rightKey;
        Server.default.bind({
            // Correct JITLib embed operator used in your project:
            Ndef(leftKey) <<> Ndef(rightKey);
        });
    };

    reconnectList = { arg listSymbols;
        indexCounter = 0;
        lastIndex = listSymbols.size - 1;
        while({ indexCounter < lastIndex }, {
            connectPair.(listSymbols[indexCounter], listSymbols[indexCounter + 1]);
            indexCounter = indexCounter + 1;
        });
    };

    effCur = pedalboard.effectiveCurrent;
    effNext = pedalboard.effectiveNext;

    reconnectList.(effCur);
    reconnectList.(effNext);

    sinkCur = effCur[0];
    sinkNext = effNext[0];

    Server.default.bind({
        if(Ndef(sinkCur).isPlaying.not) { Ndef(sinkCur).play(numChannels: 2) };
        if(Ndef(sinkNext).isPlaying)    { Ndef(sinkNext).stop };
    });

    log.("forceReconnect done. current=" ++ effCur ++ "  next=" ++ effNext);
};
)

===== MagicPedalboard/WindowDisplayExamples/ SixPanes_Layout_VH.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_VH.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: draw 6 "pane" rectangles (colored borders) arranged with VLayout/HLayout.
// - No audio, no Ndefs, no server. Pure Qt layout.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, row1, row2, row3, rootLayout;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes VHLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill  = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

// six distinct colors and titles
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory: a container with colored border and two text lines ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView()  // no parent yet; layout will parent it
        .background_(paneFill)
        .minSize_(Size(500, 230)); // give layout something decent to work with

    border = UserView(pane)
        .resize_(1)
        .drawFunc_({ |v|
            var rect;
            rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
            Pen.fillColor = Color(0.11, 0.11, 0.12);
            Pen.strokeColor = borderColor;
            Pen.width = 2;
            Pen.fillRect(rect);
            Pen.strokeRect(rect);
        });

    titleText = StaticText()
        .string_(titleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyText = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    // inner stack inside each pane (title above body)
    pane.layout_(VLayout(
        // top margin shim
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        // bottom stretch
        nil
    ));

    pane
};

// ---------- build six panes ----------
row1 = HLayout(
    makePane.(paneTitles[0], paneColors[0]),
    UserView().minWidth_(cellPadding), // spacer
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout: 3 rows stacked, with vertical spacers ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding), // top margin
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)  // bottom margin
);

// install the layout on the window
window.layout_(rootLayout);
window.front;
)

===== MagicPedalboard/WindowDisplayExamples/examplesSlidersButtons.scd =====
// examplesSlidersButtons.scd
// taken from Eli Fieldsteel book examples for chatper 8.

(
Window("Layout Management", Rect(100, 100, 250, 500)).front
.layout_(
	VLayout(
		HLayout(Knob(), Knob(), Knob(), Knob()),
		HLayout(Slider(), Slider(), Slider(), Slider()),
		Slider2D(),
		Button()
	)
);
)
===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes in GridLayout (3x2); top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, p;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

p = Array.newClear(6);

// ---------- factories ----------
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView();
    textColumn.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    pane
};

// ---------- build six panes (index 0 gets the meter) ----------
p[0] = makePaneWithMeter.(paneTitles[0], paneColors[0]); // top-left with meter
p[1] = makePane.(paneTitles[1], paneColors[1]);
p[2] = makePane.(paneTitles[2], paneColors[2]);
p[3] = makePane.(paneTitles[3], paneColors[3]);
p[4] = makePane.(paneTitles[4], paneColors[4]);
p[5] = makePane.(paneTitles[5], paneColors[5]);

// ---------- install grid 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with GridLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, paneArray;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build six panes ----------
paneArray = Array.newClear(6);
paneArray[0] = makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A); // top-left with meter A
paneArray[1] = makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B); // top-right with meter B
paneArray[2] = makeTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = makeTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = makeTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = makeTextPane.(paneTitles[5], paneBorderColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with two meters in the top row.
// - Meter A (top-left) is real (Ndef test source -> control bus); Meter B (top-right) is simulated.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterRoutine, serverBootRoutine;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI Grid + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build 3x2 grid: top row has meters ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"); // top-left real
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B"); // top-right simulated
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (GridLayout 3x2) with 2 meters in the top row.
// - Audible test source (Ndef) plays; its amplitude steps in 10 dB increments every second.
// - Meters A and B both follow the same stepped level.
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, paneArray;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0];
stepIntervalSeconds = 1.0;

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- assemble grid (top row has meters) ----------
paneArray = Array.newClear(6);
paneArray[0] = buildMeterPane.(paneTitles[0], paneBorderColors[0], "A");
paneArray[1] = buildMeterPane.(paneTitles[1], paneBorderColors[1], "B");
paneArray[2] = buildTextPane.(paneTitles[2], paneBorderColors[2]);
paneArray[3] = buildTextPane.(paneTitles[3], paneBorderColors[3]);
paneArray[4] = buildTextPane.(paneTitles[4], paneBorderColors[4]);
paneArray[5] = buildTextPane.(paneTitles[5], paneBorderColors[5]);

window.layout_(GridLayout.rows(
    [ paneArray[0], paneArray[1] ],
    [ paneArray[2], paneArray[3] ],
    [ paneArray[4], paneArray[5] ]
));
window.front;

// ---------- AUDIO bring-up (audible Ndef + stepped amplitude) ----------
serverBringUpRoutine = Routine({
    s.waitForBoot({
        var defaultNumChannels, leftFrequency, rightFrequency;
        defaultNumChannels = 2;
        s.initTree; s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        Ndef(\stepToneA, {
            var stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20, 20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30, 30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // smooth the steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            monoSignal    = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP meters + audible amplitude ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);

        { if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
          if(meterViewB.notNil, { meterViewB.value_(currentLinear) }); }.defer;

        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters.scd
// v0.3.1
// MD 2025-09-25 14:20
//
// Purpose / Style:
// - GUI-only: 6 panes in a GridLayout (3x2).
// - Top-left and top-right contain simulated meters (no audio).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makeTextPane, makeMeterPane, p;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

// returns [pane, meterView]
makeMeterPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    [pane, meterView]
};

// ---------- build six panes ----------
p = Array.newClear(6);
var pane, m;

#pane, m = makeMeterPane.(paneTitles[0], paneColors[0]); p[0] = pane; meterViewA = m; // top-left
#pane, m = makeMeterPane.(paneTitles[1], paneColors[1]); p[1] = pane; meterViewB = m; // top-right
p[2] = makeTextPane.(paneTitles[2], paneColors[2]);
p[3] = makeTextPane.(paneTitles[3], paneColors[3]);
p[4] = makeTextPane.(paneTitles[4], paneColors[4]);
p[5] = makeTextPane.(paneTitles[5], paneColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valA) });
            if(meterViewB.notNil, { meterViewB.value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_Grid.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_Grid.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: six colored panes arranged with GridLayout (3 rows x 2 columns).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles, makePane;
var p = Array.newClear(6);

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w| var nameString; nameString = w.name.asString; if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer }); });

// ---------- window ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes GridLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

// ---------- styles ----------
titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView().background_(paneFill).minSize_(Size(500, 230));
    border = UserView(pane).resize_(1).drawFunc_({ |v|
        var rect; rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11,0.11,0.12); Pen.strokeColor = borderColor; Pen.width = 2;
        Pen.fillRect(rect); Pen.strokeRect(rect);
    });
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.").font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    pane.layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane
};

// ---------- build array of six panes ----------
6.do({ |i| p[i] = makePane.(paneTitles[i], paneColors[i]) });

// ---------- grid layout: 3 rows √ó 2 columns ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));

window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_Layout_VH.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_Layout_VH.scd
// v0.1.0
// MD 2025-09-25 13:35
//
// Purpose / Style:
// - GUI-only: draw 6 "pane" rectangles (colored borders) arranged with VLayout/HLayout.
// - No audio, no Ndefs, no server. Pure Qt layout.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, row1, row2, row3, rootLayout;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI SixPanes VHLayout", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill  = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

// six distinct colors and titles
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factory: a container with colored border and two text lines ----------
makePane = { |titleString, borderColor|
    var pane, border, titleText, bodyText;
    pane = UserView()  // no parent yet; layout will parent it
        .background_(paneFill)
        .minSize_(Size(500, 230)); // give layout something decent to work with

    border = UserView(pane)
        .resize_(1)
        .drawFunc_({ |v|
            var rect;
            rect = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
            Pen.fillColor = Color(0.11, 0.11, 0.12);
            Pen.strokeColor = borderColor;
            Pen.width = 2;
            Pen.fillRect(rect);
            Pen.strokeRect(rect);
        });

    titleText = StaticText()
        .string_(titleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyText = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    // inner stack inside each pane (title above body)
    pane.layout_(VLayout(
        // top margin shim
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        // bottom stretch
        nil
    ));

    pane
};

// ---------- build six panes ----------
row1 = HLayout(
    makePane.(paneTitles[0], paneColors[0]),
    UserView().minWidth_(cellPadding), // spacer
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout: 3 rows stacked, with vertical spacers ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding), // top margin
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)  // bottom margin
);

// install the layout on the window
window.layout_(rootLayout);
window.front;
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_MeterSim.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_MeterSim.scd
// v0.2.0
// MD 2025-09-25 13:55
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left pane contains a simulated meter.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterView, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Sim Meter", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter on the right side
makePaneWithMeter = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left uses the meter) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0]), // top-left with meter
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[1], paneColors[1])
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meter animation (no audio) ----------
meterRoutine = Routine({
    var updateInterval, phase, val, noise;
    updateInterval = 0.05;
    phase = 0.0;
    loop {
        // simple sine-driven value with a hint of noise, clipped to [0,1]
        val = ((sin(phase) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noise = (0.10.rand2).clip(-0.08, 0.08);
        val = (val + noise).clip(0.0, 1.0);
        { if(meterView.notNil, { meterView.value_(val) }) }.defer;
        phase = phase + 0.15;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_Descriptive.scd
// v0.4.0
// MD 2025-09-25 14:36
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right have simulated meters.
// - Rules: var-first; descriptive lowercase variable names; no single-letter variables; no non-local returns.
// - No audio, no Ndefs.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var makeTextPane, makeMeterPaneForKey, rowTop, rowMiddle, rowBottom, rootLayout;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var nameString;
    nameString = existingWindow.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
makeTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Meter pane; meterKeySymbol is \A or \B (decides which global meterView to write)
makeMeterPaneForKey = { |paneTitleString, borderColor, meterKeySymbol|
    var paneView, titleTextView, bodyTextView, textColumnView, meterColumnView, localMeterView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    if(meterKeySymbol == \A, { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    makeMeterPaneForKey.(paneTitles[0], paneBorderColors[0], \A), // top-left
    UserView().minWidth_(cellPadding),
    makeMeterPaneForKey.(paneTitles[1], paneBorderColors[1], \B)  // top-right
);

rowMiddle = HLayout(
    makeTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    makeTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    makeTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateIntervalSeconds, phaseA, phaseB, valueA, valueB, noiseA, noiseB;
    updateIntervalSeconds = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valueA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valueA = (valueA + noiseA).clip(0.0, 1.0);
        valueB = (valueB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valueA) });
            if(meterViewB.notNil, { meterViewB.value_(valueB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_RealA_Descriptive.scd
// v0.5.0
// MD 2025-09-25 14:54
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with two meters in the top row.
// - Meter A (top-left) shows a real level from a tiny Ndef test source.
// - Meter B (top-right) is simulated (sine + noise) to verify GUI update path.
// - Rules: var-first; descriptive lowercase names; no single-letter variables; no non-local returns; no server.sync.
// - Cleans up Ndef and buses on window close.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterRoutine;           // GUI meter widgets + updater
var serverBootRoutine;                               // guard: keep GUI responsive
var amplitudeBusA;                                   // control bus for real meter A
var meterLabelFont;                                  // tiny label above meters

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VH + Real A / Sim B", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
// Text-only pane
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nGUI-only layout test.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    paneView.layout_(VLayout(
        UserView().minHeight_(6),
        textColumnView,
        nil
    ));

    paneView
};

// Pane with meter and label (labelTextString = "A" or "B")
// Returns: the pane view; assigns meterViewA/meterViewB internally
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView;
    var meterLabelView, meterColumnView, localMeterView;

    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };

    titleTextView = StaticText()
        .string_(paneTitleString)
        .font_(titleFont)
        .stringColor_(Color.white);

    bodyTextView  = StaticText()
        .string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " is shown on the right.")
        .font_(bodyFont)
        .stringColor_(Color(0.85, 0.9, 0.95));

    textColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(6),
        titleTextView,
        UserView().minHeight_(4),
        bodyTextView,
        nil
    ));

    meterLabelView = StaticText()
        .string_(labelTextString)
        .font_(meterLabelFont)
        .stringColor_(Color.white)
        .align_(\center);

    localMeterView = LevelIndicator()
        .warning_(0.7)
        .critical_(0.95)
        .minSize_(Size(20, 180));

    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });

    meterColumnView = UserView().layout_(VLayout(
        UserView().minHeight_(4),
        meterLabelView,
        UserView().minHeight_(4),
        localMeterView,
        nil
    ));

    paneView.layout_(HLayout(
        UserView().minWidth_(6),
        textColumnView,
        UserView().minWidth_(10),
        meterColumnView,
        UserView().minWidth_(6)
    ));

    paneView
};

// ---------- build rows (top row uses meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"), // top-left: meter A (real)
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")  // top-right: meter B (simulated)
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);

window.layout_(rootLayout);
window.front;

// ---------- bring up real meter A (Ndef) and simulated meter B ----------
serverBootRoutine = Routine({
    var updateIntervalSeconds, phaseB, simulatedValueB, simulatedNoiseB;

    // 1) Boot + minimal server prep
    s.waitForBoot({
        var defaultNumChannels;
        defaultNumChannels = 2;

        s.initTree;
        s.defaultGroup.freeAll;

        // 2) Control bus for meter A
        amplitudeBusA = Bus.control(s, 1);

        // 3) Tiny test source -> real meter A (no OutputProxy indexing; no server.sync)
        Ndef(\meterSourceA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeValue;
            var meterBusIndex;
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = [Saw.ar(leftFrequency), Saw.ar(rightFrequency)] * 0.07;
            monoSignal     = stereoSignal.sum * 0.5;
            amplitudeValue = Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5);
            meterBusIndex  = \meterBus.kr(0);   // language sets this before/around play
            Out.kr(meterBusIndex, amplitudeValue);
            (stereoSignal.tanh * 0.9)
        });

        // set meter bus, then play quietly to out
        Ndef(\meterSourceA).set(\meterBus, amplitudeBusA.index);
        Ndef(\meterSourceA).play;
    });

    // 4) Update both meters on AppClock (A from control bus, B simulated)
    updateIntervalSeconds = 0.05;
    phaseB = 0.0;

    meterRoutine = Routine({
        loop {
            // real meter A (read from control bus written by Ndef)
            amplitudeBusA.get({ |busValueA|
                var mappedValueA;
                mappedValueA = busValueA.clip(0.0, 1.0);
                { if(meterViewA.notNil, { meterViewA.value_(mappedValueA) }) }.defer;
            });

            // simulated meter B (sine + noise)
            simulatedValueB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
            simulatedNoiseB = (0.10.rand2).clip(-0.08, 0.08);
            simulatedValueB = (simulatedValueB + simulatedNoiseB).clip(0.0, 1.0);
            { if(meterViewB.notNil, { meterViewB.value_(simulatedValueB) }) }.defer;

            phaseB = phaseB + 0.12;
            updateIntervalSeconds.wait;
        }
    }).play(AppClock);
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
    if(serverBootRoutine.notNil, { serverBootRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\meterSourceA).notNil, {
        Ndef(\meterSourceA).stop;
        Ndef(\meterSourceA).clear;
    });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters_SteppedDB_Sound.scd
// v0.7.0
// MD 2025-09-25 15:24
//
// Purpose / Style:
// - GUI-only layout (VLayout + HLayout) with 2 meters in the top row.
// - Audible test source (Ndef) plays a soft stereo tone whose amplitude
//   steps through dB values once per second (default: [-60,-50,...,0] dB).
// - Meters A and B show the same stepped level (so you hear the same step).
// - Rules: var-first; descriptive lowercase names; no single-letter variables;
//   no non-local returns; no server.sync; known-good Qt syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBackgroundColor, paneFillColor, cellPadding;
var titleFont, bodyFont, meterLabelFont, paneBorderColors, paneTitles;
var buildTextPane, buildMeterPane, rowTop, rowMiddle, rowBottom, rootLayout;

var meterViewA, meterViewB, meterStepRoutine, serverBringUpRoutine;
var dbStepValues, stepIntervalSeconds;
var amplitudeBusA;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |existingWindow|
    var existingNameString;
    existingNameString = existingWindow.name.asString;
    if(existingNameString.beginsWith("MagicDisplayGUI"), { { existingWindow.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Stepped dB (with sound)", windowRect).alwaysOnTop_(true);
windowBackgroundColor = Color(0.08, 0.08, 0.09);
paneFillColor = Color(0.15, 0.15, 0.18);
window.view.background_(windowBackgroundColor);
cellPadding = 10;

titleFont      = Font("Helvetica-Bold", 16);
bodyFont       = Font("Menlo", 12);
meterLabelFont = Font("Helvetica-Bold", 13);

paneBorderColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles       = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- stepped-meters parameters ----------
dbStepValues        = [-60, -50, -40, -30, -20, -10, 0]; // edit as you like
stepIntervalSeconds = 1.0;                                // 1 second per step

// ---------- factories ----------
buildTextPane = { |paneTitleString, borderColor|
    var paneView, titleTextView, bodyTextView, textColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nLayout row with text.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    paneView.layout_(VLayout(UserView().minHeight_(6), textColumnView, nil));
    paneView
};

// Pane with labeled meter ("A" or "B"); assigns to meterViewA / meterViewB
buildMeterPane = { |paneTitleString, borderColor, labelTextString|
    var paneView, titleTextView, bodyTextView, textColumnView, meterLabelView, localMeterView, meterColumnView;
    paneView = UserView().background_(paneFillColor).minSize_(Size(520, 230));
    paneView.drawFunc = { |drawView|
        var borderRect;
        borderRect = Rect(1, 1, drawView.bounds.width - 2, drawView.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(borderRect);
        Pen.strokeRect(borderRect);
    };
    titleTextView = StaticText().string_(paneTitleString).font_(titleFont).stringColor_(Color.white);
    bodyTextView  = StaticText().string_("Pane: " ++ paneTitleString ++ "\nMeter " ++ labelTextString ++ " steps in 10 dB increments.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));
    textColumnView = UserView().layout_(VLayout(UserView().minHeight_(6), titleTextView, UserView().minHeight_(4), bodyTextView, nil));
    meterLabelView = StaticText().string_(labelTextString).font_(meterLabelFont).stringColor_(Color.white).align_(\center);
    localMeterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(20, 180));
    if(labelTextString == "A", { meterViewA = localMeterView }, { meterViewB = localMeterView });
    meterColumnView = UserView().layout_(VLayout(UserView().minHeight_(4), meterLabelView, UserView().minHeight_(4), localMeterView, nil));
    paneView.layout_(HLayout(UserView().minWidth_(6), textColumnView, UserView().minWidth_(10), meterColumnView, UserView().minWidth_(6)));
    paneView
};

// ---------- build rows (top has two meters) ----------
rowTop = HLayout(
    buildMeterPane.(paneTitles[0], paneBorderColors[0], "A"),
    UserView().minWidth_(cellPadding),
    buildMeterPane.(paneTitles[1], paneBorderColors[1], "B")
);

rowMiddle = HLayout(
    buildTextPane.(paneTitles[2], paneBorderColors[2]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[3], paneBorderColors[3])
);

rowBottom = HLayout(
    buildTextPane.(paneTitles[4], paneBorderColors[4]),
    UserView().minWidth_(cellPadding),
    buildTextPane.(paneTitles[5], paneBorderColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    rowTop,
    UserView().minHeight_(cellPadding),
    rowMiddle,
    UserView().minHeight_(cellPadding),
    rowBottom,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- AUDIO bring-up (small audible Ndef + AMP stepping) ----------
serverBringUpRoutine = Routine({
    var defaultNumChannels;
    s.waitForBoot({
        defaultNumChannels = 2;
        s.initTree;
        s.defaultGroup.freeAll;

        amplitudeBusA = Bus.control(s, 1);

        // Test source with controlled amplitude (stepped)
        Ndef(\stepToneA, {
            var leftFrequency, rightFrequency, stereoSignal, monoSignal, amplitudeLinear, meterBusIndex;
            // slow-moving, gentle timbre
            leftFrequency  = 220 + LFTri.kr(0.10).range(-20,  20);
            rightFrequency = 330 + LFTri.kr(0.13).range(-30,  30);
            stereoSignal   = (VarSaw.ar([leftFrequency, rightFrequency], 0.0, 0.35) * 0.5).tanh * 0.15;

            amplitudeLinear = Lag.kr(\amp.kr(0.05), 0.02); // prevent clicks on level steps
            stereoSignal    = stereoSignal * amplitudeLinear;

            // drive a meter bus so GUI can also poll (optional)
            monoSignal   = stereoSignal.sum * 0.5;
            meterBusIndex = \meterBus.kr(0);
            Out.kr(meterBusIndex, Amplitude.ar(monoSignal, 0.01, 0.30).clip(0.0, 1.5));

            stereoSignal
        });

        Ndef(\stepToneA).set(\meterBus, amplitudeBusA.index, \amp, 0.05);
        Ndef(\stepToneA).play;
    });
}).play(AppClock);

// ---------- STEP both meters + audible level every 1s ----------
meterStepRoutine = Routine({
    var stepIndex, stepCount, currentDb, currentLinear;
    stepIndex = 0;
    stepCount = dbStepValues.size;
    loop {
        currentDb     = dbStepValues.wrapAt(stepIndex);     // e.g. -60 .. 0 dB
        currentLinear = currentDb.dbamp.clip(0.0, 1.0);     // convert to 0..1

        // update meters
        {
            if(meterViewA.notNil, { meterViewA.value_(currentLinear) });
            if(meterViewB.notNil, { meterViewB.value_(currentLinear) });
        }.defer;

        // update audible amplitude
        Ndef(\stepToneA).set(\amp, currentLinear);

        stepIndex = stepIndex + 1;
        stepIntervalSeconds.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterStepRoutine.notNil, { meterStepRoutine.stop });
    if(serverBringUpRoutine.notNil, { serverBringUpRoutine.stop });
    if(amplitudeBusA.notNil, { amplitudeBusA.free });
    if(Ndef.all.at(\stepToneA).notNil, { Ndef(\stepToneA).stop; Ndef(\stepToneA).clear; });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters.scd
// v0.3.0
// MD 2025-09-25 14:08
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right contain simulated meters.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterViews, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// store two meter views [A, B]
meterViews = Array.newClear(2);

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter; meterIndex: 0 for top-left (A), 1 for top-right (B)
makePaneWithMeter = { |titleString, borderColor, meterIndex|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterViews.put(meterIndex, meterView);

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left & top-right use meters) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0], 0), // top-left meter A
    UserView().minWidth_(cellPadding),
    makePaneWithMeter.(paneTitles[1], paneColors[1], 1)  // top-right meter B
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single AppClock routine for both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 1.2; // offset so A and B differ
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViews[0].notNil, { meterViews[0].value_(valA) });
            if(meterViews[1].notNil, { meterViews[1].value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MDMiniLogger/test_MDMiniLogger.scd =====
// test_MDMiniLogger.scd

m = MDMiniLogger.get;

m.setverbosity(0);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(1);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");

m.setverbosity(2);
m.error(\TEST, "Error prints");
m.warn(\TEST,  "Warn prints");
m.info(\TEST,  "Info prints");
m.debug(\TEST, "Debug suppressed at INFO");
m.trace(\TEST, "Trace suppressed at INFO");

m.disable;  m.error(\TEST, "Should NOT print");
m.enable;   m.error(\TEST, "Should print again");


===== temp files/BringBack_UserChoicesWindow.scd =====
// BringBack_UserChoicesWindow.scd
// v0.1.0  MD 2025-09-22

/*
Purpose
- Restore the old branch-choices window (UserDisplay) and wire it to CommandManager
  *alongside* MagicDisplayGUI, without changing your classes.

Style
- var-first; lowercase; AppClock-safe; no server.sync.
*/

(
// 1) close any old "user display" windows
Window.allWindows.do({ |w|
    var nm = w.tryPerform(\name);
    if(nm.notNil and: { nm.asString == "user display" }) { w.close };
});

// 2) create the choices window
~userChoices = UserDisplay.new;  // has updateTextField(\state|\queue|\lastCommand|\choices, ...)

// 3) small fan-out adaptor so CommandManager can write to BOTH displays
~displayFan = (
    targets: [ ~system.statusDisplay, ~userChoices ],

    showExpectation: { |self, text, secs = 0|
        self.targets.do({ |t| t.tryPerform(\showExpectation, text, secs) });
    },

    updateTextField: { |self, box, msg|
        self.targets.do({ |t| t.tryPerform(\updateTextField, box, msg) });
    },

    updateStatus: { |self, text|
        self.targets.do({ |t| t.tryPerform(\updateStatus, text) });
    }
);

// 4) inject the fan-out into CommandManager
~system.commandManager.display = ~displayFan;

// 5) initial refresh (shows current state & choices)
~system.commandManager.updateDisplay;
"‚úÖ Choices window wired. Press D2=prog then play notes to see choices update.".postln;
)

===== temp files/TempGUIChoicesWindows.scd =====
// TempGUIChoicesWindows.scd
// MD 20250922-1653
(
// Floating "Choices" window (always-on-top, readable)
var titleColor = Color(0.12, 0.12, 0.12);
var textColor = Color(0.10, 0.10, 0.10);
var bgColor = Color(0.98, 0.98, 0.98, 0.98);

if(~choicesWin.notNil and: { ~choicesWin.isClosed.not }) { ~choicesWin.close };
~choicesWin = Window("Choices", Rect(30, 120, 380, 220))
    .alwaysOnTop_(true);
~choicesWin.view.background_(bgColor);

~choicesWin_title = StaticText(~choicesWin, Rect(8, 6, 364, 16))
    .string_("Choices")
    .stringColor_(titleColor);

~choicesWin_text = TextView(~choicesWin, Rect(8, 26, 364, 186))
    .string_("‚Äî")
    .editable_(false)
    .hasVerticalScroller_(true)
    .background_(bgColor)
    .stringColor_(textColor)
    .font_(Font("Menlo", 12));

~choicesSet = { |items|
    var s = (items ? []).collect(_.asString).join("\n");
    AppClock.sched(0.0, {
        if(~choicesWin_text.notNil) {
            ~choicesWin_text.string_((s.size > 0).if({ s }, { "‚Äî" }));
        };
        nil
    });
};

~choicesWin.front;
~choicesSet.([
    "fret 7 ‚Üí delay",
    "fret 9 ‚Üí tremolo",
    "fret 11 ‚Üí switch"
]);
"‚úÖ Floating Choices window ready (stop watcher: ~choicesWatcher.stop; close: ~choicesWin.close).".postln;
)

===== utilities/ControlLogVerbosity.scd =====
// ControlLogVerbosity.sc
// v1
// MD 20250923-0835

// error = 0
// warn = 1
// info = 2
// debug = 3
// trace = 4

MDMiniLogger.get.setverbosity(2);
===== utilities/DEMO20250923_FIXED.scd =====
// DEMO20250923_FIXED.scd
// v0.2.0
// MD 2025-09-23 10:46 BST

/* Purpose
 - Run the 2025-09-23 demo steps while updating MagicDisplayGUI at each step.
 - Uses ~nav_handleFret from the SimNav patch (Fix 1) so the GUI shows choices
   and "Apply ‚Üí ..." on leaf selections.
Style
 - var-first; AppClock-only; no server.sync; one MagicDisplayGUI window.
*/

(
var steps, gap, i, runStep, schedNext;

if(~system.isNil) { "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil };
if(~nav_handleFret.isNil) { "‚ö†Ô∏è Load SimNav_Bridge_ApplyLeafPayload_FIX.scd first".warn; ^nil };

// Your original script, now paced:
steps = [
    // Add delay ‚Üí /add/delay
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 1) }, // add
    { ~nav_handleFret.(4, 1) }, // delay (leaf ‚Üí applies)

    // Switch ‚Üí /switch
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 3) }, // switch (leaf ‚Üí applies)

    // Bypass delay ON
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 2) }, // bypass
    { ~nav_handleFret.(4, 1) }, // delay
    { ~nav_handleFret.(3, 2) }, // on (leaf)

    // Bypass delay OFF
    { ~nav_handleFret.(6,10) },
    { ~nav_handleFret.(5, 2) },
    { ~nav_handleFret.(4, 1) },
    { ~nav_handleFret.(3, 3) }, // off (leaf)

    // Set source testmelody ‚Üí /setSource/testmelody
    { ~nav_handleFret.(6,10) }, // commands
    { ~nav_handleFret.(5, 4) }, // setSource
    { ~nav_handleFret.(4, 1) }  // testmelody (leaf)
];

// pacing
gap = 0.55;
i = 0;
runStep = { steps[i].value; i = i + 1; if(i < steps.size) { schedNext.() } };
schedNext = { AppClock.sched(gap, { runStep.(); nil }) };

// kick off and ensure GUI is showing something
~nav_reset.();
AppClock.sched(0.0, { runStep.(); nil });
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay ‚Üí /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf ‚Üí applies)


//Switch ‚Üí /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf ‚Üí applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody ‚Üí /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Editor_AddCommands_Branch_Canonical.scd =====
// Editor_AddCommands_Branch_Canonical.scd
// v0.1.7
// MD 20250923-0956

(
/*
Purpose
- Ensure a minimal 'commands' branch exists in the canonical CommandTree JSON used by LivePedalboardSystem.
- Set each leaf's payload under 'commands' to a canonical path string ("/verb/arg/...").
- Uses only known-good methods; no caret returns; var-first at top-level.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPath, tree, ok, proceed;
var findChildByName, ensureChildUnder, ensurePath;
var commandsNode, printSampleLeaves, showFirstN;
var setCanonicalPayloads, buildPathsDown, buildPathFromSegments, rootCmd, count;

// ‚îÄ‚îÄ entry banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
"Editor_AddCommands_Branch_Canonical: ENTER".postln;

// ‚îÄ‚îÄ canonical JSON path (LivePedalboardSuite) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
jsonPath = Platform.userExtensionDir
  ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
("JSON path ‚Üí " ++ jsonPath).postln;

// ‚îÄ‚îÄ load tree ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPath);
("import ok ‚Üí " ++ ok).postln;
proceed = ok;

// ‚îÄ‚îÄ helpers (only stable fields/methods) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
findChildByName = { |parentNode, childName|
  var wanted, found;
  wanted = childName.asString;
  found = nil;
  parentNode.children.do({ |c|
    if(c.name.asString == wanted) { found = c };
  });
  found
};

ensureChildUnder = { |parentNode, childName, fretNumber|
  var existing, created, fret;
  fret = fretNumber ? 1;
  existing = findChildByName.(parentNode, childName);
  if(existing.notNil) {
    existing
  }{
    created = tree.addNode(parentNode.id, childName.asString, fret);
    if(created.isNil) { ("‚ö†Ô∏è addNode failed for " ++ childName).postln };
    created
  }
};

ensurePath = { |names, frets|
  var node, i, count, name, fret;
  node = tree.root;
  i = 0; count = names.size;
  while({ i < count }, {
    name = names[i];
    fret = frets[i] ? 1;
    node = ensureChildUnder.(node, name, fret);
    i = i + 1;
  });
  node
};

showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new;
  i = 0;
  while({ i < lim }, {
    out.add(listIn[i]);
    i = i + 1;
  });
  out.asArray
};

// ‚îÄ‚îÄ do the work only if load succeeded ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
if(proceed) {
  // 1) ensure 'commands' branch + minimal leaves (idempotent)
  ensurePath.( ["commands"], [10] );
  ensurePath.( ["commands","add","delay"],            [10,1,1] );
  ensurePath.( ["commands","bypass","delay","on"],    [10,2,1,2] );
  ensurePath.( ["commands","bypass","delay","off"],   [10,2,1,3] );
  ensurePath.( ["commands","switch"],                 [10,3] );
  ensurePath.( ["commands","setSource","testmelody"], [10,4,1] );

  // 2) normalize payloads and tag depths
  tree.assignPayloads;     // payload := name where missing
  tree.root.tagByDepth(0);

  // 2b) set canonical path strings for each 'commands' leaf ("/verb/arg/...")
  buildPathFromSegments = { |segs|
    var out, i, lim;
    out = "";
    i = 0; lim = segs.size;
    while({ i < lim }, {
      out = out ++ "/" ++ segs[i];
      i = i + 1;
    });
    out
  };

  setCanonicalPayloads = {
    rootCmd = findChildByName.(tree.root, "commands");
    if(rootCmd.isNil) {
      "‚ö†Ô∏è cannot set payloads: 'commands' missing.".postln;
    }{
      count = 0;
      buildPathsDown = { |node, segs|
        if(node.isLeaf) {
          node.payload = buildPathFromSegments.(segs);
          count = count + 1;
        }{
          node.children.do({ |child|
            var nextSegs;
            nextSegs = segs.copy;
            nextSegs.add(child.name.asString);
            buildPathsDown.(child, nextSegs);
          });
        }
      };
      // seed with immediate children of 'commands'
      rootCmd.children.do({ |child|
        buildPathsDown.(child, [child.name.asString]);
      });
      ("set canonical payloads on " ++ count ++ " leaf/leaves under 'commands'").postln;
    };
  };

  setCanonicalPayloads.();

  // 3) save back to the canonical file
  tree.exportJSONFile(jsonPath);
  ("‚úÖ Updated commands branch in ‚Üí " ++ jsonPath).postln;

  // 4) sample a few payloads under 'commands' (sanity)
  commandsNode = findChildByName.(tree.root, "commands");
  if(commandsNode.isNil) {
    "‚ö†Ô∏è 'commands' node not found after ensure-path (unexpected).".postln;
  }{
    printSampleLeaves = {
      var visit, payloads;
      payloads = List.new;
      visit = { |n|
        if(n.isLeaf) {
          payloads.add((n.payload ?? n.name).asString);
        }{
          n.children.do(visit);
        }
      };
      visit.(commandsNode);
      ("sample payloads: " ++ showFirstN.(payloads, 8).asString).postln;
    };
    printSampleLeaves.();
  };
}{
  ("‚ùå Failed to load " ++ jsonPath ++ " (no changes made)").postln;
};

// ‚îÄ‚îÄ exit banner ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"Editor_AddCommands_Branch_Canonical: EXIT".postln;
"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ".postln;
)

===== utilities/Fallback_Diag_OneShot.scd =====
//Fallback_Diag_OneShot_Verbose.scd
//v0.1.3
//MD 20250923-1523

// Purpose
// - Trace exactly where the fallback path stalls, using ONLY known-good SC constructs.
// - Sequence (with logs): /add/delay ‚Üí /switch ‚Üí /bypass/delay/on ‚Üí /bypass/delay/off ‚Üí /switch
// Style
// - var-first in EVERY block/closure; AppClock for GUI; Server.default.bind for Ndef ops;
// - no server.sync; generated audio only; zero SoundIn; no unknown Server selectors.

(
var logDiag, postKeyVals, describeEnv;
var serverReady, systemReady, pedalboardRef, guiRef;
var ensureGeneratedSources, tryEnsureAdapter, adapterAvailable;
var applyViaAdapter, applyDirectToPedalboard, applyOneCommand;
var runSequence, verifyEnd;

// ----- logger helpers (var-first) -----
logDiag = { |textString|
    var lineText;
    lineText = "[FDIAG] " ++ textString.asString;
    lineText.postln;
};

postKeyVals = { |labelString, dictLike|
    var keys, i, key, line;
    keys = dictLike.keys.asArray;
    (labelString.asString).postln;
    i = 0;
    while({ i < keys.size }, {
        key  = keys[i];
        line = "  " ++ key.asString ++ ": " ++ dictLike[key].asString;
        line.postln;
        i = i + 1;
    });
};

// ----- environment description (no unknown selectors) -----
describeEnv = {
    var s, sysOk, mpbOk, guiOk, env;
    s = Server.default;
    sysOk = (~system.notNil);
    mpbOk = sysOk and: { ~system.pedalboard.notNil };
    guiOk = sysOk and: { ~system.statusDisplay.notNil };
    env = (
        serverRunning: s.serverRunning,
        systemPresent: sysOk,
        pedalboardPresent: mpbOk,
        guiPresent: guiOk,
        adapterFnPresent: (~ct_applyOSCPathToMPB.notNil)
    );
    postKeyVals.("FDIAG: environment", env);
};

// ----- guards (no boot here; we only report) -----
logDiag.("ENTER (one-shot verbose).");
describeEnv.value;

serverReady = Server.default.serverRunning;
if(serverReady.not) {
    logDiag.("‚ö†Ô∏è Server not running. Please run Start/bring-up first; aborting diag.");
    ^nil;
};

systemReady = (~system.notNil) and: { ~system.pedalboard.notNil };
if(systemReady.not) {
    logDiag.("‚ö†Ô∏è ~system or ~system.pedalboard is nil. Run Start_LivePedalboardSystem.scd (Option B).");
    describeEnv.value;
    ^nil;
};

pedalboardRef = ~system.pedalboard;
guiRef        = ~system.statusDisplay;

// ----- 1) ensure generated sources/sinks exist (stereo) -----
ensureGeneratedSources = {
    var didDefine, defineAll;
    didDefine = false;
    logDiag.("ensureGeneratedSources: begin");
    defineAll = {
        var madeAny, needMelody, needSilent;
        madeAny     = false;
        needMelody  = Ndef(\testmelody).source.isNil;
        needSilent  = Ndef(\ts0).source.isNil;

        if(needMelody) {
            Ndef(\testmelody, {
                var trig, sequence, freq, env, pan;
                trig     = Impulse.kr(3.2);
                sequence = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                freq     = Demand.kr(trig, 0, sequence);
                env      = Decay2.kr(trig, 0.01, 0.35);
                pan      = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(freq) * env * 0.25, pan)
            });
            madeAny = true;
        };
        Ndef(\testmelody).ar(2);

        if(needSilent) {
            Ndef(\ts0, { Silent.ar(2) });
            madeAny = true;
        };
        Ndef(\ts0).ar(2);

        // keep sinks alive at audio rate (no source overwrite here)
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
        madeAny;
    };
    Server.default.bind({ didDefine = defineAll.value; });
    logDiag.("ensureGeneratedSources: createdAny=" ++ didDefine);

    if(pedalboardRef.respondsTo(\setSourceCurrent)) {
        pedalboardRef.setSourceCurrent(\testmelody);
        logDiag.("setSourceCurrent(\\testmelody) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.setSourceCurrent missing.");
    };
    if(pedalboardRef.respondsTo(\enforceExclusiveCurrentOptionA)) {
        pedalboardRef.enforceExclusiveCurrentOptionA(0.1);
        logDiag.("enforceExclusiveCurrentOptionA(0.1) applied.");
    }{
        logDiag.("‚ö†Ô∏è pedalboard.enforceExclusiveCurrentOptionA missing.");
    };
    logDiag.("ensureGeneratedSources: end");
};

// ----- 2) adapter detection (prefer adapter) -----
tryEnsureAdapter = {
    var haveAdapter, adapterPath, exists;
    haveAdapter = (~ct_applyOSCPathToMPB.notNil);
    logDiag.("adapter present at entry? " ++ haveAdapter);
    if(haveAdapter) { ^true };
    adapterPath = (Platform.userExtensionDir
        ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    exists = File.exists(adapterPath);
    postKeyVals.("FDIAG: adapter path check", (path: adapterPath, exists: exists));
    if(exists) {
        adapterPath.load;
        haveAdapter = (~ct_applyOSCPathToMPB.notNil);
        logDiag.("adapter loaded from disk ‚Üí present=" ++ haveAdapter);
        ^haveAdapter;
    }{
        logDiag.("adapter not found on disk; will use direct mapping.");
        ^false;
    };
};

adapterAvailable = tryEnsureAdapter.value;

// ----- 3) application modes (adapter vs direct), both verbose -----
applyViaAdapter = { |canonicalPath|
    var canShow;
    ("[FDIAG] applyViaAdapter ‚Üí " ++ canonicalPath).postln;
    ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, guiRef);
    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
};

applyDirectToPedalboard = { |canonicalPath|
    var segments, verb, effectKey, sourceKey, onOffStr, stateBool, canShow;
    segments = canonicalPath.asString.split($/).reject({ |s| s.size == 0 });
    if(segments.size == 0) {
        logDiag.("applyDirect: empty path?");
        ^nil;
    };
    verb = segments[0].asString;
    ("[FDIAG] applyDirect ‚Üí " ++ canonicalPath ++ " (verb=" ++ verb ++ ")").postln;

    switch(verb,
        "add", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\add) }) {
                effectKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.add(" ++ effectKey ++ ")").postln;
                pedalboardRef.add(effectKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.add missing.");
            };
        },
        "setSource", {
            if(segments.size >= 2 and: { pedalboardRef.respondsTo(\setSource) }) {
                sourceKey = segments[1].asSymbol;
                ("[FDIAG] pedalboard.setSource(" ++ sourceKey ++ ")").postln;
                pedalboardRef.setSource(sourceKey);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.setSource missing.");
            };
        },
        "switch", {
            if(pedalboardRef.respondsTo(\switchChain)) {
                "[FDIAG] pedalboard.switchChain(0.12)".postln;
                pedalboardRef.switchChain(0.12);
            }{
                logDiag.("‚ö†Ô∏è pedalboard.switchChain missing.");
            };
        },
        "bypass", {
            if(segments.size >= 3) {
                effectKey = segments[1].asSymbol;
                onOffStr  = segments[2].asString.toLower;
                stateBool = (onOffStr == "on") or: { onOffStr == "true" } or: { onOffStr == "1" };
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    ("[FDIAG] pedalboard.bypassCurrent(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                    pedalboardRef.bypassCurrent(effectKey, stateBool);
                }{
                    if(pedalboardRef.respondsTo(\bypass)) {
                        ("[FDIAG] pedalboard.bypass(" ++ effectKey ++ ", " ++ stateBool ++ ")").postln;
                        pedalboardRef.bypass(effectKey, stateBool);
                    }{
                        logDiag.("‚ö†Ô∏è pedalboard.bypass* missing.");
                    };
                };
            }{
                logDiag.("‚ö†Ô∏è bypass path too short: " ++ canonicalPath);
            };
        },
        {
            logDiag.("‚ö†Ô∏è verb not handled in direct mapping: " ++ verb);
        }
    );

    canShow = guiRef.notNil and: { guiRef.respondsTo(\showExpectation) };
    if(canShow) { guiRef.showExpectation("Sent: " ++ canonicalPath, 0) };
    if(~procHud_update.notNil) { ~procHud_update.() };
};

applyOneCommand = { |canonicalPath|
    var useAdapter;
    useAdapter = adapterAvailable;
    ("[FDIAG] applyOneCommand: " ++ canonicalPath ++ " (usingAdapter=" ++ useAdapter ++ ")").postln;
    if(useAdapter) { applyViaAdapter.value(canonicalPath) }{ applyDirectToPedalboard.value(canonicalPath) };
};

// ----- 4) sequencer with AppClock (each hop logged) -----
runSequence = {
    var seq, idx, total, gapSec, scheduleNext, stepOnce;
    seq    = [ "/add/delay", "/switch", "/bypass/delay/on", "/bypass/delay/off", "/switch" ];
    idx    = 0;
    total  = seq.size;
    gapSec = 0.60;

    logDiag.("sequence size=" ++ total ++ " gapSec=" ++ gapSec);

    stepOnce = {
        var pathNow;
        if(idx >= total) {
            logDiag.("sequence complete; scheduling verify ‚Ä¶");
            AppClock.sched(0.9, { verifyEnd.value; nil });
            ^nil;
        };
        pathNow = seq[idx];
        logDiag.("STEP " ++ (idx+1) ++ " / " ++ total ++ " ‚Üí " ++ pathNow);
        applyOneCommand.value(pathNow);
        idx = idx + 1;
        scheduleNext.value;
    };

    scheduleNext = {
        AppClock.sched(gapSec, {
            logDiag.("‚Ä¶ tick ‚Üí next step");
            stepOnce.value;
            nil
        });
    };

    AppClock.sched(0.0, {
        logDiag.("kickoff on AppClock");
        stepOnce.value;
        nil
    });
};

// ----- 5) final verify/summary -----
verifyEnd = {
    var aPlay, bPlay, havePrint;
    aPlay = Ndef(\chainA).isPlaying;
    bPlay = Ndef(\chainB).isPlaying;
    logDiag.("[PLAY] A=" ++ aPlay ++ " B=" ++ bPlay);
    havePrint = pedalboardRef.respondsTo(\printChains);
    if(havePrint) {
        logDiag.("pedalboard.printChains:");
        pedalboardRef.printChains;
    }{
        logDiag.("‚ö†Ô∏è pedalboard.printChains missing.");
    };
};

// ----- go -----
logDiag.("begin run");
ensureGeneratedSources.value;
adapterAvailable = tryEnsureAdapter.value; // log after sources too
logDiag.("adapterAvailable=" ++ adapterAvailable);
runSequence.value;
)

===== utilities/FallbackDemo_ManualSequence.scd =====
// FallbackDemo_ManualSequence
// v0.1.3
// MD 20250923

// Purpose:
// - Apply a fixed sequence of canonical commands to MagicPedalboardNew.
// - Uses AppClock for scheduling; no Routine or Task.
// - Follows Martin's SC style: var-first, descriptive names, no server.sync, AppClock-only GUI ops.

(


var canonicalCommands, commandIndex, commandDelay;
var applyCommand, runNextCommand;
var pedalboardRef, bypassState;

canonicalCommands = [
    "/add/delay",
    "/switch",
    "/bypass/delay/on",
    "/bypass/delay/off",
    "/switch"
];

commandIndex = 0;
commandDelay = 0.6;
pedalboardRef = if(~system.notNil) { ~system.pedalboard } { nil };

applyCommand = { |canonicalPath|
    ("[FallbackDemo] apply ‚Üí " ++ canonicalPath).postln;

    if(~ct_applyOSCPathToMPB.notNil) {
        ~ct_applyOSCPathToMPB.(canonicalPath, pedalboardRef, ~system.statusDisplay);
    } {
        if(pedalboardRef.isNil) {
            ("[FallbackDemo] pedalboard is nil; skipping " ++ canonicalPath).warn;
            nil;
        } {
            if(canonicalPath == "/add/delay") {
                if(pedalboardRef.respondsTo(\add)) {
                    pedalboardRef.add(\delay);
                };
            } {
            if(canonicalPath == "/switch") {
                if(pedalboardRef.respondsTo(\switchChain)) {
                    pedalboardRef.switchChain(0.12);
                };
            } {
            if(canonicalPath == "/bypass/delay/on") {
                bypassState = true;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
            if(canonicalPath == "/bypass/delay/off") {
                bypassState = false;
                if(pedalboardRef.respondsTo(\bypassCurrent)) {
                    pedalboardRef.bypassCurrent(\delay, bypassState);
                };
            } {
                ("[FallbackDemo] unhandled command: " ++ canonicalPath).warn;
            }}}};
        };
    };
};

runNextCommand = {
    if(commandIndex >= canonicalCommands.size) {
        ("[FallbackDemo] done.").postln;
        nil;
    } {
        applyCommand.(canonicalCommands[commandIndex]);
        commandIndex = commandIndex + 1;

        AppClock.sched(commandDelay, {
            runNextCommand.();
            nil;
        });
    };
};

runNextCommand.();
)

===== utilities/GUI_QuickFix_Choices_Contrast.scd =====
// GUI_QuickFix_Choices_Contrast.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   Improve legibility of the "Choices" panel immediately (runtime).
   Style: var-first; AppClock-only; no server.sync.
*/

(
var displayRef, choicesPanelView, choicesTitleView, choicesTextView, canDo;

displayRef = ~system ? nil;
if(displayRef.isNil or: { ~system.statusDisplay.isNil }) {
  "‚ö†Ô∏è No status display found; bring-up first.".warn; ^nil;
};
displayRef = ~system.statusDisplay;

displayRef.queueUi({
  choicesPanelView = displayRef.tryPerform(\choicesPanel);
  choicesTitleView = displayRef.tryPerform(\choicesTitle);
  choicesTextView  = displayRef.tryPerform(\choicesText);

  if(choicesPanelView.notNil and: { choicesPanelView.respondsTo(\background_) }) {
    choicesPanelView.background_(Color(0.12, 0.12, 0.12));
  };
  if(choicesTitleView.notNil and: { choicesTitleView.respondsTo(\stringColor_) }) {
    choicesTitleView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  if(choicesTextView.notNil and: { choicesTextView.respondsTo(\stringColor_) }) {
    choicesTextView.stringColor_(Color(0.92, 0.92, 0.92));
  };
  nil
});
)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "‚ùå Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "‚ùå Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Inspect_CommandTree_Under_Chain.scd =====
// Inspect_CommandTree_Under_Chain.scd
// v0.1.0
// MD 20250923--1255

/* Purpose
   Print child names (with frets) under "chain"; also prints under "add" if present.
   Helps confirm the live tree route to "delay".
   Style
   - var-first; descriptive variable names; no server.sync.
*/

(
var environmentReady, commandManager, commandTree, chainNode, addNode;
var listChildren, findChildByName;

environmentReady = (~system.notNil) and: { ~system.commandManager.notNil };
if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn; ^nil };

commandManager = ~system.commandManager;
commandTree    = commandManager.tree;

listChildren = { |nodeRef, labelText|
  var childrenArray, childLines;
  if(nodeRef.isNil) { ("[INSPECT] " ++ labelText ++ ": <nil>").postln; ^nil };
  childrenArray = nodeRef.children ? [];
  if(childrenArray.isEmpty) {
    ("[INSPECT] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[INSPECT] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil
};

findChildByName = { |parentNode, childNameString|
  if(parentNode.isNil) { ^nil };
  ^parentNode.getChildByName(childNameString.asString);
};

// 1) under "chain"
chainNode = commandTree.root.getChildByName("chain");
listChildren.(chainNode, "Children under [chain]");

// 2) under "chain ‚Üí add" (if present)
addNode = findChildByName.(chainNode, "add");
if(addNode.notNil) { listChildren.(addNode, "Children under [chain ‚Üí add]") };
)

===== utilities/Install_LightweightMeterPrinters.scd =====
// Install_LightweightMeterPrinters.scd
// v0.1
// MD 20250923-1556

/* Purpose
   Quiet console printers for '/ampA' and '/ampB' that print only non-zero-ish values.
*/

(
var threshold, freeIfExists;

threshold = 0.02;

freeIfExists = { |defName|
  var existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

freeIfExists.(\_meterA_dbg);
freeIfExists.(\_meterB_dbg);

OSCdef(\_meterA_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterA] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampA');

OSCdef(\_meterB_dbg, { |message|
  var leftVal = message[3].asFloat, rightVal = message[4].asFloat;
  if((leftVal > threshold) or: (rightVal > threshold)) {
    ("[meterB] [" ++ leftVal.asString ++ ", " ++ rightVal.asString ++ "]").postln;
  };
}, '/ampB');

"‚úÖ Lightweight printers installed (non-zero only).".postln;
)

===== utilities/Install_QueueExport_AdapterBridge.scd =====
// Install_QueueExport_AdapterBridge.scd
// v0.1
// MD 20250923-1456

/* Purpose
   Bridge CommandManager.queueExportCallback to your adapter (~ct_applyOSCPathToMPB),
   so queued SHORT canonical commands (e.g., "/add/delay") apply to MagicPedalboardNew.
   Tries to load the adapter if it isn't already in memory.

   Style
   - var-first; descriptive variable names; AppClock-only GUI; no server.sync.
*/

(
var environmentReady, commandManager, pedalboardRef, statusDisplayRef;
var adapterAvailable, candidatePaths, loadedPathString;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.pedalboard.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager    = ~system.commandManager;
pedalboardRef     = ~system.pedalboard;
statusDisplayRef  = ~system.statusDisplay;

// Ensure adapter is present
adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
if(adapterAvailable.not) {
  candidatePaths = [
    (Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath
  ];
  candidatePaths.do({ |fullPathString|
    if(adapterAvailable.not and: { File.exists(fullPathString) }) {
      fullPathString.load;
      adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
      if(adapterAvailable) { loadedPathString = fullPathString };
    };
  });
};

if(adapterAvailable.not) {
  "‚ùå Adapter not found. Cannot bridge queue -> MPB today.".warn;
  ^nil;
};

// Install the bridge
commandManager.queueExportCallback = { |canonicalPathString|
  ~ct_applyOSCPathToMPB.(canonicalPathString, pedalboardRef, statusDisplayRef);
};

("‚úÖ Adapter bridge active" ++ (loadedPathString.notNil.if({ " (loaded: " ++ loadedPathString ++ ")" }, { "" }))).postln;
"   Sending the queue will now apply each command via the adapter.".postln;
)

===== utilities/Install_QuietProxyMeters_Core.scd =====
// Install_QuietProxyMeters_Core.scd
// v0.1
// MD 20250923-1610

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) using .filter:
   - Low-rate sampling with Impulse.kr.
   - Threshold gate from UGens (no Boolean 'or:').
   - Sends '/ampA' '/ampB' only when above threshold.
   - No console prints by default.

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold;
var ensureProxyAudio, installOrReplaceTap, installForProxy;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyAudio = { |proxyName|
  Server.default.bind({
    Ndef(proxyName).ar(2); // ensure 2ch audio-rate proxy exists
  });
};

installOrReplaceTap = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampLeft, ampRight, ampMax, tick, gate;

      // robust channel fetch
      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0.0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // per-channel level followers
      ampLeft  = Amplitude.kr(leftIn, 0.01, 0.15);
      ampRight = Amplitude.kr(rightIn, 0.01, 0.15);
      ampMax   = ampLeft.max(ampRight);     // <- UGen-safe combine

      // low-rate tick and gate when above threshold (UGen compare)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (ampMax > postThreshold); // 0 or tick

      // emit values only when above threshold
      SendReply.kr(gate, oscPath, [ampLeft, ampRight]);

      // pass-through audio unchanged
      inSig
    });
  });
};

installForProxy = { |proxyName, oscPath|
  ensureProxyAudio.(proxyName);
  installOrReplaceTap.(proxyName, oscPath);
};

installForProxy.(\chainA, '/ampA');
installForProxy.(\chainB, '/ampB');

"‚úÖ Quiet proxy taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"‚úÖ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Meters_Diagnostic_Bootstrap_FIX.scd =====
// Meters_Diagnostic_Bootstrap_FIX.scd
// v0.1.1
// MD 20250923-1543

/* Purpose
   - Ensure bus meter SynthDefs exist (defines them via MagicDisplay.ensureMeterDefs(2) if needed).
   - Instantiate meter readers on Ndef(\chainA) and Ndef(\chainB) buses.
   - Install console debug printers for '/ampA' and '/ampB' using correct OSCdef.free pattern.

   Style
   - var-first; Server.default.bind for server ops; AppClock-safe UI; no server.sync.
*/

(
var serverRef, statusDisplayRef, chainABusIndex, chainBBusIndex, metersGroupId;
var ensureMeterDefsExist, installDebugPrinters, freeIfExists;

serverRef        = Server.default;
statusDisplayRef = (~system ? nil).notNil.if({ ~system.statusDisplay }, { nil });

ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ÑπÔ∏è Defining meter synths (busMeterA/busMeterB).".postln;
    MagicDisplay.ensureMeterDefs(2); // should be idempotent in your codebase
  };
};

freeIfExists = { |defName|
  var existingDef;
  existingDef = OSCdef(defName);
  if(existingDef.notNil) { existingDef.free };
};

installDebugPrinters = {
  // Avoid duplicates by
===== utilities/Meters_QuickCheck_And_Enable.scd =====
// Meters_QuickCheck_And_Enable.scd
// v0.1.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - Ensure meter SynthDefs exist (busMeterA/B).
   - Attach meter readers to Ndef(\chainA/\chainB) buses.
   - Print incoming values to console (quick sanity).
   - Re-enable GUI meters if the display supports it.

   Style
   - var-first; Server.default.bind for server ops; no server.sync.
*/

(
var serverRef, displayRef, chainABusIndex, chainBBusIndex, metersGroup;
var ensureMeterDefsExist, installConsolePrinters;

serverRef  = Server.default;
displayRef = ~system ? nil;

// --- helpers ---
ensureMeterDefsExist = {
  var hasA, hasB;
  hasA = SynthDescLib.global.at(\busMeterA).notNil;
  hasB = SynthDescLib.global.at(\busMeterB).notNil;
  if(hasA.not or: { hasB.not }) {
    "‚ö†Ô∏è Meter SynthDefs missing ‚Äî defining now via MagicDisplay.ensureMeterDefs(2)".postln;
  };
  MagicDisplay.ensureMeterDefs(2); // idempotent
};

installConsolePrinters = {
  // avoid duplicates
  OSCdef.remove(\_meterA_dbg);
  OSCdef.remove(\_meterB_dbg);
  OSCdef(\_meterA_dbg, { |oscMessage| ("[meterA] " ++ oscMessage[3..].asString).postln }, '/ampA');
  OSCdef(\_meterB_dbg, { |oscMessage| ("[meterB] " ++ oscMessage[3..].asString).postln }, '/ampB');
};

// --- server work ---
Server.default.bind({
  ensureMeterDefsExist.value;

  // ensure both chain proxies are realized at audio-rate
  Ndef(\chainA).ar(2);
  Ndef(\chainB).ar(2);
  chainABusIndex = Ndef(\chainA).bus.index;
  chainBBusIndex = Ndef(\chainB).bus.index;

  metersGroup = Group.head(serverRef.defaultGroup);

  // spawn readers (safe to re
===== utilities/MIDI_Input_Tests_20250922.scd =====
// MIDI_Input_Tests_20250922.scd
// Run these step by step

// STEP A ‚Äî canonical bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);   // nil -> class default tree path
    ~system.bringUpAll;
}.defer;
)


// STEP B ‚Äî Refresh and connect MIDI at the SC level (safe anytime)
(
MIDIClient.restart;     // re-scan devices (good after hot-plug)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)



// STEP C ‚Äî Inspect manager + the symbol names you can bind
(
var mi;

mi = ~system.commandManager.midiManager;

"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;   // prints "Symbol: \NAME  ‚Üí UID: 1234..."

"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;         // prints the connected devices it sees
)


// STEP D ‚Äî Bind nanoKEY2 and IAC "to SC" to handlers
(
var mi = ~system.commandManager.midiManager;

// nanoKEY2 -> FootController (so notes 36/38/40/41 switch idle/prog/queue/send)
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);

// IAC "to SC" -> Guitar handler (so notes become frets during PROG mode)
mi.bindDevice(\MD_IAC_to_SC, mi.guitarHandler);

// Show current bindings (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect { |k| mi.deviceUIDs[k] == srcID } ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)


// Option 1
MIDIdef.trace(true);   // start tracing all MIDI events
// Press a nanoKEY2 key (or send a note to IAC "to SC") ‚Äî you should see noteOn/off
// When done:
MIDIdef.trace(false);

// Option 2:
// Install once; re-evaluate if you hot-plug (it rebuilds the map)
(
var buildMap;
~midiLog_srcFilter = nil;  // e.g. set to \nanoKEY2_KEYBOARD to filter (optional)
~midiLog_chanFilter = nil; // e.g. set to 1 to filter (optional)
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name)
            .replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%"
                .format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%"
                .format(sym, chan, num, val)).postln;
        };
    };
});

// quick refresh if you hot-plug:
~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

// stop logger if needed:
~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k| MIDIdef(k).free };
    "[MIDI-LOG] stopped".postln;
};

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)


===== utilities/MIDI_Input_Tests2_20250922.scd =====
//MIDI_Input_Tests2_20250922.scd

// 0) Bring-up (Option B: default path)
(
{
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    ~system = LivePedalboardSystem.new(nil);
    ~system.bringUpAll;
}.defer;
)


// 1) Refresh MIDI in SC and connect all sources
(
MIDIClient.restart;     // re-scan devices (safe after hot-plugging)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };

"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ SC MIDI inputs refreshed & connected.".postln;
)


// 2) See the symbols your app uses and their UIDs
(
var mi = ~system.commandManager.midiManager;
"‚Äî‚Äî Device symbols ‚Üí UIDs (from MIDIInputManager) ‚Äî‚Äî".postln;
mi.listDeviceSymbols;
"‚Äî‚Äî Pretty device listing ‚Äî‚Äî".postln;
mi.listDevices;
)


// 3) Bind nanoKEY2 -> FootController; IAC 'to SC' -> Guitar
(
var mi = ~system.commandManager.midiManager;
mi.bindDevice(\nanoKEY2_KEYBOARD, mi.footControllerHandler);
mi.bindDevice(\MD_IAC_to_SC,      mi.guitarHandler);

// Print bound table (srcID ‚Üí symbol ‚Üí handler)
"‚Äî‚Äî Bound handlers (srcID ‚Üí symbol ‚Üí handler) ‚Äî‚Äî".postln;
mi.deviceHandlers.keysValuesDo { |srcID, handler|
    var sym = mi.deviceUIDs.keys.detect({ |k| mi.deviceUIDs[k] == srcID }) ? \UNKNOWN;
    ("  " ++ srcID ++ "  ‚Üí  " ++ sym ++ "  ‚Üí  " ++ handler.class.name).postln;
};
)

MIDIdef.trace(true);   // enable global trace
// press keys on nanoKEY2 or send notes to IAC "to SC"
MIDIdef.trace(false);

// 4B) Install raw taps (noteOn/noteOff/cc)
(
var mkLabel, fns;

mkLabel = { |src|
    var ep = MIDIClient.sources.detect({ |e| e.uid == src });
    if(ep.notNil) { (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_") } { "uid:" ++ src }
};

~midiTap_remove.(); // remove any previous tap safely (defined below)

// keep references so we can remove cleanly
~midiTap_fns = IdentityDictionary[
    \noteOn  -> MIDIIn.addFuncTo(\noteOn,  { |src, chan, num, vel| ("[RAW] noteOn  src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \noteOff -> MIDIIn.addFuncTo(\noteOff, { |src, chan, num, vel| ("[RAW] noteOff src=%  ch=%  num=%  vel=%".format(mkLabel.(src), chan, num, vel)).postln; }),
    \control -> MIDIIn.addFuncTo(\control, { |src, chan, num, val| ("[RAW] cc     src=%  ch=%  num=%  val=%".format(mkLabel.(src), chan, num, val)).postln; })
];

~midiTap_remove = {
    if(~midiTap_fns.notNil) {
        ~midiTap_fns.keysValuesDo { |k, fn| if(fn.notNil) { MIDIIn.removeFuncFrom(k, fn) } };
        ~midiTap_fns = nil;
        "[RAW] taps removed".postln;
    } {
        // noop
    };
};

"[RAW] taps installed ‚Äî press nanoKEY2 or send to IAC".postln;
)


// 4C) Minimal logger (noteOn/off & CC), with map refresh helper
(
var buildMap;
~midiLog_srcFilter = nil;
~midiLog_chanFilter = nil;
~midiLog_sources   = Dictionary.new;

buildMap = {
    MIDIClient.init;
    ~midiLog_sources = Dictionary.new;
    MIDIClient.sources.do { |ep|
        var sym = (ep.device ++ "_" ++ ep.name).replace(" ","_").replace("-","_").asSymbol;
        ~midiLog_sources[ep.uid] = sym;
    };
    "[MIDI-LOG] map built".postln;
};

~midiLog_refresh = {
    MIDIClient.restart; MIDIIn.disconnectAll; MIDIIn.connectAll;
    buildMap.value; "[MIDI-LOG] refreshed".postln;
};

~midiLog_stop = {
    [\mdLog_noteOn,\mdLog_noteOff,\mdLog_cc].do { |k|
        var def = MIDIdef(k);
        if(def.notNil) { def.free };
    };
    "[MIDI-LOG] stopped".postln;
};

buildMap.value;

MIDIdef.noteOn(\mdLog_noteOn, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOn  src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] noteOff src=%  ch=%  num=%  vel=%".format(sym, chan, num, vel)).postln;
        };
    };
});
MIDIdef.cc(\mdLog_cc, { |val, num, chan, src|
    var sym = ~midiLog_sources[src] ? ("uid:" ++ src);
    if(~midiLog_srcFilter.isNil or: { sym == ~midiLog_srcFilter }) {
        if(~midiLog_chanFilter.isNil or: { chan == ~midiLog_chanFilter }) {
            ("[MIDI] cc     src=%  ch=%  num=%  val=%".format(sym, chan, num, val)).postln;
        };
    };
});

"[MIDI-LOG] ACTIVE ‚Äî press nanoKEY2 or send to IAC".postln;
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "üîé [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"‚úÖ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "üõë [MIDI-LOG] stopped.".postln;
};
)

===== utilities/MIDI_Log_RefreshAndConnect.scd =====
// MIDI_Log_RefreshAndConnect.scd
// v0.1.0
// MD 20250922-1422

/*
Purpose
- If you plugged devices while SC was running, restart the MIDI client,
  reconnect all inputs, and refresh the logger's source map.
- Also clears any logger filters so you see everything.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

(
var announce;

announce = { |title| ("[MIDI-LOG] " ++ title).postln };

MIDIClient.restart;           // re-scan devices (idempotent & safe)
MIDIIn.disconnectAll;
MIDIIn.connectAll;

~midiLog_srcFilter = nil;     // show all sources
~midiLog_chanFilter = nil;    // show all channels

if(~midiLog_refresh.isKindOf(Function)) {
    ~midiLog_refresh.();      // rebuild the uid->label map used by the logger
    announce.("sources remapped.");
} {
    announce.("note: logger not installed yet; run MIDI_Log_Console.scd first.");
};

// quick device listing
"MIDI Sources:".postln;
MIDIClient.sources.do { |ep| ("  " ++ ep.asString).postln };
"MIDI Destinations:".postln;
MIDIClient.destinations.do { |ep| ("  " ++ ep.asString).postln };
"‚úÖ [MIDI-LOG] refresh complete ‚Äî play/send something to see messages.".postln;
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "‚ö†Ô∏è Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "üßπ Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("üì• Command added: " ++ canonicalPathString).postln;
("üì¶ Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Report_ChainPlayFlags.scd =====
// Report_ChainPlayFlags.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Print whether Ndef(\chainA) and Ndef(\chainB) are playing.
   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var isChainAPlaying, isChainBPlaying;

isChainAPlaying = Ndef(\chainA).isPlaying;
isChainBPlaying = Ndef(\chainB).isPlaying;

("[PLAY] chainA=" ++ isChainAPlaying ++ "  chainB=" ++ isChainBPlaying).postln;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd =====
// SimNav_Bridge_ApplyLeafPayload_CommandsOnly.scd
// v0.1.2
// MD 20250923-1040

(
/*
Purpose
- Drive the "commands" branch using (string, fret) without relying on MDCommandBuilder.navigateToChild.
- When a leaf is reached, apply its canonical payload "/verb/arg/..." via the adapter.

Style
- var-first; lowercase; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed;
var currentNode, rootNode;
var findChildByName, buildPathFromSegments, applyPayloadPath, ensureAdapterOk;
var mapAtRoot, mapAtCommands, mapAtAdd, mapAtBypassLevel1, mapAtBypassLevel2, mapAtSetSource;
var handleFret, resetNav;

// --- preconditions -----------------------------------------------------------
proceed = true;
if(~system.isNil) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".postln;
    proceed = false;
};

// adapter presence (known-good, absolute locations)
if(~ct_applyOSCPathToMPB.isNil) {
    var candidates, i, p;
    candidates = List[
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
        Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
        p = candidates[i].standardizePath;
        if(File.exists(p)) { p.load };
        i = i + 1;
    });
};
ensureAdapterOk = (~ct_applyOSCPathToMPB.notNil);
if(ensureAdapterOk.not) {
    "‚ö†Ô∏è Adapter missing; evaluate adapter_* file".postln;
    proceed = false;
};

// load the canonical CommandTree JSON (same as your tests/editor)
if(proceed) {
    jsonPath = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    tree = MDCommandTree.new("root");
    ok = tree.importJSONFile(jsonPath);
    ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
    proceed = ok;
};

if(proceed) {

    // --- helpers -------------------------------------------------------------
    findChildByName = { |parentNode, childName|
        var wanted, found;
        wanted = childName.asString; found = nil;
        parentNode.children.do({ |c| if(c.name.asString == wanted) { found = c } });
        found
    };

    buildPathFromSegments = { |segmentsArray|
        var out, i, lim;
        out = ""; i = 0; lim = segmentsArray.size;
        while({ i < lim }, { out = out ++ "/" ++ segmentsArray[i]; i = i + 1 });
        out
    };

    applyPayloadPath = { |payloadString|
        var pedalboardRef, guiRef, pathText;
        pedalboardRef = ~system.pedalboard;
        guiRef = ~system.statusDisplay;
        pathText = payloadString.asString;
        ("[BRIDGE] apply ‚Üí " ++ pathText).postln;
        ~ct_applyOSCPathToMPB.(pathText, pedalboardRef, guiRef);
    };

    resetNav = {
        currentNode = tree.root;
        "[BRIDGE] nav reset".postln;
    };

    // --- routing tables for (string, fret) ‚Üí child.name ----------------------
    // Note: you created these frets in the editor script we just ran.
    mapAtRoot = { |stringNum, fretNum|
        if(stringNum == 6 and: { fretNum == 10 }) { "commands" } { nil }
    };

    mapAtCommands = { |stringNum, fretNum|
        // depth 1 under "commands": string 5
        if(stringNum != 5) { nil } {
            if(fretNum == 1) { "add" }
            { if(fretNum == 2) { "bypass" }
            { if(fretNum == 3) { "switch" }
            { if(fretNum == 4) { "setSource" } { nil }}}}
        }
    };

    mapAtAdd = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel1 = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "delay" } { nil }
    };

    mapAtBypassLevel2 = { |stringNum, fretNum|
        // string 3 (after selecting "delay")
        if(stringNum == 3) {
            if(fretNum == 2) { "on" } { if(fretNum == 3) { "off" } { nil } }
        } { nil }
    };

    mapAtSetSource = { |stringNum, fretNum|
        // string 4
        if(stringNum == 4 and: { fretNum == 1 }) { "testmelody" } { nil }
    };

    // --- main entry: called per (string, fret) --------------------------------
    handleFret = { |stringNum, fretNum|
        var parentName, childName, childNode, payloadText;

        parentName = currentNode.name.asString;

        // decide next child name by context
        if(parentName == "root") {
            childName = mapAtRoot.(stringNum, fretNum);
        }{
            if(parentName == "commands") {
                childName = mapAtCommands.(stringNum, fretNum);
            }{
                if(parentName == "add") {
                    childName = mapAtAdd.(stringNum, fretNum);
                }{
                    if(parentName == "bypass") {
                        childName = mapAtBypassLevel1.(stringNum, fretNum);
                    }{
                        if(parentName == "delay") {
                            // only valid when parent is "bypass" ‚Üí "delay"
                            childName = mapAtBypassLevel2.(stringNum, fretNum);
                        }{
                            if(parentName == "setSource") {
                                childName = mapAtSetSource.(stringNum, fretNum);
                            }{
                                childName = nil; // unknown context
                            };
                        };
                    };
                };
            };
        };

        if(childName.isNil) {
            ("[BRIDGE] no child for (" ++ stringNum ++ "," ++ fretNum
             ++ ") under '" ++ parentName ++ "'").postln;
        }{
            childNode = findChildByName.(currentNode, childName);
            if(childNode.isNil) {
                ("[BRIDGE] child '" ++ childName ++ "' not found under '" ++ parentName ++ "'").postln;
            }{
                currentNode = childNode;
                ("[BRIDGE] ‚Üí " ++ currentNode.name.asString).postln;

                if(currentNode.isLeaf) {
                    // prefer the canonical payload string written by the editor; if missing, derive
                    if(currentNode.payload.notNil) {
                        payloadText = currentNode.payload.asString;
                    }{
                        // derive path from names (after "commands")
                        var segments, walker, at, stop, segsOut;
                        segments = List.new; at = currentNode; stop = false;
                        // if your node lacks .parent, you can skip this; we set payloads already
                        // here we just fallback to "/verb/arg/..." builder if payload is missing
                        segsOut = [ currentNode.name.asString ];
                        payloadText = buildPathFromSegments.(segsOut);
                    };
                    applyPayloadPath.(payloadText);
                    resetNav.(); // ready for next gesture
                }{
                    // not a leaf ‚Äî print children so you see next choices
                    var names;
                    names = List.new;
                    currentNode.children.do({ |c| names.add(c.name.asString) });
                    ("[BRIDGE] choices: " ++ names.asString).postln;
                };
            };
        };
    };

    // publish API
    ~nav_reset = resetNav;
    ~nav_handleFret = handleFret;

    // init state
    rootNode = tree.root;
    resetNav.();
    "[BRIDGE] commands-only router ready (string/fret)".postln;
};
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager‚Äôs builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X ‚Üí Name" lines for the GUI‚Äôs Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " ‚Üí " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI‚Äôs expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager‚Äôs builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply ‚Üí " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready ‚Äî use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply ‚Üí " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "‚ö†Ô∏è Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "‚ö†Ô∏è Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok ‚Üí " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready ‚Äî call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long ‚Üí short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long ‚Üí short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain ‚Üí add ‚Üí delay        (preferred if present)
       (b) chain ‚Üí add ‚Üí timebased ‚Üí delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "‚ö†Ô∏è Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  ‚Ä¢ " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("‚ùå navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> ‚Üí /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> ‚Üí /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path‚Üí " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) ‚Üí still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

===== utilities/Test_MagicPedalboard_MIDI_Simulation.scd =====
// Test_MagicPedalboard_MIDI_Simulation.scd
// v0.1.1
// MD 20250922-18-15

/*
Purpose
- Simulate MIDI input sequences for MagicPedalboard system testing.
- Each test step is labeled and commented with expected GUI/behavior.
- Allows repeatable, device-free testing and can be bundled with the suite.

Style
- var-first; lowercase; AppClock-only; no server.sync; clear comments.
*/

// --- Device UIDs: update these to match your system ---
var nanoUID = 302172822;    // nanoKEY2_KEYBOARD
var iacUID  = 1339807908;   // MD_IAC_to_SC

// --- Helper: fire a sequence of steps ---
~fireMidiSequence = { |steps|
    Routine({
        steps.do { |step|
            var src, chan, note, vel, dur, comment;
            src = step[0]; chan = step[1]; note = step[2];
            vel = step[3]; dur = step[4]; comment = step[5];
            ("[TEST] " ++ comment).postln;
            MIDIIn.doNoteOnAction(src, chan, note, vel);
            (dur ? 0.5).wait;
            MIDIIn.doNoteOffAction(src, chan, note, 0);
            0.1.wait;
        }
    }).play(AppClock);
};

// --- Test Sequence 1: Add Delay and Send ---
~test_add_delay = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 41, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /add"],
    [iacUID,  1, 45, 100, 0.5, "Step 3: IAC string 5 ‚Üí select /delay"],
    [nanoUID, 0, 40, 100, 0.5, "Step 4: nanoKEY2 E2 ‚Üí queue path"],
    [nanoUID, 0, 41, 100, 0.5, "Step 5: nanoKEY2 F2 ‚Üí send path"]
];

// --- Test Sequence 2: Switch Chain ---
/*~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"],
    [iacUID,  0, 48, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"],
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]
];*/
~test_switch_chain = [
    [nanoUID, 0, 38, 100, 0.5, "Step 1: nanoKEY2 D2 ‚Üí enter PROG mode"], // enter prog mode
    [iacUID,  0, 43, 100, 0.5, "Step 2: IAC string 6 ‚Üí select /switch"], // pitch 43 = base 40 + fret 3
    [nanoUID, 0, 40, 100, 0.5, "Step 3: nanoKEY2 E2 ‚Üí queue /switch"],   // queue
    [nanoUID, 0, 41, 100, 0.5, "Step 4: nanoKEY2 F2 ‚Üí send /switch"]     // send
];



// --- To run a test sequence ---
~fireMidiSequence.(~test_add_delay);
// ~fireMidiSequence.(~test_switch_chain); // ‚Üê uncomment to run this one

// --- Add more sequences below as needed ---

===== utilities/Verify_Baseline_CurrentAudible_NextSilent.scd =====
// Verify_Baseline_CurrentAudible_NextSilent.scd
// v0.1.0
// MD 20250923-1032

(
/* Purpose
   - Verify that CURRENT‚Äôs sink is the audible one and NEXT‚Äôs sink is silent (Option A).
   - Posts a clear PASS/FAIL with details.

   Style
   - var-first; lowercase; no server.sync; .scd-safe (no caret).
*/

var systemReady, pedalboardRef;
var currentSinkSymbol, nextSinkSymbol;
var isChainAPlaying, isChainBPlaying;
var currentIsAudible, nextIsSilent;
var summaryText;

// guards
systemReady = ~system.notNil;
if(systemReady.not) {
    "‚ö†Ô∏è ~system is nil. Run Start_LivePedalboardSystem.scd (Option B) first.".postln;
};

// proceed only if ready
if(systemReady) {
    pedalboardRef = ~system.pedalboard;

    // sink symbols at the heads of CURRENT/NEXT
    currentSinkSymbol = pedalboardRef.effectiveCurrent[0];  // \chainA or \chainB
    nextSinkSymbol    = pedalboardRef.effectiveNext[0];     // \chainB or \chainA

    // live flags (do not change any routing)
    isChainAPlaying = Ndef(\chainA).isPlaying;
    isChainBPlaying = Ndef(\chainB).isPlaying;

    // interpret flags relative to CURRENT/NEXT
    currentIsAudible =
        ((currentSinkSymbol == \chainA) and: { isChainAPlaying })
        or: { (currentSinkSymbol == \chainB) and: { isChainBPlaying } };

    nextIsSilent =
        ((nextSinkSymbol == \chainA) and: { isChainAPlaying.not })
        or: { (nextSinkSymbol == \chainB) and: { isChainBPlaying.not } };

    if(currentIsAudible and: { nextIsSilent }) {
        "‚úÖ Baseline OK: CURRENT is audible; NEXT is silent.".postln;
    }{
        summaryText =
            "‚ö†Ô∏è Baseline mismatch ‚Äî "
            ++ "CURRENT=" ++ currentSinkSymbol.asString
            ++ " NEXT=" ++ nextSinkSymbol.asString
            ++ " | chainA=" ++ isChainAPlaying
            ++ " chainB=" ++ isChainBPlaying;
        summaryText.postln;
    };
};
)

