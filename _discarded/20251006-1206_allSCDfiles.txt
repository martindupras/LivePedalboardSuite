===== _archived/RunBook_20251002.scd =====
// RunBook.scd
// MD
// 20251002-1157

/*
--- > RUN BLOCK BY BLOCK! <--
*/

//////////////////////////////
// 0) Clean up (safe preflight)

(
// Close LPDisplay / MagicDisplay windows
Window.allWindows
 .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
        or: { w.tryPerform(\name) == "Layout Test" } })
 .do(_.close);

// Free OSCdefs used by the LPDisplay demo (if present)
[ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ].do { |k|
    var d = OSCdef(k); if(d.notNil) { d.free };
};

// Stop the LPDisplay demo Ndefs if they exist
[ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ].do { |sym|
    var nd = Ndef(sym); if(nd.notNil) { nd.stop };
};
"Cleanup done.".postln;
)


//////////////////////////////
// 1) Open LPDisplay window (silence its internal demo sources)
(
// Controller (instance with setSourceA/B) and GUI window
~inst = LPDisplayLayoutTestWindow.new(nil);  // pass a HUD object if you prefer; nil = raw meters
~win  = ~inst.open;                          // -> a Window titled "Layout Test"

// Silence the LPDisplay demo sources so the meters don't show its noise/tone
~inst.setSourceA(\srcZ);
~inst.setSourceB(\srcZ);

// If you added the console gate previously:
try { ~inst.setConsoleLevelsOn(false) } { };  // optional: keep console quiet

// Ready check
[ ~inst.notNil, ~win.notNil, ~win.class ].postln;
)

//////////////////////////////
// 2) Bring up LivePedalboardSystem (headless UI)
(
~system = LivePedalboardSystem.new(nil);
~system.ensureServerReady;
~system.bringUpPedalboard;      // MagicPedalboardNew
~system.bringUpCommandSystem;   // CommandManager + MIDI
~system.installAdapterBridge;   // routes '/add/delay', '/switch', etc. to MPB
"OK: LPS up (headless UI).".postln;

// Sanity
[ ~system.notNil, ~system.pedalboard.notNil, ~system.commandManager.notNil ].postln;
)

//////////////////////////////
// 3) Confirm core objects and callback exist
(
~cm = ~system.commandManager;
~mm = ~cm.midiManager;
[ ~system.notNil, ~cm.notNil, ~mm.notNil, (~cm.queueExportCallback.notNil) ].postln;
)


//////////////////////////////
//4) Load the emulator helpers (block [1] in the emulator file)

/*
Open Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd and evaluate the parenthesized block under [1] Emulation helpers.
That block defines: ~fc, ~toProg, ~toQueue, ~toSend, ~gm, ~nav, ~showNav, etc.
*/
//verify helps exist:
[ ~toProg.isKindOf(Function), ~nav.isKindOf(Function), ~toQueue.isKindOf(Function), ~toSend.isKindOf(Function) ].postln;
// Expect: [ true, true, true, true ]


//////////////////////////////
//5) Scenario A — Add Delay (navigate → queue → send)
(
~toProg.();           // enter navigation mode
~nav.(6, 1);          // "audio"
~nav.(5, 5);          // "timebased"
~nav.(4, 3);          // "delay"
~showNav.();          // optional: prints long/canonical path
~toQueue.();          // queue canonical (e.g. "/add/delay")
~toSend.();           // send via adapter -> MagicPedalboardNew
)

//////////////////////////////
//6) Scenario B — Switch chains
(
~toProg.();
~nav.(6, 5);          // "switch"
~showNav.();
~toQueue.();
~toSend.();
)


//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//

//////////////////////////////
//
===== _broken/StartHere_LivePedalboardSuite_Standalone.scd =====
// StartHere_LivePedalboardSuite_Standalone.scd
// v0.1.0
// MD 20250928-1641

/*
Purpose
- Canonical bring-up for MagicDisplayGUI_AB with PerfHUD and taps.
- Works for both simulation and hardware (via testmelody feed).
- Returns -> a Window.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
- AppClock only inside called files; loud banners; returns -> a Window.
*/


(
var guiWindow, levelSubscriber, tapRoutine, audioSynth, expectedRms, leftRms, rightRms;

// ===[ STOP ALL DIAGNOSTICS ]===
OSCdef.all.do(_.free);
~md_levelsById = nil;

// ===[ CREATE GUI WINDOW ]===
guiWindow = Window("MagicDisplayGUI_AB", Rect(100, 100, 600, 400));
guiWindow.front;

// ===[ START LEVEL SUBSCRIBER ]===
levelSubscriber = OSCdef.new(
    key: \md_levels_sub,
    func: { |msg|
        var replyId, leftLevel, rightLevel;
        replyId = msg[1];
        leftLevel = msg[2];
        rightLevel = msg[3];
        ~md_levelsById = ~md_levelsById ?? ();
        ~md_levelsById[replyId] = [leftLevel, rightLevel];
    },
    path: "/md/levels"
);

// ===[ CLEAR ALL TAPS ]===
Ndef.clear;
SynthDef.removeAll;

// ===[ RUN PHASE C AUDIO FIX TAPS ]===
SynthDef.new("testmelody_sine", {
    arg frequency = 220, amplitude = 0.2;
    var signal;
    signal = SinOsc.ar(frequency, 0, amplitude);
    Out.ar(0, [signal, signal]);
}).add;

audioSynth = Synth("testmelody_sine");

expectedRms = 0.1414;

tapRoutine = Routine({
    60.do {
        leftRms = amplitudeToRMS(0.2);
        rightRms = amplitudeToRMS(0.2);
        OSCFunc.sendMsg("/md/levels", 2001, leftRms, rightRms);
        ("A_meas (L,R)=(" ++ leftRms.round(0.001) ++ "," ++ rightRms.round(0.001) ++ ")  vs expected_RMS≈" ++ expectedRms).postln;
        0.2.wait;
    };
}).play(AppClock);

guiWindow
)

===== _discarded/turnintooneplease.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"✅ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW — ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD’s window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ——— bring-up sequence ———

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your “-> a Window” acceptance pattern
windowRef
)
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd → -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB→0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/Meter_Calibration_Saw_100Hz.scd =====
// Meter_Calibration_Saw_100Hz.scd
// v1.2 - remove .stretch_ (unsupported), align tick strip & meter; 6 dB ticks; 0 dBFS marked
// MD 20251001

/* Purpose
   - Single Ndef playing a 100 Hz saw at selectable peak dBFS: 0, -6, -12, -18, -20, -60, -128.
   - LevelIndicator shows RMS via SendPeakRMS; a tick strip shows 6 dB marks with 0 dBFS highlighted.
   - Clean layout: tick strip and meter share identical height and align perfectly.

   Style
   - var-first declarations in every block/function
   - lowercase method names, descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var window, paneColor, meter, tickView, labelRms, labelInfo, layout, controlsRow;
var ndefName, oscNameGui, oscNameConsole;

var ampMenu, ampDbChoices, currentAmpDb;
var setAmpDb, ampToRmsDbSaw;

var topDb, floorDb, gamma, mapLinToUi, mapDbToUi, valueFromMsg;

var rebuildNdef, bindOsc, unbindOsc, updateUiLabels;

var meterHeight, tickWidth;

// ------------- constants for alignment -------------
meterHeight = 220;  // exact shared height for tick strip & meter
tickWidth   = 72;   // width for tick area (room for labels)

// ------------- UI bring-up -------------
Window.allWindows.do({ |w| if(w.name == "Meter Calibration Demo", { w.close }) });

window = Window("Meter Calibration Demo", Rect(160, 160, 540, 340))
    .background_(Color.white)
    .front;

paneColor = Color(0.10, 0.30, 0.10);

// ------------- Mapping (linear RMS -> UI) -------------
topDb   = 0.0;     // UI=1 at 0 dBFS RMS
floorDb = -120.0;  // UI=0 at -120 dBFS RMS
gamma   = 1.0;     // 1.0 = straight mapping in dB

mapLinToUi = { |lin, top, floor, g|
    var v, vdb, u;
    v   = lin.max(1e-9);        // avoid -inf
    vdb = v.ampdb;              // lin -> dB
    vdb = vdb.clip(floor, top);
    u   = (vdb - floor) / (top - floor);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

mapDbToUi = { |db, top, floor, g|
    var vlin, u;
    vlin = db.dbamp.clip(1e-9, 1.0);
    u = mapLinToUi.(vlin, top, floor, g);
    u
};

// ------------- Test source config -------------
ndefName       = \calSaw;
oscNameGui     = \calSaw_toGUI;
oscNameConsole = \calSaw_console;

ampDbChoices = [0, -6, -12, -18, -20, -60, -128];
currentAmpDb = -12;  // default on bring-up

ampToRmsDbSaw = { |peakDb|
    var peakLin, rmsLin, rmsDb;
    peakLin = peakDb.dbamp;        // peak amplitude as linear
    rmsLin  = peakLin / sqrt(3);   // RMS of a symmetric saw
    rmsDb   = rmsLin.ampdb;
    rmsDb
};

rebuildNdef = {
    var freqDefault;
    freqDefault = 100;
    Ndef(ndefName, {
        var amp, freq, sig;
        amp  = \amp.kr(currentAmpDb.dbamp).clip(0.0, 1.0);
        freq = \freq.kr(freqDefault).max(10);
        sig  = Saw.ar([freq, freq]) * amp;   // band-limited saw, stereo
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsDemo', 1);  // 20 Hz GUI updates
        sig
    });
    Ndef(ndefName).play(numChannels: 2);
};

valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };  // take final RMS element
    };
    v.clip(0.0, 1.0)
};

// ------------- GUI controls (top row) -------------
ampMenu = PopUpMenu()
    .items_(ampDbChoices.collect({ |db| (db.asString ++ " dBFS (peak)") }))
    .background_(Color(0.92, 0.98, 0.92))
    .action_({ |menu|
        var idx, db;
        idx = menu.value;
        db  = ampDbChoices.wrapAt(idx);
        setAmpDb.(db);
    });

labelRms  = StaticText().string_("RMS: (waiting)").align_(\left);
labelInfo = StaticText().string_("info").align_(\left).stringColor_(Color.gray(0.35));

controlsRow = HLayout(
    StaticText().string_("Amplitude:").stringColor_(Color.black),
    ampMenu,                 // no .stretch_; we control spacing with explicit spacers
    UserView().minSize_(Size(12, 0)),  // spacer
    nil
);

// Meter + ticks (side-by-side, identical heights)
meter = LevelIndicator()
    .fixedWidth_(30)
    .fixedHeight_(meterHeight)    // keep height exactly in sync with tick strip
    .warning_(0.50)
    .critical_(0.80);

tickView = UserView()
    .minSize_(Size(tickWidth, meterHeight))
    .maxSize_(Size(tickWidth, meterHeight))
    .background_(Color.white);

// Whole layout
layout = VLayout(
    UserView().minSize_(Size(0, 8)),  // spacer
    controlsRow,
    UserView().minSize_(Size(0, 6)),
    HLayout(
        tickView,                         // left: tick strip (draws header inside)
        UserView().minSize_(Size(8, 0)),  // spacer between tick and meter
        meter,
        UserView().minSize_(Size(12, 0)),
        VLayout(
            labelRms,
            UserView().minSize_(Size(6, 6)),
            labelInfo
        ).margins_(2)
    ).margins_(8)
).margins_(8);

window.layout = layout;

// ------------- Tick drawing (inside the fixed-height tickView) -------------
tickView.drawFunc_({ |v|
    var ctx, w, h, leftPad, rightPad, tickLong, tickShort, db, step, y, u, text;
    var font, zeroColor, tickColor;

    ctx = Pen;
    w = v.bounds.width;
    h = v.bounds.height;

    leftPad  = 6;
    rightPad = w - 6;  // right margin; labels must fit before this
    tickLong  = 14;
    tickShort = 9;
    step = 6;         // every 6 dB

    zeroColor = Color.red;
    tickColor = Color.gray(0.22);
    font = Font("Helvetica", 10);

    ctx.use {
        // background
        ctx.color = Color.white;
        ctx.addRect(Rect(0, 0, w, h));
        ctx.fill;

        // small "dBFS" header at top-left (doesn't change layout height)
        ctx.stringAtPoint("dBFS", Point(leftPad, 2), Font("Helvetica", 10), Color.gray(0.25));

        // grid line at 0 dB
        u = mapDbToUi.(0, topDb, floorDb, gamma);
        y = (1 - u) * h;
        ctx.color = zeroColor.alpha_(0.35);
        ctx.width = 1.0;
        ctx.moveTo(Point(1, y));
        ctx.lineTo(Point(w - 1, y));
        ctx.stroke;

        // ticks every 6 dB down to floor
        db = 0;
        while({ db >= floorDb }, {
            var isMajor, tickLen, labelX;
            isMajor = ((db % 12) == 0) or: { db == 0 };
            tickLen = isMajor.if(tickLong, tickShort);

            u = mapDbToUi.(db, topDb, floorDb, gamma);
            y = (1 - u) * h;

            // tick
            ctx.color = (db == 0).if(zeroColor, tickColor);
            ctx.width = 1.0;
            ctx.moveTo(Point(leftPad, y));
            ctx.lineTo(Point(leftPad + tickLen, y));
            ctx.stroke;

            // label on majors (12 dB) and 0 dB
            if(isMajor) {
                labelX = leftPad + tickLong + 4;
                text = db.asString;
                if(labelX < (rightPad - 6)) {
                    ctx.stringAtPoint(text, Point(labelX, y - 6), font, Color.black);
                };
            };

            db = db - step;
        });

        // border
        ctx.color = paneColor;
        ctx.width = 1;
        ctx.addRect(Rect(0.5, 0.5, w - 1, h - 1));
        ctx.stroke;
    };
});

// ------------- OSC + UI updates -------------
bindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };

    OSCdef(oscNameGui, { |msg|
        var lin, ui, rmsDb;
        lin  = valueFromMsg.(msg);
        ui   = mapLinToUi.(lin, topDb, floorDb, gamma);
        rmsDb = lin.max(1e-9).ampdb;

        {
            meter.value_(ui);
            labelRms.string_("RMS: " ++ rmsDb.round(0.1) ++ " dBFS  (UI: " ++ ui.round(0.003) ++ ")");
        }.defer;
    }, '/peakrmsDemo');

    // optional console OSCdef omitted to keep output quiet
};

unbindOsc = {
    var a, b;
    a = OSCdef(oscNameGui);     if(a.notNil) { a.free; };
    b = OSCdef(oscNameConsole); if(b.notNil) { b.free; };
};

updateUiLabels = {
    var pred;
    pred = ampToRmsDbSaw.(currentAmpDb);
    {
        labelInfo.string_("peak: " ++ currentAmpDb.asString ++ " dBFS   →   expected RMS (saw): "
            ++ pred.round(0.1) ++ " dBFS   |   top=" ++ topDb ++ " , floor=" ++ floorDb);
        tickView.refresh;
    }.defer;
};

// ------------- Control logic -------------
setAmpDb = { |db|
    var idx;
    currentAmpDb = db.asFloat;
    Ndef(ndefName).set(\amp, currentAmpDb.dbamp);
    updateUiLabels.();
    idx = ampDbChoices.indexOf(currentAmpDb).max(0);
    { ampMenu.value_(idx) }.defer;
};

// ------------- Boot + run -------------
Server.default.waitForBoot({
    rebuildNdef.();
    bindOsc.();
    {
        ampMenu.items = ampDbChoices.collect({ |x| x.asString ++ " dBFS (peak)" });
    }.defer;
    setAmpDb.(currentAmpDb);
});

// ------------- Cleanup -------------
window.onClose = {
    unbindOsc.();
    Ndef(ndefName).stop;
};

window  // -> a Window
)

// -------------------------------------------------------------------------
// One-liners (optional): change amplitude without using the menu
// -------------------------------------------------------------------------
~cal_ampDb = { |db| var val; val = db.asFloat; Ndef(\calSaw).set(\amp, val.dbamp); ("set peak = " ++ val ++ " dBFS").postln; };

~cal_ampDb.(0);
~cal_ampDb.(-6);
~cal_ampDb.(-12);
~cal_ampDb.(-18);
~cal_ampDb.(-20);
~cal_ampDb.(-60);
~cal_ampDb.(-128);

===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/meter test/SawMeter_SingleNdef_100Hz.scd =====
/*-------------------------------------------------------------
SawMeter_SingleNdef_100Hz
v0.1.7
MD 2025-10-01 12:58

Purpose:
- One Ndef plays a 100 Hz sawtooth at selectable amplitudes (dBFS).
- Meter shows RMS directly; Peak overlaid via LevelIndicator.drawsPeak/peakLevel.
- Tick marks every 6 dB to the RIGHT; 0 dBFS line + 0..-6 dB headroom band.
- Floor extended to -72 dB so RMS at -60 dBFS is visible (saw RMS ≈ -4.77 dB below peak).
- Compact UI; no legend; returns -> a Window.

Style:
- var-first declarations; lowercase methods; no server.sync
- AppClock-only GUI refresh
- Single window whose name begins with "MagicDisplayGUI"
-------------------------------------------------------------*/

(
// ------------------ config + helpers ------------------
var window_name, floor_db, headroom_top_db, refresh_hz;
var ndef_name, reply_id, amp_db_list, default_db;
var close_existing_magic_windows;
var clamp_db, db_to_ui_frac, y_for_db_padded;

window_name      = "MagicDisplayGUI — Single Saw Meter (100 Hz)"; // must start with MagicDisplayGUI
floor_db         = -72;   // EXTENDED floor so RMS at -60 dBFS (~ -64.77) is visible
headroom_top_db  = -6;    // headroom shading top (visual only)
refresh_hz       = 30;    // GUI / telemetry refresh (Hz)

ndef_name        = \md_saw_100hz;
reply_id         = 9001;
amp_db_list      = [0, -6, -12, -18, -20, -60, -128];
default_db       = -18;

close_existing_magic_windows = {
    var to_close;
    to_close = Window.allWindows.select({ |w| w.name.asString.beginsWith("MagicDisplayGUI") });
    to_close.do({ |w| w.close });
};

// dB clamp + mapping (0 dBFS -> 1.0 UI; floor_db -> 0.0 UI)
clamp_db = { |db| db.clip(floor_db, 0) };
db_to_ui_frac = { |db|
    var dbc = clamp_db.(db);
    (dbc - floor_db) / (0 - floor_db); // 0 at floor, 1 at 0 dBFS
};

// y for dB with small padding so bottom tick is always visible
y_for_db_padded = { |db, h, pad = 1|
    var p = db_to_ui_frac.(db).clip(0, 1);     // 0..1 (floor..0dB)
    var y = pad + (h - 1 - 2*pad) * (1 - p);   // 0 at top
    y.clip(0, h - 1);
};

// ------------------ main ------------------
close_existing_magic_windows.value;

s.waitForBoot({
    var window, amp_menu_view, info_view, readout_view;
    var indicator, ticks_view;
    var oscdef_levels, updater;

    var last_rms_lin, last_peak_lin, current_amp_db, current_amp_lin;
    var set_amp_db, db_ticks;

    // clean server tree
    s.initTree;
    s.defaultGroup.freeAll;

    // ---------- Ndef with telemetry (literal defaults; set real values after) ----------
    Ndef(ndef_name, { |amp = 0.125, trigID = 1, uiHz = 30|
        var sig_st, mono, peak_est, rms_est;
        var win_samps, sumsq, mean, rms_audio, trig;

        sig_st  = Saw.ar(100) * amp ! 2;
        mono    = (sig_st[0] + sig_st[1]) * 0.5;

        peak_est = Amplitude.kr(mono, 0.0, 0.05); // peak-ish envelope
        win_samps = (SampleRate.ir * 0.05).max(1).asInteger; // ~50 ms RMS
        sumsq     = RunningSum.ar(mono.squared, win_samps);
        mean      = sumsq / win_samps;
        rms_audio = mean.sqrt;
        rms_est   = A2K.kr(rms_audio);

        trig = Impulse.kr(uiHz);
        SendReply.kr(trig, "/md/levels", [ peak_est, rms_est ], trigID);

        sig_st
    });

    Ndef(ndef_name).set(\amp, default_db.dbamp, \trigID, reply_id, \uiHz, refresh_hz);

    // ---------- UI + state ----------
    last_peak_lin   = 0.0;
    last_rms_lin    = 0.0;
    current_amp_db  = default_db;
    current_amp_lin = current_amp_db.dbamp;

    set_amp_db = { |db|
        current_amp_db  = db;
        current_amp_lin = db.dbamp;
        Ndef(ndef_name).set(\amp, current_amp_lin);
        info_view.string = "Amp: % dBFS (lin %)"
            .format(db.asInteger, current_amp_lin.round(1e-6));
    };

    // ticks every 6 dB from 0 down to floor_db (== -72)
    db_ticks = Array.series(((0 - floor_db) / 6).asInteger + 1, 0, -6)
        .select({ |db| db >= floor_db });

    // ---------- window & views (compact) ----------
    window = Window(window_name, Rect(100, 100, 360, 230)).alwaysOnTop_(true);

    amp_menu_view = PopUpMenu(window, Rect(16, 16, 150, 22))
        .items_(amp_db_list.collect({ |db| "% dBFS".format(db) }))
        .action_({ |m| set_amp_db.(amp_db_list[m.value]) });

    info_view = StaticText(window, Rect(176, 16, 168, 22))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // RMS bar with Peak overlay (normalized UI fractions 0..1)
    indicator = LevelIndicator(window, Rect(16, 56, 36, 160))
        .style_(\continuous)
        .warning_(0.85)
        .critical_(0.95)
        .drawsPeak_(true);

    // ticks to the RIGHT of the meter (compact)
    ticks_view = UserView(window, Rect(58, 56, 110, 160))
        .background_(Color(0.94, 0.94, 0.96));

    // numeric readout (RMS & Peak in dBFS)
    readout_view = StaticText(window, Rect(176, 56, 168, 20))
        .align_(\left)
        .stringColor_(Color.gray(0.1));

    // ticks drawing (0..-6 headroom band; -72 floor; -60 visible)
    ticks_view.drawFunc_({
        var b, w, h, y0, y_head, font;
        b = ticks_view.bounds; w = b.width; h = b.height;
        font = Font(Font.default.name, 11);

        // background
        Pen.color = Color(0.96, 0.96, 0.98);
        Pen.fillRect(Rect(0, 0, w, h));

        // headroom band (0..-6)
        y0    = y_for_db_padded.(0, h, 1);
        y_head = y_for_db_padded.(headroom_top_db, h, 1);
        Pen.color = Color(1.0, 0.8, 0.8, 0.35);
        Pen.fillRect(Rect(0, y0, w, (y_head - y0)));

        // 0 dBFS line (red)
        Pen.color = Color(0.8, 0.1, 0.1, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y0));
        Pen.lineTo(Point(w, y0));
        Pen.stroke;

        // -6 dB line
        Pen.color = Color(0.6, 0.2, 0.2, 0.9);
        Pen.width = 1.0;
        Pen.moveTo(Point(0, y_head));
        Pen.lineTo(Point(w, y_head));
        Pen.stroke;

        // ticks + labels (0, -6, -12, ... down to -72)
        db_ticks.do({ |db|
            var y, major, tick_len, label, lx, ly;
            y = y_for_db_padded.(db, h, 1);
            major = (((db.asInteger % 12) == 0) or: (db == 0));
            tick_len = major.if(12, 8);
            label = "% dB".format(db.asInteger);

            Pen.color = Color(0.25, 0.25, 0.28, 1.0);
            Pen.width = 1.0;
            Pen.moveTo(Point(0, y));
            Pen.lineTo(Point(tick_len, y));
            Pen.stroke;

            Pen.color = Color(0.15, 0.15, 0.16, 1.0);
            lx = tick_len + 4;
            ly = (y - 7).clip(0, h - 14);
            Pen.stringAtPoint(label, Point(lx, ly), font);
        });
    });

    // ---------- OSC + updater ----------
    oscdef_levels = OSCdef(\md_levels, { |msg|
        // msg = [ '/md/levels', nodeID, replyID, peak, rms ]
        if (msg[2] == reply_id) {
            last_peak_lin = msg[3].asFloat.max(0);
            last_rms_lin  = msg[4].asFloat.max(0);
        };
    }, '/md/levels', s.addr);

    updater = Routine({
        var spf = 1.0 / refresh_hz;
        var min_ui = 1.0 / 160.0; // ensure 1 px visible if clamped to floor
        inf.do({
            {
                var db_rms, db_peak, p_rms, p_peak;

                db_rms  = last_rms_lin.max(1e-12).ampdb;  // dBFS
                db_peak = last_peak_lin.max(1e-12).ampdb; // dBFS

                // Normalize to UI 0..1 (0=floor, 1=0dB)
                p_rms  = db_to_ui_frac.(db_rms).clip(0, 1);
                p_peak = db_to_ui_frac.(db_peak).clip(0, 1);

                // show a 1px sliver if p_rms == 0 (below floor)
                p_rms = (p_rms <= 0).if(min_ui, p_rms);

                indicator.value_(p_rms);
                indicator.peakLevel_(p_peak);

                readout_view.string = "RMS: % dBFS | Peak: % dBFS"
                    .format(clamp_db.(db_rms).round(0.1), clamp_db.(db_peak).round(0.1));

                indicator.refresh;
                ticks_view.refresh;
            }.defer;
            spf.wait;
        });
    }).play(AppClock);

    // ---------- bring up ----------
    Ndef(ndef_name).play;
    set_amp_db.(default_db);
    amp_menu_view.value = amp_db_list.indexOf(default_db).max(0);

    window.onClose_({
        updater.stop;
        oscdef_levels.free;
        Ndef(ndef_name).stop(0.1);
        // Ndef(ndef_name).clear; // uncomment to remove definition
    });

    window.front;

    // return -> a Window
    window;
});
)
===== _isolated_tests_and_experiments/latestDisplayWithNdefChainsAndMeters/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

   Style
   - var-first declarations in every block and function
   - lowercase names, descriptive identifiers
   - AppClock.defer for GUI updates
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/commands.scd =====
// Switch sources
~setSourceA.(\tone_m6);
~setSourceB.(\bp_sweep);

// Live tweaks
Ndef(\tone_m12).set(\freq, 100);
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);

// Pane text
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag, "Re-evaluated quick helpers at " ++ Date.getDate.stamp);
~lt_send.(\left,  "Chain A: ~setSourceA.(\\tone_m6)");
~lt_send.(\right, "Chain B: ~setSourceB.(\\bp_sweep)");

===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.3 — simpler bind + HUD mapper; only GUI responders are replaced
// MD 20251001

/* Purpose
 - Calibrate existing "Layout Test" meters using a perceptual dB mapping (top/floor/gamma).
 - Rebind only the GUI OSCdefs to apply mapping; preserve console OSCdefs untouched.
 - Provide ~hud_set/~hud_preview/~hud_print and a reusable ~hud_map_linear_to_ui.
 Style
 - var-first declarations; lowercase names; no non-local returns; AppClock.defer for GUI.
*/

(
var win, root, meter_left, meter_right;
var find_window_by_name, find_level_by_pane_label;
var install_mapped_gui, value_from_msg;

// Defaults (RMS dB): top = -6 dB, floor = -60 dB, gamma = 1.0
if(~hud_topDb.isNil)  { ~hud_topDb  = -6.0 };
if(~hud_floorDb.isNil){ ~hud_floorDb = -60.0 };
if(~hud_gamma.isNil)  { ~hud_gamma  = 1.0 };

// Linear (0..1) -> UI (0..1) using dB window and gamma
~hud_map_linear_to_ui = { |lin|
    var v, vdb, top, floor, g, u;
    v = lin.max(1e-9);
    vdb = v.ampdb;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    g = ~hud_gamma.asFloat.max(1e-6);
    vdb = vdb.clip(floor, top);
    u = (vdb - floor) / (top - floor);
    u = u.pow(g);
    u.clip(0.0, 1.0)
};

// Small HUD helpers
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol; v = value.asFloat;
    if(k == \top)   { ~hud_topDb = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma = v.max(1e-6) };
    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb; ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ")").postln;
    };
    ("HUD mapping set: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, db_clip, u;
    top = ~hud_topDb.asFloat; floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);
    lin = db.dbamp.clip(1e-9, 1.0);
    db_clip = lin.ampdb.clip(floor, top);
    u = (db_clip - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

// --- Locate meters in the existing window ---
find_window_by_name = { |name| Window.allWindows.detect({ |w| w.name == name }) };

find_level_by_pane_label = { |root_view, pane_label|
    var found_static, result, search_static, search_under_parent;
    found_static = nil; result = nil;

    search_static = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == pane_label }) {
                found_static = child;
            }{
                search_static.(child);
            };
            i = i + 1;
        });
    };

    search_under_parent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child };
            }{
                search_under_parent.(child);
            };
            i = i + 1;
        });
    };

    search_static.(root_view);
    if(found_static.notNil and: { found_static.parent.notNil }) {
        search_under_parent.(found_static.parent);
    };
    result
};

// Bind window + meters
win = find_window_by_name.("Layout Test");
if(win.isNil) {
    "Layout Test window not found. Open the window script first.".postln;
}{
    root = win.view;
    meter_left  = find_level_by_pane_label.(root, "Top Left Pane");
    meter_right = find_level_by_pane_label.(root, "Top Right Pane");
};

// --- Rebind only GUI OSCdefs to insert mapping ---
value_from_msg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat };
    };
    v.clip(0.0, 1.0)
};

install_mapped_gui = {
    var a, b;
    a = OSCdef(\rmsA_toGUI); if(a.notNil) { a.free };
    b = OSCdef(\rmsB_toGUI); if(b.notNil) { b.free };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v = value_from_msg.(msg);
        ui = ~hud_map_linear_to_ui.(v);
        { meter_left.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v = value_from_msg.(msg);
        ui = ~hud_map_linear_to_ui.(v);
        { meter_right.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

if(meter_left.notNil and: { meter_right.notNil }) {
    install_mapped_gui.();
}{ "Meter calibration patch not installed (meters not bound).".postln };

~hud_print.();
)

===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.3 — programmatic tone set, compact pane binding, same one-liner API
// MD 20251001

/* Purpose
 - Provide calibrated tone sources, pulse sources, and a sweeping band-pass noise.
 - Offer single-line pane text updates targeting the existing "Layout Test" panes.
 - Keep your ~setSourceA/~setSourceB and avoid rebuilding unless asked.
 Style
 - var-first declarations; lowercase identifiers; AppClock.defer for GUI updates.
 - Sources are Ndefs; sinks/processors use \in.ar(2) (handled in the window script).
*/

(
var make_cal_tones, make_pulses, make_bp_sweep;
var db_list, make_tone;
var bind_panes, find_window_by_name, find_text_by_pane_label;

// --- Calibration tones (stereo) programmatically
db_list = [-6, -12, -18, -24, -30];

make_tone = { |name_sym, db_val|
    var amp;
    amp = db_val.dbamp;
    Ndef(name_sym, {
        var freq, sig;
        freq = \freq.kr(100).max(10);
        sig = SinOsc.ar([freq, freq], 0, amp);
        sig
    });
};

make_cal_tones = {
    make_tone.(\tone_m0,    0);
    db_list.do({ |db| make_tone.(("tone_m" ++ db.neg.asInteger).asSymbol, db) });
    make_tone.(\tone_m128, -128);
};

// --- Pulses
make_pulses = {
    // Clicks
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08);
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env;
        sig
    });

    // Decaying tone "ping"
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train gate on noise
    Ndef(\pulse_train, {
        var rate, duty, gate_ctl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gate_ctl = LFPulse.kr(rate, 0, duty).lag(0.001);
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gate_ctl;
        sig
    });
};

// --- Band-passed noise with sweeping center frequency
make_bp_sweep = {
    Ndef(\bp_sweep, {
        var base, range, rate, center, rq, src, sig;
        base = \base.kr(200).clip(20, 10000);
        range = \range.kr(5000).clip(0, 18000);
        rate = \rate.kr(0.07).clip(0.005, 2.0);
        center = base + (range * (LFTri.kr(rate).range(0, 1)));
        rq = \rq.kr(0.15).clip(0.01, 0.9);
        src = PinkNoise.ar([0.5, 0.5]);
        sig = BPF.ar(src, center, rq) * 1.2;
        sig
    });
};

// --- Pane text helpers (bind once, then ~lt_send.(\left, "…"))
find_window_by_name = { |target|
    var match;
    match = Window.allWindows.detect({ |w| w.name == target });
    match
};

find_text_by_pane_label = { |root_view, pane_label|
    var found_static, result, search_static, collect_text;
    found_static = nil; result = nil;

    search_static = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == pane_label }) {
                found_static = child;
            }{
                search_static.(child);
            };
            i = i + 1;
        });
    };

    collect_text = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(TextView)) {
                if(result.isNil) { result = child };
            }{
                collect_text.(child);
            };
            i = i + 1;
        });
    };

    search_static.(root_view);
    if(found_static.notNil and: { found_static.parent.notNil }) {
        collect_text.(found_static.parent);
    };
    result
};

bind_panes = {
    var win, root, left, right, system, diag, choices, recv, map;
    win = find_window_by_name.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open the window script first.".postln;
    }{
        root    = win.view;
        left    = find_text_by_pane_label.(root, "Top Left Pane");
        right   = find_text_by_pane_label.(root, "Top Right Pane");
        system  = find_text_by_pane_label.(root, "System State");
        diag    = find_text_by_pane_label.(root, "Diagnostic Messages");
        choices = find_text_by_pane_label.(root, "Choices");
        recv    = find_text_by_pane_label.(root, "Receiving Commands");
        map = IdentityDictionary[
            \left   -> left,
            \right  -> right,
            \system -> system,
            \diag   -> diag,
            \choices-> choices,
            \recv   -> recv
        ];
        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public API: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |pane_key, a_string|
    var panes, view_to_set, text_string, win;
    panes = ~lt_panes;
    text_string = a_string.asString;
    if(panes.isNil) { bind_panes.(); panes = ~lt_panes };
    if(panes.notNil) {
        view_to_set = panes[pane_key.asSymbol];
        if(view_to_set.notNil) {
            { view_to_set.string_(text_string) }.defer;
        }{
            win = find_window_by_name.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found (bound keys: %)".format(pane_key, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
make_cal_tones.();
make_pulses.();
make_bp_sweep.();

"Quick changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
)
===== _isolated_tests_and_experiments/out/SIMPLIFIED 20250110 - abandonedForNow/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.9 — clearer layout, unified helpers, same behavior
// MD 20251001

/* Purpose
 - Create the "Layout Test" window with top-left/right text + meters and four lower panes.
 - Build initial A/B chains (srcA → outA, srcB → outB), sinks meter via SendPeakRMS.
 - Provide setSourceA/B, decimated console prints (ampdb), and robust meter value extraction.
 Style
 - var-first declarations everywhere; lowercase names; no non-local returns (^).
 - GUI updates via AppClock.defer; sinks read from \in.ar(2).
 - Use Ndef(left) <<> Ndef(right); return -> a Window.
*/

(
var window, make_pane, pane_color;
var top_left_text, top_left_meter, top_right_text, top_right_meter;
var osc_gui_a, osc_gui_b, osc_con_a, osc_con_b;
var chain_a, chain_b, ensure_stereo, rebuild_chain, chain_to_string;
var set_source_a, set_source_b, value_from_msg;
var dec_a = 0, dec_b = 0, dump_a = true, dump_b = true;

var existing;

// --- GUI ---

// --- safely close any prior "Layout Test" windows -- NOT SURE IF STILL NEEDED
existing = Window.allWindows.reject({ |x| x.isNil });
existing.do({ |w|
    if(w.isKindOf(Window) and: { w.name == "Layout Test" }, { w.close });
});


Window.allWindows.do({ | w | if(w.name == "Layout Test", { w.close }) });
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

pane_color = Color(0.0, 0.35, 0.0);

make_pane = { |content, label|
    var label_view, inner, pane, inset;
    label_view = StaticText().string_(label).align_(\center)
        .stringColor_(Color.white).background_(pane_color);
    inner = VLayout(label_view, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = pane_color;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        make_pane.(HLayout(
            top_left_text  = TextView().editable_(false),
            top_left_meter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        make_pane.(HLayout(
            top_right_text  = TextView().editable_(false),
            top_right_meter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        make_pane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// --- Audio + chains + OSC ---
osc_gui_a = \rmsA_toGUI;
osc_gui_b = \rmsB_toGUI;
osc_con_a = \rmsA_console;
osc_con_b = \rmsB_console;

Server.default.waitForBoot({
    // SOURCES (stereo)
    Ndef(\srcZ, { Silent.ar(numChannels: 1) }); // spare
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // SINKS (must read \in.ar(2)), meter to GUI
    // replyIDs A=1, B=2
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });
    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // Chain helpers
    ensure_stereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);
        };
    };

    chain_to_string = { |an_array|
        var forward;
        forward = an_array.copy.reverse; // [source ... sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuild_chain = { |an_array|
        var i;
        i = 0;
        if(an_array.size < 2) {
            "need at least [sink, source]".postln;
        }{
            an_array.do(ensure_stereo);
            i = 0;
            while({ i < (an_array.size - 1) }, {
                Ndef(an_array[i]) <<> Ndef(an_array[i + 1]); // left receives right at \in
                i = i + 1;
            });
            Ndef(an_array[0]).play(numChannels: 2);
        };
    };

    // Initial chains
    chain_a = [\outA, \srcA];
    chain_b = [\outB, \srcB];
    rebuild_chain.(chain_a);
    rebuild_chain.(chain_b);

    // Robust meter extractor: last numeric = final RMS from SendPeakRMS
    value_from_msg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) { v = msg[sz - 1].asFloat };
        };
        v.clip(0.0, 1.0)
    };

    // Rebind OSC (avoid duplicates on re-eval)
    { OSCdef(osc_gui_a).free; OSCdef(osc_gui_b).free; OSCdef(osc_con_a).free; OSCdef(osc_con_b).free; }.value;

    // GUI meters @ 20 Hz
    OSCdef(osc_gui_a, { |msg| { top_left_meter.value_(value_from_msg.(msg)) }.defer }, '/peakrmsA');
    OSCdef(osc_gui_b, { |msg| { top_right_meter.value_(value_from_msg.(msg)) }.defer }, '/peakrmsB');

    // Console prints (≈1 Hz via simple decimation)
    OSCdef(osc_con_a, { |msg|
        var v;
        if(dump_a) { "A first msg: %".format(msg).postln; dump_a = false }; // just the first message to see the actual formatting of it
        dec_a = dec_a + 1;
        if(dec_a >= 20) {
            v = value_from_msg.(msg).max(1e-6); // prevent ampdb on 0 which would be inf
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
			dec_a = 0; // e.g "A level: -38.5 dB (0.012)"
        };
    }, '/peakrmsA');

    OSCdef(osc_con_b, { |msg|
        var v;
        if(dump_b) { "B first msg: %".format(msg).postln; dump_b = false };
        dec_b = dec_b + 1;
        if(dec_b >= 20) {
            v = value_from_msg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB (" ++ v.round(0.003) ++ ")").postln;
            dec_b = 0;
        };
    }, '/peakrmsB');

    // Paint initial chain strings
    {
        top_left_text.string_(chain_to_string.(chain_a));
        top_right_text.string_(chain_to_string.(chain_b));
    }.defer;
});

// Convenience: change only the tail (source) of each chain
set_source_a = { |src_sym|
    var new_sym;
    new_sym = src_sym.asSymbol;
    chain_a[chain_a.size - 1] = new_sym;
    rebuild_chain.(chain_a);
    { top_left_text.string_(chain_to_string.(chain_a)) }.defer;
};
set_source_b = { |src_sym|
    var new_sym;
    new_sym = src_sym.asSymbol;
    chain_b[chain_b.size - 1] = new_sym;
    rebuild_chain.(chain_b);
    { top_right_text.string_(chain_to_string.(chain_b)) }.defer;
};
~setSourceA = set_source_a;
~setSourceB = set_source_b;

// Cleanup
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(osc_gui_a).free;
    OSCdef(osc_gui_b).free;
    OSCdef(osc_con_a).free;
    OSCdef(osc_con_b).free;
};

window  // -> a Window
)
===== _isolated_tests_and_experiments/out/WindowLayout_Grid_Minimal.scd =====
// WindowLayout_Grid_Minimal.scd
// v1.1 - Ultra-simple 3x2 grid with debug outlines + coloured labels
// MD 20250930

(
var debugLayout = true;

var window, grid;
var makePane;

makePane = { |content, label, color|
    var strokeColor = if(debugLayout, { color }, { Color.gray(0.55) });
    var labelText = if(debugLayout, { label }, { "---" });
    var labelView = StaticText()
        .string_(labelText)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(22);
    var inner = VLayout(labelView, content).margins_(8).spacing_(6);
    var pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var w = v.bounds.width, h = v.bounds.height, inset = 0.5;
        Pen.use {
            Pen.color = strokeColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, w - 1, h - 1));
            Pen.stroke;
        };
    });
    pane
};

Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

grid = GridLayout.rows(
    [makePane.(HLayout(TextView(), LevelIndicator().style_(\led).fixedWidth_(30)), "Top Left", Color.blue),
     makePane.(HLayout(TextView(), LevelIndicator().style_(\led).fixedWidth_(30)), "Top Right", Color.blue)],
    [makePane.(TextView(), "System State", Color.green),
     makePane.(TextView(), "Diagnostics", Color.green)],
    [makePane.(TextView(), "Choices", Color.green),
     makePane.(TextView(), "Receiving", Color.green)]
).margins_(12).spacing_(12);

window.layout = grid;
window
)

===== _isolated_tests_and_experiments/out/WindowLayoutTest_20250930_Grid.scd =====
// WindowLayoutTest_20250930_Grid.scd
// v1.4 - GridLayout (3x2), crisp borders, coloured labels, correct var placement
// MD 20250930-1210

/*
Purpose:
  - Fix the var-placement syntax error and ensure a proper GridLayout with shared columns.
  - Provide thin (1px) outlines and coloured pane-name bars in debug mode.
  - Draw borders in local coordinates to avoid offsets and “overlap” artifacts.

Style:
  - var-first declarations, descriptive lowercase names, no non-local returns.
  - Returns '-> a Window'.
*/

(
var debugLayout = true;
var outlineContentOnly = false;   // true = border excludes label; false = includes label

// ---- declare ALL vars up front (SuperCollider requirement) ----
var window, grid;

var topLeftText, topLeftMeter, topRightText, topRightMeter;
var systemStateText, diagnosticMessagesText;
var choicesText, receivingCommandsText;

var outerMargin, cellSpacing, paneMargin, paneSpacing, labelFixedHeight, strokeWidth, strokeInset;

var makePane;
var topLeftPane, topRightPane, systemStatePane, diagnosticPane, choicesPane, receivingPane;

// ---- geometry constants ----
outerMargin = 12;       // margins around the entire grid
cellSpacing = 12;       // spacing between grid cells
paneMargin = 8;         // inner padding inside each pane
paneSpacing = 6;        // gap between label and content inside a pane
labelFixedHeight = 22;  // stable label height so borders don't jump
strokeWidth = 1;        // thin outline
strokeInset = strokeWidth * 0.5;

// ---- helper: construct one pane (UserView) with label bar + thin outline ----
makePane = { |contentLayout, labelString, debugColor|
    var strokeColor, labelStringToShow, labelView, innerLayout, containerView;

    strokeColor = if(debugLayout, { debugColor }, { Color.gray(0.55) });
    labelStringToShow = if(debugLayout, { labelString }, { "---" });

    // Label bar
    labelView = StaticText()
        .string_(labelStringToShow)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(strokeColor)
        .fixedHeight_(labelFixedHeight)
        .resize_(3); // fill horizontally

    // Stack label above the content
    innerLayout = VLayout(
        labelView,
        contentLayout
    )
    .margins_(paneMargin)
    .spacing_(paneSpacing);

    // Container: fills its grid cell and draws its own outline in LOCAL coordinates
    containerView = UserView()
        .layout_(innerLayout)
        .resize_(3); // fill both directions

    containerView.drawFunc_({ |view|
        var w, h, rect;
        w = view.bounds.width;
        h = view.bounds.height;

        if(outlineContentOnly, {
            // outline content area only (exclude the label bar)
            rect = Rect(
                paneMargin + strokeInset,
                paneMargin + labelFixedHeight + paneSpacing + strokeInset,
                w - (2 * paneMargin) - (2 * strokeInset),
                h - (2 * paneMargin) - labelFixedHeight - paneSpacing - (2 * strokeInset)
            );
        }, {
            // outline the entire pane (including the label bar)
            rect = Rect(strokeInset, strokeInset, w - (2 * strokeInset), h - (2 * strokeInset));
        });

        Pen.use {
            Pen.color = strokeColor;
            Pen.width = strokeWidth;
            Pen.addRect(rect);
            Pen.stroke;
        };
    });

    containerView
};

// ---- close any existing window with the same name ----
Window.allWindows.do({ |w|
    if(w.name == "Layout Test", { w.close });
});

// ---- create window ----
window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

// ---- build pane contents ----
topLeftPane = makePane.(
    VLayout(
        HLayout(
            topLeftText = TextView()
                .string_("Top Left Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topLeftMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)  // keep rail width fixed
                .resize_(2)       // vertical stretch only
        )
    ),
    "Top Left Pane",
    Color.red(1.0, 0.55)
);

topRightPane = makePane.(
    VLayout(
        HLayout(
            topRightText = TextView()
                .string_("Top Right Text Area")
                .minWidth_(80)
                .minHeight_(100)
                .resize_(3),
            topRightMeter = LevelIndicator()
                .numTicks_(10)
                .style_(\led)
                .fixedWidth_(30)
                .resize_(2)
        )
    ),
    "Top Right Pane",
    Color.blue(1.0, 0.55)
);

systemStatePane = makePane.(
    VLayout(
        StaticText().string_("System State").align_(\center).resize_(3),
        systemStateText = TextView()
            .string_("System state info here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "System State",
    Color.green(1.0, 0.55)
);

diagnosticPane = makePane.(
    VLayout(
        StaticText().string_("Diagnostic Messages").align_(\center).resize_(3),
        diagnosticMessagesText = TextView()
            .string_("Diagnostic messages here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Diagnostic Messages",
    Color.yellow(1.0, 0.6)
);

choicesPane = makePane.(
    VLayout(
        StaticText().string_("Choices").align_(\center).resize_(3),
        choicesText = TextView()
            .string_("Choices text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Choices",
    Color.magenta(1.0, 0.5)
);

receivingPane = makePane.(
    VLayout(
        StaticText().string_("Receiving Commands").align_(\center).resize_(3),
        receivingCommandsText = TextView()
            .string_("Receiving commands text here...")
            .minHeight_(100)
            .resize_(3)
    ),
    "Receiving Commands",
    Color.cyan(1.0, 0.6)
);

// ---- compose a 3x2 grid and assign to the window ----
// Safer, version-agnostic approach: create the grid and add cells explicitly.
grid = GridLayout()
    .margins_(outerMargin)
    .spacing_(cellSpacing);

// Place panes by (row, col)
grid.add(topLeftPane,     0, 0);
grid.add(topRightPane,    0, 1);
grid.add(systemStatePane, 1, 0);
grid.add(diagnosticPane,  1, 1);
grid.add(choicesPane,     2, 0);
grid.add(receivingPane,   2, 1);

// Optional (if available in your SC build): set column/row stretch to balance space
// (safe to comment out if your SC doesn't support these)
// grid.setColumnStretch(0, 1);
// grid.setColumnStretch(1, 1);
// grid.setRowStretch(0, 2);   // make the top row taller if you wish
// grid.setRowStretch(1, 1);
// grid.setRowStretch(2, 1);

window.layout = grid;

if(debugLayout) {
    "DEBUG ON: GridLayout aligned; coloured labels + crisp thin outlines.".postln;
} {
    "DEBUG OFF: GridLayout aligned; neutral labels + thin grey outlines.".postln;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== _isolated_tests_and_experiments/routableChainsWithDisplayWorkingMeters/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

   Style
   - var-first declarations in every block and function
   - lowercase names, descriptive identifiers
   - AppClock.defer for GUI updates
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // left chain: sink ... source
    chainB = [\outB, \srcB];   // right chain
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0)
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/SIMPLIFIED clode/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== _isolated_tests_and_experiments/SIMPLIFIED clode/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== _isolated_tests_and_experiments/SIMPLIFIED clode/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== _isolated_tests_and_experiments/SIMPLIFIED clode/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.6 - no non-local returns (no ^); robust SendPeakRMS parser; console prints restored
// MD 20250930

/* Purpose
   - Fix “no console output” by eliminating ^ non-local returns inside parseRMS.
   - Robustly parse SendPeakRMS with/without address and with/without numCh.
   - Keep your GUI + chains intact and meters moving.

   Style
   - var-first declarations in every block
   - lowercase names, descriptive
   - AppClock defer for GUI updates
   - no non-local returns
*/

(

var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var parseRMS;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

("test").postln;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30).warning_(0.50).critical_(0.80)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30).warning_(0.50).critical_(0.80)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) ---
    // Keep distinct replyIDs (A=1, B=2) to match your earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);
        sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];
    chainB = [\outB, \srcB];
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // Robust RMS parser (no ^ anywhere):
    // Supports:
    //   A) [address?, nodeID, replyID, numCh, peak1, rms1, peak2, rms2, ...]
    //   B) [address?, nodeID, replyID,        peak1, rms1, peak2, rms2, ...]
    parseRMS = { |msg|
        var ret, hasAddr, base, msgSize, maybeNumCh, dataStart, pairs, sum, k, rmsIndex;

        ret = 0.0;
        if(msg.notNil) {
            msgSize = msg.size;
            hasAddr = (msgSize > 0) && { msg[0].isString };
            base = hasAddr.binaryValue;

            // Decide layout by looking at slot base+2 and overall payload length
            if(msgSize >= (base + 4)) {
                maybeNumCh = msg[base + 2];
                if(maybeNumCh.isNumber and: { (msgSize - (base + 3)) >= (maybeNumCh.asInteger * 2) }) {
                    dataStart = base + 3;
                    pairs = maybeNumCh.asInteger.max(1);
                }{
                    dataStart = base + 2;
                    pairs = ((msgSize - dataStart) / 2).floor.max(0);
                };
            }{
                dataStart = base + 2;
                pairs = ((msgSize - dataStart) / 2).floor.max(0);
            };

            if(pairs > 0) {
                sum = 0.0;
                k = 0;
                while({ k < pairs }, {
                    rmsIndex = dataStart + (k * 2) + 1;  // second of each (peak,rms)
                    if(rmsIndex < msgSize) {
                        sum = sum + msg[rmsIndex].asFloat;
                    };
                    k = k + 1;
                });
                if(pairs > 0) {
                    ret = (sum / pairs).clip(0.0, 1.0);
                };
            };
        };
        ret
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(parseRMS.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(parseRMS.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = parseRMS.(msg);
            v = v.max(1e-6);
            ("A RMS: " ++ (v.ampDb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = parseRMS.(msg);
            v = v.max(1e-6);
            ("B RMS: " ++ (v.ampDb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== _isolated_tests_and_experiments/WindowLayout_Grid_WithSigChainsAndMeters.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters.scd
// v1.2 - Aligns with sigChainOperations: <<> wiring + \in.ar(2) sinks; meters A & B
// MD 20250930

/*
Purpose:
  - Same dark-green window (3x2 grid).
  - Sources: srcA/srcB/srcC (stereo).
  - Chains: chainA=[outA,...,src?], chainB=[outB,...,src?], wired by Ndef(left) <<> Ndef(right).
  - Sinks: outA/outB read \in.ar(2), meter with SendPeakRMS to GUI.
  - Left pane meters sinkA; right pane meters sinkB; both panes display the full chain string.

Conventions (from sigChainOperations v0.2.1):
  - Receivers that consume audio MUST declare \in.ar(2).
  - Wiring uses Ndef(left) <<> Ndef(right) (left receives right at \in).
  - (Optional) pre-arm proxies to stereo audio buses before wiring.  [See file notes]
*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;
var oscNameA, oscNameB;

// --- chain data + functions (mirroring your sigChain style) ---
var chainA, chainB;
var ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        var inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView(),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),

        makePane.(HLayout(
            topRightText  = TextView(),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + chains ----------
oscNameA = \rmsA_toGUI;
oscNameB = \rmsB_toGUI;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (MUST declare \in.ar(2)) ---
    // outA: sink for chainA (also meters -> /peakrmsA)
    Ndef(\outA, {
        var sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // id=1
        sig
    });

    // outB: sink for chainB (also meters -> /peakrmsB)
    Ndef(\outB, {
        var sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);  // id=2
        sig
    });

    // --- OPTIONAL PROCESSORS (declared here to be ready if you insert them) ---
    // Ndef(\p1, { var inSig = \in.ar(2) * 0.8; inSig });
    // Ndef(\p2, { var inSig = \in.ar(2).tanh * 0.7; inSig });

    // --- CHAIN HELPERS (aligned with sigChainOperations) ---
    ensureStereo = { |key|
        var bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio
===== _isolated_tests_and_experiments/working/sanityTestsWithNdefs.scd =====
// sanityTestsWithNdefs.scd
// v.0.4
// MD 20250930
(
// Debug flag
var debug = true;  // Set to false to disable debug output

// vars
var win, meterA, meterB;
var printCounterA = 0, printCounterB = 0;  // Local variables instead of environment

// create display window:
win = Window("RMS Meters", Rect(100, 100, 300, 400)).front;
win.layout = HLayout(  // Horizontal layout for left/right panes
    VLayout(  // Left pane
        StaticText().string_("Sink A").align_(\center),
        meterA = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)  // resize code 1: fixed dimensions
            .fixedWidth_(30)
    ).margins_(5).spacing_(5),   // Outline: margins create visible border
    VLayout(  // Right pane
        StaticText().string_("Sink B").align_(\center),
        meterB = LevelIndicator()
            .numTicks_(10)
            .style_(\led)
            .resize_(1)
            .fixedWidth_(30)
    ).margins_(5).spacing_(5)
);

// create Ndef sources:
Ndef(\srcA, {PinkNoise.ar(0.1 ! 2)});
Ndef(\srcB, {SinOsc.ar([300,301], mul:0.2)});
Ndef(\srcC, {SinOsc.ar([250,301], mul:0.2)});

// Debug: display bus values for source Ndefs
if(debug, {
    "___ Source Ndef Bus Values ___".postln;
    "Ndef(\\srcA) bus: %".format(Ndef(\srcA).bus).postln;
    "Ndef(\\srcB) bus: %".format(Ndef(\srcB).bus).postln;
    "Ndef(\\srcC) bus: %".format(Ndef(\srcC).bus).postln;
});

// Sink Ndefs with SendPeakRMS monitoring
Ndef(\sinkA, {
    var sig = Ndef(\srcA).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);  // 20Hz for meters
    sig;
});

Ndef(\sinkB, {
    var sig = Ndef(\srcB).ar;
    SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
    sig;
});

// Debug: display bus values for sink Ndefs
if(debug, {
    "___ Sink Ndef Bus Values ___".postln;
    "Ndef(\\sinkA) bus: %".format(Ndef(\sinkA).bus).postln;
    "Ndef(\\sinkB) bus: %".format(Ndef(\sinkB).bus).postln;
    "____________________________".postln;
});

// Fast OSCdef responders for meters (20Hz updates)
OSCdef(\rmsAMeter, {|msg|
    // msg[3] = replyID, msg[4] = numChannels, msg[5] = peak, msg[6] = RMS
    {meterA.value = msg[6]}.defer;  // Use RMS value
}, '/peakrmsA');

OSCdef(\rmsBMeter, {|msg|
    {meterB.value = msg[6]}.defer;
}, '/peakrmsB');

// Slow responders for console printing (1Hz)
OSCdef(\rmsAConsole, {|msg|
    printCounterA = printCounterA + 1;
    if(printCounterA >= 20, {  // Print every 20th message (20Hz / 20 = 1Hz)
        "sinkA RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        printCounterA = 0;
    });
}, '/peakrmsA');

OSCdef(\rmsBConsole, {|msg|
    printCounterB = printCounterB + 1;
    if(printCounterB >= 20, {
        "sinkB RMS: % dB".format((msg[6].ampdb).round(0.1)).postln;
        printCounterB = 0;
    });
}, '/peakrmsB');

// Cleanup when window closes
win.onClose = {
    OSCdef(\rmsAMeter).free;
    OSCdef(\rmsBMeter).free;
    OSCdef(\rmsAConsole).free;
    OSCdef(\rmsBConsole).free;
};

// Play the sinks
Ndef(\sinkA).play;
Ndef(\sinkB).play;
)
===== CommandTree/archived/MDCommandQueue.scd =====
// MDCommandQueue.sc
// MD 20250801

MDCommandQueue{

	var <> queue;

	*new{
		^super.new.init();
	}

	init{
		this.queue = List.new(8);
		^this
	}


} // end of class MDCommandQueue
===== CommandTree/martinTreeEditor.scd =====
// martinTreeEditor.scd

// v1.1 20250916-0847 - fixed 'tree'/'~tree' mismatch. All
// 20250818-1431
// allows editing of the tree step by step.

/*
Loads JSON tree from /Users/martindupras/CommandTreeSavefiles/myTree.json
Displays the tree in the console
Adds branches interactively
Saves the updated tree back to the same file
*/

//using circular
(
// Setup versioned saver
var saveFolder, savePrefix;

saveFolder = "/Users/martindupras/CommandTreeSavefiles";
savePrefix = "myTree";

~saver = CircularFileSave.new(savePrefix, saveFolder, 10);
"🗂 CircularFileSave initialized.".postln;
)

//load latest version:
(
// Load latest saved version
var json;

json = ~saver.latestVersion;
if (json.notNil) {
    ~tree = MDCommandTree.new;
    ~tree.importJSON(json);
    "✅ Latest version loaded.".postln;
    ~tree.printTreePretty;
} {
    "⚠️ No saved version found.".postln;
};
)



///// STEP 1 - LOAD
(
// Load tree from JSON file
var path;

path = "/Users/martindupras/CommandTreeSavefiles/myTree.json";
~tree = MDCommandTree.new;
~tree.importJSONFile(path);
"JSON Tree loaded from file.".postln;
)

///// STEP 2 - PRINT
(
// Print the tree structure
~tree.printTreePretty;
)


///// STEP 3 - ADD NODES
(
// Add a node
var parentId = 8;
var nodeName = "bob";
var fret = 11;
var newNode = ~tree.addNode(parentId, nodeName, fret);

if (newNode.notNil) {
    ("✅ Added node '" ++ nodeName ++ "' under parent ID " ++ parentId).postln;
    ~tree.printTreePretty;
} {
    "⚠️ Failed to add node.".postln;
};
)

(
// Remove the node
var nodeIdToRemove = 24;
var removed = ~tree.removeNode(nodeIdToRemove);

if (removed.notNil) {
    ("🗑 Node " ++ nodeIdToRemove ++ " removed.").postln;
} {
    ("⚠️ Failed to remove node " ++ nodeIdToRemove).postln;
};

// Always reprint after change
~tree.printTreePretty;
)


// using circular
(
// Save tree to versioned file
if (~tree.notNil) {
    var json = ~tree.asJSON;
    ~saver.saveVersion(json);
    "💾 Tree saved to versioned file.".postln;
} {
    "⚠️ No tree to save.".postln;
};
)

// list saved versions:
(
// List saved versions
~saver.listVersions;
)





// (
// // Save tree to JSON file
// var savePath;
//
// savePath = "/Users/martindupras/CommandTreeSavefiles/UpdatedTree.json";
// ~tree.exportJSONFile(savePath);
// ("Tree saved to:" + savePath).postln;
// savePath.postln;
// )




// TEST save and reload
(
// Save and reload test
var savePath, reloadedTree;

savePath = "/Users/martindupras/CommandTreeSavefiles/testTree.json";

// Save current tree
~tree.exportJSONFile(savePath);
"Tree saved.".postln;

// Reload into a new tree instance
reloadedTree = MDCommandTree.new;
if (reloadedTree.importJSONFile(savePath)) {
    "Tree reloaded successfully.".postln;
    reloadedTree.printTreePretty;
} {
    "Failed to reload tree.".postln;
};
)






















~tree;

(
// Load the tree from JSON
var filePath;
filePath = "/Users/martindupras/CommandTreeSavefiles/myTree.json";

~tree = MDCommandTree.new;
if (~tree.importJSONFile(filePath)) {
    "✅ Tree loaded successfully.".postln;
    ~tree.printTreePretty;
} {
    "❌ Failed to load tree.".postln;
};
)
// === Add branches interactively ===
// Example: Add a branch to node named "A"
var parentNode = ~tree.findNodeByName("A");
if (parentNode.notNil) {
    var newNode = ~tree.addNode(parentNode.id, "A_newBranch", 7);
    ("✅ Added branch to 'A': " ++ newNode.name ++ " (ID: " ++ newNode.id ++ ")").postln;
    ~tree.printTreePretty;
} {
    "⚠️ Parent node 'A' not found.".postln;
};

// === Save the updated tree ===
~tree.exportJSONFile(filePath);
"💾 Tree saved to file.".postln;
)

===== CommandTree/MDCommandBuilderTest.scd =====
// MDCommandBuilderTest.scd
// MD 20250801

// FOR THIS TO WORK: we need to rund MDCommandNodeTest (version 20250731) because we need a populated tree ("tree")


/*// run this for debugging messages
(~mdDebug = true;

+Object {
    debug { |msg|
        if (~mdDebug == true) {
            msg.postln;
        };
    }
}
)*/



// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(5); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(11); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;


===== CommandTree/MDCommandSystemTest20250804.scd =====
// MDCommandSystemTest20250804.scd
// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);

// 📋 Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " →").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.navigateToChild(3); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/MDCommandSystemTest20250812.scd =====
// MDCommandSystemTest20250804.scd
// update 20250811
// addiing changing |fret| to |string, fret| in navigateToChild methods

// MD 20250804

// This is the testing code to test various aspects of the tree. This is just for testing, it does not do anything really useful yet other than invoke most methods.

////////////////////////////////////////////////////////////////////
// [1] Run this block to create a tree structure with data in it
///////////////////////////////////////////////////////////////////

(
// Build a tree for testing
var tree, root;
var node1, node2, node3, node4;
var leaf1A, leaf1B, leaf2A, leaf2B, leaf3A, leaf3B, leaf4A, leaf4B, leaf4C, leaf4D;
var testNodeMethods, printTreeSummary;

// Create tree
tree = MDCommandTree.new("root", 0, 50);
root = tree.root;

// Add intermediate nodes to root
node1 = tree.addNode(tree.getNodeByName("root").id, "audio", 3);
 leaf1A = tree.addNode(tree.getNodeByName("audio").id, "noise", 7);
leaf1B = tree.addNode(tree.getNodeByName("audio").id, "oscillators", 9);
//
node2 = tree.addNode(tree.getNodeByName("root").id, "control", 5);
 leaf2A = tree.addNode(tree.getNodeByName("control").id, "LFO", 7);
 leaf2B = tree.addNode(tree.getNodeByName("control").id, "gate", 9);
//
node3 = tree.addNode(tree.getNodeByName("root").id, "names", 7);
 leaf3A = tree.addNode(tree.getNodeByName("names").id, "sends", 2);
 leaf4A = tree.addNode(tree.getNodeByName("names").id, "receive", 4);
//
node4 = tree.addNode(tree.getNodeByName("root").id, "values", 9);
 leaf4A = tree.addNode(tree.getNodeByName("values").id, "10", 9);
 leaf4B = tree.addNode(tree.getNodeByName("values").id, "100", 10);
 leaf4C = tree.addNode(tree.getNodeByName("values").id, "10", 11);
 leaf4D = tree.addNode(tree.getNodeByName("values").id, "100", 12);

// Tag all nodes with depth
tree.root.tagByDepth(0);
"----- Depth:".postln;
tree.root.depthTag;
"-----".postln;

// 📋 Node Testing Function
testNodeMethods = { |node, label|
    var isLeafVal, descCount, leafCount, depth, depthTag;
    isLeafVal = node.isLeaf();
    descCount = node.countDescendants();
    leafCount = node.countLeavesOnly();
    depth = node.getDepth();      // computed recursively
    depthTag = node.depthTag;    // stored via tagByDepth

    (label ++ " →").postln;
    ("  isLeaf:           " ++ isLeafVal).postln;
    ("  countDescendants: " ++ descCount).postln;
    ("  countLeavesOnly:  " ++ leafCount).postln;
    ("  getDepth:         " ++ depth).postln;
    ("  depthTag:         " ++ depthTag).postln;
    "---".postln;
};

// Tree Summary Function
printTreeSummary = {
    tree.nodeMap.values.do { |node|
        testNodeMethods.(node, node.name);
    };
};

// Run tests
printTreeSummary.();
"-----".postln;
tree.printTreePretty;
"-----".postln;

~tree = tree;


// Export
tree.exportJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

// Import
tree.importJSONFile("~/Command Tree savefiles/myTree.json".standardizePath);

)

////////////////////////////////////////////////////////////////////
// [2] Now run these line and watch the console
///////////////////////////////////////////////////////////////////

// Setup
~builder = MDCommandBuilder.new(~tree);
~queue = MDCommandQueue.new;

// Explore
~builder.listChildren;
~builder.currentNode.getDepth;
// what is the string
~builder.navigateToChild(6,3); // string 6 fret 3, branch A
~builder.listChildren;
~builder.currentNode.getDepth;
~builder.navigateToChild(5,7); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

~builder.reset; // we need this to start at root again

// Explore
~builder.listChildren;
~builder.navigateToChild(6,9); // e.g. Branch A
~builder.listChildren;
~builder.navigateToChild(5,12); // e.g. Twig A1b
~builder.printCurrentPath;

~builder.getCurrentCommand;
// Add to queue
~queue.addCommand(~builder.getCurrentCommand);

// Export
~queue.queue.postln; // To inspect queue contents directly
~queue.exportToEnv;

~commandToSend;
~commandToSend = nil;


===== CommandTree/Tests/TestLogging_CommandTree.scd =====
// TestLogging_CommandTree.scd
// v0.1.6
// MD 20250923-1007

(
/*
Purpose
- Load the canonical CommandTree JSON used by LivePedalboardSystem.
- Print a useful summary: structure, counts, payload coverage, and canonical command paths.
- Validate and export a .tmp snapshot; list saved versions if available.
- No early returns; no nonstandard List methods; do NOT reassign payloads here.

Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/

var jsonPrimary, jsonFallback, jsonPathUsed;
var tree, ok, proceed;
var totalNodes, leafCount, leavesAll, leavesWithPayload, payloadCoverage, payloadPctStr;
var findByName, commandsNode, haveCommands, samplePaths, tmpPath;

// small helpers (known-good)
var showFirstN, buildPathFromSegments;

MDMiniLogger.get.setverbosity(3);

// choose path (prefer LivePedalboardSuite; fall back to MDclasses if present)
jsonPrimary  = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonFallback = Platform.userExtensionDir
    ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
jsonPathUsed = if(File.exists(jsonPrimary)) { jsonPrimary } { jsonFallback };
("JSON path → " ++ jsonPathUsed).postln;

// load
tree = MDCommandTree.new("root");
ok = tree.importJSONFile(jsonPathUsed);
("import ok → " ++ ok).postln;
proceed = ok;

// helpers
showFirstN = { |listIn, nIn|
  var lim, out, i;
  lim = nIn ? 8;
  if(lim > listIn.size) { lim = listIn.size };
  out = List.new; i = 0;
  while({ i < lim }, { out.add(listIn[i]); i = i + 1 });
  out.asArray
};

buildPathFromSegments = { |segs|
  var out, i, lim;
  out = ""; i = 0; lim = segs.size;
  while({ i < lim }, { out = out ++ "/" ++ segs[i]; i = i + 1 });
  out
};

// continue only if loaded
if(proceed) {
  // tag depths (do NOT call assignPayloads; we keep canonical payloads written by the editor)
  tree.root.tagByDepth(0);

  // pretty tree
  "--- Tree (pretty) ---".postln;
  tree.printTreePretty;

  // stats
  "--- Stats ---".postln;
  totalNodes = tree.nodeMap.size;
  leafCount  = tree.root.countLeavesOnly;
  ("nodes=" ++ totalNodes ++ "  leaves=" ++ leafCount).postln;

  // payload coverage (leaves) — informative only
  leavesAll = List.new;
  tree.nodeMap.values.do({ |n| if(n.isLeaf) { leavesAll.add(n) } });
  leavesWithPayload = leavesAll.select({ |n| n.payload.notNil });
  payloadCoverage = (leavesWithPayload.size.asFloat / (leavesAll.size.max(1).asFloat)) * 100.0;
  payloadPctStr = (payloadCoverage.round(0.1)).asString ++ "%";
  ("payload coverage=" ++ leavesWithPayload.size ++ "/" ++ leavesAll.size
   ++ " (" ++ payloadPctStr ++ ")").postln;

  // robust name lookup across versions (tree/root; findNodeByName or getNodeByName)
  findByName = { |nameString|
    var n;
    n = if(tree.respondsTo(\findNodeByName)) { tree.findNodeByName(nameString) } { nil };
    if(n.isNil and: { tree.respondsTo(\getNodeByName) }) { n = tree.getNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\findNodeByName) }) { n = tree.root.findNodeByName(nameString) };
    if(n.isNil and: { tree.root.respondsTo(\getNodeByName) }) { n = tree.root.getNodeByName(nameString) };
    n
  };

  // commands branch diagnostic — print canonical "/verb/arg/..." by deriving paths
  "--- Commands branch (if present) ---".postln;
  commandsNode = findByName.("commands");
  haveCommands = commandsNode.notNil;
  ("have 'commands' → " ++ haveCommands).postln;
  if(haveCommands) {
    var leafPaths, traverse;
    leafPaths = List.new;

    traverse = { |node, segs|
      if(node.isLeaf) {
        leafPaths.add(buildPathFromSegments.(segs));
      }{
        node.children.do({ |child|
          var nextSegs;
          nextSegs = segs.copy;
          nextSegs.add(child.name.asString);
          traverse.(child, nextSegs);
        });
      }
    };

    // seed traversal under "commands"
    commandsNode.children.do({ |child|
      traverse.(child, [child.name.asString]);
    });

    samplePaths = showFirstN.(leafPaths, 8);
    ("sample payloads: " ++ samplePaths.asString).postln;
  };

  // validate & export tmp
  tree.validateTree;
  tmpPath = jsonPathUsed ++ ".tmp";
  tree.exportJSONFile(tmpPath);
  ("exported → " ++ tmpPath).postln;

  // saved versions, if configured
  "--- Saved versions ---".postln;
  tree.listSavedVersions;

  "done.".postln;
}{
  ("⚠️ Import failed; nothing to print for " ++ jsonPathUsed).postln;
};
)

===== Demo-simulated/Sim_MIDIInput_Emulator_For_TreeNav.scd =====
// Sim_MIDIInput_Emulator_For_TreeNav.scd
// v0.1.2
// MD 20250924-1510
/*
Purpose
- Emulate hardware control of your system:
  • FOOT controller: mode changes (idle/prog/queue/send).
  • MIDI GUITAR: string/fret → channel/pitch → tree navigation.
- Keep everything in ONE file; evaluate section-by-section.

Style
- var-first in every block/closure; lowercase methods; no server.sync.
- Works with your current LivePedalboardSystem, CommandManager, and adapter bridge.
- Generated audio only (no SoundIn); Option A exclusivity remains enforced by your bring-up.
*/

// ───────────────────────────────────────────────────────────────────────────
// [0] Bring-up (idempotent): system + GUI + MagicPedalboard + adapter bridge
//    Evaluate once after a fresh compile (or re-run to refresh).
// ───────────────────────────────────────────────────────────────────────────
(
var needNew, systemRef;

// If an older system exists, shut it down cleanly.
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) {
    ~system.shutdownAll;
};

// Create (or reuse) the LivePedalboardSystem and bring everything up.
needNew = (~system.isNil);
if(needNew) {
    systemRef = LivePedalboardSystem.new(nil); // nil → class default JSON path resolver
    ~system = systemRef;
};

~system.bringUpAll;          // server + GUI + pedalboard + command system + meters
~system.installAdapterBridge; // queueExportCallback routes SHORT canonicals to MPB via adapter

// Convenience handles
~cm  = ~system.commandManager;
~mm  = ~cm.midiManager;
~mpb = ~system.pedalboard;
~gui = ~system.statusDisplay;

"✅ System is up. (~system, ~cm, ~mm, ~mpb, ~gui)".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [1] Emulation helpers (define once)
//    These call your actual handlers—no MIDI devices required.
//    FOOT MAPPING (noteOn): 36→\idle, 38→\prog, 40→\queue, 41→\send
//    GUITAR MAPPING (channels 0..5 → strings 6..1) with bases [40,45,50,55,59,64]
// ───────────────────────────────────────────────────────────────────────────
(
var ensure, bases;

// Basic guard so we don't call handlers before bring-up.
ensure = {
    var ok;
    ok = ~system.notNil
     and: { ~system.commandManager.notNil }
     and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "⚠️ Run section [0] (bring-up) first.".warn };
    ok
};

// E A D G B E (low→high), per your GuitarMIDIHandler
bases = IdentityDictionary[
    0 -> 40,  // chan 0 → string 6 (E2)
    1 -> 45,  // chan 1 → string 5 (A2)
    2 -> 50,  // chan 2 → string 4 (D3)
    3 -> 55,  // chan 3 → string 3 (G3)
    4 -> 59,  // chan 4 → string 2 (B3)
    5 -> 64   // chan 5 → string 1 (E4)
];

// FOOT: emulate pressing a foot button (note number).
~fc = { arg noteNumber;
    var mmLocal;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    // channel is irrelevant for FootControllerHandler; value = note number.
    mmLocal.footControllerHandler.handleMessage(0, \noteOn, noteNumber.asInteger);
};

// Foot shortcuts
~toIdle  = { ~fc.(36) };  // idle
~toProg  = { ~fc.(38) };  // prog (tree navigation)
~toQueue = { ~fc.(40) };  // queue (enqueue current canonical)
~toSend  = { ~fc.(41) };  // send  (export & apply queue via bridge)

// GUITAR: emulate “play fret” on given string (1..6).
// Computes channel = 6 - string, pitch = base + fret; calls your GuitarMIDIHandler.
~gm = { arg stringNum, fret;
    var mmLocal, chan, base, pitch;
    if(ensure.().not) { ^nil };
    mmLocal = ~system.commandManager.midiManager;
    chan = (6 - stringNum.asInteger).clip(0, 5);
    base = bases[chan];
    if(base.isNil) { "⚠️ Invalid string number.".warn; ^nil };
    pitch = base + fret.asInteger;
    mmLocal.guitarHandler.handleMessage(chan, \noteOn, pitch);
};

// Convenience alias for navigation (string,fret)
~nav = { arg s, f; ~gm.(s, f) };

// Peek: print the builder’s path and the canonical short form (e.g., "/add/delay").
~showNav = {
    var cm, b, long, short;
    if(ensure.().not) { ^nil };
    cm = ~system.commandManager;
    b  = cm.builder;
    b.printPathToRoot;
    long  = cm.buildLongPathFromBuilder(b);
    short = cm.canonicalPathFromBuilder(b);
    ("• long=" ++ long ++ "  |  canonical=" ++ short).postln;
};

// Optional: show available choices in GUI (if present)
~refreshChoices = {
    if(~system.notNil) { ~system.commandManager.updateDisplay };
};
)

// ───────────────────────────────────────────────────────────────────────────
// [2] Scenario A — Add delay to NEXT via guitar nav, then switch
//    Top-level/children/grandchildren frets per your mapping:
//    string 6 fret 1 → "audio", string 5 fret 5 → "timebased", string 4 fret 3 → "delay"
//    Then queue (note 40) and send (note 41) → adapter applies "/add/delay"
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();           // enter navigation mode
~refreshChoices.();   // optional UI refresh
~nav.(6, 1);          // 6/1 → audio
~nav.(5, 5);          // 5/5 → timebased
~nav.(4, 3);          // 4/3 → delay
~showNav.();          // should report canonical "/add/delay"
~toQueue.();          // enqueue
~toSend.();           // apply via adapter
done = true;
"✅ Scenario A complete (add delay, then you can use Scenario B to switch).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [3] Scenario B — Switch chain from top-level “switch”
//    string 6 fret 5 → "switch" → queue → send
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();
~nav.(6, 5);      // top-level "switch"
~showNav.();      // should be "/switch"
~toQueue.();
~toSend.();
done = true;
"✅ Scenario B complete (switch with guarded crossfade).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [4] Scenario C — Bypass: chain → bypass → delay → on
//    Adjust frets if your JSON uses slightly different grandchildren numbers.
//    Example: 6/3="chain", 5/9="bypass", 4/3="delay", 3/3="on"
// ───────────────────────────────────────────────────────────────────────────
(
var done;
~toProg.();
~nav.(6, 3);   // "chain"
~nav.(5, 9);   // "bypass"
~nav.(4, 3);   // "delay"
~nav.(3, 3);   // "on"    // change to actual fret if needed
~showNav.();
~toQueue.();
~toSend.();
done = true;
"✅ Scenario C complete (bypass delay ON).".postln;
)

// ───────────────────────────────────────────────────────────────────────────
// [5] Quick extras
//    • Re-run [2] then [3] to hear the effect.
//    • To bypass OFF, redo [4] but pick “…/off” as per your tree’s leaf fret.
//    • Inspect the current queue at any time:
//        ~system.commandManager.midiManager.queue.commandList.postln;
// ───────────────────────────────────────────────────────────────────────────

===== LivePedalboardSystem/Start_LivePedalboardSystem.scd =====
// Start_LivePedalboardSystem.scd
// v0.2.7
// MD 20250923-1331

/*
Purpose
- Canonical entry to construct LivePedalboardSystem and call bringUpAll.
- Install the queue→adapter bridge so SHORT canonical commands are applied via the adapter.

Style
- var-first; Function.defer (not thisProcess.defer); no server.sync; AppClock-safe.
*/

// --- Option A: explicit path (uncomment to use) ---
//(
//     {
//         var customPath;
//         if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
//         customPath = Platform.userExtensionDir
//             ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
//         ~system = LivePedalboardSystem.new(customPath);
//         ~system.bringUpAll;
//         ~system.installAdapterBridge;   // ← ONE LINE
//     }.defer;
//)

// --- Option B: rely on class default (preferred day to day)
(
    {
        var systemRef;
        if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
        systemRef = LivePedalboardSystem.new(nil);  // nil → class default in LivePedalboardSuite
        ~system = systemRef;
        ~system.bringUpAll;



	    ~system.installAdapterBridge;         // ← MUST be before enableAutoMeters


	    // *** NEW: inline meter taps + post-switch auto-reinstall + GUI re-arm
    ~system.enableAutoMeters(18, 0.35);
    }.defer;
)


===== LivePedalboardSystem/Tests/Fallback_Acceptance_PassFail.scd =====
// Fallback_Acceptance_PassFail.scd
// v0.1.0 — 2025-09-23 16:20 BST (MD)
//
// Purpose
// - Run: /add/delay → /switch → /bypass/delay/on → /bypass/delay/off → /switch
// - After each switch, assert A XOR B and post PASS/FAIL.
// Style
// - var-first everywhere; AppClock scheduling; Server.default.bind for Ndefs; no server.sync.

(
var say, assertXor, ok, mpb, gui, useAdapter;
var ensureSources, applyViaAdapter, applyDirect, applyOne, stepSeries, gap, i, sched;

say = { |msg| ("[ACCEPT] " ++ msg).postln };
assertXor = { |expectA, expectB, label|
    var aPlay, bPlay, okFlag, tag;
    aPlay  = Ndef(\chainA).isPlaying;
    bPlay  = Ndef(\chainB).isPlaying;
    okFlag = (aPlay == expectA) and: { bPlay == expectB };
    tag    = if(okFlag) { "PASS" }{ "FAIL" };
    (tag ++ " — " ++ label ++ " (A=" ++ aPlay ++ " B=" ++ bPlay ++ ")").postln;
};

ok = (~system.notNil) and: { ~system.pedalboard.notNil };
if(ok.not) { say.("⚠️ Bring-up first (Start Option B)."); ^nil; };
mpb = ~system.pedalboard;
gui = ~system.statusDisplay;
useAdapter = (~ct_applyOSCPathToMPB.notNil);

ensureSources = {
    var defined;
    defined = false;
    Server.default.bind({
        var needMelody, needSilent;
        needMelody = Ndef(\testmelody).source.isNil;
        needSilent = Ndef(\ts0).source.isNil;
        if(needMelody) {
            Ndef(\testmelody, {
                var trig, seqd, f, env, pan;
                trig = Impulse.kr(3.2);
                seqd = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f    = Demand.kr(trig, 0, seqd);
                env  = Decay2.kr(trig, 0.01, 0.35);
                pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
        if(needSilent) { Ndef(\ts0, { Silent.ar(2) }) };
        Ndef(\ts0).ar(2);
        Ndef(\chainA).ar(2);
        Ndef(\chainB).ar(2);
    });
    if(mpb.respondsTo(\setSourceCurrent)) { mpb.setSourceCurrent(\testmelody) };
    if(mpb.respondsTo(\enforceExclusiveCurrentOptionA)) { mpb.enforceExclusiveCurrentOptionA(0.1) };
    say.("sources ensured; Option A enforced (if present).");
};

applyViaAdapter = { |path|
    var canShow;
    say.("apply → " ++ path);
    ~ct_applyOSCPathToMPB.(path, mpb, gui);
    canShow = gui.notNil and: { gui.respondsTo(\showExpectation) };
    if(canShow) { gui.showExpectation("Sent: " ++ path, 0) };
};

applyDirect = { |path|
    var segs, verb, key, src, onOff, state;
    segs = path.asString.split($/).reject({ |s| s.size == 0 });
    if(segs.size == 0) { ^nil };
    verb = segs[0].asString;
    say.("direct → " ++ path);
    switch(verb,
        "add", {
            if(segs.size >= 2 and: { mpb.respondsTo(\add) }) {
                key = segs[1].asSymbol; mpb.add(key);
            };
        },
        "setSource", {
            if(segs.size >= 2 and: { mpb.respondsTo(\setSource) }) {
                src = segs[1].asSymbol; mpb.setSource(src);
            };
        },
        "switch", {
            if(mpb.respondsTo(\switchChain)) { mpb.switchChain(0.12) };
        },
        "bypass", {
            if(segs.size >= 3) {
                key   = segs[1].asSymbol;
                onOff = segs[2].asString.toLower;
                state = (onOff == "on") or: { onOff == "true" } or: { onOff == "1" };
                if(mpb.respondsTo(\bypassCurrent)) { mpb.bypassCurrent(key, state) } {
                    if(mpb.respondsTo(\bypass)) { mpb.bypass(key, state) };
                };
            };
        },
        { /* no-op */ }
    );
};

applyOne = { |path| if(useAdapter) { applyViaAdapter.value(path) }{ applyDirect.value(path) } };

stepSeries = [
    { applyOne.value("/add/delay") },
    { applyOne.value("/switch"); assertXor.(false, true,  "after first switch") },
    { applyOne.value("/bypass/delay/on") },
    { applyOne.value("/bypass/delay/off") },
    { applyOne.value("/switch"); assertXor.(true,  false, "after second switch") }
];

gap = 0.60;
i   = 0;

sched = {
    if(i >= stepSeries.size) { say.("done."); ^nil; };
    stepSeries[i].value;
    i = i + 1;
    AppClock.sched(gap, { sched.value; nil });
};

ensureSources.value;
AppClock.sched(0.0, { sched.value; nil });
)

===== LPDisplay/Migration_tests/archived/ Close_LPDisplayLayoutWindow.scd =====
// Close_LPDisplayLayoutWindow.scd
// v0.1.0
// MD 20251003-1110

/* Purpose/Style:
- Find and close any open windows whose name matches LPDisplayLayoutWindow (or default).
*/

(
var closedCount;

closedCount = 0;
Window.allWindows.do({ |w|
    var matches;
    matches = (w.name == "LPDisplayLayoutWindow") or: { w.name.contains("LPDisplayLayoutWindow") };
    matches.if({
        w.close;
        closedCount = closedCount + 1;
    });
});

("Closed LPDisplayLayoutWindow windows: " ++ closedCount.asString).postln;
)
===== LPDisplay/Migration_tests/archived/Test_LPS_WindowManager_BringUp.scd =====
// Test_LPS_WindowManager_BringUp.scd
// v0.1.2
// MD 20251003-1138

/* Purpose/Style:
- Acceptance: enforce a single GUI window using the manager, building LPDisplayLayoutWindow.
- Returns '-> a Window'.
*/

(
var createdWindow, windowPrefix, builderFunction, desiredTitle;

("Running: Test_LPS_WindowManager_BringUp.scd").postln;

windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

// Builder must return a Window
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.notNil.if({
        createdWindowLocal.name = requestedTitle;
    });
    createdWindowLocal
};

// Bring up exactly one window and front it
createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);

// Return -> a Window
createdWindow
)
===== LPDisplay/Migration_tests/Close_LPDisplayLayoutWindow.scd =====
// Close_LPDisplayLayoutWindow.scd
// v0.1.1
// MD 20251003-1120

/* Purpose/Style:
- Close any windows created by LPDisplayLayoutWindow tests.
- Matches both "Layout Test" and names containing "LPDisplayLayoutWindow".
- Style: var-first, descriptive names, no single-letter locals.
*/

(
var closedCount;

closedCount = 0;

Window.allWindows.do({ |w|
    var windowName;
    windowName = w.name.asString;
    if(windowName == "Layout Test" or: { windowName.contains("LPDisplayLayoutWindow") }) {
        w.close;
        closedCount = closedCount + 1;
    };
});

("Closed LPDisplayLayoutWindow windows: " ++ closedCount).postln;
closedCount
)
===== LPDisplay/Migration_tests/LivePedalboardSystem_WindowManager_Install.scd =====
// LivePedalboardSystem_WindowManager_Install.scd
// v0.2.2
// MD 20251003-1248

/* Purpose/Style:
- Install ALL LivePedalboardSystem GUI helpers right here (single source of truth):
  * policy prefix
  * find/close/bring-up (single-window invariant)
  * front and front-or-bring-up
  * bounds save/load/apply (NO onClose hooks)
- Known-good SC only; idempotent installs via isNil.if (no '??' auto-eval).
- Style: tilde vars, var-first, descriptive names, lowercase methods.
*/

(
var ensure;

("Running: LivePedalboardSystem_WindowManager_Install.scd").postln;

ensure = {
    // --- policy prefix
    ~lps_windowPrefix.isNil.if({
        ~lps_windowPrefix = "MagicDisplayGUI";
    });

    // --- find windows by prefix
    ~lps_findWindowsByPrefix.isNil.if({
        ~lps_findWindowsByPrefix = { |prefix|
            var effectivePrefix, matchingWindows;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            matchingWindows = Window.allWindows.select({ |win|
                var windowName;
                windowName = win.name.asString;
                windowName.notNil and: { windowName.beginsWith(effectivePrefix) }
            });
            matchingWindows
        };
    });

    // --- close windows by prefix
    ~lps_closeWindowsByPrefix.isNil.if({
        ~lps_closeWindowsByPrefix = { |prefix|
            var windowsToClose, closedCount;
            windowsToClose = ~lps_findWindowsByPrefix.(prefix).copy; // avoid mutating while iterating
            closedCount = 0;
            windowsToClose.do({ |win|
                win.close;
                closedCount = closedCount + 1;
            });
            closedCount
        };
    });

    // --- bring up exactly one window via builder
    ~lps_bringUpSingleWindow.isNil.if({
        ~lps_bringUpSingleWindow = { |prefix, buildFunc, desiredTitle|
            var effectivePrefix, existing, windowTitle, createdWindow;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            windowTitle = desiredTitle ?? { effectivePrefix };
            existing = ~lps_findWindowsByPrefix.(effectivePrefix);

            if(existing.size == 1) {
                createdWindow = existing.first;
                if(createdWindow.name.asString != windowTitle) { createdWindow.name = windowTitle };
                createdWindow.front;
                createdWindow
            } {
                // Close *all* of ours, then build fresh
                ~lps_closeWindowsByPrefix.(effectivePrefix);
                createdWindow = buildFunc.value(windowTitle);
                if(createdWindow.notNil and: { createdWindow.isKindOf(Window) }) {
                    createdWindow.name = windowTitle;
                    createdWindow.front;
                };
                createdWindow
            }
        };
    });

    // --- front existing (non-destructive)
    ~lps_frontByPrefix.isNil.if({
        ~lps_frontByPrefix = { |prefix|
            var effectivePrefix, wins;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            wins = ~lps_findWindowsByPrefix.(effectivePrefix);
            wins.notEmpty.if({ wins.first.front; wins.first }, { nil })
        };
    });

    // --- front or bring-up
    ~lps_frontOrBringUpByPrefix.isNil.if({
        ~lps_frontOrBringUpByPrefix = { |prefix, buildFunc, desiredTitle|
            var effectivePrefix, win;
            effectivePrefix = prefix ?? { ~lps_windowPrefix };
            win = ~lps_frontByPrefix.(effectivePrefix);
            win.notNil.if({ win }, {
                ~lps_bringUpSingleWindow.(effectivePrefix, buildFunc, desiredTitle)
            })
        };
    });

    // --- bounds: prefs dir + file path
    ~lps_prefsDir.isNil.if({
        ~lps_prefsDir = Platform.userExtensionDir +/+ "LivePedalboardSuite" +/+ "prefs";
    });

    ~lps_boundsFilePathForPrefix.isNil.if({
        ~lps_boundsFilePathForPrefix = { |prefix|
            var safePrefix;
            safePrefix = prefix ?? { ~lps_windowPrefix };
            ~lps_prefsDir +/+ (safePrefix ++ "_window_bounds.txt")
        };
    });

    // --- save bounds (guards for nils)
    ~lps_saveWindowBounds.isNil.if({
        ~lps_saveWindowBounds = { |window, prefix|
            var filePath, rect, content;
            if(window.isNil) { "saveWindowBounds: window is nil".warn; ^nil };
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(~lps_prefsDir).if({ }, { File.mkdir(~lps_prefsDir) });
            rect = window.bounds;
            if(rect.isNil) { "saveWindowBounds: window.bounds is nil".warn; ^nil };
            content = [rect.left, rect.top, rect.width, rect.height].collect(_.asString).join(" ");
            File.use(filePath, "w", { |f| f.write(content) });
            ("Saved bounds to: " ++ filePath ++ " -> " ++ content).postln;
            filePath
        };
    });

    // --- load bounds
    ~lps_loadWindowBounds.isNil.if({
        ~lps_loadWindowBounds = { |prefix|
            var filePath, content, parts, rect;
            filePath = ~lps_boundsFilePathForPrefix.(prefix);
            File.exists(filePath).if({
                content = File.readAllString(filePath);
                parts = content.split($ );
                if(parts.size >= 4) {
                    rect = Rect(parts[0].asFloat, parts[1].asFloat, parts[2].asFloat, parts[3].asFloat);
                    ("Loaded bounds from: " ++ filePath ++ " -> " ++ rect.asString).postln;
                    rect
                } {
                    ("Bounds file malformed: " ++ filePath ++ " -> '" ++ content ++ "'").warn;
                    nil
                }
            }, {
                ("No saved bounds at: " ++ filePath).postln;
                nil
            })
        };
    });

    // --- apply bounds (guard: rect not nil)
    ~lps_applyLastWindowBounds.isNil.if({
        ~lps_applyLastWindowBounds = { |window, prefix|
            var rect;
            if(window.isNil) { "applyLastWindowBounds: window is nil".warn; ^nil };
            rect = ~lps_loadWindowBounds.(prefix);
            if(rect.notNil) {
                window.bounds = rect;
                ("Applied saved bounds: " ++ rect.asString).postln;
            };
            window
        };
    });
};

ensure.();
)
===== LPDisplay/Migration_tests/LivePedalboardSystem_WindowManager.scd =====
// LivePedalboardSystem_WindowManager.scd
// v0.1.0
// MD 20251003-1028

/* Purpose/Style:
- Utilities to enforce a single GUI window for LivePedalboardSystem.
- Default prefix is "MagicDisplayGUI"; you can override per call.
- Style: tilde vars, var-first, descriptive names, no single-letter locals.
*/

(
var ensureDefaults;

("Running: LivePedalboardSystem_WindowManager.scd").postln;

ensureDefaults = {
    ~lps_windowPrefix = ~lps_windowPrefix ?? { "MagicDisplayGUI" };

    ~lps_findWindowsByPrefix = ~lps_findWindowsByPrefix ?? { |prefix|
        var effectivePrefix, matchingWindows;
        effectivePrefix = prefix ?? { ~lps_windowPrefix };
        matchingWindows = Window.allWindows.select({ |win|
            var windowName;
            windowName = win.name.asString;
            windowName.notNil and: { windowName.beginsWith(effectivePrefix) }
        });
        matchingWindows
    };

    ~lps_closeWindowsByPrefix = ~lps_closeWindowsByPrefix ?? { |prefix|
        var windowsToClose, closedCount;
        windowsToClose = ~lps_findWindowsByPrefix.(prefix).copy; // copy to avoid modifying during iteration
        closedCount = 0;
        windowsToClose.do({ |win|
            win.close;
            closedCount = closedCount + 1;
        });
        closedCount
    };

    ~lps_bringUpSingleWindow = ~lps_bringUpSingleWindow ?? { |prefix, buildFunc, desiredTitle|
        var effectivePrefix, existing, windowTitle, createdWindow;

        effectivePrefix = prefix ?? { ~lps_windowPrefix };
        existing = ~lps_findWindowsByPrefix.(effectivePrefix);

        // Determine title we want to enforce; default to the prefix itself
        windowTitle = desiredTitle ?? { effectivePrefix };

        // Reuse if exactly one exists; otherwise close all and build fresh
        if(existing.size == 1) {
            createdWindow = existing.first;
            // normalize the title if different
            if(createdWindow.name.asString != windowTitle) {
                createdWindow.name = windowTitle;
            };
            createdWindow.front;
            createdWindow
        } {
            // remove strays and create a single window via builder
            ~lps_closeWindowsByPrefix.(effectivePrefix);

            // buildFunc must return a Window; we pass the title
            createdWindow = buildFunc.value(windowTitle);

            // ensure title and visibility
            if(createdWindow.notNil and: { createdWindow.isKindOf(Window) }) {
                createdWindow.name = windowTitle;
                createdWindow.front;
            };
            createdWindow
        }
    };
};

ensureDefaults.();
)
===== LPDisplay/Migration_tests/LPDisplay_Navigation_Smoke.scd =====
// LPDisplay_Navigation_Smoke.scd
// v0.1.1
// MD 20251003-1342

/* Purpose / Style
- Standalone CommandManager → LPDisplay via LPDisplayAdapter.
- Drive real navigation text into LPDisplay (System, Choices, Diag).
- Style: var-first; tilde vars; lowercase; known-good SC; AppClock only in classes.
*/

(
var cmLocal, adapterLocal, showNow;

// 1) CommandManager (standalone); it resolves default tree path inside the class
cmLocal = (~cm.notNil).if({ ~cm }, { CommandManager.new(nil) });
~cm = cmLocal;

// 2) Ensure adapter is present and bound to the current LPDisplay controller
adapterLocal = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
~lp_adapter = adapterLocal;
cmLocal.display = adapterLocal;

// 3) Small helper to refresh panes (declaring vars first INSIDE the block too)
showNow = {
    var hasCanon, canonText;

    hasCanon = ~cm.respondsTo(\canonicalPathFromBuilder) and: { ~cm.builder.notNil };
    canonText = if(hasCanon) { ~cm.canonicalPathFromBuilder(~cm.builder) } { "n/a" };

    // This triggers CommandManager → (legacy selectors) → adapter → LPDisplay panes
    ~cm.updateDisplay;

    // Show canonical "Next:" in Diag pane (non-destructive)
    (~guiLP.notNil).if({
        ~guiLP.sendPaneText(\diag, "Next: " ++ canonText.asString)
    });
};

// Public one-liners
~nav_show  = { showNow.value };
~nav_fret  = { arg fret; ~cm.builder.navigateByFret(nil, fret); showNow.value };
~nav_reset = { ~cm.builder.resetNavigation; showNow.value };

// Initial smoke
"Ready: ~nav_fret.(3), ~nav_fret.(5), ~nav_fret.(7) … ; and ~nav_reset.()".postln;
~nav_show.();

// Progress (in-memory only; no file I/O)
~md_progress = (~md_progress ? List.new).add("Sprint3 fixed: nav smoke v0.1.1 @ " ++ Date.localtime.stamp);
)
===== LPDisplay/Migration_tests/Start_LiveMagicPedalboardSuite_LPDisplay.scd =====
// Start_LiveMagicPedalboardSuite_LPDisplay.scd
// v0.1.6
// MD 20251003-1530

/* Purpose / Style
- (Re)open LPDisplay safely and return -> a Window.
- NON-DESTRUCTIVE to your running audio (no initTree, no defaultGroup.freeAll).
- Teardown only LPDisplay's controller + OSC responders between runs.
- Auto-bind LPDisplayAdapter to SYSTEM CommandManager *if ~system already exists*.
- Publishes ~guiLP (controller), ~lp_window (Window), ~lp_front helper.
- Style: tilde vars; var-first; lowercase; AppClock UI only; no server.sync.
*/

(
var ensureServerReady, freeOscdefIf, cleanupLPDisplayOnly, openLP, autoBindIfSystemExists, defaultServer, windowLocal;

ensureServerReady = {
    defaultServer = Server.default;
    defaultServer.waitForBoot({ "Server is up (non-destructive)".postln; });
    true
};

freeOscdefIf = { arg nameSymbol;
    var oscDef;
    oscDef = OSCdef.all.tryPerform(\at, nameSymbol);
    (oscDef.notNil).if({
        oscDef.free;
        ("Freed OSCdef: " ++ nameSymbol.asString).postln;
    });
    nil
};

cleanupLPDisplayOnly = {
    if(~guiLP.notNil) {
        ~guiLP.close;  // closes window and stops LPDisplay-owned responders/JIT state
        // belt-and-braces: free known OSCdef names if the controller exposes them
        [ ~guiLP.tryPerform(\oscNameA)
        , ~guiLP.tryPerform(\oscNameB)
        , ~guiLP.tryPerform(\oscConsoleA)
        , ~guiLP.tryPerform(\oscConsoleB)
        ].do({ arg sym; (sym.notNil).if({ freeOscdefIf.(sym) }) });
        ~guiLP = nil;
        ~lp_window = nil;
        "Closed previous LPDisplay instance (controller + responders).".postln;
    };
    nil
};

openLP = {
    var controller, win;
    controller = LPDisplayLayoutWindow.new(nil);   // start with raw 0..1 meters
    win = controller.open;                         // -> a Window
    win.tryPerform(\name_, "LPDisplay — LivePedalboard");
    ~guiLP = controller;
    ~lp_window = win;
    ~lp_front = { (~lp_window.notNil).if({ ~lp_window.front.alwaysOnTop_(true) }) };
    "LPDisplay is up. Try ~guiLP.sendPaneText(\\system, \"hello\");".postln;

    // optional: persist a log line if logger is installed
    (~md_log.notNil).if({ ~md_log.("LPDisplay bring-up v0.1.6") });

    win
};

autoBindIfSystemExists = {
    var cm, selectors, sel, adapter;
    // only bind if ~system already exists and exposes a CM under common names
    if(~system.notNil and: { LPDisplayAdapter.respondsTo(\new) }) {
        selectors = [\commandManager, \cmdManager, \cm, \manager];
        sel = selectors.detect({ arg s; ~system.respondsTo(s) and: { ~system.perform(s).notNil } });
        if(sel.notNil) {
            cm = ~system.perform(sel);
            adapter = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(~guiLP) });
            ~lp_adapter = adapter;
            cm.display = adapter;
            cm.updateDisplay;
            "Adapter bound to SYSTEM CommandManager.".postln;
            (~md_log.notNil).if({ ~md_log.("Auto-bound LPDisplayAdapter to SYSTEM CM via selector " ++ sel.asString) });
        };
    };
    nil
};

ensureServerReady.();
cleanupLPDisplayOnly.();

windowLocal = openLP.();
autoBindIfSystemExists.();

windowLocal.front.alwaysOnTop_(true);
windowLocal   // -> a Window
)
===== LPDisplay/Migration_tests/StartHere_BringUp_MagicDisplayGUI.scd =====
// StartHere_BringUp_MagicDisplayGUI.scd
// v0.1.1
// MD 20251003-1248

/* Purpose/Style:
- Bring up exactly ONE MagicDisplayGUI window using LPDisplayLayoutWindow.
- Applies saved bounds if present; stores ~lps_mainWindow.
- Returns '-> a Window'.
*/

(
var windowPrefix, desiredTitle, builderFunction, createdWindow;

("Running: StartHere_BringUp_MagicDisplayGUI.scd").postln;

// Require helpers to be loaded first (Install file)
(~lps_bringUpSingleWindow.isNil or: { ~lps_applyLastWindowBounds.isNil }).if({
    "ERROR: Window manager helpers are not installed. Run LivePedalboardSystem_WindowManager_Install.scd first.".warn;
    ^nil
});

// Policy + title
windowPrefix = "MagicDisplayGUI";
desiredTitle = "MagicDisplayGUI - LPDisplayLayout";

// Builder: prefer .open, fallback to .new; must return a Window
builderFunction = { |requestedTitle|
    var createdWindowLocal;
    createdWindowLocal = LPDisplayLayoutWindow.respondsTo(\open).if({
        LPDisplayLayoutWindow.open
    }, {
        LPDisplayLayoutWindow.new
    });
    createdWindowLocal.name = requestedTitle;
    createdWindowLocal
};

// Create/reuse single window, then apply saved bounds
createdWindow = ~lps_bringUpSingleWindow.(windowPrefix, builderFunction, desiredTitle);
~lps_applyLastWindowBounds.(createdWindow, windowPrefix);

// Store handle
~lps_mainWindow = createdWindow;

// Return -> a Window
createdWindow
)
===== LPDisplay/older versions/starting files/commands.scd =====
// commands.scd

// Make a -6 dBFS sine (≈ -9 dB RMS) hit the top of the meter:
~hud_set.(\top, -9);

// Keep deep floor and straight-in-dB mapping:
~hud_set.(\floor, -60);
~hud_set.(\gamma, 1.0);

// Sanity print current settings:
~hud_print.();

// Preview expected UI value for an RMS dB (useful for tone calibration):
~hud_preview.(-9);   // -6 dBFS sine ≈ -9 dB RMS
~hud_preview.(-18);

===== LPDisplay/older versions/starting files/LayoutTest_MeterCalibration_Patch.scd =====
// LayoutTest_MeterCalibration_Patch.scd
// v1.2 - calibrate existing Layout Test meters (dB mapping: top/floor/gamma) + balanced helpers
// MD 20250930

/* Purpose
   - Calibrate the already-running "Layout Test" meters using a perceptual dB mapping.
   - Keep audio graph and console logging untouched; rebind only the GUI meter OSCdefs.
   - Provide helpers to set/inspect mapping and to preview expected UI for a given RMS dB.

   Style
   - var-first declarations in every block/function
   - lowercase method names and descriptive identifiers
   - no non-local returns (^)
   - GUI updates via AppClock.defer
*/

(
var leftPaneName, rightPaneName;
var ensureHudVars, mapLinToUi, valueFromMsg;
var findByPaneLabel, bindLayoutUi, installMappedMeters;
var meterLeft, meterRight;

// --- pane labels (as used in WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd v1.8) ---
leftPaneName  = "Top Left Pane";
rightPaneName = "Top Right Pane";

// --- ensure globals & defaults exist (top = -6 dBFS RMS, floor = -60 dBFS RMS, gamma = 1.0) ---
ensureHudVars = {
    if(~hud_topDb.isNil)   { ~hud_topDb   = -6.0 };
    if(~hud_floorDb.isNil) { ~hud_floorDb = -60.0 };
    if(~hud_gamma.isNil)   { ~hud_gamma   = 1.0 };
};

// --- linear (0..1) -> UI (0..1) via dB headroom + gamma ---
mapLinToUi = { |lin, topDb, floorDb, gamma|
    var v, vdb, tdb, fdb, g, u;
    v   = lin.max(1e-9);     // avoid -inf
    vdb = v.ampdb;           // linear amplitude -> dB
    tdb = topDb.asFloat;
    fdb = floorDb.asFloat;
    g   = gamma.asFloat.max(1e-6);

    vdb = vdb.clip(fdb, tdb);
    u   = (vdb - fdb) / (tdb - fdb);
    u   = u.pow(g);
    u.clip(0.0, 1.0)
};

// --- extract meter value from SendPeakRMS OSC (use last element = final RMS) ---
valueFromMsg = { |msg|
    var v, sz;
    v = 0.0;
    if(msg.notNil) {
        sz = msg.size;
        if(sz >= 4) { v = msg[sz - 1].asFloat; };
    };
    v.clip(0.0, 1.0)
};

// --- locate a LevelIndicator under a pane identified by its label (StaticText string) ---
findByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, result, searchStatic, searchUnderParent;

    foundStatic = nil;
    result = nil;

    searchStatic = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(StaticText) and: { child.string == paneLabelString }) {
                foundStatic = child;
            }{
                searchStatic.(child);
            };
            i = i + 1;
        });
    };

    searchUnderParent = { |view|
        var i, n, child;
        i = 0; n = view.children.size;
        while({ i < n }, {
            child = view.children[i];
            if(child.isKindOf(LevelIndicator)) {
                if(result.isNil) { result = child; };
            }{
                searchUnderParent.(child);
            };
            i = i + 1;
        });
    };

    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        searchUnderParent.(foundStatic.parent);
    };
    result
};

// --- find existing "Layout Test" meters and cache them ---
bindLayoutUi = {
    var win, root;
    win = Window.allWindows.detect({ |w| w.name == "Layout Test" });
    if(win.isNil) {
        "Layout Test window not found. Start WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;
        meterLeft  = findByPaneLabel.(root, leftPaneName);
        meterRight = findByPaneLabel.(root, rightPaneName);
        if(meterLeft.isNil or: { meterRight.isNil }) {
            "Could not locate LevelIndicators in the Layout Test panes.".postln;
        }{
            ~lt_meterLeft  = meterLeft;
            ~lt_meterRight = meterRight;
            "Bound meters: left/right found.".postln;
        };
    };
};

// --- rebind only the GUI meter OSCdefs to apply mapping; keep console OSCdefs intact ---
installMappedMeters = {
    var a, b;

    a = OSCdef(\rmsA_toGUI);
    if(a.notNil) { a.free; };

    b = OSCdef(\rmsB_toGUI);
    if(b.notNil) { b.free; };

    OSCdef(\rmsA_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterLeft.value_(ui) }.defer;
    }, '/peakrmsA');

    OSCdef(\rmsB_toGUI, { |msg|
        var v, ui;
        v  = valueFromMsg.(msg);
        ui = mapLinToUi.(v, ~hud_topDb, ~hud_floorDb, ~hud_gamma);
        { ~lt_meterRight.value_(ui) }.defer;
    }, '/peakrmsB');

    ("Mapped meter responders installed (top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma ++ ").").postln;
};

// --- bring-up for this patch ---
ensureHudVars.();
bindLayoutUi.();
if(~lt_meterLeft.notNil and: { ~lt_meterRight.notNil }) {
    installMappedMeters.();
} {
    "Meter calibration patch not installed (meters not bound).".postln;
};

// --- balanced helpers (set/preview/print) ---
~hud_set = { |key, value|
    var k, v, tmp;
    k = key.asSymbol;
    v = value.asFloat;

    if(k == \top)   { ~hud_topDb   = v };
    if(k == \floor) { ~hud_floorDb = v };
    if(k == \gamma) { ~hud_gamma   = v.max(1e-6) };

    if(~hud_topDb <= ~hud_floorDb) {
        tmp = ~hud_topDb;
        ~hud_topDb = ~hud_floorDb + 0.1;
        ("Adjusted top to floor+0.1 dB (was " ++ tmp ++ ") to keep mapping valid.").postln;
    };

    ("HUD mapping set: top=" ++ ~hud_topDb
        ++ " dB, floor=" ++ ~hud_floorDb
        ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_preview = { |db|
    var top, floor, gamma, lin, dbClipped, u;
    top = ~hud_topDb.asFloat;
    floor = ~hud_floorDb.asFloat;
    gamma = ~hud_gamma.asFloat.max(1e-6);

    lin = db.dbamp.clip(1e-9, 1.0);
    dbClipped = lin.ampdb.clip(floor, top);
    u = (dbClipped - floor) / (top - floor);
    u = u.pow(gamma);
    ("UI -> " ++ u.round(0.003) ++ " for " ++ db ++ " dBFS RMS").postln;
    u
};

~hud_print = {
    ("HUD: top=" ++ ~hud_topDb ++ " dB, floor=" ++ ~hud_floorDb ++ " dB, gamma=" ++ ~hud_gamma).postln;
};

~hud_print.();
)

===== LPDisplay/older versions/starting files/LayoutTest_Quick_ChainChanges.scd =====
// LayoutTest_Quick_ChainChanges.scd
// v1.2 - calibrated test signals, pulses, sweeping BP noise; pane text one-liners for Layout Test
// MD 20250930

/* Purpose
   - Augment an already-running "Layout Test" session (v1.8) with ready-to-use test sources:
       • 100 Hz tones at -6/-12/-18/-24/-30 dBFS (stereo)
       • pulse clicks and decaying tone pulses for echo testing
       • band-passed noise with a sweeping center frequency
   - Provide one-line commands to:
       • switch A/B sources quickly
       • update text in the "Layout Test" panes (left/right/system/diag/choices/recv)
   - No new windows; no chain rebuild unless you choose to rewire explicitly.

   Style
   - var-first declarations in every function/block
   - lowercase names, descriptive identifiers
   - Ndef(left) <<> Ndef(right); sinks/processors use \in.ar(2)
   - no non-local returns (^); AppClock.defer for GUI updates
*/

(
// ---------- Setup: test sources + pane helpers (evaluate this block once) ----------
var defineCalTones, definePulses, defineSweepingNoise, dbList;
var bindLayoutPanes, findTextViewByPaneLabel, findWindowByName;

/*** Calibration tones (100 Hz, stereo) at set dBFS ***/
dbList = [-6, -12, -18, -24, -30];

defineCalTones = {
    var freqDefault, makeTone;
    freqDefault = 100;
    makeTone = { |nameSym, dbVal|
        var amp;
        amp = dbVal.dbamp;  // dBFS -> linear amplitude
        Ndef(nameSym, {
            var freq, sig;
            freq = \freq.kr(freqDefault).max(10);
            sig = SinOsc.ar([freq, freq], 0, amp);
            sig
        });
    };
    makeTone.(\tone_m0,  0);
    makeTone.(\tone_m6,  -6);
    makeTone.(\tone_m12, -12);
    makeTone.(\tone_m18, -18);
    makeTone.(\tone_m24, -24);
    makeTone.(\tone_m30, -30);
	makeTone.(\tone_m128, -128);

};

/*** Pulse sources (for echo audibility) ***/
definePulses = {
    // Wideband click bursts at low rate
    Ndef(\pulse_click, {
        var rate, env, noise, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);          // clicks per second
        env  = Decay2.kr(Impulse.kr(rate), 0.002, 0.08); // short burst envelope
        noise = PinkNoise.ar([0.5, 0.5]);
        sig = noise * env; // stereo
        sig
    });

    // Decaying 1 kHz tone "ping" at adjustable rate
    Ndef(\pulse_tone, {
        var rate, freq, env, tone, sig;
        rate = \rate.kr(1.0).clip(0.1, 10.0);
        freq = \freq.kr(1000).clip(50, 8000);
        env  = Decay2.kr(Impulse.kr(rate), 0.005, \dec.kr(0.3).clip(0.01, 2.0));
        tone = SinOsc.ar([freq, freq]);
        sig  = (tone * env) * 0.8;
        sig
    });

    // Pulse train (gate) on noise for rhythmic echoes
    Ndef(\pulse_train, {
        var rate, duty, gateCtl, noise, sig;
        rate = \rate.kr(2.0).clip(0.1, 20.0);
        duty = \duty.kr(0.25).clip(0.01, 0.95);
        gateCtl = LFPulse.kr(rate, 0, duty).lag(0.001); // soften edges slightly
        noise = WhiteNoise.ar([0.4, 0.4]);
        sig = noise * gateCtl;
        sig
    });
};

/*** Band-passed noise with sweeping center frequency ***/
defineSweepingNoise = {
    Ndef(\bp_sweep, {
        var base, range, sweepRate, center, rq, src, sig;
        base      = \base.kr(200).clip(20, 10000);
        range     = \range.kr(5000).clip(0, 18000);
        sweepRate = \rate.kr(0.07).clip(0.005, 2.0);   // Hz of sweep
        center    = base + (range * (LFTri.kr(sweepRate).range(0, 1)));
        rq        = \rq.kr(0.15).clip(0.01, 0.9);
        src       = PinkNoise.ar([0.5, 0.5]);
        sig       = BPF.ar(src, center, rq) * 1.2;     // modest makeup gain
        sig
    });
};

/*** Helpers to update text in the existing "Layout Test" panes ***/
findWindowByName = { |targetName|
    var match;
    match = Window.allWindows.detect({ |win| win.name == targetName });
    match
};

// This tries to find the TextView that pairs with a pane label (StaticText string)
findTextViewByPaneLabel = { |rootView, paneLabelString|
    var foundStatic, paneTextView, searchStatic, collectTextViews;

    foundStatic = nil;
    paneTextView = nil;

    searchStatic = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(StaticText) and: { childView.string == paneLabelString }) {
                foundStatic = childView;
            }{
                searchStatic.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    collectTextViews = { |view|
        var childIndex, childCount, childView;
        childIndex = 0;
        childCount = view.children.size;
        while({ childIndex < childCount }, {
            childView = view.children[childIndex];
            if(childView.isKindOf(TextView)) {
                if(paneTextView.isNil) { paneTextView = childView; };
            }{
                collectTextViews.(childView);
            };
            childIndex = childIndex + 1;
        });
    };

    // locate the StaticText with the pane label, then search its parent subtree for the first TextView
    searchStatic.(rootView);
    if(foundStatic.notNil and: { foundStatic.parent.notNil }) {
        collectTextViews.(foundStatic.parent);
    };

    paneTextView
};

// Cache and simple API
bindLayoutPanes = {
    var win, root, leftText, rightText, systemText, diagText, choicesText, recvText, map;

    win = findWindowByName.("Layout Test");
    if(win.isNil) {
        "Layout Test window not found. Open WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd first.".postln;
    }{
        root = win.view;

        leftText    = findTextViewByPaneLabel.(root, "Top Left Pane");
        rightText   = findTextViewByPaneLabel.(root, "Top Right Pane");
        systemText  = findTextViewByPaneLabel.(root, "System State");
        diagText    = findTextViewByPaneLabel.(root, "Diagnostic Messages");
        choicesText = findTextViewByPaneLabel.(root, "Choices");
        recvText    = findTextViewByPaneLabel.(root, "Receiving Commands");

        map = IdentityDictionary[
            \left   -> leftText,
            \right  -> rightText,
            \system -> systemText,
            \diag   -> diagText,
            \choices-> choicesText,
            \recv   -> recvText
        ];

        ~lt_panes = map;
        "Layout Test panes bound: %".format(map.keys).postln;
    };
};

// Public: set pane text by key (\left, \right, \system, \diag, \choices, \recv)
~lt_send = { |paneKey, aString|
    var panes, win, viewToSet, textString;
    panes = ~lt_panes;
    textString = aString.asString;
    if(panes.isNil) { bindLayoutPanes.(); panes = ~lt_panes; };
    if(panes.notNil) {
        viewToSet = panes[paneKey.asSymbol];
        if(viewToSet.notNil) {
            { viewToSet.string_(textString) }.defer;
        }{
            win = findWindowByName.("Layout Test");
            if(win.notNil) {
                "Pane '%' not found in Layout Test (bound keys: %).".format(paneKey, panes.keys).postln;
            }{
                "Layout Test window not found.".postln;
            };
        };
    };
};

// Define sources
defineCalTones.();
definePulses.();
defineSweepingNoise.();

// Convenience: quick status ping
"Quick Chain Changes ready: tones (tone_m6..tone_m30), pulses (pulse_click, pulse_tone, pulse_train), sweep (bp_sweep).".postln;
);


// ======================================================================
// ONE-LINERS (evaluate any of these as needed)
// ======================================================================

// ---------- 1) Switch A/B sources (updates the Top Left/Right pane text via your ~setSourceA/B) ----------
~setSourceA.(\tone_m0);
~setSourceA.(\tone_m6);
~setSourceA.(\tone_m12);
~setSourceA.(\tone_m18);
~setSourceA.(\tone_m24);
~setSourceA.(\tone_m30);
~setSourceA.(\tone_m128);
~setSourceA.(\pulse_click);
~setSourceA.(\pulse_tone);
~setSourceA.(\pulse_train);
~setSourceA.(\bp_sweep);

~setSourceB.(\tone_m0);
~setSourceB.(\tone_m6);
~setSourceB.(\tone_m12);
~setSourceB.(\tone_m18);
~setSourceB.(\tone_m24);
~setSourceB.(\tone_m30);
~setSourceB.(\tone_m128);
~setSourceB.(\pulse_click);
~setSourceB.(\pulse_tone);
~setSourceB.(\pulse_train);
~setSourceB.(\bp_sweep);

// ---------- 2) Tweak source parameters live (no chain rebuild needed) ----------
// Tones: set tone frequency for any calibration tone
Ndef(\tone_m6).set(\freq, 100);
Ndef(\tone_m12).set(\freq, 100);
Ndef(\tone_m18).set(\freq, 100);
Ndef(\tone_m24).set(\freq, 100);
Ndef(\tone_m30).set(\freq, 100);

// Pulses: rate / decay / pulse width
Ndef(\pulse_click).set(\rate, 1.0);     // clicks per second
Ndef(\pulse_tone).set(\rate, 1.2, \freq, 800, \dec, 0.25);
Ndef(\pulse_train).set(\rate, 2.0, \duty, 0.25);

// Band-passed sweep: base frequency, range, sweep rate, and resonance (rq)
Ndef(\bp_sweep).set(\base, 200, \range, 5000, \rate, 0.07, \rq, 0.15);
Ndef(\bp_sweep).set(\base, 100, \range, 8000, \rate, 0.12, \rq, 0.10);

// ---------- 3) Send text to Layout Test panes (single-liners) ----------
// First bind once (if not already bound):
~lt_send.(\system, "System ready — quick changes loaded.");
~lt_send.(\diag,   "Re-evaluated quick chain helpers at " ++ Date.getDate.stamp );
~lt_send.(\choices,"A: tone_m12 | B: pulse_train");
~lt_send.(\recv,   "Waiting for commands…");
~lt_send.(\left,   "Chain A: swap via ~setSourceA.(\\tone_m6)");
~lt_send.(\right,  "Chain B: swap via ~setSourceB.(\\bp_sweep)");

// ---------- 4) (Optional) Direct rewire one-liners (audio + meters update immediately; GUI labels do not) ----------
// A direct to specific source:
(Ndef(\outA) <<> Ndef(\tone_m6);   Ndef(\outA).play(numChannels: 2););
(Ndef(\outA) <<> Ndef(\pulse_tone); Ndef(\outA).play(numChannels: 2););

// B direct to specific source:
(Ndef(\outB) <<> Ndef(\bp_sweep);   Ndef(\outB).play(numChannels: 2););
(Ndef(\outB) <<> Ndef(\pulse_click); Ndef(\outB).play(numChannels: 2););

// ---------- 5) Quick recovery (go back to your original A/B defaults) ----------
~setSourceA.(\srcA);
~setSourceB.(\srcA);

===== LPDisplay/older versions/starting files/WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd =====
// WindowLayout_Grid_WithSigChainsAndMeters_Debug.scd
// v1.8 - minimal meter fix (last RMS value), 'ampdb' console, no non-local returns (^)
// MD 20250930

/* Purpose
   - Restore moving meters using a simple, robust extractor: take the last numeric (RMS) value in the OSC message.
   - Fix console level print by using 'ampdb' (lowercase).
   - Keep everything else unchanged: your chain helpers, GUI layout, and OSC bindings.
   - No non-local returns anywhere.

*/

(
var window, makePane, paneColor;
var topLeftText, topLeftMeter, topRightText, topRightMeter;

var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
var chainA, chainB, ensureStereo, rebuildChain, chainToString;
var setSourceA, setSourceB;

var valueFromMsg;

var countA = 0, countB = 0, firstDumpA = true, firstDumpB = true;

// ---------- GUI ----------
Window.allWindows.do({ |w| if(w.name == "Layout Test", { w.close }) });

window = Window("Layout Test", Rect(100, 100, 800, 600))
    .background_(Color.white)
    .front;

paneColor = Color(0.0, 0.35, 0.0);

makePane = { |content, label|
    var labelView, inner, pane, inset;
    labelView = StaticText()
        .string_(label)
        .align_(\center)
        .stringColor_(Color.white)
        .background_(paneColor);
    inner = VLayout(labelView, content);
    pane = UserView().layout_(inner);
    pane.drawFunc_({ |v|
        inset = 0.5;
        Pen.use {
            Pen.color = paneColor;
            Pen.width = 1;
            Pen.addRect(Rect(inset, inset, v.bounds.width - (2 * inset), v.bounds.height - (2 * inset)));
            Pen.stroke;
        };
    });
    pane
};

window.layout = GridLayout.rows(
    [
        makePane.(HLayout(
            topLeftText  = TextView().editable_(false),
            topLeftMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Left Pane"),
        makePane.(HLayout(
            topRightText  = TextView().editable_(false),
            topRightMeter = LevelIndicator().fixedWidth_(30)
        ), "Top Right Pane")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "System State"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Diagnostic Messages")
    ],
    [
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Choices"),
        makePane.(VLayout(StaticText().align_(\center), TextView()), "Receiving Commands")
    ]
);

// ---------- Audio graph + sigChains ----------
oscNameA     = \rmsA_toGUI;
oscNameB     = \rmsB_toGUI;
oscConsoleA  = \rmsA_console;
oscConsoleB  = \rmsB_console;

Server.default.waitForBoot({
    // --- SOURCES (stereo) ---
	Ndef(\srcZ, { Silent.ar(numChannels:1) });
    Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
    Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
    Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

    // --- RECEIVERS (sinks) MUST declare \in.ar(2); they also meter to GUI ---
    // Keep replyIDs A=1, B=2 to match earlier dumps.
    Ndef(\outA, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1);

		/*
		//TEST TextVU:
		// it works but is just difficult to read between the rest of the console messages. Nice though.
		TextVU.ar(2, sig, "sinkA"); // 2 = trig 2Hz
        */

		sig
    });

    Ndef(\outB, {
        var sig;
        sig = \in.ar(2);
        SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2);
        sig
    });

    // --- Chain helpers (mirrors your sigChainOperations style) ---
    ensureStereo = { |key|
        var bus;
        bus = Ndef(key).bus;
        if(bus.isNil or: { bus.rate != \audio } or: { bus.numChannels != 2 }) {
            Ndef(key).ar(2);  // pre-arm as stereo audio before wiring
        };
    };

    chainToString = { |anArray|
        var forward;
        forward = anArray.copy.reverse; // [source, ..., sink]
        forward.collect(_.asString).join(" → ")
    };

    rebuildChain = { |anArray|
        var i;
        i = 0;
        if(anArray.size < 2) {
            "need at least [sink, source]".postln;
        }{
            anArray.do(ensureStereo);
            i = 0;
            while({ i < (anArray.size - 1) }, {
                Ndef(anArray[i]) <<> Ndef(anArray[i + 1]);  // left receives right at \in
                i = i + 1;
            });
            Ndef(anArray[0]).play(numChannels: 2);  // play the sink
        };
    };

    // --- INITIAL CHAINS ---
    chainA = [\outA, \srcA];   // chainA: sink ... source
    chainB = [\outB, \srcB];   // chainB
    rebuildChain.(chainA);
    rebuildChain.(chainB);

    // --- (Re)bind OSC responders (avoid duplicates on re-eval) ---
    { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

    // --- Minimal, robust extractor for meter value: take the last number (typically final RMS) ---
    valueFromMsg = { |msg|
        var v, sz;
        v = 0.0;
        if(msg.notNil) {
            sz = msg.size;
            if(sz >= 4) {  // enough to have at least one (peak,rms) after node+reply
                v = msg[sz - 1].asFloat;  // last element; usually an RMS
            };
        };
        v.clip(0.0, 1.0) // MAYBE ADD if v< 0.0 or v >1.0  warning to console
    };

    // GUI meter updaters (20 Hz)
    OSCdef(oscNameA, { |msg| { topLeftMeter.value_(valueFromMsg.(msg))  }.defer; }, '/peakrmsA');
    OSCdef(oscNameB, { |msg| { topRightMeter.value_(valueFromMsg.(msg)) }.defer; }, '/peakrmsB');

    // Console printers (~1 Hz by decimation) + first-message dump (uses ampdb, lowercase)
    OSCdef(oscConsoleA, { |msg|
        var v;
        if(firstDumpA) { "A first msg: %".format(msg).postln; firstDumpA = false; };
        countA = countA + 1;
        if(countA >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("A level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countA = 0;
        };
    }, '/peakrmsA');

    OSCdef(oscConsoleB, { |msg|
        var v;
        if(firstDumpB) { "B first msg: %".format(msg).postln; firstDumpB = false; };
        countB = countB + 1;
        if(countB >= 20) {
            v = valueFromMsg.(msg).max(1e-6);
            ("B level: " ++ (v.ampdb.round(0.1)) ++ " dB  (" ++ v.round(0.003) ++ ")").postln;
            countB = 0;
        };
    }, '/peakrmsB');

    // Show full chain strings in the GUI
    {
        topLeftText.string_(chainToString.(chainA));
        topRightText.string_(chainToString.(chainB));
    }.defer;
});

// ---------- Convenience: change ONLY the source at the tail of each chain ----------
setSourceA = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainA[chainA.size - 1] = newSym;
    rebuildChain.(chainA);
    { topLeftText.string_(chainToString.(chainA)) }.defer;
};

setSourceB = { |srcSym|
    var newSym;
    newSym = srcSym.asSymbol;
    chainB[chainB.size - 1] = newSym;
    rebuildChain.(chainB);
    { topRightText.string_(chainToString.(chainB)) }.defer;
};

~setSourceA = setSourceA;
~setSourceB = setSourceB;

// ---------- Cleanup ----------
window.onClose = {
    Ndef(\outA).stop;
    Ndef(\outB).stop;
    OSCdef(oscNameA).free;
    OSCdef(oscNameB).free;
    OSCdef(oscConsoleA).free;
    OSCdef(oscConsoleB).free;
};

window  // -> a Window
)

===== MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd =====
// adapter_commandtree_to_magicpedalboard.scd
// v0.3.1
// MD 20250916-14:49

(

var alreadyWrapped;

~ct_knownVerbs = #[\add, \bypass, \removeAt, \swap, \clear, \setSource, \switch];
~ct_knownProcs = #[\delay, \chorus, \tremolo, \reverb, \drive, \transpose, \hex, \audio, \filters, \delays, \noise, \oscillators];
~ct_log = { arg messageString; ("[CT->MPB] " ++ messageString).postln };

~ct_normalizeTokens = { arg oscPathString;
    var rawTokens, tokens;
    rawTokens = oscPathString.asString.split($/).reject({ arg one; one.isEmpty });
    tokens = if(rawTokens.size > 0 and: { rawTokens[0].asSymbol == \commands }) {
        rawTokens.copyRange(1, rawTokens.size - 1)
    }{
        rawTokens
    };
    tokens.collect({ arg one; one.asSymbol })
};

~ct_applyOneVerb = { arg tokens, pedalboard, gui;
    var consumed, verb, params, indexCount;
    consumed = 0;
    if(tokens.isEmpty) { ^0 };
    verb = tokens[0];
    params = tokens.copyRange(1, tokens.size - 1);

    switch(verb,

/*        \add, {
            if(params.size >= 1) { pedalboard.add(params[0]); ~ct_log.("add " ++ params[0]); consumed = 2; }
            { ~ct_log.("add: missing processor"); consumed = 1; };
        },*/
\add, {
    if(params.size >= 1) {
        var procSym;
        procSym = params[0].asSymbol;
        ~ct_ensureProcessor.(procSym);        // <-- ensure Ndef exists and is stereo
        pedalboard.add(procSym);
        ~ct_log.("add " ++ procSym);
        consumed = 2;
    }{
        ~ct_log.("add: missing processor"); consumed = 1;
    };
},

		\bypass, {
            if(params.size >= 2) {
                var procSym, stateBool;
                procSym = params[0];
                stateBool = (params[1] == \on);
                pedalboard.bypass(procSym, stateBool);
                ~ct_log.("bypass " ++ procSym ++ " -> " ++ stateBool);
                consumed = 3;
            }{ ~ct_log.("bypass: need proc and on/off"); consumed = 1; };
        },
        \removeAt, {
            if(params.size >= 1) {
                var indexInteger;
                indexInteger = params[0].asString.asInteger;
                pedalboard.removeAt(indexInteger);
                ~ct_log.("removeAt " ++ indexInteger);
                consumed = 2;
            }{ ~ct_log.("removeAt: need index"); consumed = 1; };
        },
        \swap, {
            if(params.size >= 2) {
                var aIndex, bIndex;
                aIndex = params[0].asString.asInteger;
                bIndex = params[1].asString.asInteger;
                pedalboard.swap(aIndex, bIndex);
                ~ct_log.("swap " ++ aIndex ++ " <-> " ++ bIndex);
                consumed = 3;
            }{ ~ct_log.("swap: need two indices"); consumed = 1; };
        },
        \clear, { pedalboard.clearChain; ~ct_log.("clear NEXT"); consumed = 1; },
        \setSource, {
            if(params.size >= 1) { pedalboard.setSource(params[0]); ~ct_log.("setSource " ++ params[0]); consumed = 2; }
            { ~ct_log.("setSource: missing symbol"); consumed = 1; };
        },
        \switch, { pedalboard.switchChain(0.12); ~ct_log.("switch crossfade"); consumed = 1; },
        {
            if(~ct_knownProcs.includes(verb)) {
                pedalboard.add(verb); ~ct_log.("add (fallback) " ++ verb); consumed = 1;
            }{ ~ct_log.("unknown verb: " ++ verb); consumed = 1; };
        }
    );
    consumed
};

~ct_applyOSCPathToMPB = { arg oscPathString, pedalboard, gui;
    var tokens, tokenIndex, consumedNow, appliedCount, tailTokens;
    tokens = ~ct_normalizeTokens.(oscPathString);
    if(tokens.isEmpty) { ~ct_log.("empty OSC path"); ^false };
    ~ct_log.("path=" ++ oscPathString ++ "  tokens=" ++ tokens);
    tokenIndex = 0; appliedCount = 0;
    while({ tokenIndex < tokens.size }, {
        tailTokens = tokens.copyRange(tokenIndex, tokens.size - 1);
        consumedNow = ~ct_applyOneVerb.(tailTokens, pedalboard, gui);
        if(consumedNow <= 0) { consumedNow = 1 };
        tokenIndex = tokenIndex + consumedNow;
        appliedCount = appliedCount + 1;
    });
    appliedCount > 0
};

~ct_applyQueueToMPBFromCM = { arg commandManager, pedalboard, gui;
    var oscPathString, listSnapshot;
    listSnapshot = commandManager.midiManager.queue.commandList;
    ~ct_log.("queue snapshot: " ++ listSnapshot);
    oscPathString = commandManager.midiManager.queue.exportAsOSCPath;
    ~ct_log.("exported path: " ++ oscPathString);
    ~ct_applyOSCPathToMPB.(oscPathString, pedalboard, gui);
    commandManager.midiManager.queue.clear;
    true
};

~ct_sendAndApply = { arg commandManager, pedalboard, gui;
    ~ct_applyQueueToMPBFromCM.(commandManager, pedalboard, gui);
};



// 0) Capture the original adapter exactly once so we can delegate non-switch paths safely.
alreadyWrapped = (~ct_applyOSCPathToMPB_raw.notNil);
if(alreadyWrapped.not) {
    ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB;
};

// 1) Helper: guard NEXT tail before switch, then audit after fade and recover if needed.

~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal, myGen;

    // initialize state vars once
    if(~ct_switchBusy.isNil) { ~ct_switchBusy = false };
    if(~ct_switchGen.isNil)  { ~ct_switchGen  = 0     };

    // prevent overlapping switches (re-entrant safe)
    if(~ct_switchBusy == true) {
        "[CT->MPB] switch ignored (busy)".postln;
        ^nil;
    };

    ~ct_switchBusy = true;
    ~ct_switchGen  = ~ct_switchGen + 1;
    myGen          = ~ct_switchGen;

    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last    = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            // Use the original adapter to avoid wrapping recursion
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    auditAndFix = {
        var a, b;
        // ignore stale audits from older generations
        if(~ct_switchGen != myGen) { ^nil };

        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;

        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;

        // release busy flag only after our generation’s audit runs
        ~ct_switchBusy = false;
    };

    fadeLocal = fade ? 0.12;

    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);

    // schedule audit a bit after the fade completes; protect with generation check
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};


/*~ct_switchWithRecovery = { arg mpb, gui, fade = 0.12;
    var ensureNextAudible, auditAndFix, fadeLocal;

    // Ensure NEXT ends with an audible source before switching.
    ensureNextAudible = {
        var effNext, last;
        effNext = mpb.effectiveNext;
        last = effNext[effNext.size - 1];
        if(last == \ts0) {
            "[CT->MPB] guard: NEXT tail \\ts0 -> /setSource/testmelody".postln;
            ~ct_applyOSCPathToMPB_raw.("/setSource/testmelody", mpb, gui);
        };
    };

    // After the crossfade, check A/B; if both false, make CURRENT audible and re-enforce Option A.
    auditAndFix = {
        var a, b;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        if((a or: { b }).not) {
            "[CT->MPB] post-switch audit: both stopped -> recovering CURRENT & OptionA".postln;
            mpb.playCurrent;
            mpb.enforceExclusiveCurrentOptionA(0.1);
        };
        ("[PLAY] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
    };

    fadeLocal = fade ? 0.12;
    ensureNextAudible.value;
    mpb.switchChain(fadeLocal);
    AppClock.sched(fadeLocal + 0.20, { auditAndFix.value; nil });
};*/

// 2) Wrapper adapter: intercept ONLY "/switch"; delegate all other paths to the original.
~ct_applyOSCPathToMPB = { arg path, mpb, gui;
    var p, f;
    p = path.asString;
    if(p == "/switch") {
        f = 0.12; // keep your usual fade; adjust if you use a different default
        ~ct_switchWithRecovery.(mpb, gui, f);
    }{
        ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
    };
};


~ct_ensureProcessor = { arg keySym;
    var k;
    k = keySym.asSymbol;

    Server.default.bind({
        var defineDelay, defineBypass, defineIdentity;

        defineIdentity = {
            var make;
            make = {
                // pass-through “processor” that keeps stereo and \in.ar(2)
                // used as a safe fallback for unknown keys
                Ndef(k, { var sig; sig = \in.ar(2); sig });
                Ndef(k).ar(2);
            };
            if(Ndef(k).source.isNil) { make.value } { Ndef(k).ar(2) };
        };

        defineDelay = {
            var make;
            make = {
                // simple stereo delay: read from \in.ar(2) → short delay → mix
                Ndef(\delay, {
                    var sig, del, time, fb, mix;
                    sig  = \in.ar(2);
                    time = 0.25;   // s
                    fb   = 0.25;
                    mix  = 0.5;
                    del  = DelayC.ar(sig + (LocalIn.ar(2) * fb), 1.0, time);
                    LocalOut.ar(del);
                    XFade2.ar(sig, del, (mix * 2 - 1).clip(-1, 1))
                });
                Ndef(\delay).ar(2);
            };
            if(Ndef(\delay).source.isNil) { make.value } { Ndef(\delay).ar(2) };
        };

        defineBypass = {
            // A named pass-through “processor” you might use in test chains
            var make;
            make = {
                Ndef(\bypass, { \in.ar(2) });
                Ndef(\bypass).ar(2);
            };
            if(Ndef(\bypass).source.isNil) { make.value } { Ndef(\bypass).ar(2) };
        };

        // choose per key
        if(k == \delay) { defineDelay.value }
        { if(k == \bypass) { defineBypass.value } { defineIdentity.value } };
    });
};


)

===== MagicPedalboard/MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd =====
// MagicDisplayGUI_PerfHUD_MeterResponders_Ext.scd
// v0.1.0
// MD 2025-09-26 15:36 BST

/* Purpose
   Install language-side responders for /ampA and /ampB so that, even when
   AutoMeters emits those paths (instead of /md/levels), we keep populating
   ~md_levelsById (A=2001, B=2002) used by PerfHUD meters.
   - var-first; descriptive lowercase; AppClock-only; no server.sync.
*/

(

	//new
	var ensureAmpRespondersInstalled;
var installHudMeterMappingHelpers;


~md_installAmpToModelResponders = {
    var ensureModel, existingA, existingB;




    ensureModel = {
        ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
        ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
        nil
    };
    ensureModel.();

    // /ampA -> model[2001]
    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };
    OSCdef(\ampA_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2001, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    // /ampB -> model[2002]
    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };
    OSCdef(\ampB_to_model, { arg msg;
        var leftVal, rightVal;
        leftVal  = (msg.size >= 4).if({ msg[3] }, { 0 }).asFloat.clip(0, 1);
        rightVal = (msg.size >= 5).if({ msg[4] }, { 0 }).asFloat.clip(0, 1);
        ~md_levelsById.put(2002, [leftVal, rightVal]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
    nil
};


ensureAmpRespondersInstalled = {
    var hasAmpA, hasAmpB;

    hasAmpA = OSCdef.all.at(\ampA_to_model).notNil;
    hasAmpB = OSCdef.all.at(\ampB_to_model).notNil;

    if(hasAmpA.not or: { hasAmpB.not }) {
        (~md_installAmpToModelResponders ? { nil }).value;
        "[HUD] ensured ampA/ampB responders installed.".postln;
    };
    nil
};

installHudMeterMappingHelpers = {
    // Display calibration (keeper defaults; tweak to taste)
    ~hud_meter_floor_db = ~hud_meter_floor_db ? -60.0; // visual floor
    ~hud_meter_top_db   = ~hud_meter_top_db   ? -6.0;  // headroom so typical peaks don't peg
    ~hud_meter_gamma    = ~hud_meter_gamma    ? 1.0;   // 1.0=linear; <1 raises lows; >1 tames lows

    // Linear (0..1) → UI value (0..1) with dB headroom and optional curve
    ~hud_map_linear_to_ui = { arg linearValue;
        var dbValue, normalizedValue, curvedValue, floorDb, topDb, gammaValue;
        floorDb    = ~hud_meter_floor_db;
        topDb      = ~hud_meter_top_db;
        gammaValue = ~hud_meter_gamma;

        dbValue = (max(linearValue, 1e-7)).log10 * 20.0;             // linear → dB
        normalizedValue = dbValue.linlin(floorDb, topDb, 0.0, 1.0);  // dB → 0..1 (with top < 0 dBFS)
        normalizedValue = normalizedValue.clip(0.0, 1.0);
        curvedValue = normalizedValue.pow(gammaValue);                // perceptual shaping (optional)
        curvedValue
    };

    "[HUD] meter mapping helpers installed (floor/top/gamma)".postln;
    nil
};

AppClock.sched(0.0, { ensureAmpRespondersInstalled.(); nil });
AppClock.sched(0.0, { installHudMeterMappingHelpers.(); nil });

)

===== MagicPedalboard/MagicProcessorLibrary_defs.scd =====
/* MagicProcessorLibrary_defs.scd
   Register a few defaults. Keep this file small and readable.
*/
(
var lib, define;

lib = MagicProcessorLibrary.new;

define = { arg key, func; lib.register(key, func) };

// Sources
define.(\ts0, {
    var inputSignal;
    inputSignal = Silent.ar((0..1));
    inputSignal * 1.0
});

// Effects – same as in bootstrap, or your refined versions
define.(\delay, {
    var inputSignal, time, fb, mix, delayed;
    inputSignal = \in.ar;
    time = \time.kr(0.35).clip(0.01, 2.0);
    fb   = \fb.kr(0.35).clip(0.0, 0.95);
    mix  = \mix.kr(0.25).clip(0.0, 1.0);
    delayed = CombC.ar(inputSignal, 2.0, time, time * (fb * 6 + 0.1));
    XFade2.ar(inputSignal, delayed, (mix * 2 - 1))
});

define.(\tremolo, {
    var inputSignal, rate, depth;
    inputSignal = \in.ar;
    rate  = \rate.kr(5).clip(0.1, 20);
    depth = \depth.kr(0.5).clip(0, 1);
    inputSignal * SinOsc.kr(rate).range(1 - depth, 1)
});

define.(\reverb, {
    var inputSignal, mix, room, damp;
    inputSignal = \in.ar;
    mix  = \mix.kr(0.25).clip(0, 1);
    room = \room.kr(0.5).clip(0, 1);
    damp = \damp.kr(0.3).clip(0, 1);
    XFade2.ar(inputSignal, FreeVerb2.ar(inputSignal[0], inputSignal[1], mix, room, damp), 0)
});

define.(\chorus, {
    var inputSignal, rate, depth, baseDelay, modDelay;
    inputSignal = \in.ar;
    rate      = \rate.kr(0.8).clip(0.1, 5);
    depth     = \depth.kr(0.008).clip(0.0, 0.02);
    baseDelay = \base.kr(0.020).clip(0.0, 0.05);
    modDelay  = baseDelay + (SinOsc.kr(rate, 0, depth));
    DelayC.ar(inputSignal, 0.1, modDelay)
});

define.(\drive, {
    var inputSignal, gain;
    inputSignal = \in.ar;
    gain = \gain.kr(2.5).clip(1, 10);
    (inputSignal * gain).tanh
});

// Expose the library in a tilde var for convenience
~procLib = lib;

// Ensure a basic set now (optional; you can call ensureFromChain later)
~procLib.ensureMany(~procLib.keys, 2);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_HealthCheck.scd =====
(
// MPBTest_Run_HealthCheck.scd
// v0.1.2
// MD 20250920-2015

var pass, fail, scen, suite1, suite2, startWhenReady;

pass = 0;
fail = 0;

// Kick bring-up (fresh boot, Grid GUI default, publish tildes)
~bring = MPBTest_BringUp.new(true, 2, 0.40, true, true);

// Poll until bring-up finished and server is running, then start scenarios
startWhenReady = {
    if(
        (~bring.notNil) and: { ~bring.isReady } and: { Server.default.serverRunning }
    ) {
        // Belt-and-braces: keep CURRENT-only invariant and meters attached
        ~mpb.enforceExclusiveCurrentOptionA(0.1);
        if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
            ~gui.enableMeters(false); ~gui.enableMeters(true);
        };

        // Scenario runner (+ default CT path applier if present)
        scen   = MPBTest_Scenario.new(~mpb, ~gui).useDefaultAdapterIfPresent;
        suite1 = MPBTest_AcceptanceSuites.classic(0.12);
        suite2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

        scen.run(suite1);

        AppClock.sched(0.40, {
            MPBTest_Assertions.xorPlaying(false, true).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(1.40, {
            MPBTest_Assertions.xorPlaying(true, false).if({ pass = pass + 1 }, { fail = fail + 1 });
            nil
        });

        AppClock.sched(2.20, { scen.run(suite2); nil });

        AppClock.sched(3.40, {
            ~mpb.printChains;
            if(~gui.notNil and: { ~gui.respondsTo(\enableMeters) }) {
                ~gui.enableMeters(false); ~gui.enableMeters(true);
            };
            ("[HEALTH] PASS=" ++ pass ++ " FAIL=" ++ fail).postln;
            nil
        });

    }{
        AppClock.sched(0.05, startWhenReady);
    };
    nil
};

AppClock.sched(0.00, startWhenReady);
)

===== MagicPedalboard/MPBTest/Scripts/MPBTest_Run_OneGo.scd =====
// MPBTest_Run_OneGo.scd
// v0.1.0
// MD 20250920-1608

(
var bring, mpb, gui, scen, steps1, steps2;

bring = MPBTest_BringUp.new(true, 2);
mpb = bring.getPedalboard;
gui = bring.getGui;

scen = MPBTest_Scenario.new(mpb, gui).useDefaultAdapterIfPresent;

steps1 = MPBTest_AcceptanceSuites.classic(0.12);
steps2 = MPBTest_AcceptanceSuites.mutatorsBasic(0.12);

scen.run(steps1);
AppClock.sched(0.40, { MPBTest_Assertions.xorPlaying(false, true);  nil });
AppClock.sched(1.40, { MPBTest_Assertions.xorPlaying(true,  false); nil });

AppClock.sched(2.20, { scen.run(steps2); nil });
)

===== MagicPedalboard/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "⚠️ ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "⚠️ CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "⚠️ queueExportCallback missing.".warn };
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd =====
// MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15.scd
// v0.3.15
// MD timestamp: 2025-09-25

/* Purpose
   - Attach A(2001)/B(2002) level probes directly *after* Ndef(\chainA/\chainB) groups.
   - Read each Ndef's actual output bus (mono or stereo).
   - Neutralize any in-proxy meter/tap filters to avoid duplicate /md/levels.
   - Announce actions in console so logs clearly show what ran.

   Style
   - var-first; no non-local returns (^); descriptive lowercase names; known-good SC syntax.
*/

(
var announce, ensureProbeDefs, neutralizeInProxyFilters,
    detectInfo, freeIfPlaying, attachAfterNdef,
    aInfo, bInfo, ok;

announce = {
    var ok2;
    ok2 = true;
    "=== RUN MagicDisplayGUI_Attach_ProbesAfterNdefs_v0.3.15 ===".postln;
    ok2;
};

ensureProbeDefs = {
    var ok2, defMono, defStereo;

    ok2 = true;

    // mono probe: reads 1 channel, sends a single float
    defMono = SynthDef(\md_levelProbe_1ch, { |inBus = 0, replyID = 2001|
        var sig, amp, ticker;
        sig = In.ar(inBus, 1);
        amp = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amp, replyID);
        // no audio output
    }).add;

    // stereo probe: reads 2 channels, sends an array of two floats
    defStereo = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 2001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
        // no audio output
    }).add;

    ok2;
};

neutralizeInProxyFilters = {
    var ok2;

    ok2 = true;

    // Overwrite prior filters/taps to identity so they do nothing
    if (Ndef(\chainA).notNil and: { Ndef(\chainA).respondsTo(\filter) }) {
        Ndef(\chainA).filter(\mdMeterA, { |in| in });
        Ndef(\chainA).filter(\mdProbeTapA, { |in| in });
    };
    if (Ndef(\chainB).notNil and: { Ndef(\chainB).respondsTo(\filter) }) {
        Ndef(\chainB).filter(\mdMeterB, { |in| in });
        Ndef(\chainB).filter(\mdProbeTapB, { |in| in });
    };

    ok2;
};

// Inspect an Ndef and report (exists, playing, bus index, channel count, group)
detectInfo = { |name|
    var proxy, info, isThere, isPlaying, busIdx, numCh, group;

    proxy = Ndef(name);

    isThere = proxy.notNil;
    isPlaying = false;
    busIdx = -1;
    numCh = 2;
    group = nil;

    if (isThere) {
        isPlaying = proxy.isPlaying;
        if (proxy.bus.notNil) {
            busIdx = proxy.bus.index;
            if (proxy.bus.respondsTo(\numChannels)) {
                numCh = proxy.bus.numChannels.max(1).min(2);
            };
        };
        group = proxy.group;
    };

    info = (
        key: name,
        exists: isThere,
        playing: isPlaying,
        bus: busIdx,
        ch: numCh,
        group: group
    );

    (name.asString ++ ": exists=" ++ isThere.asString
        ++ " playing=" ++ isPlaying.asString
        ++ " bus=" ++ busIdx.asString
        ++ " ch=" ++ numCh.asString).postln;

    info;
};

freeIfPlaying = { |node|
    var ok2;
    ok2 = true;
    if (node.notNil) {
        if (node.respondsTo(\isPlaying)) {
            if (node.isPlaying) { node.free; };
        } {
            if (node.respondsTo(\free)) { node.free; };
        };
    };
    ok2;
};

// Create a probe group AFTER the Ndef's group and attach the proper probe synth.
// Uses setter closures to store references in ~vars (no reflection).
attachAfterNdef = { |info, replyID, setGroupFunc, setSynthFunc, freeOldSynthFunc|
    var ok2, grp, synth, inBus, numCh, groupTarget;

    ok2 = true;
    grp = nil;
    synth = nil;
    inBus = info[\bus];
    numCh = info[\ch];
    groupTarget = info[\group];

    if (info[\exists] and: { inBus >= 0 } and: { groupTarget.notNil }) {
        // free the previous synth if any (quietly)
        freeOldSynthFunc.value;

        s.bind({
            grp = Group.after(groupTarget);

            if (numCh == 1) {
                synth = Synth.tail(grp, \md_levelProbe_1ch, [\inBus, inBus, \replyID, replyID]);
            } {
                synth = Synth.tail(grp, \md_levelProbe_2ch, [\inBus, inBus, \replyID, replyID]);
            };
        });

        setGroupFunc.value(grp);
        setSynthFunc.value(synth);

        ((info[\key].asString ++ " probe attached: nodeID=" ++ synth.nodeID.asString
            ++ " afterGroup=" ++ grp.nodeID.asString
            ++ " inBus=" ++ inBus.asString
            ++ " ch=" ++ numCh.asString
            ++ " replyID=" ++ replyID.asString)).postln;
    } {
        (info[\key].asString ++ ": cannot attach (exists=" ++ info[\exists].asString
            ++ " playing=" ++ info[\playing].asString
            ++ " bus=" ++ info[\bus].asString ++ ").").postln;
    };

    ok2;
};

// ---------- run sequence ----------
ok = true;
announce.value;

ensureProbeDefs.value;

// Ensure our base routing exists WITHOUT clearing your Ndefs
if (~md_ensureRouting.notNil) { ~md_ensureRouting.value; };

// Avoid duplicate SendReply by neutralizing any in-proxy filters/taps
neutralizeInProxyFilters.value;

// Detect chains (prints status)
aInfo = detectInfo.value(\chainA);
bInfo = detectInfo.value(\chainB);

// Attach probes AFTER the Ndef groups (ordering-safe)
attachAfterNdef.value(
    aInfo, 2001,
    { |g| ~md_probeGroupA = g },            // set group
    { |sy| ~md_probeA = sy },               // set synth
    { freeIfPlaying.value(~md_probeA); ~md_probeA = nil }  // free old synth if any
);

attachAfterNdef.value(
    bInfo, 2002,
    { |g| ~md_probeGroupB = g },
    { |sy| ~md_probeB = sy },
    { freeIfPlaying.value(~md_probeB); ~md_probeB = nil }
);

"Attach_ProbesAfterNdefs: done.".postln;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.5.scd
// v0.3.5
// MD timestamp: 2025-09-25

/* Purpose
   - Reboot the server to a known-clean state.
   - Define SynthDefs (fixed 2ch), create a private bus, groups, relay-to-hardware and a level probe.
   - Install an OSC receiver bound to '/md/levels' (matches SendReply).
   - Publish robust public API with auto-heal:
       ~md_reinstallReceiver, ~md_ensureRouting, ~md_startTestSource, ~md_stopTestSource, ~md_cleanup

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase names; no server.sync; server ops wrapped in s.bind.
   - generated audio only; probe reads a private bus; compile-time channel counts.
*/

(
var bootServerClean, defineSynthDefs, reinstallReceiver, createRouting, definePublicAPI, printSummary;

bootServerClean = {
    var ok;

    ok = true;

    // Close any MagicDisplayGUI windows
    {
        var windows, i, w, nameString;
        windows = Window.allWindows;
        i = 0;
        while { i < windows.size } {
            w = windows[i];
            nameString = w.name.asString;
            if (nameString.beginsWith("MagicDisplayGUI")) {
                w.close;
            };
            i = i + 1;
        };
    }.value;

    // Reset client-side state vars
    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = 0.0;
    ~md_testSynth = nil;
    ~md_probe = nil;
    ~md_toHardware = nil;
    ~md_mixBus = nil;
    ~md_srcGroup = nil;
    ~md_meterGroup = nil;
    ~md_outGroup = nil;

    // Reboot server to a known state
    if (s.serverRunning) {
        s.quit;
    };
    s.boot;

    s.waitForBoot({
        var ok2;
        ok2 = true;
        s.initTree;
        s.defaultGroup.freeAll;
        ok2;
    });

    ok;
};

defineSynthDefs = {
    var ok, def_testSource, def_toHardware2, def_levelProbe2;

    ok = true;

    // Test source (stereo beeps)
    def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.28|
        var trig, freqSeq, sig, env, stereo;
        trig = Impulse.kr(2);
        freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
        env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
        sig = SinOsc.ar(freqSeq) * env;
        stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
        Out.ar(outBus, stereo * amp);
    }).add;

    // Relay to hardware (2ch fixed)
    def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
        var sig;
        sig = In.ar(inBus, 2);
        Out.ar(0, sig);
    }).add;

    // Level probe (2ch fixed) → '/md/levels'
    // Message format: ['/md/levels', nodeID, replyID, val1, val2, ...]
    def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, replyID = 1001|
        var sig, amps, ticker;
        sig = In.ar(inBus, 2);
        amps = Amplitude.kr(sig, 0.01, 0.30);
        ticker = Impulse.kr(20);
        SendReply.kr(ticker, "/md/levels", amps, replyID);
    }).add;

    ok;
};

// Install or re-install the OSC receiver (binds to '/md/levels')
reinstallReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];
    ~md_lastLevelAt = Main.elapsedTime;

    OSCdef(
        \md_levels,
        { |msg, time, addr, recvPort|
            var nodeId, replyId, count, i, outArray;

            nodeId = 0;
            replyId = 0;
            count = 0;
            i = 0;
            outArray = nil;

            if (msg.size >= 3) {
                nodeId = msg[1].asInteger;
                replyId = msg[2].asInteger;

                count = msg.size - 3;
                outArray = Array.newClear(count);

                i = 0;
                while { i < count } {
                    outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                    i = i + 1;
                };

                ~levels = outArray;
                ~md_lastLevelAt = Main.elapsedTime;
            };
        },
        '/md/levels',
        recvPort: NetAddr.langPort
    );

    true;
};

// Create routing (fresh bus + fresh groups + relay + probe). Clears default group first.
createRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        // Clear any stale nodes from previous runs
        s.defaultGroup.freeAll;

        // Fresh bus
        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };
        ~md_mixBus = Bus.audio(s, 2);

        // Fresh groups in strict order: src -> meter -> out
        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        // Relay and probe (safe even without source)
        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \replyID, 1001]);

        // No source yet
        ~md_testSynth = nil;
    });

    ok;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_reinstallReceiver = {
        var ok2;
        ok2 = true;
        reinstallReceiver.value;
        ok2;
    };

    // Always rebuild routing to avoid stale groups after a server reboot
    ~md_ensureRouting = {
        var ok2;
        ok2 = true;
        createRouting.value;
        reinstallReceiver.value;
        ok2;
    };

    ~md_startTestSource = {
        var ok2;

        ok2 = true;

        ~md_ensureRouting.value;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.28]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    // Clean everything (leave server running)
    ~md_cleanup = {
        var ok2;

        ok2 = true;

        s.bind({
            s.defaultGroup.freeAll;
        });

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        ~levels = [0.0, 0.0];
        ~md_lastLevelAt = 0.0;

        ~md_testSynth = nil;
        ~md_probe = nil;
        ~md_toHardware = nil;
        ~md_srcGroup = nil;
        ~md_meterGroup = nil;
        ~md_outGroup = nil;

        ok2;
    };

    ok;
};

printSummary = {
    var ok;

    ok = true;

    "MagicDisplayGUI bring-up complete:".postln;
    ("  mixBus index: " ++ (if (~md_mixBus.notNil) { ~md_mixBus.index } { "nil" }).asString).postln;
    "  API: ~md_startTestSource, ~md_stopTestSource, ~md_cleanup".postln;
    "  Guards: ~md_ensureRouting, ~md_reinstallReceiver".postln;
    "  OSC: listening on /md/levels".postln;

    ok;
};

// ---------- Run sequence ----------
"Booting server clean...".postln; bootServerClean.value;
"Defining SynthDefs...".postln; defineSynthDefs.value;
"Creating routing...".postln; createRouting.value;
"Installing OSC receiver...".postln; reinstallReceiver.value;
"Publishing public API...".postln; definePublicAPI.value;
printSummary.value;

// Usage:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
// ~md_ensureRouting.value;
// ~md_reinstallReceiver.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd =====
// MagicDisplayGUI_New_ServerBootAndProbe_v0.3.7.scd
// v0.3.7
// MD 2025-09-25 15:10 BST

/*
Purpose
- Non-destructive bring-up of OSC receiver and A/B meters:
  A) Preferred: inline in-proxy taps on Ndef(\chainA/\chainB) using .filter + SendReply.kr
     -> /md/levels with replyIDs A=2001, B=2002. Returns input unchanged (no sound-path change).
  B) Optional: after-group bus probes with explicit ordering and compile-time 2ch SynthDef.
- Provides tiny API used by the GUI script:
  ~md_startTestSource, ~md_stopTestSource, ~md_cleanup
  ~md_ensureRouting (NON-DESTRUCTIVE)
  ~md_reinstallReceiver
  ~md_attachProbesAB(busA, busB), ~md_attachProbeFinal(bus), ~md_detachAllProbes
Style
- var-first everywhere; descriptive lowercase names; no server.sync.
- AppClock for UI only; Server.default.bind for server ops.
- Generated audio only (tests); no SoundIn. No destructive freeAll in ensure.
*/

(
// === RUN ===
var s, ensureDictionaries, installReceiver, neutralizeFilter, installInlineMeters, installTestTap;
var makeAfterGroupProbeDef, attachProbeAB, detachAllProbes, ensureRouting;
var startTestSource, stopTestSource, banner, ids, rateHz;

var windowNote, apiNote;

s = Server.default;
rateHz = 28;                 // ~30 Hz GUI-friendly
ids = (test: 1001, A: 2001, B: 2002, final: 2101);

// --- helpers / state ---------------------------------------------------------
ensureDictionaries = {
    var okA, okB;
    ~md_levelsById = (~md_levelsById ? IdentityDictionary.new);
    ~md_levelsById[ids[\A]] = (~md_levelsById[ids[\A]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\B]] = (~md_levelsById[ids[\B]] ? [0.0, 0.0]);
    ~md_levelsById[ids[\test]] = (~md_levelsById[ids[\test]] ? [0.0, 0.0]);
    okA = ~md_levelsById[ids[\A]].notNil;
    okB = ~md_levelsById[ids[\B]].notNil;
    okA && okB
};

installReceiver = {
    var defName, doInstall;
    defName = \md_levels;
    doInstall = {
        var existing;
        // free old one if present (idempotent reset)
        existing = OSCdef(defName);
        if(existing.notNil) { existing.free };
        OSCdef(
            defName,
            { arg msg, time, addr, recvPort;
                var replyId, left, right, arr;
                // SendReply.kr emits: [ '/md/levels', nodeID, replyID, v0, v1, ... ]
                replyId = (msg.size > 2).if({ msg[2].asInteger }, { -1 });
                left    = (msg.size > 3).if({ msg[3].asFloat }, { 0.0 });
                right   = (msg.size > 4).if({ msg[4].asFloat }, { left });
                arr = [ left, right ];
                ~md_levelsById[replyId] = arr;
                ~md_lastMsgStamp = Main.elapsedTime;
            },
            '/md/levels',
            recvPort: NetAddr.langPort
        );
        ("OSCdef(\\md_levels) on /md/levels, recvPort=" ++ NetAddr.langPort).postln;
        true
    };
    doInstall.value
};

neutralizeFilter = { arg ndefKey;
    var keySym, apply;
    keySym = (ndefKey ? \chainA).asSymbol;
    apply = {
        // removeFilter() not available -> overwrite .filter with pass-through
        Ndef(keySym).filter(\md_meter, { arg in; var sig; sig = in; sig });
    };
    Server.default.bind({ apply.value });
};

installInlineMeters = {
    var each;
    each = { arg ndefKey, replyId;
        Server.default.bind({
            var keySym, meterKey;
            keySym = ndefKey.asSymbol;
            meterKey = \md_meter; // per-Ndef namespace; same symbol ok
            Ndef(keySym).filter(meterKey, { arg in;
                var sig, aL, aR, trig, r, id;
                r = rateHz;
                id = replyId;                 // replyID 2001 (A) / 2002 (B)
                sig = in.isArray.if({ in }, { [in, in] }); // mono-safe -> pair
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(r);
                SendReply.kr(trig, "/md/levels", [aL, aR], id);
                in // pass-through (no sound-path change)
            });
        });
    };
    each.value(\chainA, ids[\A]);
    each.value(\chainB, ids[\B]);
    true
};

installTestTap = { // fallback 1001 for demos when A/B are silent
    Server.default.bind({
        var haveSrc;
        haveSrc = Ndef(\testmelody).source.notNil;
        if(haveSrc) {
            Ndef(\testmelody).filter(\md_testmeter, { arg in;
                var sig, aL, aR, trig;
                sig = in.isArray.if({ in }, { [in, in] });
                aL = Amplitude.kr(sig[0]).clip(0, 1);
                aR = Amplitude.kr(sig[1]).clip(0, 1);
                trig = Impulse.kr(rateHz);
                SendReply.kr(trig, "/md/levels", [aL, aR], ids[\test]);
                in
            });
            "Test tap 1001 installed on \\testmelody".postln;
        } {
            "\\testmelody not present; no test tap added.".postln;
        };
    });
};

// --- Plan B: after-group probes (explicit ordering; compile-time 2ch) --------
makeAfterGroupProbeDef = {
    Server.default.bind({
        SynthDef(\md_busProbe2, { arg inBus=0, replyId=2001, rate=18;
            var sig, ampL, ampR, trig;
            sig = In.ar(inBus, 2); // compile-time 2ch
            ampL = Amplitude.kr(sig[0]).clip(0, 1);
            ampR = Amplitude.kr(sig[1]).clip(0, 1);
            trig = Impulse.kr(rate);
            SendReply.kr(trig, "/md/levels", [ampL, ampR], replyId);
        }).add;
    });
    true
};

attachProbeAB = {
    var ensureDef, makeOne;
    ensureDef = { makeAfterGroupProbeDef.value };
    makeOne = { arg ndefKey, replyId, ~slotName;
        var grp, syn, busIndex;
        Server.default.bind({
            // place probe AFTER the Ndef's group to guarantee source -> (tap) -> out
            grp = Group.after(Ndef(ndefKey).group);
            busIndex = Ndef(ndefKey).bus.index; // two channels
            syn = Synth(\md_busProbe2, [\inBus, busIndex, \replyId, replyId, \rate, rateHz], grp);
        });
        syn
    };
    ~md_probeA = ~md_probeA ? { makeOne.value(\chainA, ids[\A]) } !? { ~md_probeA };
    ~md_probeB = ~md_probeB ? { makeOne.value(\chainB, ids[\B]) } !? { ~md_probeB };
    true
};

detachAllProbes = {
    Server.default.bind({
        if(~md_probeA.notNil) { ~md_probeA.free; ~md_probeA = nil };
        if(~md_probeB.notNil) { ~md_probeB.free; ~md_probeB = nil };
    });
    // also neutralize inline filters if present
    neutralizeFilter.value(\chainA);
    neutralizeFilter.value(\chainB);
    true
};

// --- routing / sources (NON-DESTRUCTIVE ensure) ------------------------------
ensureRouting = {
    Server.default.bind({
        // keep this non-destructive: do NOT freeAll here
        Ndef(\chainA).ar(2); // ensure ar rate + stereo shape exists
        Ndef(\chainB).ar(2);
        // leave signal path untouched; if silent they’ll still meter 0.0
    });
    true
};

startTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                var trig, seq, f, env, pan;
                trig = Impulse.kr(3.2);
                seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                f   = Demand.kr(trig, 0, seq);
                env = Decay2.kr(trig, 0.01, 0.35);
                pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
            });
        };
        Ndef(\testmelody).ar(2);
    });
    installTestTap.value; // publishes replyID 1001
    true
};

stopTestSource = {
    Server.default.bind({
        if(Ndef(\testmelody).source.notNil) {
            // remove test tap and stop (idempotent)
            Ndef(\testmelody).filter(\md_testmeter, { arg in; in });
            Ndef(\testmelody).stop;
        };
    });
    true
};

~md_ensureRouting = ensureRouting;
~md_reinstallReceiver = installReceiver;
~md_attachProbesAB   = { arg busA=nil, busB=nil; attachProbeAB.value }; // signature kept
~md_detachAllProbes  = detachAllProbes;
~md_startTestSource  = startTestSource;
~md_stopTestSource   = stopTestSource;

// --- bring-up sequence -------------------------------------------------------
banner = {
    "--- MagicDisplayGUI Bring-up (non-destructive) ---".postln;
    ("ReplyIDs: test=" ++ ids[\test] ++ " A=" ++ ids[\A] ++ " B=" ++ ids[\B]).postln;
};

banner.value;
ensureDictionaries.value;
s.waitForBoot;         // permitted here; non-destructive thereafter
~md_ensureRouting.();  // do not freeAll user nodes
~md_reinstallReceiver.();
installInlineMeters.value;  // A) preferred path
// -> You can switch to Plan B by calling: ~md_detachAllProbes.(); ~md_attachProbesAB.();

apiNote = {
    "[API] ~md_startTestSource, ~md_stopTestSource, ~md_ensureRouting, ~md_reinstallReceiver, ~md_attachProbesAB, ~md_detachAllProbes".postln;
};
apiNote.value;
true
) // -> true

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd =====
// MagicDisplayGUI_New_Window_AB_Styled_v0.4.3.scd
// v0.4.3
// MD 2025-09-25 16:36 BST

/*
Purpose
- Single window titled "MagicDisplayGUI ..." with a stable, deterministic layout akin to yesterday’s GUI:
  • HUD at top-left
  • Two grouped sections: "Chain A" (A-L, A-R) and "Chain B" (B-L, B-R)
  • Bars read A(2001)/B(2002). If both are effectively zero, mirror test(1001) for demo fallback.

Style
- var-first in every block and closure; AppClock-only; fixed rects; single-window policy.
- Known-good SC/Qt calls; no server.sync; final expression -> a Window.
*/

(
var closeExistingMagicDisplayWindows, ensureReceiver;
var w, rect, padX, padY, rowGap;
var headerH, sectionTitleH, barH, labelW, meterW;
var ids, dict, fps, fallbackThreshold, uiGamma;
var hudText;
var viewFrame;
var aTitle, aLblL, aLblR, viewAL, viewAR;
var bTitle, bLblL, bLblR, viewBL, viewBR;
var aL, aR, bL, bR, tL, tR;
var dAL, dAR, dBL, dBR;
var makeFrame, makeBar, drawFrame, readLevels, makeTicker, killTicker, ticker;

// --- constants/state (assignments after var-first) ---------------------------
fps = 30;
ids = (test: 1001, A: 2001, B: 2002);
dict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003;   // sum(A+B) <= this => mirror test(1001) into bars
uiGamma = 1.0;               // 1.0=linear; try 0.7..0.5 to visually boost low levels

// layout constants (fixed) — tweak here to adjust spacing
padX = 12; padY = 10;
rowGap = 8;
headerH = 22;
sectionTitleH = 16;
barH = 14;
labelW = 64;
meterW = 360;

// init numbers
aL=0.0; aR=0.0; bL=0.0; bR=0.0; tL=0.0; tR=0.0;
dAL=0.0; dAR=0.0; dBL=0.0; dBR=0.0;

// --- helpers -----------------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var wins;
    wins = Window.allWindows.select({ arg wi;
        var nm;
        nm = wi.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { wins.do({ arg wi; wi.close }); nil });
};

ensureReceiver = {
    var can;
    can = (~md_reinstallReceiver.notNil);
    if(can) { ~md_reinstallReceiver.() };
};

makeFrame = { arg parentView, r;
    var v;
    v = UserView(parentView, r);
    v.background_(Color(0.95,0.95,0.95));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.70);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeBar = { arg parentView, left, top, getLevelFunc;
    var uv;
    uv = UserView(parentView, Rect(left, top, meterW, barH));
    uv.background_(Color(0.92, 0.92, 0.92));
    uv.drawFunc = { arg v;
        var b, raw, scaled;
        b = v.bounds;
        raw = getLevelFunc.value.clip(0, 1);
        scaled = raw.pow(uiGamma);
        Pen.color = Color.gray(0.85);
        Pen.addRect(Rect(0, 0, b.width, b.height)); Pen.fill;
        Pen.color = Color(0.20, 0.70, 0.20);
        Pen.addRect(Rect(0, 0, b.width * scaled, b.height)); Pen.fill;
        Pen.color = Color.gray(0.55);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    uv
};

drawFrame = { arg v;
    var b, sectionH, aBoxTop, bBoxTop;
    b = v.bounds;
    sectionH = (sectionTitleH + rowGap + (2*barH) + rowGap);
    aBoxTop = 6;
    bBoxTop = aBoxTop + sectionH + rowGap;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  aBoxTop, b.width-16, sectionH)); Pen.stroke;
    Pen.color = Color.gray(0.80);
    Pen.addRect(Rect(8,  bBoxTop, b.width-16, sectionH)); Pen.stroke;
};

readLevels = {
    var a, b, t, sumAB, sumT, txt;
    dict = (~md_levelsById ? dict);

    a = dict[ids[\A]] ? [0.0, 0.0];
    b = dict[ids[\B]] ? [0.0, 0.0];
    t = dict[ids[\test]] ? [0.0, 0.0];

    aL = a[0]; aR = a[1];
    bL = b[0]; bR = b[1];
    tL = t[0]; tR = t[1];

    sumAB = (aL + aR + bL + bR).abs;
    sumT  = (tL + tR).abs;

    // fallback: if both A and B effectively zero, mirror test(1001)
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        dAL = tL.clip(0,1); dAR = tR.clip(0,1);
        dBL = tL.clip(0,1); dBR = tR.clip(0,1);
    } {
        dAL = aL.clip(0,1); dAR = aR.clip(0,1);
        dBL = bL.clip(0,1); dBR = bR.clip(0,1);
    };

    txt = "A[" ++ aL.round(0.001) ++ "," ++ aR.round(0.001) ++ "]  " ++
          "B[" ++ bL.round(0.001) ++ "," ++ bR.round(0.001) ++ "]";
    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        txt = txt ++ "  (fallback: test " ++ [tL.round(0.001), tR.round(0.001)] ++ ")";
    };
    hudText.string = "HUD: " ++ txt;
};

makeTicker = {
    var period, step;
    period = 1.0 / fps;
    step = {
        readLevels.value;
        viewAL.refresh; viewAR.refresh; viewBL.refresh; viewBR.refresh;
        viewFrame.refresh;
        AppClock.sched(period, { if(ticker == true) { step.value }; nil });
    };
    ticker = true;
    AppClock.sched(0.0, { step.value; nil });
};

killTicker = {
    ticker = nil;
};

// --- window + precise layout -------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiver.value;

// Overall height is computed from independent metrics only.
rect = Rect(
    60, 60,
    padX + labelW + 8 + meterW + padX,
    padY + headerH + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // A section
    + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)   // B section
    + padY
);

// NOTE: resizable=false, border=true -> proper title bar visible
w = Window("MagicDisplayGUI — Status + A/B Meters (v0.4.3)", rect, false, true);

// HUD
hudText = StaticText(w, Rect(padX, padY, labelW + 8 + meterW, headerH));
hudText.stringColor = Color.black;
hudText.string = "HUD: waiting for levels…";

// Frame region
viewFrame = makeFrame.value(w, Rect(
    padX,
    padY + headerH + rowGap,
    (labelW + 8 + meterW),
    (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap
    + (sectionTitleH + rowGap + (2*barH) + rowGap)
));
viewFrame.drawFunc = { arg uv; drawFrame.value(uv) };

// Compute deterministic Y positions (no dependency on other views’ bounds)
var a_title_y, a_bar1_y, a_bar2_y, b_title_y, b_bar1_y, b_bar2_y;
a_title_y = padY + headerH + rowGap + 6;
a_bar1_y  = a_title_y + sectionTitleH + rowGap;
a_bar2_y  = a_bar1_y + barH + rowGap;

b_title_y = a_title_y + (sectionTitleH + rowGap + (2*barH) + rowGap) + rowGap;
b_bar1_y  = b_title_y + sectionTitleH + rowGap;
b_bar2_y  = b_bar1_y + barH + rowGap;

// Chain A
aTitle = StaticText(w, Rect(padX + 8, a_title_y, 80, sectionTitleH)); aTitle.string = "Chain A";
aLblL  = StaticText(w, Rect(padX + 16, a_bar1_y, labelW, barH));      aLblL.string = "A-L";
viewAL = makeBar.value(w, padX + 16 + labelW + 8, a_bar1_y, { dAL });
aLblR  = StaticText(w, Rect(padX + 16, a_bar2_y, labelW, barH));      aLblR.string = "A-R";
viewAR = makeBar.value(w, padX + 16 + labelW + 8, a_bar2_y, { dAR });

// Chain B
bTitle = StaticText(w, Rect(padX + 8, b_title_y, 80, sectionTitleH)); bTitle.string = "Chain B";
bLblL  = StaticText(w, Rect(padX + 16, b_bar1_y, labelW, barH));      bLblL.string = "B-L";
viewBL = makeBar.value(w, padX + 16 + labelW + 8, b_bar1_y, { dBL });
bLblR  = StaticText(w, Rect(padX + 16, b_bar2_y, labelW, barH));      bLblR.string = "B-R";
viewBR = makeBar.value(w, padX + 16 + labelW + 8, b_bar2_y, { dBR });

// run
w.onClose_({ killTicker.value });
w.front;
makeTicker.value;
w
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_AB_v0.3.7.scd =====
// MagicDisplayGUI_New_Window_AB_v0.3.7.scd
// v0.3.7
// MD timestamp: 2025-09-25

/* Purpose
   - Open one "MagicDisplayGUI ..." window with FOUR meters:
       A-L, A-R (replyID 2001), B-L, B-R (replyID 2002)
     and fall back to the default test probe (replyID 1001) if A/B not attached.
   - AppClock-only ticker; HUD shows rx age (global heartbeat).

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase; no FlowLayout; top-left anchored layout.
*/

(
var closeExistingMagicDisplayWindows, ampToDbString, clampOrDefault,
    getLevelsForId, buildWindow, startTicker, stopTicker, mdGuiOpen, mdGuiClose;

closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows;
    i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.name.asString;
        if (nameString.beginsWith("MagicDisplayGUI")) {
            w.close;
        };
        i = i + 1;
    };
};

ampToDbString = { |amp|
    var safeAmp, db;
    safeAmp = amp.max(1.0e-6);
    db = safeAmp.ampdb.round(0.1);
    db.asString ++ " dB";
};

clampOrDefault = { |array, index, defaultValue|
    var value;
    value = defaultValue;
    if (array.notNil) {
        if (index >= 0 and: { index < array.size }) {
            value = array[index].clip(0.0, 1.0);
        };
    };
    value;
};

getLevelsForId = { |replyID, fallback|
    var dict, arr;
    dict = ~md_levelsById;
    arr = nil;
    if (dict.notNil) {
        arr = dict[replyID];
    };
    if (arr.isNil) {
        arr = fallback;
    };
    arr;
};

buildWindow = {
    var window, content, titleString,
        labelA, aLeft, aRight, aDbL, aDbR,
        labelB, bLeft, bRight, bDbL, bDbR,
        statusA, statusB,
        startButton, stopButton,
        barWidth, barHeight;

    titleString = "MagicDisplayGUI — A/B Window (v0.3.7)";

    window = Window.new(titleString, Rect(60, 60, 560, 260), resizable: false);
    content = CompositeView.new(window, window.view.bounds);
    content.background = Color.black;

    // A section
    labelA = StaticText(content, Rect(16, 12, 240, 22));
    labelA.string = "Chain A (replyID 2001)";
    labelA.stringColor = Color.white;
    labelA.background = Color.clear;
    labelA.align = \left;

    // B section
    labelB = StaticText(content, Rect(292, 12, 240, 22));
    labelB.string = "Chain B (replyID 2002)";
    labelB.stringColor = Color.white;
    labelB.background = Color.clear;
    labelB.align = \left;

    barWidth = 26;
    barHeight = 160;

    // A meters
    aLeft  = LevelIndicator(content, Rect(40,  44, barWidth, barHeight));
    aRight = LevelIndicator(content, Rect(100, 44, barWidth, barHeight));
    aLeft.warning = (-6).dbamp; aLeft.critical = (-3).dbamp;
    aRight.warning = (-6).dbamp; aRight.critical = (-3).dbamp;

    aDbL = StaticText(content, Rect(32, 210, 60, 18));
    aDbL.string = "-inf dB";
    aDbL.stringColor = Color.gray(0.85);
    aDbL.background = Color.clear;
    aDbL.align = \center;

    aDbR = StaticText(content, Rect(92, 210, 60, 18));
    aDbR.string = "-inf dB";
    aDbR.stringColor = Color.gray(0.85);
    aDbR.background = Color.clear;
    aDbR.align = \center;

    // B meters
    bLeft  = LevelIndicator(content, Rect(316, 44, barWidth, barHeight));
    bRight = LevelIndicator(content, Rect(376, 44, barWidth, barHeight));
    bLeft.warning = (-6).dbamp; bLeft.critical = (-3).dbamp;
    bRight.warning = (-6).dbamp; bRight.critical = (-3).dbamp;

    bDbL = StaticText(content, Rect(308, 210, 60, 18));
    bDbL.string = "-inf dB";
    bDbL.stringColor = Color.gray(0.85);
    bDbL.background = Color.clear;
    bDbL.align = \center;

    bDbR = StaticText(content, Rect(368, 210, 60, 18));
    bDbR.string = "-inf dB";
    bDbR.stringColor = Color.gray(0.85);
    bDbR.background = Color.clear;
    bDbR.align = \center;

    // rx age
    statusA = StaticText(content, Rect(180, 44, 100, 18));
    statusA.string = "A rx: —";
    statusA.stringColor = Color.gray(0.85);
    statusA.background = Color.clear;
    statusA.align = \left;

    statusB = StaticText(content, Rect(456, 44, 100, 18));
    statusB.string = "B rx: —";
    statusB.stringColor = Color.gray(0.85);
    statusB.background = Color.clear;
    statusB.align = \left;

    // test controls (optional)
    startButton = Button(content, Rect(180, 80, 100, 28));
    startButton.states = [["Start Test", Color.white, Color.green(0.6)]];
    startButton.action = {
        var ok;
        ok = true;
        if (~md_startTestSource.notNil) { ~md_startTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    stopButton = Button(content, Rect(180, 114, 100, 28));
    stopButton.states = [["Stop Test", Color.white, Color.red(0.5)]];
    stopButton.action = {
        var ok;
        ok = true;
        if (~md_stopTestSource.notNil) { ~md_stopTestSource.value; } { "Run bring-up file first.".postln; };
        ok;
    };

    // store refs
    ~mdGui_aLeft = aLeft;     ~mdGui_aRight = aRight;   ~mdGui_aDbL = aDbL;   ~mdGui_aDbR = aDbR;
    ~mdGui_bLeft = bLeft;     ~mdGui_bRight = bRight;   ~mdGui_bDbL = bDbL;   ~mdGui_bDbR = bDbR;
    ~mdGui_statusA = statusA; ~mdGui_statusB = statusB;

    window.onClose_({
        var ok;
        ok = true;
        stopTicker.value;
        ~mdGui_window = nil;
        ok;
    });

    window.front;

    ~mdGui_window = window;

    window;
};

startTicker = {
    var period, tickerRoutine;

    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };

    period = 1 / 30;

    tickerRoutine = Routine({
        var running,
            aLevels, bLevels, testLevels,
            aL, aR, bL, bR,
            aDbL, aDbR, bDbL, bDbR,
            age, lastAt;

        running = true;

        while { running } {
            testLevels = getLevelsForId.value(1001, [0.0, 0.0]);
            aLevels = getLevelsForId.value(2001, testLevels);
            bLevels = getLevelsForId.value(2002, testLevels);

            aL = clampOrDefault.value(aLevels, 0, 0.0);
            aR = clampOrDefault.value(aLevels, 1, 0.0);
            bL = clampOrDefault.value(bLevels, 0, 0.0);
            bR = clampOrDefault.value(bLevels, 1, 0.0);

            aDbL = ampToDbString.value(aL);
            aDbR = ampToDbString.value(aR);
            bDbL = ampToDbString.value(bL);
            bDbR = ampToDbString.value(bR);

            if (~mdGui_aLeft.notNil)  { ~mdGui_aLeft.value  = aL; };
            if (~mdGui_aRight.notNil) { ~mdGui_aRight.value = aR; };
            if (~mdGui_bLeft.notNil)  { ~mdGui_bLeft.value  = bL; };
            if (~mdGui_bRight.notNil) { ~mdGui_bRight.value = bR; };

            if (~mdGui_aDbL.notNil) { ~mdGui_aDbL.string = aDbL; };
            if (~mdGui_aDbR.notNil) { ~mdGui_aDbR.string = aDbR; };
            if (~mdGui_bDbL.notNil) { ~mdGui_bDbL.string = bDbL; };
            if (~mdGui_bDbR.notNil) { ~mdGui_bDbR.string = bDbR; };

            lastAt = if (~md_lastLevelAt.notNil) { ~md_lastLevelAt } { 0.0 };
            age = (Main.elapsedTime - lastAt).max(0.0).round(0.01);

            if (~mdGui_statusA.notNil) { ~mdGui_statusA.string = "A rx: " ++ age.asString ++ " s"; };
            if (~mdGui_statusB.notNil) { ~mdGui_statusB.string = "B rx: " ++ age.asString ++ " s"; };

            period.yield;
            running = (~mdGui_window.notNil);
        };
    });

    ~mdGui_ticker = tickerRoutine.play(AppClock);

    true;
};

stopTicker = {
    var ok;
    ok = true;
    if (~mdGui_ticker.notNil) {
        ~mdGui_ticker.stop;
        ~mdGui_ticker = nil;
    };
    ok;
};

mdGuiOpen = {
    var window;
    closeExistingMagicDisplayWindows.value;
    window = buildWindow.value;
    startTicker.value;
    window;
};

mdGuiClose = {
    var ok;
    ok = true;
    stopTicker.value;
    if (~mdGui_window.notNil) { ~mdGui_window.close; ~mdGui_window = nil; };
    ok;
};

// ---------- Open the window (returns -> a Window) ----------
mdGuiOpen.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd =====
// MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd  / v0.5.4-p1 (safe background) / MD 2025-09-28
//
// Purpose
// - Performance HUD window (single, resizable "MagicDisplayGUI …").
// - Same layout and features as v0.5.4, but with SAFE deferred background color
//   assignment for TextView widgets to avoid 'base_' on nil during early layout.
//
// Style
// - var-first in every block/closure; AppClock-only; no server.sync; known-good SC/Qt calls.
// - Final expression returns -> a Window.

(
var closeExistingMagicDisplayWindows, ensureReceiverInstalled;
// window + metrics
var windowRef, windowRect;
var paddingX, paddingY, rowGap, columnGap;
var topRowHeight, systemTitleHeight, systemBodyHeight, bottomRowHeight;
var minPanelTextWidth, meterStripWidth;
// ids + levels + shaping
var levelIds, levelsDict, framesPerSecond, fallbackThreshold, uiGamma;
// top row views
var chainAPanel, chainBPanel;
var chainATitleLabel, chainBTitleLabel;
var meterViewBetweenA, meterViewBetweenB;
// system row views
var systemStateTitleLabel, systemStateTextView;
// bottom row views
var choicesTitleLabel, choicesTextView;
var processorsTitleLabel, processorsTextView;
// live state
var chainALevelLeft, chainALevelRight, chainBLevelLeft, chainBLevelRight, testLevelLeft, testLevelRight;
var displayALevelLeft, displayALevelRight, displayBLevelLeft, displayBLevelRight;
var isAActive, isBActive;
// helpers
var makePanelView, makeTitleLabel, makeVerticalMeterViewForA, makeVerticalMeterViewForB;
var drawVerticalMetersA, drawVerticalMetersB, setPanelActiveColor, setPanelNeutralColor;
var safeSetBackground; // NEW: safe, deferred TextView background setter
// refresh + layout + ticker
var readLevelsAndUpdate, refreshChoicesPane, refreshProcessorsPane;
var computeAndApplyLayout, layoutInitialized;
var startTicker, stopTicker, tickerFlag, stepFunc;
var lastWidth, lastHeight;
// identity banner
var identityBanner;

// === console identity =========================================================
identityBanner = "=== RUN === MagicDisplayGUI_New_Window_PerfHUD_AB_v0.5.4.scd";
identityBanner.postln;

// --- constants/state ----------------------------------------------------------
framesPerSecond = 30;
levelIds = (test: 1001, A: 2001, B: 2002);
levelsDict = (~md_levelsById ? IdentityDictionary.new);
fallbackThreshold = 0.003; // if A+B near zero, mirror test for visual continuity
uiGamma = 1.0; // 1.0 linear; try 0.7..0.5 to boost quiet levels

// layout metrics (steady verticals)
paddingX = 10;
paddingY = 10;
rowGap = 8;
columnGap= 12;
topRowHeight = 140;       // Chain A/B panels
systemTitleHeight = 18;   // "System State"
systemBodyHeight = 78;    // ~triple height
bottomRowHeight = 180;    // Choices + Processors
minPanelTextWidth = 220;
meterStripWidth = 18;

// init values
chainALevelLeft = 0.0; chainALevelRight = 0.0;
chainBLevelLeft = 0.0; chainBLevelRight = 0.0;
testLevelLeft = 0.0; testLevelRight = 0.0;
displayALevelLeft = 0.0; displayALevelRight = 0.0;
displayBLevelLeft = 0.0; displayBLevelRight = 0.0;
isAActive = false; isBActive = false;
layoutInitialized = false;

// --- helpers (views) ----------------------------------------------------------
closeExistingMagicDisplayWindows = {
    var existingWindows;
    existingWindows = Window.allWindows.select({ arg w;
        var nm;
        nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    AppClock.sched(0.0, { existingWindows.do({ arg w; w.close }); nil });
};

ensureReceiverInstalled = {
    var canInstall;
    canInstall = (~md_reinstallReceiver.notNil);
    if(canInstall) { ~md_reinstallReceiver.() };
};

// NEW: safe, deferred setter for TextView backgrounds (prevents 'base_' on nil)
safeSetBackground = { |view, color, delay=0.03|
    AppClock.sched(delay, {
        if(view.notNil and: { view.isClosed.not }) {
            view.background_(color);
        };
        nil
    });
};

makePanelView = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.94, 0.94, 0.94));
    v.drawFunc = { arg uv;
        var b;
        b = uv.bounds;
        Pen.color = Color.gray(0.65);
        Pen.strokeRect(Rect(0.5, 0.5, b.width-1, b.height-1));
    };
    v
};

makeTitleLabel = { arg parent, r, titleString;
    var label;
    label = StaticText(parent, r);
    label.string_(titleString);
    label.stringColor_(Color.black);
    label.align_(\left);
    label
};

drawVerticalMetersA = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayALevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayALevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

drawVerticalMetersB = { arg uv;
    var b, gap, oneWidth, leftVal, rightVal, leftH, rightH;
    b = uv.bounds;
    gap = 2;
    oneWidth = ((b.width - gap) / 2).max(3);
    leftVal  = displayBLevelLeft.clip(0,1).pow(uiGamma);
    rightVal = displayBLevelRight.clip(0,1).pow(uiGamma);
    leftH  = (b.height * leftVal).clip(0, b.height);
    rightH = (b.height * rightVal).clip(0, b.height);
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(0, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.86,0.86,0.86); Pen.addRect(Rect(oneWidth + gap, 0, oneWidth, b.height)); Pen.fill;
    Pen.color = Color(0.20, 0.70, 0.20);
    Pen.addRect(Rect(0,              b.height - leftH,  oneWidth, leftH));  Pen.fill;
    Pen.addRect(Rect(oneWidth + gap, b.height - rightH, oneWidth, rightH)); Pen.fill;
    Pen.color = Color.gray(0.55);
    Pen.strokeRect(Rect(0.5, 0.5, oneWidth-1, b.height-1));
    Pen.strokeRect(Rect(oneWidth + gap + 0.5, 0.5, oneWidth-1, b.height-1));
};

makeVerticalMeterViewForA = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersA.value(uv) };
    v
};

makeVerticalMeterViewForB = { arg parent, r;
    var v;
    v = UserView(parent, r);
    v.background_(Color(0.92,0.92,0.92));
    v.drawFunc = { arg uv; var dummy; dummy=nil; drawVerticalMetersB.value(uv) };
    v
};

setPanelActiveColor  = { arg panelView;  panelView.background_(Color(0.86, 0.97, 0.86)) };
setPanelNeutralColor = { arg panelView;  panelView.background_(Color(0.94, 0.94, 0.94)) };

// --- data + UI refresh (DEFENSIVE) -------------------------------------------
readLevelsAndUpdate = {
    var aVals, bVals, tVals, sumAB, sumT;
    var sumAEnergy, sumBEnergy, epsilon, ageSeconds;
    var getPairSafe;

    getPairSafe = { arg dict, key;
        var arr;
        arr = (dict.respondsTo(\at)).if({ dict.at(key) }, { nil });
        (arr.isArray and: { arr.size >= 2 and: { arr[0].isNumber and: { arr[1].isNumber } } })
        .if({ arr }, { [0.0, 0.0] })
    };

    levelsDict = (~md_levelsById.isKindOf(IdentityDictionary)).if({ ~md_levelsById }, { IdentityDictionary.new });

    aVals = getPairSafe.value(levelsDict, levelIds[\A]);
    bVals = getPairSafe.value(levelsDict, levelIds[\B]);
    tVals = getPairSafe.value(levelsDict, levelIds[\test]);

    chainALevelLeft = aVals[0]; chainALevelRight = aVals[1];
    chainBLevelLeft = bVals[0]; chainBLevelRight = bVals[1];
    testLevelLeft   = tVals[0]; testLevelRight   = tVals[1];

    sumAB = (chainALevelLeft + chainALevelRight + chainBLevelLeft + chainBLevelRight).abs;
    sumT  = (testLevelLeft + testLevelRight).abs;

    if((sumAB <= fallbackThreshold) and: { sumT > (fallbackThreshold * 0.3) }) {
        displayALevelLeft  = testLevelLeft.clip(0,1);
        displayALevelRight = testLevelRight.clip(0,1);
        displayBLevelLeft  = testLevelLeft.clip(0,1);
        displayBLevelRight = testLevelRight.clip(0,1);
    }{
        displayALevelLeft  = chainALevelLeft.clip(0,1);
        displayALevelRight = chainALevelRight.clip(0,1);
        displayBLevelLeft  = chainBLevelLeft.clip(0,1);
        displayBLevelRight = chainBLevelRight.clip(0,1);
    };

    sumAEnergy = ((displayALevelLeft.isNumber.if({ displayALevelLeft }, { 0.0 })) +
                  (displayALevelRight.isNumber.if({ displayALevelRight }, { 0.0 })));
    sumBEnergy = ((displayBLevelLeft.isNumber.if({ displayBLevelLeft }, { 0.0 })) +
                  (displayBLevelRight.isNumber.if({ displayBLevelRight }, { 0.0 })));
    epsilon = 0.001;

    isAActive = (sumAEnergy > (sumBEnergy + epsilon));
    isBActive = (sumBEnergy > (sumAEnergy + epsilon));

    if(chainAPanel.notNil) { if(isAActive) { setPanelActiveColor.value(chainAPanel) } { setPanelNeutralColor.value(chainAPanel) } };
    if(chainBPanel.notNil) { if(isBActive) { setPanelActiveColor.value(chainBPanel) } { setPanelNeutralColor.value(chainBPanel) } };

    // System State with last /md/levels age
    ageSeconds = (Main.elapsedTime - (~md_lastMsgStamp ? 0)).round(0.01);
    systemStateTextView.string_("system ready\n(last /md/levels: " ++ ageSeconds ++ " s ago)");
};

refreshChoicesPane = {
    var sysObj, cm, builder, textLines, s;
    sysObj = ~system;
    if(sysObj.isNil) {
        s = "(n/a — no ~system)";
    }{
        cm = sysObj.tryPerform(\commandManager);
        builder = cm.tryPerform(\builder);
        if(builder.notNil and: { builder.tryPerform(\currentNode).notNil }) {
            textLines = builder.currentNode.children.collect({ arg child;
                var nm, fr;
                nm = child.tryPerform(\name) ? child.asString;
                fr = child.tryPerform(\fret);
                (fr.notNil).if({ ("fret " ++ fr.asString ++ " → " ++ nm) }, { nm });
            });
            s = textLines.join($\n);
        }{
            s = "(n/a — no builder or no node)";
        };
    };
    choicesTextView.string_(s);
};

refreshProcessorsPane = {
    var providerFunc, s;
    providerFunc = ( ~md_cmdTextProvider.isKindOf(Function) ).if({ ~md_cmdTextProvider }, { nil });
    if(providerFunc.notNil) {
        s = providerFunc.value;
    }{
        s = "Processors / Queue:\n"
        ++ "(no provider)\n"
        ++ "Set ~md_cmdTextProvider to a function that returns a string.\n\n"
        ++ "Example (temporary):\n"
        ++ "~md_cmdTextProvider = {\n"
        ++ " var cm, next;\n"
        ++ " cm = (~system.tryPerform(\\commandManager));\n"
        ++ " next = (cm.notNil and: { cm.respondsTo(\\canonicalPathFromBuilder) })\n"
        ++ " .if({ cm.canonicalPathFromBuilder(cm.builder) }, { \"(n/a)\" });\n"
        ++ " \"Next: \" ++ next.asString\n"
        ++ "};";
    };
    processorsTextView.string_(s);
};

// --- layout (GUARDED; never writes nil Rect) ----------------------------------
computeAndApplyLayout = {
    var wb, contentW, halfW;
    var panelY, systemTitleY, systemBodyY, bottomY;
    var aX, aW, bX, bW;
    var meterAX, meterBX, meterY, meterH;
    var titleH;

    wb = windowRef.bounds;
    if(wb.isKindOf(Rect).not) {
        AppClock.sched(0.03, { computeAndApplyLayout.value; nil });
    }{
        contentW = (wb.width - (paddingX * 2)).max(560);
        halfW    = (((contentW - columnGap) / 2)).max(minPanelTextWidth + meterStripWidth + 16);
        panelY = paddingY;
        systemTitleY = panelY + topRowHeight + rowGap;
        systemBodyY  = systemTitleY + systemTitleHeight + 4;
        bottomY = systemBodyY + systemBodyHeight + rowGap;

        aX = paddingX; aW = halfW;
        bX = paddingX + halfW + columnGap; bW = halfW;
        titleH = 16;

        chainAPanel.bounds_(Rect(aX, panelY, aW, topRowHeight));
        chainBPanel.bounds_(Rect(bX, panelY, bW, topRowHeight));
        chainATitleLabel.bounds_(Rect(aX + 8, panelY + 6, 120, titleH));
        chainBTitleLabel.bounds_(Rect(bX + 8, panelY + 6, 120, titleH));

        meterY = panelY + 8 + titleH + 4;
        meterH = topRowHeight - (meterY - panelY) - 8;
        meterAX = aX + aW - 8 - meterStripWidth; // A: right edge
        meterBX = bX + 8; // B: left edge
        meterViewBetweenA.bounds_(Rect(meterAX, meterY, meterStripWidth, meterH));
        meterViewBetweenB.bounds_(Rect(meterBX, meterY, meterStripWidth, meterH));

        systemStateTitleLabel.bounds_(Rect(paddingX, systemTitleY, contentW, systemTitleHeight));
        systemStateTextView.bounds_(Rect(paddingX, systemBodyY, contentW, systemBodyHeight));

        // SAFE: defer TextView background (prevents 'base_' on nil)
        safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));

        choicesTitleLabel.bounds_(Rect(paddingX, bottomY, halfW, 16));
        choicesTextView.bounds_(Rect(paddingX, bottomY + 18, halfW, bottomRowHeight - 20));
        processorsTitleLabel.bounds_(Rect(paddingX + halfW + columnGap, bottomY, halfW, 16));
        processorsTextView.bounds_(Rect(paddingX + halfW + columnGap, bottomY + 18, halfW, bottomRowHeight - 20));
    };
};

// --- ticker (GUARDED sequencing; layout first, then step loop) ----------------
startTicker = {
    var periodSeconds;
    periodSeconds = 1.0 / framesPerSecond;

    AppClock.sched(0.05, {
        layoutInitialized = true;
        computeAndApplyLayout.value;
        nil
    });

    AppClock.sched(0.10, {
        lastWidth  = windowRef.bounds.width;
        lastHeight = windowRef.bounds.height;

        stepFunc = {
            var w, h;
            readLevelsAndUpdate.value;
            if(layoutInitialized) {
                w = windowRef.bounds.width;  h = windowRef.bounds.height;
                if((w != lastWidth) or: { h != lastHeight }) {
                    computeAndApplyLayout.value;
                    lastWidth = w; lastHeight = h;
                };
            };
            meterViewBetweenA.refresh;
            meterViewBetweenB.refresh;
            AppClock.sched(periodSeconds, { if(tickerFlag == true) { stepFunc.value }; nil });
        };

        tickerFlag = true;
        stepFunc.value;
        nil
    });
};

stopTicker = { tickerFlag = nil };

// --- construct + run ----------------------------------------------------------
closeExistingMagicDisplayWindows.value;
ensureReceiverInstalled.value;

// Initial size (fits on first open)
windowRect = Rect(
  70, 70,
  paddingX + (minPanelTextWidth + meterStripWidth + columnGap + minPanelTextWidth + meterStripWidth) + paddingX + 60,
  paddingY + topRowHeight + rowGap + systemTitleHeight + systemBodyHeight + rowGap + bottomRowHeight + paddingY
);

// Resizable=true, border=true -> proper title + resizable
windowRef = Window("MagicDisplayGUI — Performance HUD (v0.5.4)", windowRect, true, true);

// top row
chainAPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainBPanel       = makePanelView.value(windowRef, Rect(0,0,10,10));
chainATitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain A");
chainBTitleLabel  = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Chain B");
meterViewBetweenA = makeVerticalMeterViewForA.value(windowRef, Rect(0,0,10,10));
meterViewBetweenB = makeVerticalMeterViewForB.value(windowRef, Rect(0,0,10,10));

// system state row
systemStateTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "System State");
systemStateTextView   = TextView(windowRef, Rect(0,0,10,10));
systemStateTextView.editable_(false);
// SAFE: defer initial background too
safeSetBackground.(systemStateTextView, Color(1.0, 0.95, 0.6));
systemStateTextView.string_("system ready");

// bottom row
choicesTitleLabel   = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Choices");
choicesTextView     = TextView(windowRef, Rect(0,0,10,10));
choicesTextView.editable_(false);
safeSetBackground.(choicesTextView,    Color(0.97,0.97,0.97));

processorsTitleLabel = makeTitleLabel.value(windowRef, Rect(0,0,10,10), "Processors");
processorsTextView   = TextView(windowRef, Rect(0,0,10,10));
processorsTextView.editable_(false);
safeSetBackground.(processorsTextView, Color(0.97,0.97,0.97));

// run
windowRef.onClose_({ stopTicker.value });
windowRef.front;
startTicker.value;
windowRef
) // -> a Window

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd =====
// MagicDisplayGUI_NewPath_Step1_ServerAndMeters.scd
// v0.2.1
// MD timestamp: 2025-09-25
/* Purpose
   - Cleanly (re)initialize the audio server tree, build a generated-only test signal path,
     and install a level probe that reports channel levels via /reply.
   - Publish public tilde helpers (~md_startTestSource, ~md_stopTestSource, ~md_cleanup) for GUI use.
   - Use compile-time channel counts (2ch) in SynthDefs.

   Style
   - var-first in every block; no non-local returns (^).
   - descriptive lowercase variables; no server.sync; server ops wrapped in s.bind where relevant.
   - generated audio only; probe reads a private bus.
*/

(
var prepareServerAndDefs, setupRouting, installOscReceiver, definePublicAPI, startStartupSequence;

prepareServerAndDefs = {
    var ok;
    ok = true;

    s.waitForBoot({
        var def_testSource, def_toHardware2, def_levelProbe2;

        s.initTree;
        s.defaultGroup.freeAll;

        ~levels = [0.0, 0.0];

        // Test source: stereo beeps
        def_testSource = SynthDef(\md_testSource, { |outBus = 0, amp = 0.20|
            var trig, freqSeq, sig, env, stereo;
            trig = Impulse.kr(2);
            freqSeq = Demand.kr(trig, 0, Dseq([60, 64, 67, 72].midicps, inf));
            env = EnvGen.kr(Env.perc(0.005, 0.20), trig);
            sig = SinOsc.ar(freqSeq) * env;
            stereo = [sig, DelayN.ar(sig, 0.03, 0.02)];
            Out.ar(outBus, stereo * amp);
        }).add;

        // Relay to hardware (fixed 2ch)
        def_toHardware2 = SynthDef(\md_toHardware_2ch, { |inBus = 0|
            var sig;
            sig = In.ar(inBus, 2);
            Out.ar(0, sig);
        }).add;

        // Level probe (fixed 2ch) → /reply
        def_levelProbe2 = SynthDef(\md_levelProbe_2ch, { |inBus = 0, sendID = 1001|
            var sig, amps, ticker;
            sig = In.ar(inBus, 2);
            amps = Amplitude.kr(sig, 0.01, 0.30);
            ticker = Impulse.kr(20);
            SendReply.kr(ticker, "/md/levels", amps, sendID);
        }).add;
    });

    ok;
};

setupRouting = {
    var ok;

    ok = true;

    s.bind({
        var defaultGroup;

        defaultGroup = s.defaultGroup;

        ~md_mixBus = Bus.audio(s, 2);

        ~md_srcGroup = Group.head(defaultGroup);
        ~md_meterGroup = Group.after(~md_srcGroup);
        ~md_outGroup = Group.after(~md_meterGroup);

        ~md_toHardware = Synth.tail(~md_outGroup, \md_toHardware_2ch, [\inBus, ~md_mixBus.index]);
        ~md_probe = Synth.tail(~md_meterGroup, \md_levelProbe_2ch, [\inBus, ~md_mixBus.index, \sendID, 1001]);

        ~md_testSynth = nil;
    });

    ok;
};

installOscReceiver = {
    var existing;

    existing = OSCdef(\md_levels);
    if (existing.notNil) {
        existing.free;
    };

    ~levels = [0.0, 0.0];

    OSCdef(\md_levels, { |msg, time, addr, recvPort|
        var tag, count, i, outArray;

        tag = msg[2];
        count = 0;
        i = 0;
        outArray = nil;

        if (tag == "/md/levels") {
            count = msg.size - 3;
            outArray = Array.newClear(count);
            i = 0;
            while { i < count } {
                outArray[i] = msg[3 + i].asFloat.clip(0.0, 1.0);
                i = i + 1;
            };
            ~levels = outArray;
        };
    }, '/reply');

    true;
};

definePublicAPI = {
    var ok;

    ok = true;

    ~md_startTestSource = {
        var ok2;
        ok2 = true;

        s.bind({
            if (~md_testSynth.notNil) {
                ~md_testSynth.free;
                ~md_testSynth = nil;
            };
            ~md_testSynth = Synth.tail(~md_srcGroup, \md_testSource, [\outBus, ~md_mixBus.index, \amp, 0.20]);
        });

        ok2;
    };

    ~md_stopTestSource = {
        var ok2;
        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        ok2;
    };

    ~md_cleanup = {
        var ok2;

        ok2 = true;

        if (~md_testSynth.notNil) {
            ~md_testSynth.free;
            ~md_testSynth = nil;
        };

        if (~md_probe.notNil) {
            ~md_probe.free;
            ~md_probe = nil;
        };

        if (~md_toHardware.notNil) {
            ~md_toHardware.free;
            ~md_toHardware = nil;
        };

        if (~md_outGroup.notNil) {
            ~md_outGroup.free;
            ~md_outGroup = nil;
        };
        if (~md_meterGroup.notNil) {
            ~md_meterGroup.free;
            ~md_meterGroup = nil;
        };
        if (~md_srcGroup.notNil) {
            ~md_srcGroup.free;
            ~md_srcGroup = nil;
        };

        if (~md_mixBus.notNil) {
            ~md_mixBus.free;
            ~md_mixBus = nil;
        };

        if (OSCdef(\md_levels).notNil) {
            OSCdef(\md_levels).free;
        };

        s.defaultGroup.freeAll;

        ok2;
    };

    ok;
};

startStartupSequence = {
    var ok;

    ok = true;

    "Step 1: preparing server + defs...".postln;
    prepareServerAndDefs.value;

    "Step 1: setting up routing (bus, groups, probe)...".postln;
    setupRouting.value;

    "Step 1: installing OSC receiver...".postln;
    installOscReceiver.value;

    // ✅ Publish the API so Step 2 can call it
    "Step 1: defining public API...".postln;
    definePublicAPI.value;

    "Step 1: ready. Use ~md_startTestSource.value to begin audio.".postln;

    ok;
};

// ---------- run ----------
startStartupSequence.value;

// Tips:
// ~md_startTestSource.value;
// ~md_stopTestSource.value;
// ~md_cleanup.value;
)

===== MagicPedalboard/troubleshooting/MagicDisplayGUI_ResetReceiver_v0.3.11.scd =====
// MagicDisplayGUI_ResetReceiver_v0.3.11.scd
// v0.3.11
// MD 2025-09-25 15:10 BST

/*
Purpose
- Reinstall the /md/levels receiver on NetAddr.langPort (idempotent).
- Posts identity banner so logs show exact order of actions.
Style
- var-first; no server.sync; returns -> true.
*/

(
// === RUN ===
var ok, dict;
dict = (~md_levelsById ? IdentityDictionary.new);
~md_levelsById = dict;
ok = ~md_reinstallReceiver !? { ~md_reinstallReceiver.() } ? false;
("Receiver reset: " ++ ok).postln;
true
) // -> true

===== MagicPedalboard/WindowDisplayExamples/SixPanes_GridLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_GridLayout_TwoMeters.scd
// v0.3.1
// MD 2025-09-25 14:20
//
// Purpose / Style:
// - GUI-only: 6 panes in a GridLayout (3x2).
// - Top-left and top-right contain simulated meters (no audio).
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill;
var titleFont, bodyFont, paneColors, paneTitles;
var makeTextPane, makeMeterPane, p;
var meterViewA, meterViewB, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI GridLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);
paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// ---------- factories ----------
makeTextPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    pane.layout_(VLayout(UserView().minHeight_(6), textColumn, nil));
    pane
};

// returns [pane, meterView]
makeMeterPane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };
    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText().string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85,0.9,0.95));
    meterView = LevelIndicator().warning_(0.7).critical_(0.95).minSize_(Size(18, 180));
    textColumn = UserView().layout_(VLayout(UserView().minHeight_(6), titleText, UserView().minHeight_(4), bodyText, nil));
    meterBox   = UserView().layout_(VLayout(UserView().minHeight_(6), meterView, nil));
    pane.layout_(HLayout(UserView().minWidth_(6), textColumn, UserView().minWidth_(10), meterBox, UserView().minWidth_(6)));
    [pane, meterView]
};

// ---------- build six panes ----------
p = Array.newClear(6);
var pane, m;

#pane, m = makeMeterPane.(paneTitles[0], paneColors[0]); p[0] = pane; meterViewA = m; // top-left
#pane, m = makeMeterPane.(paneTitles[1], paneColors[1]); p[1] = pane; meterViewB = m; // top-right
p[2] = makeTextPane.(paneTitles[2], paneColors[2]);
p[3] = makeTextPane.(paneTitles[3], paneColors[3]);
p[4] = makeTextPane.(paneTitles[4], paneColors[4]);
p[5] = makeTextPane.(paneTitles[5], paneColors[5]);

// ---------- grid layout 3x2 ----------
window.layout_(GridLayout.rows(
    [ p[0], p[1] ],
    [ p[2], p[3] ],
    [ p[4], p[5] ]
));
window.front;

// ---------- simulated meters (single routine updates both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 0.9;
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViewA.notNil, { meterViewA.value_(valA) });
            if(meterViewB.notNil, { meterViewB.value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== MagicPedalboard/WindowDisplayExamples/SixPanes_VHLayout_TwoMeters.scd =====
/////////////////////////////////////////////////////////////
// SixPanes_VHLayout_TwoMeters.scd
// v0.3.0
// MD 2025-09-25 14:08
//
// Purpose / Style:
// - GUI-only: 6 panes arranged with VLayout/HLayout; top-left and top-right contain simulated meters.
// - No audio, no Ndefs. Pure Qt UI.
// - Rules: var-first; descriptive lowercase names; no non-local returns; known-good SC syntax.
/////////////////////////////////////////////////////////////

(
var window, windowRect, windowBg, paneFill, cellPadding;
var titleFont, bodyFont, paneColors, paneTitles;
var makePane, makePaneWithMeter, row1, row2, row3, rootLayout;
var meterViews, meterRoutine;

// ---------- close prior MagicDisplayGUI windows ----------
Window.allWindows.do({ |w|
    var nameString;
    nameString = w.name.asString;
    if(nameString.beginsWith("MagicDisplayGUI"), { { w.close }.defer });
});

// ---------- window & styles ----------
windowRect = Rect(80, 60, 1200, 850);
window = Window("MagicDisplayGUI VHLayout + Two Sim Meters", windowRect).alwaysOnTop_(true);
windowBg = Color(0.08, 0.08, 0.09);
paneFill = Color(0.15, 0.15, 0.18);
window.view.background_(windowBg);
cellPadding = 10;

titleFont = Font("Helvetica-Bold", 16);
bodyFont  = Font("Menlo", 12);

paneColors = [Color.red, Color.green, Color.blue, Color.yellow, Color.magenta, Color.cyan];
paneTitles = ["top-left","top-right","middle-left","middle-right","bottom-left","bottom-right"];

// store two meter views [A, B]
meterViews = Array.newClear(2);

// ---------- pane factories ----------
// Plain pane (no meter)
makePane = { |titleString, borderColor|
    var pane, titleText, bodyText, textColumn;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nGUI-only layout test.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    pane.layout_(VLayout(
        UserView().minHeight_(6),
        textColumn,
        nil
    ));

    pane
};

// Pane with meter; meterIndex: 0 for top-left (A), 1 for top-right (B)
makePaneWithMeter = { |titleString, borderColor, meterIndex|
    var pane, titleText, bodyText, textColumn, meterBox, meterView;
    pane = UserView().background_(paneFill).minSize_(Size(520, 230));
    pane.drawFunc = { |v|
        var r;
        r = Rect(1, 1, v.bounds.width - 2, v.bounds.height - 2);
        Pen.fillColor = Color(0.11, 0.11, 0.12);
        Pen.strokeColor = borderColor;
        Pen.width = 2;
        Pen.fillRect(r);
        Pen.strokeRect(r);
    };

    titleText = StaticText().string_(titleString).font_(titleFont).stringColor_(Color.white);
    bodyText  = StaticText()
        .string_("Pane: " ++ titleString ++ "\nSimulated meter on the right.")
        .font_(bodyFont).stringColor_(Color(0.85, 0.9, 0.95));

    textColumn = UserView();
    textColumn.layout_(VLayout(
        UserView().minHeight_(6),
        titleText,
        UserView().minHeight_(4),
        bodyText,
        nil
    ));

    // vertical level indicator
    meterView = LevelIndicator()
        .warning_(0.7).critical_(0.95)
        .minSize_(Size(18, 180));

    meterViews.put(meterIndex, meterView);

    meterBox = UserView();
    meterBox.layout_(VLayout(
        UserView().minHeight_(6),
        meterView,
        nil
    ));

    pane.layout_(HLayout(
        UserView().minWidth_(6),
        textColumn,
        UserView().minWidth_(10), // spacer between text and meter
        meterBox,
        UserView().minWidth_(6)
    ));

    pane
};

// ---------- build rows (top-left & top-right use meters) ----------
row1 = HLayout(
    makePaneWithMeter.(paneTitles[0], paneColors[0], 0), // top-left meter A
    UserView().minWidth_(cellPadding),
    makePaneWithMeter.(paneTitles[1], paneColors[1], 1)  // top-right meter B
);

row2 = HLayout(
    makePane.(paneTitles[2], paneColors[2]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[3], paneColors[3])
);

row3 = HLayout(
    makePane.(paneTitles[4], paneColors[4]),
    UserView().minWidth_(cellPadding),
    makePane.(paneTitles[5], paneColors[5])
);

// ---------- root layout ----------
rootLayout = VLayout(
    UserView().minHeight_(cellPadding),
    row1,
    UserView().minHeight_(cellPadding),
    row2,
    UserView().minHeight_(cellPadding),
    row3,
    UserView().minHeight_(cellPadding)
);
window.layout_(rootLayout);
window.front;

// ---------- simulated meters (single AppClock routine for both) ----------
meterRoutine = Routine({
    var updateInterval, phaseA, phaseB, valA, valB, noiseA, noiseB;
    updateInterval = 0.05;
    phaseA = 0.0; phaseB = 1.2; // offset so A and B differ
    loop {
        valA = ((sin(phaseA) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        valB = ((sin(phaseB) + 1.0) * 0.5).linlin(0.0, 1.0, 0.05, 0.92);
        noiseA = (0.10.rand2).clip(-0.08, 0.08);
        noiseB = (0.10.rand2).clip(-0.08, 0.08);
        valA = (valA + noiseA).clip(0.0, 1.0);
        valB = (valB + noiseB).clip(0.0, 1.0);
        {
            if(meterViews[0].notNil, { meterViews[0].value_(valA) });
            if(meterViews[1].notNil, { meterViews[1].value_(valB) });
        }.defer;
        phaseA = phaseA + 0.15;
        phaseB = phaseB + 0.11;
        updateInterval.wait;
    }
}).play(AppClock);

// ---------- cleanup ----------
window.onClose_({
    if(meterRoutine.notNil, { meterRoutine.stop });
});
)

===== RulesForChatGPT-Copilot.scd =====
// RulesForChatGPT-Copilot.scd

/*
STYLE, SYNTAX & CODING RULES (STRICT)
- SuperCollider ONLY known‑good syntax. Do NOT invent methods or pseudo‑slots.
- Variable style: descriptive lowercase names; **var-first in EVERY block and closure** (do a second pass each time).
- No non‑local returns; no `try` or `protect` (not supported).
- No `server.sync`. Use `Server.default.bind` for server ops. `s.waitForBoot` is allowed in bring‑up only.
- GUI: AppClock ONLY; NO FlowLayout; fixed vertical metrics; top‑left anchored; resizable width with safe layout; single titled window (“MagicDisplayGUI …”).
- Windows MUST return **→ a Window** as final expression.
- Titles/headers: Every SC file starts with my standard header:
  - Line 1: `<file name>`
  - Line 2: `// vX.Y.Z`
  - Line 3: `// MD <YYYY-MM-DD HH:MM TZ>`
  - Blank line
  - `/* Purpose / Style */`
  - Then code.
- Do not use any “v6” labels (legacy).
- JITLib connect operator: **`Ndef(left) <<> Ndef(right)`** ONLY (never `<>` or `<<>>`).
- Sinks/processors read from `\in.ar(defaultNumChannels)`.
- Acceptance tests: generated audio only; NO SoundIn.

- ALWAYS do a second pass to check for variables after statements before showing me code.
*/
===== RunBook_20251002_Diagnostics.scd =====
// RunBook_20251002_Diagnostics.scd
// MD + Copilot 2025-10-02
// --- > RUN BLOCK BY BLOCK! <---
// Goal: Diagnosable bring-up of LPS headless + LPDisplay window.
// Adds pane writers, source toggles, retaps, chain probes, and robust adapter send.

//////////////////////////////////////////////////////
// 1) Preflight cleanup (safe, idempotent; no errors)
//////////////////////////////////////////////////////
(
var wins, demoKeys, demoSyms;

wins = Window.allWindows.select({ |w|
    (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI")
    or: { w.tryPerform(\name) == "Layout Test" }
});
wins.do(_.close);

// Free LPDisplay demo responders (if they exist)
demoKeys = [ \rmsA_toGUI, \rmsB_toGUI, \rmsA_console, \rmsB_console ];
demoKeys.do({ |k| var d = OSCdef(k); if(d.notNil) { d.free } });

// Stop LPDisplay demo Ndefs (if present)
demoSyms = [ \srcA, \srcB, \srcC, \srcZ, \outA, \outB ];
demoSyms.do({ |sym| var nd = Ndef(sym); if(nd.notNil) { nd.stop } });

// Remove any prior visualization taps we may have installed in an earlier run
Server.default.bind({
    if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\lpdispTapA) };
    if (Ndef(\chainB).notNil) { Ndef(\chainB).clear(\lpdispTapB) };
});

"✔ Cleanup done.".postln;
)


//////////////////////////////////////////////////////////
// 2) Open the LPDisplay window + install PANE HELPERS
//////////////////////////////////////////////////////////
(
var inst, win;

// Controller + window  (-> a Window titled "Layout Test")
inst = LPDisplayLayoutTestWindow.new(nil);  // nil HUD = raw meters
win  = inst.open;                           // -> a Window

// Keep LPDisplay's own demo quiet by default (we'll offer toggles)
inst.setSourceA(\srcZ);
inst.setSourceB(\srcZ);

// Optional console gate (if your class has it)
try { inst.setConsoleLevelsOn(false) } { };

// Export handles
~inst = inst; ~win = win;

// ---- Pane helpers (so we can write quickly) ----
// pane keys seen in LPDisplayLayoutTestWindow: \left \right \system \diag \choices \recv
~pane = { |paneKey, text|
    // failsafe if sendPaneText not present
    var ok = (~inst.notNil and: { ~inst.respondsTo(\sendPaneText) });
    if (ok) { ~inst.sendPaneText(paneKey.asSymbol, text.asString) } { text.postln };
};
~paneAppend = { |paneKey, text|
    // naive append: readback not available, so just post new line
    ~pane.(paneKey, text)
};
~statusHUD = { |msg|  // put important status in the system pane & console
    ("[HUD] " ++ msg).postln;
    ~pane.(\system, msg);
};

// Initial HUD
~pane.(\diag, "LPDisplay ready @ " ++ Date.getDate.stamp);
~pane.(\system, "System: waiting for LPS…");
~pane.(\left,  "A: (LPDisplay demo source muted)");
~pane.(\right, "B: (LPDisplay demo source muted)");
~pane.(\choices, "—");
~pane.(\recv, "—");

// Quick confirmation
[ inst.notNil, win.notNil, win.class ].postln;
"→ a Window".postln;
)


////////////////////////////////////////////////////////////
// 3) Bring up LivePedalboardSystem (headless) + quick HUD
////////////////////////////////////////////////////////////
(
var system;
var san;
system = LivePedalboardSystem.new(nil);
system.ensureServerReady;
system.bringUpPedalboard;
system.bringUpCommandSystem;
system.installAdapterBridge;

~system = system;

"✔ LPS up (headless).".postln;
~statusHUD.("LPS up (headless)");

Server.default.bind({ Ndef(\chainA).ar(2); Ndef(\chainB).ar(2) });  // assert stereo busses

// Show core boolean sanity in console AND pane:
san = [ \system: ~system.notNil, \pedalboard: ~system.pedalboard.notNil, \cm: ~system.commandManager.notNil ];
san.postln;
~pane.(\diag, ("Sanity: " ++ san).asString);
)


///////////////////////////////////////////////////////////////
// 4) LPDisplay RETAP from LPS chain ends (safe pass-through)
///////////////////////////////////////////////////////////////
(
var rateHz;
var r;

rateHz = 20;

Server.default.bind({
    if (Ndef(\chainA).notNil) {
        Ndef(\chainA).filter(\lpdispTapA, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsA",  [rms[0], rms[1]], 1);   // console/legacy path
            SendReply.kr(t, "/rmsA_toGUI",[rms[0], rms[1]], 1);   // GUI path
            in
        });
    };
    if (Ndef(\chainB).notNil) {
        Ndef(\chainB).filter(\lpdispTapB, { |in|
            var sig = in.isArray.if({ in }, { [in, in] });
            var rms = RMS.kr(sig, 500);
            var t   = Impulse.kr(rateHz);
            SendReply.kr(t, "/peakrmsB",  [rms[0], rms[1]], 2);
            SendReply.kr(t, "/rmsB_toGUI",[rms[0], rms[1]], 2);
            in
        });
    };
});
"✔ LPDisplay retap installed.".postln;

// Confirm which responders are live
r = [
    \rmsA_toGUI: (OSCdef(\rmsA_toGUI).notNil),
    \rmsB_toGUI: (OSCdef(\rmsB_toGUI).notNil),
    \rmsA_console: (OSCdef(\rmsA_console).notNil),
    \rmsB_console: (OSCdef(\rmsB_console).notNil)
];
r.postln;
~pane.(\diag, ("OSC responders: " ++ r).asString);
)


///////////////////////////////////////////////////////
// 5) Quick DIAGNOSTIC CONTROLS & INSPECTION HELPERS
///////////////////////////////////////////////////////
(
// A) Toggle LPDisplay’s INTERNAL demo sources (pure UI demo, not LPS):
~lpDemo_on  = { ~inst.setSourceA(\srcA); ~inst.setSourceB(\srcB);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcA");
                ~pane.(\right, "B: LPDisplay demo src = \\srcB");
                ~statusHUD.("LPDisplay demo sources ON") };

~lpDemo_off = { ~inst.setSourceA(\srcZ); ~inst.setSourceB(\srcZ);
                ~pane.(\left,  "A: LPDisplay demo src = \\srcZ (muted)");
                ~pane.(\right, "B: LPDisplay demo src = \\srcZ (muted)");
                ~statusHUD.("LPDisplay demo sources OFF") };

// B) Chain probes (prints + panes)
~probeChains = {
    var aPlay = Ndef(\chainA).isPlaying, bPlay = Ndef(\chainB).isPlaying;
    var busA  = (Ndef(\chainA).bus ? \nil), busB = (Ndef(\chainB).bus ? \nil);
    var msg   = ("A playing="++aPlay++" bus="++busA) ++ " | " ++ ("B playing="++bPlay++" bus="++busB);
    msg.postln;
    ~pane.(\system, "Chains — " ++ msg);
};

// C) Audible test insert/remove on chain A (tremolo) — safe pass-through
~diag_addTremA = {
    Server.default.bind({
        Ndef(\chainA).filter(\diag_tremA, { |in| in * LFTri.kr(1).range(0.25, 1.0) });
    });
    ~statusHUD.("Inserted test tremolo on chain A");
};
~diag_clearTrem = {
    Server.default.bind({
        if (Ndef(\chainA).notNil) { Ndef(\chainA).clear(\diag_tremA) };
    });
    ~statusHUD.("Cleared test tremolo on chain A");
};

// D) Try to describe chains via pedalboard API if present (best-effort)
~describeChains = {
    var pb = ~system.tryPerform(\pedalboard);
    var aTxt = "A: (unknown)", bTxt = "B: (unknown)";
    if (pb.notNil) {
        if (pb.respondsTo(\describe))      { aTxt = pb.describe(\A); bTxt = pb.describe(\B) } {
        if (pb.respondsTo(\chainToString)) { aTxt = pb.chainToString(\A); bTxt = pb.chainToString(\B) } };
    };
    ("ChainDesc: " ++ aTxt ++ " | " ++ bTxt).postln;
    ~pane.(\left,  aTxt.asString);
    ~pane.(\right, bTxt.asString);
};

// E) Minimal HUD refresh bundle
~refreshHUD = {
    ~probeChains.();
    ~describeChains.();
    ~pane.(\choices, "Nav helpers: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend");
};

"✔ Diagnostics installed. Use: ~lpDemo_on/off, ~probeChains, ~diag_addTremA, ~diag_clearTrem, ~describeChains, ~refreshHUD".postln;
)


/////////////////////////////////////////////////////////////
// 6) Inline Emulator: navigation + robust canonical sender
/////////////////////////////////////////////////////////////
(
// --- var-first: gather references
var cm, mm, builder;
var longFromBuilder, canonicalize, applyCanonical, sendCanonical;
var showChildren, navName, navFret;

cm      = ~system.commandManager;
mm      = cm.midiManager;
builder = cm.builder;

// --- path builders (drop "root")
longFromBuilder = {
    var names = builder.currentNode.getPathToRoot;
    var filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
    ^("/" ++ filtered.join("/"))
};

canonicalize = { |rawPath|
    var parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
    if (parts.isEmpty) { ^rawPath.asString };
    var first = parts[0].asString;

    if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
        ^("/" ++ parts.join("/"));
    };
    if (first == "switch") { ^"/switch" };

    if (first == "chain") {
        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
            ^("/add/" ++ parts.last.asString);
        };
        if (parts.size >= 5
            and: { parts[1] == "setsource" }
            and: { parts[2] == "audio" }
            and: { parts[3] == "source" }) {
            ^("/setSource/" ++ parts.last.asString);
        };
    };

    ^rawPath.asString
};

// --- ROBUST sender: try bridge method names, then fallback direct to pedalboard if present
applyCanonical = { |shortPath|
    var bridge, applied=false;

    // 1) System-level applyCanonicalPath
    if (~system.respondsTo(\applyCanonicalPath)) {
        ~system.applyCanonicalPath(shortPath); applied=true;
    } {
        // 2) adapterBridge object with .applyPath ?
        bridge = ~system.tryPerform(\adapterBridge);
        if (bridge.notNil and: { bridge.respondsTo(\applyPath) }) {
            bridge.applyPath(shortPath); applied=true;
        } {
            // 3) Sometimes adapterBridge is a Function or symbol-wrapped
            if (bridge.isKindOf(Function)) {
                bridge.value(shortPath); applied=true;
            };
        };
    };

    if (applied) {
        ("Adapter applied: " ++ shortPath).postln;
        ~pane.(\recv, "Applied: " ++ shortPath);
        ^true
    } {
        // 4) Fallback: direct pedalboard verbs if exposed (best-effort)
        var pb = ~system.tryPerform(\pedalboard);
        if (pb.notNil) {
            var toks = shortPath.asString.split($/).reject(_.isEmpty);
            var verb = toks[0].asSymbol;
            var arg  = (toks.size>1).if({ toks[1].asSymbol }, { nil });
            var did  = false;

            switch(verb,
                \add,      { if (pb.respondsTo(\add) and: { arg.notNil }) { pb.add(arg); did=true } },
                \bypass,   { if (pb.respondsTo(\bypass) and: { arg.notNil }) { pb.bypass(arg); did=true } },
                \clear,    { if (pb.respondsTo(\clear)) { pb.clear; did=true } },
                \setSource,{ if (pb.respondsTo(\setSource) and: { arg.notNil }) { pb.setSource(arg); did=true } },
                \switch,   { /* NO direct mpb.switch() (name clashes with Object:switch) */ },
                { } // default
            );

            if (did) {
                ("Fallback MPB applied: " ++ shortPath).postln;
                ~pane.(\recv, "Fallback applied: " ++ shortPath);
                ^true
            };
        };

        ("⚠ Adapter not available for: " ++ shortPath).warn;
        ~pane.(\recv, "⚠ No adapter for: " ++ shortPath);
        ^false
    };
};

sendCanonical = { |shortPath|
    var ok = applyCanonical.(shortPath);
    ~refreshHUD.();  // update panes after any change
    ok
};

// --- Navigation helpers
showChildren = {
    var info = builder.currentNode.children.collect({ |n| [n.name, n.fret] });
    ("Children: " ++ info).postln;
    ~pane.(\choices, info.asString);
    ^info
};

navName = { |nameString|
    builder.navigateByName(nil, nameString.asString);
    cm.updateDisplay;
    showChildren.();
};
navFret = { |stringNum, fretNum|
    builder.navigateByFret(stringNum, fretNum);
    cm.updateDisplay;
    showChildren.();
};

// --- Top-level API (like the old emulator)
~toProg = {
    cm.currentState = \prog;
    cm.updateDisplay;
    "Navigation started (prog).".postln;
    ~pane.(\system, "Mode: prog (nav)");
    showChildren.();
};

~showNav  = {
    var long = longFromBuilder.(), short = canonicalize.(long);
    ("Long:  " ++ long).postln;  ("Short: " ++ short).postln;
    ~pane.(\diag, "Long="++long++"  Short="++short);
};

~toQueue  = {
    var short = canonicalize.( longFromBuilder.() );
    cm.queue.enqueueCommand(short);
    ("Queued: " ++ short).postln;
    ~pane.(\recv, "Queued: " ++ short);
    short
};

~toSend   = {
    var short = canonicalize.( longFromBuilder.() );
    sendCanonical.(short);
};

~navName  = navName;
~navFret  = navFret;
"✔ Emulator online. Use: ~toProg, ~navName(\"…\"), ~navFret(s,f), ~showNav, ~toQueue, ~toSend".postln;
)


//////////////////////////////////////////////////////
// 7) Scenarios — first by NAME, then direct CANONICAL
//////////////////////////////////////////////////////

// 7A) NAME-based Add Delay
(
~toProg.();
~navName.("audio");
~navName.("timebased");
~navName.("delay");
~showNav.();               // expect Short: /add/delay
~toSend.();                // robust adapter call or fallback
)

// 7B) Direct CANONICAL (no nav) — prove the path independently
(
~sendCanonical.("/add/delay");
)

// 7C) Switch chains — ALWAYS via adapter (no direct mpb.switch())
(
~toProg.();
~navName.("switch");
~showNav.();               // expect Short: /switch
~toSend.();                // robust adapter call
// OR direct canonical:
// ~sendCanonical.("/switch");
)

//////////////////////////////////////////////////////
// 8) Quick audible checks (optional, reversible)
//////////////////////////////////////////////////////

// 8A) Turn LPDisplay demo sources ON (just to see UI move), then OFF
// ~lpDemo_on.();
// ~lpDemo_off.();

// 8B) Insert tremolo on A (you should hear amplitude wobble), then clear
// ~diag_addTremA.();
// ~diag_clearTrem.();

// 8C) Refresh HUD summary
// ~refreshHUD.();
===== Sim_MIDI_FootAndGuitar_Demo_v0.1.scd =====
// Sim_MIDI_FootAndGuitar_Demo_v0.1.scd
// v0.1.2
// MD 2025-09-26 10:45 BST

/* Purpose / Style
   Simulate foot controller + hex guitar without hardware:
   - FOOT (noteOn): 36→\idle, 38→\prog, 40→\queue, 41→\send
   - GUITAR (channels 0..5 → strings 6..1) bases [40,45,50,55,59,64]
   - Drives MIDIInputManager handlers + CommandManager + adapter bridge if present.

   Style
   - var-first everywhere; descriptive lowercase variable names; AppClock-only; no server.sync.
   - Generated audio only; exclusivity Option A remains enforced by bring-up (no SoundIn).
*/

(
var ensureSystem, basePitches, ensureReady, footToIdle, footToProg, footToQueue, footToSend;
var guitarNote, navFret, showCanonical, refreshChoices;
var runScenarioAddDelay, runScenarioSwitch, runScenarioBypassOn, runAllScenarios, logger;

logger = { arg message; ("[SIM] " ++ message).postln };

ensureSystem = {
    var systemInstance;
    if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };
    systemInstance = LivePedalboardSystem.new(nil);  // nil -> class path resolver
    ~system = systemInstance;
    ~system.bringUpAll;
    if(~system.respondsTo(\installAdapterBridge)) { ~system.installAdapterBridge };
    logger.("system is up (GUI + MPB + CommandTree)");
};

ensureReady = {
    var ok;
    ok = ~system.notNil
        and: { ~system.commandManager.notNil }
        and: { ~system.commandManager.midiManager.notNil };
    if(ok.not) { "⚠️ Run ensureSystem.() first".warn };
    ok
};

basePitches = IdentityDictionary[
    0 -> 40, 1 -> 45, 2 -> 50, 3 -> 55, 4 -> 59, 5 -> 64
];

footToIdle  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 36) } };
footToProg  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 38) } };
footToQueue = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 40) } };
footToSend  = { if(ensureReady.()) { ~system.commandManager.midiManager.footControllerHandler.handleMessage(0, \noteOn, 41) } };

guitarNote = { arg stringNumber, fretNumber;
    var midiManager, channelIndex, baseNote, midiPitch;
    if(ensureReady.().not) { ^nil };
    midiManager = ~system.commandManager.midiManager;
    channelIndex = (6 - stringNumber.asInteger).clip(0, 5);
    baseNote = basePitches[channelIndex];
    if(baseNote.isNil) { "⚠️ Invalid string number".warn; ^nil };
    midiPitch = (baseNote + fretNumber.asInteger).asInteger;
    midiManager.guitarHandler.handleMessage(channelIndex, \noteOn, midiPitch);
};
navFret = { arg stringNumber, fretNumber; guitarNote.(stringNumber, fretNumber) };

showCanonical = {
    var cmRef, builderRef, longPath, shortPath;
    if(ensureReady.().not) { ^nil };
    cmRef = ~system.commandManager; builderRef = cmRef.builder;
    builderRef.printPathToRoot;
    longPath  = cmRef.buildLongPathFromBuilder(builderRef);
    shortPath = cmRef.canonicalPathFromBuilder(builderRef);
    ("• long=" ++ longPath ++ "  canonical=" ++ shortPath).postln;
};
refreshChoices = { if(~system.notNil) { ~system.commandManager.updateDisplay } };

runScenarioAddDelay = {
    footToProg.(); refreshChoices.();
    navFret.(6, 1); navFret.(5, 5); navFret.(4, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario A complete (add delay)");
};

runScenarioSwitch = {
    footToProg.();
    navFret.(6, 5);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario B complete (switch)");
};

runScenarioBypassOn = {
    footToProg.();
    navFret.(6, 3); navFret.(5, 9); navFret.(4, 3); navFret.(3, 3);
    showCanonical.(); footToQueue.(); footToSend.();
    logger.("Scenario C complete (bypass delay on)");
};

runAllScenarios = {
    var stepIndex;
    stepIndex = 0;
    AppClock.sched(0.0, {
        switch(stepIndex,
            0, { ensureSystem.(); stepIndex = 1; AppClock.sched(0.40, { runAllScenarios.(); nil }) },
            1, { runScenarioAddDelay.(); stepIndex = 2; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            2, { runScenarioSwitch.();   stepIndex = 3; AppClock.sched(0.80, { runAllScenarios.(); nil }) },
            3, { runScenarioBypassOn.(); nil },
            { nil }
        );
        nil
    });
    "[SIM] queued runAllScenarios".postln;
};

~sim_runAll = { runAllScenarios.() };
logger.("Evaluate:  ensureSystem.();  then  ~sim_runAll.();");
)

===== Start_LivePedalboardSuite_BringUp_LPDisplay.scd =====
// Start_LivePedalboardSuite_BringUp_LPDisplay.scd
// v0.3.1
// MD 20251006-1155

/*
Purpose / Style
---------------
Starter script to bring up the LivePedalboardSystem with LPDisplay GUI.
- Relies on internal GUI bring-up from LivePedalboardSystem v0.3.0
- Uses bringUpAllWithLPDisplayAutoBind for full system + display binding
- Returns -> a Window

Style:
- var-first declarations
- No non-local returns (^)
- AppClock only for GUI timing
- Known-good SuperCollider syntax only
*/

(
var livePedalboardSystem, lpDisplayController;

// Step 1 — Boot server and clean tree if needed
s.waitForBoot;
s.initTree;
s.defaultGroup.freeAll;
"[Start-LPDisplay] Server booted and tree initialized.".postln;

// Step 2 — Create LivePedalboardSystem and bring up everything
livePedalboardSystem = LivePedalboardSystem.new(nil);
~livePedalboardSystem = livePedalboardSystem; // optional global for debugging
livePedalboardSystem.bringUpAllWithLPDisplayAutoBind;
"[Start-LPDisplay] System and display bring-up completed.".postln;

// Step 3 — Retrieve display controller from system
lpDisplayController = livePedalboardSystem.statusDisplay;
~lpDisplayController = lpDisplayController; // optional global for debugging

// Step 4 — Return GUI controller (required: -> a Window)
lpDisplayController
)

===== StartHere_LivePedalboardSuite.scd =====
// StartHere_LivePedalboardSuite.scd
// v0.6.1
// MD 20250928-1824
//
// Purpose
// - Canonical bring-up for LivePedalboardSuite using ONE GUI with WORKING METERS.
// - Avoid duplicate GUI/taps: rely on LivePedalboardSystem.bringUpAll to open GUI,
//   then install the adapter bridge and auto-meters once.
//
// Style / Guard Rails
// - single () block; var-first; lowercase names; no server.sync; no non-local '^'.
// - UI via AppClock; server ops inside Server.default.bind when needed.
// - Returns -> a Window (MagicDisplayGUI…).

(
var meterRate, postSwitchDelay, systemRef, windowRef;
var findMagicDisplayWindow, closeExistingMagicDisplayWindows, frontWindow, afterBringUp;

// ---- tunables ----
meterRate = 24;
postSwitchDelay = 0.35;

// ---- helpers ----
closeExistingMagicDisplayWindows = {
    var windows, i, w, nameString;
    windows = Window.allWindows; i = 0;
    while { i < windows.size } {
        w = windows[i];
        nameString = w.tryPerform(\name);
        if(nameString.notNil and: { nameString.asString.beginsWith("MagicDisplayGUI") }) {
            w.close;
        };
        i = i + 1;
    };
};

findMagicDisplayWindow = {
    var win;
    win = Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    });
    win
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    // Adapter: route short canonical commands to MagicPedalboard (+HUD toggle on /switch)
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    // Meters: assert one set of taps + GUI re-arm (idempotent)
    if(lps.respondsTo(\enableAutoMeters)) { lps.enableAutoMeters(meterRate, postSwitchDelay) };
    // detect and front the GUI window
    frontWindow.(findMagicDisplayWindow.());
};

// ---- run ----

// 0) keep one GUI window only
closeExistingMagicDisplayWindows.();

// 1) shutdown existing system cleanly (if present)
if(~system.notNil and: { ~system.respondsTo(\shutdownAll) }) { ~system.shutdownAll };

// 2) construct and bring up everything (this will open the GUI once)
systemRef = LivePedalboardSystem.new(nil);
systemRef.bringUpAll;

// 3) post-steps: adapter bridge + meters + front window
windowRef = afterBringUp.(systemRef);

// 4) publish handles
~system = systemRef;
~mpb = systemRef.pedalboard;
~gui = systemRef.statusDisplay;

// 5) return the GUI window
windowRef
)

===== temporary/Hook_Switch_NoXfade.scd =====
// Hook_Switch_NoXfade_FIX.scd
// v0.1.1
// MD 20251005-1758

/*
Purpose
- TEMP: bypass MagicPedalboard's internal crossfade for "/switch".
- IMPORTANT CHANGE vs v0.1.0: Do *all* mapping *after* the bridge toggles
  ~md_currentChain, so CURRENT is the new active side when we assign sources.
Behavior on "/switch":
  1) Do NOT call the original adapter (prevents MPB crossfade).
  2) After ~60 ms (enough for the bridge to toggle the current side & update UI):
     - set CURRENT -> \testmelody
     - set NEXT    -> \ts0
     - mpb.playCurrent
     - rematerialize endpoints as 2-ch
- All other paths pass through unchanged.
Style
- var-first; lowercase; no server.sync; AppClock for timing; defensive respondsTo.
*/

(
var install, wrap;

install = {
    var prev;

    // Keep the currently-active adapter (it may already be a wrapper from AutoMeters)
    prev = ~ct_applyOSCPathToMPB;

    // Install wrapper only once (idempotent-ish)
    if(~ct_applyOSCPathToMPB_prev.isNil) {
        ~ct_applyOSCPathToMPB_prev = prev;
    } {
        // If already installed, refresh wrapper to the latest prev
        prev = ~ct_applyOSCPathToMPB_prev;
    };

    ~ct_applyOSCPathToMPB = { |pathString, mpb, gui|
        var p, isSwitch;

        p = pathString.asString;
        isSwitch = p.beginsWith("/switch");

        if(isSwitch.not) {
            ^~ct_applyOSCPathToMPB_prev.(p, mpb, gui);
        };

        // --- switch path (NO XFADE) ---
        // We *don’t* forward /switch to the prev adapter.
        // Instead, we wait a tick so the bridge can toggle ~md_currentChain.
        AppClock.sched(0.06, {
            var currentSide, currentIsA;

            currentSide = (~md_currentChain ? \A); // now reflects the new ACTIVE side
            currentIsA  = (currentSide == \A);

            if(currentIsA) {
                if(mpb.respondsTo(\setSourceA)) { mpb.setSourceA(\testmelody) };
                if(mpb.respondsTo(\setSourceB)) { mpb.setSourceB(\ts0) };
            }{
                if(mpb.respondsTo(\setSourceA)) { mpb.setSourceA(\ts0) };
                if(mpb.respondsTo(\setSourceB)) { mpb.setSourceB(\testmelody) };
            };

            if(mpb.respondsTo(\playCurrent)) { mpb.playCurrent };

            Server.default.bind({
                if(Ndef(\chainA).notNil) { Ndef(\chainA).ar(2) };
                if(Ndef(\chainB).notNil) { Ndef(\chainB).ar(2) };
            });

            ("[NoXfade] switch mapped AFTER toggle: CURRENT=" ++ currentSide.asString
             ++ " (CURRENT->\\testmelody, NEXT->\\ts0)").postln;
            nil
        });

        ^nil
    };

    "[NoXfade] Hook installed (mapping AFTER bridge toggle).".postln;
};

install.();
)
===== temporary/List_ClassExtensions_ByOwner.scd =====
// List_ClassExtensions_ByOwner.scd
// v1.0.0
// MD 20251006-1530

/*
Purpose
- List all class extension files that add methods to key classes using the +ClassName { ... } form.
- Targets: LivePedalboardSystem, MagicPedalboard, LPDisplayLayoutWindow, LPDisplayAdapter.
- Opens a Document with grouped results.

Style
- STRICT: var-first; descriptive lowercase names; no single-letter locals; no non-local returns (^).
- Known-good sclang only.

Notes
- We avoid deep parsing; we just detect lines that begin with "+ClassName" and contain "{".
- If you want to add more classes, edit targetClasses below.
*/

(
var nowStamp, suiteRoot, targetClasses;
var listFiles, readText, toRel, scanForExtensions;
var allFiles, scFiles, hitsByClass, docLines, doc;

// ----- config -----
nowStamp     = Date.getDate.stamp;
suiteRoot    = (Platform.userExtensionDir ++ "/LivePedalboardSuite").standardizePath;
targetClasses = ["LivePedalboardSystem", "MagicPedalboard", "LPDisplayLayoutWindow", "LPDisplayAdapter"];

// ----- helpers -----
listFiles = { arg rootPath;
    var out, walk, skip;
    out = List.new;
    skip = [".git", ".cache", "_archived"];
    walk = { arg pn;
        var name, stopHere;
        name = pn.fileName.asString;
        stopHere = skip.any({ arg s; name == s });
        if(stopHere) {
            nil
        } {
            if(pn.isFile) { out.add(pn.fullPath) } { pn.entries.do({ arg c; walk.value(c) }) };
        };
        nil
    };
    walk.value(PathName(rootPath));
    out.asArray
};

readText = { arg fullPath;
    var text;
    text = "";
    File.use(fullPath, "r", { arg f; text = f.readAllString; });
    text ? ""
};

toRel = { arg fullPath;
    var norm;
    norm = fullPath.standardizePath;
    if(norm.beginsWith(suiteRoot)) {
        norm.copyRange(suiteRoot.size + 1, norm.size - 1)
    } {
        norm
    }
};

scanForExtensions = { arg fullPath;
    var text, lines, results, idx, line, stripped;
    text    = readText.value(fullPath);
    lines   = text.split(Char.nl);
    results = List.new;

    idx = 0;
    while({ idx < lines.size }, {
        line = lines[idx];
        if(line.notNil) {
            stripped = line.stripWhiteSpace;
            targetClasses.do({ arg cls;
                var key = "+" ++ cls;
                if(
                    (stripped.beginsWith(key))
                    and: { stripped.contains("{") }
                ) {
                    results.add(cls);
                };
            });
        };
        idx = idx + 1;
    });
    results.asArray
};

// ----- scan -----
allFiles = listFiles.value(suiteRoot);
scFiles  = allFiles.select({ arg p; p.endsWith(".sc") });

hitsByClass = IdentityDictionary.new;
targetClasses.do({ arg cls; hitsByClass[cls] = List.new });

scFiles.do({ arg f;
    var extHits;
    extHits = scanForExtensions.value(f);
    extHits.do({ arg cls; hitsByClass[cls].add(f) });
});

// ----- report -----
docLines = List.new;
docLines.add("List_ClassExtensions_ByOwner — " ++ nowStamp);
docLines.add("Root: " ++ suiteRoot);
docLines.add(String.fill(88, $-));

targetClasses.do({ arg cls;
    var rows;
    docLines.add("== Extensions for +" ++ cls ++ " ==");
    rows = (hitsByClass[cls] ? List.new).asArray.sort;
    if(rows.size == 0) {
        docLines.add(" (none found)");
    } {
        rows.do({ arg full;
            docLines.add(" - " ++ toRel.value(full));
        });
    };
    docLines.add(String.fill(88, $-));
});

doc = Document.new("Class Extensions (" ++ nowStamp ++ ")", docLines.join(Char.nl.asString));
doc.front;
doc
)
===== temporary/Make_CURRENT_Audible.scd =====
// Make_CURRENT_Audible.scd
// v0.1.0
// MD 20251004-1820

/* Purpose
- Switch CURRENT to \testmelody and start playback (audible).
*/

(
var pb = ~system.tryPerform(\pedalboard);
if(pb.isNil) { "No ~system or pedalboard. Run Start_LivePedalboardSuite_BringUp.scd first.".warn; ^nil };
if(pb.respondsTo(\setSourceCurrent)) { pb.setSourceCurrent(\testmelody) };
if(pb.respondsTo(\playCurrent))      { pb.playCurrent };
"CURRENT set to testmelody (audible).".postln;
)
===== temporary/Make_Project_Inventory.scd =====
// Make_Project_Inventory.scd
// v0.1.0
// MD 20251005-2017

/*
Purpose
- Produce a concise, readable manifest of the LivePedalboardSuite:
  • Top-level tree (depth 2) for quick orientation
  • List all .sc / .scd files with their first 3 header lines (filename/version/MD stamp)
  • Confirm the adapter file path: adapter_CommandTree_to_MagicPedalboard.scd (if present)
- Writes a single text file in temporary/ so you can share or paste.

Style
- var-first; lowercase; no server.sync; conservative file reads.
*/

(
var rootDir, outDir, outPath;
var lines, nl, nowStamp;
var treeDepth, add, addSep, addLine, addSection, isCodeFile;
var relPathOf, printTreeL2, collectHeaders;

nl = Char.nl;
nowStamp = Date.getDate.stamp;  // e.g. 251005_2017

rootDir = (Platform.userExtensionDir ++ "/LivePedalboardSuite").standardizePath;
outDir  = (rootDir ++ "/temporary").standardizePath;
outPath = (outDir ++ "/Project_Inventory_" ++ nowStamp ++ ".txt").standardizePath;

lines = List.new;

add = { |s| lines.add(s); };
addSep = { lines.add("----------------------------------------"); };
addLine = { |k, v| lines.add((k ++ ": " ++ v.asString)); };
addSection = { |title|
    lines.add("");
    lines.add("===== " ++ title ++ " =====");
};

isCodeFile = { |pn|
    var ext;
    ext = pn.extension ? "";
    [ "sc", "scd" ].includes(ext.asString.toLower)
};

relPathOf = { |full|
    var base = PathName.new(rootDir).pathOnly;
    var s = full.asString;
    s.replace(base, "").replace("//", "/")
};

treeDepth = 2;  // depth for quick tree

printTreeL2 = { |dirPath|
    var pn, level1Dirs;

    pn = PathName.new(dirPath);
    if(pn.exists.not) {
        add("[!] Directory does not exist: " ++ dirPath);
        ^this;
    };

    add("ROOT: " ++ dirPath);
    addSep.();

    // level 0 files
    pn.files.do { |f|
        add("· " ++ relPathOf.(f.fullPath));
    };

    // level 1 folders and their files (depth 2 total)
    level1Dirs = pn.folders;
    level1Dirs.do { |d1|
        add("▸ " ++ relPathOf.(d1.fullPath));
        // files in d1
        PathName.new(d1.fullPath).files.do { |f1|
            add("  · " ++ relPathOf.(f1.fullPath));
        };
        // subfolders one level deeper
        PathName.new(d1.fullPath).folders.do { |d2|
            add("  ▸ " ++ relPathOf.(d2.fullPath));
            PathName.new(d2.fullPath).files.do { |f2|
                add("    · " ++ relPathOf.(f2.fullPath));
            };
        };
    };
};

collectHeaders = {
    var walk, pnRoot;

    pnRoot = PathName.new(rootDir);

    addSection.("Code files with headers (.sc / .scd)");
    add("(first 3 lines per file, if present: filename/version/MD stamp)");
    addSep.();

    walk = { |pn|
        // files at this level
        pn.files.do { |f|
            var p, contents, heads, head1, head2, head3;
            if(isCodeFile.(f)) {
                p = f.fullPath;
                // read first few KB to avoid loading huge files
                contents = "";
                File.use(p, "r", { |fh|
                    contents = fh.readAllString;  // ok for typical SC files; adjust if needed
                });
                heads = contents.split(Char.nl);
                head1 = heads.size > 0.if({ heads[0] }, { "" });
                head2 = heads.size > 1.if({ heads[1] }, { "" });
                head3 = heads.size > 2.if({ heads[2] }, { "" });

                add(relPathOf.(p));
                add("  " ++ head1);
                add("  " ++ head2);
                add("  " ++ head3);
                add("");
            };
        };
        // recurse folders
        pn.folders.do { |fd| walk.(PathName.new(fd.fullPath)) };
    };

    walk.(pnRoot);
};

// ---------------------------------------------------------------------
// Build the manifest
add("LPDisplay ↔ MagicPedalboard — Project Inventory");
addLine.("Generated", nowStamp);
addLine.("UserExtensionDir", Platform.userExtensionDir);
addLine.("Suite root", rootDir);
addSep.();

addSection.("Directory tree (depth 2)");
printTreeL2.(rootDir);

addSection.("Adapter file");
{
    var adapterPath = (rootDir ++ "/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd").standardizePath;
    addLine.("adapter_CommandTree_to_MagicPedalboard.scd", (File.exists(adapterPath).if({adapterPath}, {"[missing]"})));
};

collectHeaders.();

// ---------------------------------------------------------------------
// Write to file
File.mkdir(outDir);  // ensure temporary/ exists
{
    var f, txt;
    f = File(outPath, "w");
    txt = String.join(lines, nl);
    f.write(txt);
    f.close;
};

("📄 Inventory written to: " ++ outPath).postln;
// End
)
===== temporary/Open_SPEC_LPS_LPDisplay_Draft.scd =====
// Open_SPEC_LPS_LPDisplay_Draft.scd
// v1.0.0
// MD 20251006-1530

/*
Purpose
- Open the LPDisplay-focused system SPEC in a SC Document so you can review & save.
*/

(
var nowStamp, lines, doc;
nowStamp = Date.getDate.stamp;

lines = [
"# LivePedalboardSystem + LPDisplay — System Specification",
"**Version:** 1.0 (" ++ nowStamp ++ ")",
"",
"## 1. Purpose",
"LivePedalboardSystem orchestrates **MagicPedalboard** (A/B JITLib chains), **MDMiniLogger**, and the **CommandTree**. The **LPDisplay** UI (controller: `LPDisplayLayoutWindow`) is the *only* user-facing display. The old window code is out of scope.",
"",
"## 2. Architecture Overview",
"- **MagicPedalboard**",
"  - Two chains: **A** and **B** (Ndefs).",
"  - Wiring operator: `Ndef(left) <<> Ndef(right)`; sinks read `\\in.ar(2)`.",
"  - Exclusivity: only one chain audible at a time (A or B), enforced at the source.",
"- **Meters**",
"  - Meters update via `SendPeakRMS` taps **inside** the active chains, publishing to:",
"    - `/peakrmsA` (id **2001**), `/peakrmsB` (id **2002**).",
"  - HUD/UI mapping uses headroom: **top −6 dB**, **floor −60 dB**, **gamma 1.0** (PerfHUD/LPDisplay convention).",
"- **LPDisplay (controller: `LPDisplayLayoutWindow`)**",
"  - Renders: chain labels (processor lists), active chain highlight, status text, meters.",
"  - GUI refresh: **AppClock** only; single window returned by bring‑up (`-> a Window`).",
"- **LivePedalboardSystem**",
"  - Holds references to MagicPedalboard, MDMiniLogger, CommandTree, and (after binding) LPDisplay controller/adapter.",
"  - Provides **one binding entry point** to connect LPDisplay and push a snapshot (see §4).",
"",
"## 3. OSC & IDs",
"- `/peakrmsA` id **2001**, `/peakrmsB` id **2002** (two floats payload: peak + RMS/approx‑amp as used by the HUD).",
"- No alternate paths or “retap” scripts; taps live **inside** the chains.",
"",
"## 4. Binding LPDisplay",
"- System‑led binding (preferred):",
"  - `~livePedalboardSystem.autoBindLPDisplay(displayController)` sets the controller and calls the adapter under the hood.",
"  - On bind (or via `refreshDisplay`), the system must push:",
"    - `setChains(chainA_symbols, chainB_symbols)`",
"    - `setActiveChain(\\A | \\B)`",
"    - `setStatus(\"READY\" | presetName | message)`",
"- Optional: `~livePedalboardSystem.enableAutoMeters` installs taps via the project’s canonical helpers.",
"",
"## 5. Acceptance Criteria",
"1. **Bring‑up** (starter returns `-> a Window`) shows LPDisplay window front.",
"2. **Chain labels** reflect the current processor lists (source → … → sink) for A and B.",
"3. **Active highlight** follows the MagicPedalboard active chain (A/B toggle).",
"4. **Meters** move whenever audio is generated internally (no SoundIn needed).",
"5. On exit, all test resources are cleaned (no stray Ndefs or OSCdefs).",
"",
"## 6. Non‑goals",
"- The old window/UI code is not used for live operation.",
"- No ad‑hoc retap scripts; only `SendPeakRMS` taps inside the chains.",
"",
"## 7. Diagnostics",
"- Starter emits `[Start-LPDisplay] ...` logs at each step.",
"- System binding emits `[LPS↔LPD] bound/updated` logs (adapter/bridge are encouraged to post succinct confirmations)."
];

doc = Document.new("SPEC_LivePedalboardSystem_LPDisplay.md", lines.join(Char.nl.asString));
doc.front;
doc
)

===== temporary/Run_Start_LPS_BringUp_WithSmoke.scd =====
// Run_Start_LPS_BringUp_WithSmoke.scd
// v0.9.2
// MD 20251006-1224

/*
Purpose
- Execute the current Start_LivePedalboardSuite_BringUp.scd (LPDisplay path),
  verify the LPDisplay window appears, and play a short beep for visual sanity.
- Returns -> a Window (the LPDisplay window) when successful.

Style
- STRICT: var-first, descriptive lowercase names, no single-letter locals, no non-local returns (^).
- Known-good sclang only. No server.sync; only s.waitForBoot, s.initTree, s.defaultGroup.freeAll.
- AppClock only for GUI timing.

Notes
- This runner does NOT modify your Start script; it simply reads & interprets it.
- Beep is generated audio (no SoundIn), then freed automatically.
*/

(
var nowStamp, userExtDir, suiteRoot;
var starterRelPath, starterFullPath;
var readText, interpretFile, findLPDisplayWindow, openInfoDoc;
var s, win, doc, beepSynth, ticker;

// ----- config -----
nowStamp      = Date.getDate.stamp;
userExtDir    = Platform.userExtensionDir;
suiteRoot     = (userExtDir ++ "/LivePedalboardSuite").standardizePath;
starterRelPath = "temporary/Start_LivePedalboardSuite_BringUp.scd";
starterFullPath = (suiteRoot ++ "/" ++ starterRelPath).standardizePath;

// ----- helpers -----
readText = { arg fullPath;
    var text;
    text = "";
    File.use(fullPath, "r", { arg f; text = f.readAllString; });
    text ? ""
};

interpretFile = { arg fullPath;
    var src;
    src = readText.value(fullPath);
    if(src.size > 0) { src.interpret } { "/* empty file */".interpret };
    nil
};

// Heuristic: look for an LPDisplay window by name
findLPDisplayWindow = {
    var wins, hit, nameStr;
    wins = Window.allWindows ? [];
    hit = nil;
    wins.do({ arg w;
        nameStr = w.name ? "";
        if(
            nameStr.contains("LPDisplay") or: {
                nameStr.contains("Layout") or: { nameStr.contains("MagicDisplayGUI") }
            }
        ) {
            hit = w;
        };
    });
    hit
};

openInfoDoc = { arg linesArray;
    var d;
    d = Document.new("BringUp report (" ++ nowStamp ++ ")", linesArray.join(Char.nl.asString));
    d.front;
    d
};

// ----- begin -----
s = Server.default;

// clean server boot (no server.sync)
if(s.serverRunning.not) {
    s.waitForBoot({
        ("Server booted @ " ++ nowStamp).postln;
    });
} {
    "Server already running; proceeding with init.".postln;
};

// ensure known state
s.initTree;
s.defaultGroup.freeAll;

// run the Start script (must use LPDisplay path)
if(File.exists(starterFullPath)) {
    ("Running: " ++ starterRelPath).postln;
    interpretFile.value(starterFullPath);
} {
    doc = openInfoDoc.value([
        "ERROR: Starter not found",
        "Expected at: " ++ starterFullPath,
        "",
        "Check Platform.userExtensionDir and that your suite root contains:",
        "  /LivePedalboardSuite/" ++ starterRelPath
    ]);
    doc // return -> a Document; early exit
};

// small delay for windows to appear (GUI only)
AppClock.sched(0.1, {
    win = findLPDisplayWindow.value;
    if(win.isNil) {
        doc = openInfoDoc.value([
            "LPDisplay window not detected.",
            "Looked for window names containing: LPDisplay / Layout / MagicDisplayGUI",
            "",
            "Tip: Verify your Start script creates LPDisplayLayoutWindow and brings it front."
        ]);
        doc.front;
        // still finish with doc to avoid nil return
    } {
        // short sanity beep so meters can show life
        beepSynth = {
            var env, sig;
            env = Env.perc(0.005, 0.25, curve: -4).kr(doneAction: 2);
            sig = SinOsc.ar(880) * 0.1 * env;
            (sig ! 2)
        }.play;

        // bring the display to front; return it
        win.front;

        // post a small banner to console
        "LPDisplay bring-up OK — short beep played; window front.".postln;
    };
    // return the window (or doc fallback) as last value in AppClock
    win ? doc
});
)

===== temporary/Start_LivePedalboardSuite_BringUp_LPDisplay_older.scd =====
// Start_LivePedalboardSuite_BringUp_LPDisplay.scd
// v1.0.1
// MD 20251006-1438

/*
Purpose
- From a clean SC restart, bring up LivePedalboardSystem and show LPDisplay (not the old window).
- Keep it minimal and robust; return -> a Window (the LPDisplay GUI window).

Style
- STRICT: var-first; descriptive lowercase names; no single-letter locals; no non-local returns (^).
- No server.sync; use Server.default.waitForBoot, s.initTree, s.defaultGroup.freeAll.
- AppClock only for any GUI timing.

What this does
1) Boot the server into a known state.
2) Close any existing LPDisplay windows.
3) Create the LPDisplayLayoutWindow controller and obtain its GUI Window safely.
4) Instantiate LivePedalboardSystem.
5) (You uncomment exactly one) bind LPDisplay <-> system using your real helper.
6) Bring the LPDisplay window to front and return it.
*/

(
var server, nowStamp, suiteRoot;
var displayController, displayWindow;
var closeExistingLPDisplayWindows, obtainDisplayWindow, findDisplayWindowByName;

// ----- configuration -----
nowStamp   = Date.getDate.stamp;
suiteRoot  = (Platform.userExtensionDir ++ "/LivePedalboardSuite").standardizePath;
server     = Server.default;

// ----- helpers -----
closeExistingLPDisplayWindows = {
    var windows, nameString;
    windows = Window.allWindows ? [];
    windows.do({ arg w;
        nameString = w.name ? "";
        if(nameString.contains("LPDisplay") or: { nameString.contains("Layout") or: { nameString.contains("MagicDisplayGUI") } }) {
            w.close;
        };
    });
    nil
};

findDisplayWindowByName = {
    var windows, nameString, hit;
    windows = Window.allWindows ? [];
    hit = nil;
    windows.do({ arg w;
        nameString = w.name ? "";
        if(nameString.contains("LPDisplay") or: { nameString.contains("Layout") or: { nameString.contains("MagicDisplayGUI") } }) {
            hit = w;
        };
    });
    hit
};

obtainDisplayWindow = { arg controller;
    // Try common controller methods, then fall back to scanning open windows.
    var w;
    w = nil;

    // Some controllers implement .open, .makeWindow or .build returning a Window.
    if(w.isNil and: { controller.respondsTo(\open) })        { w = controller.open };
    if(w.isNil and: { controller.respondsTo(\makeWindow) })  { w = controller.makeWindow };
    if(w.isNil and: { controller.respondsTo(\build) })       { w = controller.build };
    // Some expose the internal Window via a .window accessor.
    if(w.isNil and: { controller.respondsTo(\window) })      { w = controller.window };

    // If still nil or not a Window, search by window title.
    if(w.isNil or: { w.isKindOf(Window).not }) {
        w = findDisplayWindowByName.value;
    };

    w // may still be nil if the controller didn't create a window
};

// ----- 1) server boot -> known state -----
if(server.serverRunning.not) {
    server.waitForBoot({ ("[Start] Server booted @ " ++ nowStamp).postln; });
} {
    "[Start] Server already running; proceeding.".postln;
};
server.initTree;
server.defaultGroup.freeAll;

// ----- 2) close any prior LPDisplay windows -----
closeExistingLPDisplayWindows.value;

// ----- 3) create LPDisplay controller and obtain the GUI Window -----
displayController = LPDisplayLayoutWindow.new;
displayWindow     = obtainDisplayWindow.value(displayController);

// If the controller didn't create a window, try a simple fallback open.
if(displayWindow.isNil) {
    if(displayController.respondsTo(\open)) {
        displayWindow = displayController.open;
    } {
        // As a last resort, look again by name (a deferred GUI build may have occurred).
        0.1.wait; // small GUI settle
        displayWindow = findDisplayWindowByName.value;
    };
}

// If we still have no Window, post a helpful note but keep going (so you can inspect).
if(displayWindow.isNil) {
    "[Start] LPDisplayLayoutWindow did not return a Window; check the controller's API.".postln;
} {
    displayWindow.front;
}

// ----- 4) instantiate the system (MagicPedalboard + MDMiniLogger + CommandTree) -----
~livePedalboardSystem = LivePedalboardSystem.new;

// ----- 5) YOU CHOOSE ONE binding line and UNCOMMENT it (leave the other commented) -----
// A) If you use the system’s autobind helper (file: LivePedalboardSystem-AutoBindLPDisplay.sc):
// ~livePedalboardSystem.autoBindLPDisplay(displayController);

// B) If you use the adapter (file: LPDisplayAdapter_SetController.sc):
// LPDisplayAdapter.setController(displayController);

// (Optional) If you have an auto-meters helper (file: LivePedalboardSystem-AutoMeters.sc):
// ~livePedalboardSystem.enableAutoMeters; // or ~livePedalboardSystem.autoMetersInstall;

// ----- 6) bring front and return -> a Window -----
if(displayWindow.notNil) { displayWindow.front };
displayWindow // -> a Window (or nil with console guidance)
)
===== temporary/Start_LivePedalboardSuite_BringUp_LPDisplay.scd =====
// Start_LivePedalboardSuite_BringUp_LPDisplay.scd
// v1.0.2
// MD 20251006-1502

/*
Purpose
- From a clean SC restart, bring up LivePedalboardSystem and show LPDisplay (not the old window).
- Minimal, explicit diagnostics, and returns -> a Window (the LPDisplay GUI window).

Style
- STRICT: var-first; descriptive lowercase names; no single-letter locals; no non-local returns (^).
- No server.sync; use Server.default.waitForBoot, s.initTree, s.defaultGroup.freeAll.
*/

(
var nowStamp, suiteRoot;
var displayController, displayWindow;
var s, postStep, scanForDisplayWindow, closeExistingDisplayWindows;

nowStamp  = Date.getDate.stamp;
suiteRoot = (Platform.userExtensionDir ++ "/LivePedalboardSuite").standardizePath;
s         = Server.default;

postStep = { arg msg; ("[Start-LPDisplay] " ++ msg).postln };

scanForDisplayWindow = {
    var hit;
    hit = nil;
    Window.allWindows.do({ arg w;
        var nameString = w.name ? "";
        if(
            nameString.contains("LPDisplay")
            or: { nameString.contains("Layout") }
            or: { nameString.contains("MagicDisplayGUI") }
        ) {
            hit = w;
        };
    });
    hit
};

closeExistingDisplayWindows = {
    var closedCount;
    closedCount = 0;
    Window.allWindows.do({ arg w;
        var nameString = w.name ? "";
        if(
            nameString.contains("LPDisplay")
            or: { nameString.contains("Layout") }
            or: { nameString.contains("MagicDisplayGUI") }
        ) {
            closedCount = closedCount + 1;
            w.close;
        };
    });
    postStep.value("Closed " ++ closedCount ++ " existing LPDisplay-related window(s).");
    nil
};

// 1) Boot server -> known state
s.serverRunning.not.if({
    postStep.value("Booting server...");
    s.waitForBoot({ postStep.value("Server booted @ " ++ nowStamp) });
},{
    postStep.value("Server already running; proceeding.");
});
s.initTree;
s.defaultGroup.freeAll;
postStep.value("Server tree initialized and default group cleared.");

// 2) Close any existing LPDisplay windows
closeExistingDisplayWindows.value;

// 3) Create LPDisplay controller and obtain its Window safely
postStep.value("Creating LPDisplayLayoutWindow controller...");
displayController = LPDisplayLayoutWindow.new;
postStep.value("Controller created: " ++ displayController.class.asString);

displayWindow = nil;

// Try common controller APIs in order; post diagnostics for each attempt
(displayWindow.isNil and: { displayController.respondsTo(\open) }).if({
    postStep.value("Calling controller.open ...");
    displayWindow = displayController.open;
    postStep.value("controller.open returned: " ++ displayWindow.class.asString);
},{});

(displayWindow.isNil and: { displayController.respondsTo(\makeWindow) }).if({
    postStep.value("Calling controller.makeWindow ...");
    displayWindow = displayController.makeWindow;
    postStep.value("controller.makeWindow returned: " ++ (displayWindow.notNil.if({ displayWindow.class.asString }, { "nil" })));
},{});

(displayWindow.isNil and: { displayController.respondsTo(\build) }).if({
    postStep.value("Calling controller.build ...");
    displayWindow = displayController.build;
    postStep.value("controller.build returned: " ++ (displayWindow.notNil.if({ displayWindow.class.asString }, { "nil" })));
},{});

(displayWindow.isNil and: { displayController.respondsTo(\window) }).if({
    postStep.value("Reading controller.window ...");
    displayWindow = displayController.window;
    postStep.value("controller.window is: " ++ (displayWindow.notNil.if({ displayWindow.class.asString }, { "nil" })));
},{});

// Fallback: scan open windows by title
displayWindow.isNil.if({
    postStep.value("Scanning open windows by name as fallback...");
    displayWindow = scanForDisplayWindow.value;
    postStep.value("Scan result: " ++ (displayWindow.notNil.if({ "found a Window" }, { "no Window found" })));
},{});

// 4) Instantiate the system (MagicPedalboard + MDMiniLogger + CommandTree)
postStep.value("Instantiating LivePedalboardSystem...");
~livePedalboardSystem = LivePedalboardSystem.new;
postStep.value("LivePedalboardSystem instance: " ++ ~livePedalboardSystem.class.asString);

// 5) Bind LPDisplay <-> system (UNCOMMENT EXACTLY ONE LINE YOU USE)
// A) If you use the system’s autobind helper:
// ~livePedalboardSystem.autoBindLPDisplay(displayController); postStep.value("autoBindLPDisplay called.");

// B) If you use the adapter:
// LPDisplayAdapter.setController(displayController); postStep.value("LPDisplayAdapter.setController called.");

// Optional: Auto-meters helper (uncomment if you want it in the starter):
// ~livePedalboardSystem.enableAutoMeters; postStep.value("enableAutoMeters called.");

// 6) Bring to front (only call .front on actual Window)
(displayWindow.notNil).if({
    postStep.value("Bringing LPDisplay window to front...");
    displayWindow.front;
    postStep.value("LPDisplay Window fronted. Starter returning -> a Window.");
},{
    postStep.value("WARNING: Could not obtain an LPDisplay Window. Check controller API and binding step.");
});

displayWindow // -> a Window, or nil with diagnostics above
)
===== temporary/Start_LivePedalboardSuite_BringUp.scd =====
// Start_LivePedalboardSuite_BringUp.scd
// v0.9.3
// MD 20251004-17:35

/*
Purpose
- One-run bring-up for LivePedalboardSuite:
  - Open/reuse LPDisplayLayoutWindow (single window).
  - Bring up LivePedalboardSystem (server, pedalboard, command system, MIDI).
  - Auto-bind CommandManager -> LPDisplay via LPDisplayAdapter.
  - Ensure audio graph is materialized; default is muted (CURRENT->\ts0).
  - Enable A/B end-of-chain meters after settle.
  - Set top pane titles to "Chain A"/"Chain B" and show src | procs | sink.
  - Auto-refresh ACTIVE/NEXT visual at start and on "/switch" (via AdapterBridge).

Style
- Single block; var-first; tilde (~) interpreter vars; AppClock for UI only.
- No server.sync; non-destructive across re-runs.
- Returns -> a Window.
*/

(
var lps_startMuted, lpResolveClass, lpOpenWindow, silenceLpDemo, silenceLpDemoDeferred,
    buildChainSummary, setTitlesOnce, findPaneLabel, setLabelString,
    setCurrentSource, win, hadSystem, cm, displayObj;

// CONFIG: set to false if you want the arpeggio audible on bring-up
lps_startMuted = false;

// ---------- LPDisplay helpers ----------
lpResolveClass = { \LPDisplayLayoutWindow.asClass ?? { \LPDisplayLayoutTestWindow.asClass } };

lpOpenWindow = {
    var klass, controller, w;
    klass = lpResolveClass.();
    if(klass.isNil) { "No LPDisplay class found.".warn; ^nil };
    controller = ~guiLP ?? { ~guiLP = klass.new(nil) };
    w = Window.allWindows.detect({ |x| (x.tryPerform(\name) ? "").asString == "Layout Test" })
        ?? { controller.open };
    controller.tryPerform(\setSourceA, \srcZ);  // silence LPDisplay demo tails
    controller.tryPerform(\setSourceB, \srcZ);
    w
};

silenceLpDemo = {
    Server.default.bind({
        [\srcA, \srcB, \srcC, \srcZ, \outA, \outB].do({ |name|
            var nd = Ndef(name); if(nd.notNil) { nd.stop };
        });
    });
    "LPDisplay demo sources silenced.".postln;
};

silenceLpDemoDeferred = { AppClock.sched(0.15, { silenceLpDemo.(); nil }) };

findPaneLabel = { |candidatesArray|
    var found = nil;
    var scan;
    scan = { |view|
        view.children.do({ |child|
            if(child.isKindOf(StaticText) and: { candidatesArray.any({ |s| child.string.asString == s.asString }) }) {
                found = child;
            }{
                scan.(child);
            };
        });
    };
    Window.allWindows.do({ |w| if((w.tryPerform(\name) ? "").asString == "Layout Test") { scan.(w.view) } });
    found
};

setLabelString = { |labelObj, str| if(labelObj.notNil) { { labelObj.string_(str.asString) }.defer } };

buildChainSummary = { |which = \A|
    var pb, src, procs, sink, arr;
    pb = ~system.tryPerform(\pedalboard);

    // source
    src = (which == \A).if({
        pb.tryPerform(\sourceA) ?? { pb.tryPerform(\getSourceA) } ?? { pb.tryPerform(\getSource, \A) }
    },{
        pb.tryPerform(\sourceB) ?? { pb.tryPerform(\getSourceB) } ?? { pb.tryPerform(\getSource, \B) }
    });
    if(src.isNil) { src = (which == \A).if({ \testmelody }, { \ts0 }) };

    // processors
    procs = "(none)";
    arr = (which == \A).if({
        pb.tryPerform(\chainA) ?? { pb.tryPerform(\getChainA) } ?? { pb.tryPerform(\getChain, \A) }
    },{
        pb.tryPerform(\chainB) ?? { pb.tryPerform(\getChainB) } ?? { pb.tryPerform(\getChain, \B) }
    });
    if(arr.isKindOf(Array)) {
        var cleaned = arr.reject({ |sym| [\guitar, \destination, \chainA, \chainB].includes(sym.asSymbol) });
        procs = (cleaned.isEmpty).if({ "(none)" }, { cleaned.collect(_.asString).join(" → ") });
    };

    // sink
    sink = (which == \A).if({ "chainA" }, { "chainB" });

    "src: % | procs: % | sink: %".format(src.asString, procs, sink)
};

setTitlesOnce = {
    var labelA, labelB, txtA, txtB;
    labelA = findPaneLabel.(["Top Left Pane", "Chain A", "Chain A ACTIVE", "Chain A NEXT"]);
    labelB = findPaneLabel.(["Top Right Pane", "Chain B", "Chain B ACTIVE", "Chain B NEXT"]);
    txtA = buildChainSummary.(\A);
    txtB = buildChainSummary.(\B);
    setLabelString.(labelA, "Chain A — " ++ txtA);
    setLabelString.(labelB, "Chain B — " ++ txtB);
};

setCurrentSource = { |sym|
    var pb = ~system.tryPerform(\pedalboard);
    if(pb.notNil) {
        if(pb.respondsTo(\setSourceCurrent)) { pb.setSourceCurrent(sym) };
        if(pb.respondsTo(\enforceExclusiveCurrentOptionA)) { pb.enforceExclusiveCurrentOptionA(0.1) };
        if(pb.respondsTo(\playCurrent)) { pb.playCurrent };
    };
};

// ---------- 1) Open/reuse LPDisplay window ----------
win = lpOpenWindow.();
silenceLpDemo.();
silenceLpDemoDeferred.();
"=== LPDisplay window ready ===".postln;

// ---------- 2) Bring up or reuse LivePedalboardSystem ----------
hadSystem = (~system.notNil);
if(hadSystem.not) {
    ~system = LivePedalboardSystem.new(nil);
    ~system.ensureServerReady;
    ~system.bringUpPedalboard;
    ~system.bringUpCommandSystem;
    ~system.autoBindLPDisplayIfPresent;     // BIND FIRST
    ~system.installAdapterBridge;           // THEN bridge (captures display)
    "OK: LivePedalboardSystem up (headless).".postln;
} {
    "Reusing existing ~system (non-destructive).".postln;
    ~system.autoBindLPDisplayIfPresent;     // ensure bound
    ~system.installAdapterBridge;           // refresh capture
};

// Paint ACTIVE/NEXT at startup (defaults to A if unset)
(~system.statusDisplay.tryPerform(\setActiveChainVisual, (~md_currentChain ? \A)));

// ---------- 3) Audio graph then mute-by-default ----------
~system.ensureAudioOn;
if(lps_startMuted) {
    setCurrentSource.(\ts0);
    Server.default.bind({ var nd = Ndef(\testmelody); if(nd.notNil) { nd.stop } });
    "Current set to ts0 (silent). testmelody stopped.".postln;
} {
    setCurrentSource.(\testmelody);
    "Current set to testmelody (audible).".postln;
};

// ---------- 4) Install meters AFTER settle ----------
AppClock.sched(0.25, {
    ~system.enableAutoMeters(18, 0.5);   // slightly longer post-switch settle
    cm = ~system.commandManager;
    cm.updateDisplay;
    setTitlesOnce.();

    displayObj = (cm ? nil).tryPerform(\display);
    [
        \cmClass, (cm ? \nil).class,
        \displayClass, (displayObj ? \nil).class
    ].postln;
    if(~md_log.notNil) { ~md_log.("BRINGUP OK: bound; meters live; titles set; muted=" ++ lps_startMuted) };
    nil
});

// ---------- 5) Return window so you see "-> a Window" ----------
win
)
===== temporary/Test_LPS_ManualSwitch.scd =====
// Test_LPS_ManualSwitch.scd
// v0.1.0
// MD 20251004-1807

(
var cm;
if(~system.isNil) { "No ~system. Run Start_LivePedalboardSuite_BringUp.scd first.".warn; ^nil };

cm = ~system.commandManager;
if(cm.isNil) { "No commandManager on ~system.".warn; ^nil };
if(cm.queueExportCallback.isNil) { "No queueExportCallback (installAdapterBridge?).".warn; ^nil };

cm.queueExportCallback.value("/switch"); // should swap ACTIVE/NEXT and colors
"Manual /switch invoked via queueExportCallback.".postln;
)

===== temporary/Troubleshoot_MPB_Switch_Trace.scd =====
// Troubleshoot_MPB_Switch_Trace.scd
// v0.1.0
// MD 20251005-1828

/*
Purpose
- Observe (not change) what happens around /switch at the audio layer.
- Prints server node notifications for the Ndef synth nodes behind \chainA/\chainB,
  and snapshots of key Ndef facts at T0 / +120 ms / +300 ms / +600 ms:
  * isPlaying, numChannels, nodeID, bus, fadeTime, sourceClass
- Also prints pedalboard.printChains if available.

Style
- var-first; lowercase; no server.sync; AppClock for timing; defensive checks.
*/

(
var s, cm, pb;
var install, uninstall, snapshot, switchAndTrace;
var updateNodeIDs, mkDef, getInfo;

s  = Server.default;
cm = ~system.tryPerform(\commandManager);
pb = ~system.tryPerform(\pedalboard);

// -- helpers -------------------------------------------------------------

updateNodeIDs = {
    var ids;
    ids = Set.new;
    [\chainA, \chainB].do { |k|
        var nd = Ndef(k);
        if(nd.notNil) {
            var id = nd.nodeID; // NodeProxy node ID of current synth
            if(id.isKindOf(Integer)) { ids.add(id) };
        };
    };
    ~trace_nodeIDs = ids; // Set used by OSCdefs to filter logs
};

mkDef = { |name, path|
    OSCdef(name, { |msg, time, addr, port|
        var nodeId;
        nodeId = msg[1];
        if(~trace_nodeIDs.notNil and: { ~trace_nodeIDs.includes(nodeId) }) {
            ("[SCN] " ++ path ++ "  id=" ++ nodeId ++ "  msg=" ++ msg).postln;
        };
    }, path);
};

getInfo = { |key|
    var nd, info;
    nd = Ndef(key);
    info = (
        key: key,
        exists: nd.notNil,
        isPlaying: nd.notNil.if({ nd.isPlaying }, { nil }),
        numChannels: nd.notNil.if({ nd.numChannels }, { nil }),
        nodeID: nd.notNil.if({ nd.nodeID }, { nil }),
        bus: nd.notNil.if({ nd.bus }, { nil }),
        fadeTime: nd.notNil.if({ nd.fadeTime }, { nil }),
        sourceClass: nd.notNil.if({ (nd.source ? nil).class }, { nil })
    );
    info
};

// -- public API ----------------------------------------------------------

install = {
    s.notify = true;  // enable /n_* notifications from scsynth
    updateNodeIDs.();

    mkDef.(\trace_go,   '/n_go');
    mkDef.(\trace_end,  '/n_end');
    mkDef.(\trace_off,  '/n_off');
    mkDef.(\trace_on,   '/n_on');
    mkDef.(\trace_set,  '/n_set');
    mkDef.(\trace_move, '/n_move');
    mkDef.(\trace_fail, '/fail');

    "[TRACE] node notifications armed for chainA/chainB nodeIDs: "
    ++ (~trace_nodeIDs.asArray).postln;
};

snapshot = { |label = "now"|
    var a, b, tm, cur;
    updateNodeIDs.();

    a  = getInfo.(\chainA);
    b  = getInfo.(\chainB);
    tm = getInfo.(\testmelody);
    cur = (~md_currentChain ? \A);

    ("[SNAP] " ++ label).postln;
    ("  current=" ++ cur.asString).postln;
    ("  chainA: play=" ++ a[\isPlaying] ++ "  ch=" ++ a[\numChannels]
       ++ "  node=" ++ a[\nodeID] ++ "  bus=" ++ a[\bus]
       ++ "  fade=" ++ a[\fadeTime] ++ "  src=" ++ a[\sourceClass]).postln;
    ("  chainB: play=" ++ b[\isPlaying] ++ "  ch=" ++ b[\numChannels]
       ++ "  node=" ++ b[\nodeID] ++ "  bus=" ++ b[\bus]
       ++ "  fade=" ++ b[\fadeTime] ++ "  src=" ++ b[\sourceClass]).postln;
    ("  testmelody: play=" ++ tm[\isPlaying] ++ "  ch=" ++ tm[\numChannels]
       ++ "  node=" ++ tm[\nodeID]).postln;

    if(pb.notNil and: { pb.respondsTo(\printChains) }) {
        "---- pedalboard.printChains ----".postln;
        pb.printChains;
        "--------------------------------".postln;
    };
};

switchAndTrace = {
    var cmLocal;
    cmLocal = ~system.tryPerform(\commandManager);
    if(cmLocal.isNil or: { cmLocal.queueExportCallback.isNil }) {
        "⚠️ No queueExportCallback; cannot trigger /switch.".warn;
        ^nil
    };
    snapshot.("T0 (before)");
    cmLocal.queueExportCallback.value("/switch");
    AppClock.sched(0.12, { snapshot.("T+120 ms"); nil });
    AppClock.sched(0.30, { snapshot.("T+300 ms"); nil });
    AppClock.sched(0.60, { snapshot.("T+600 ms"); nil });
    // also refresh IDs early, so subsequent /n_* are caught
    AppClock.sched(0.05, { updateNodeIDs.(); nil });
};

uninstall = {
    [\trace_go, \trace_end, \trace_off, \trace_on, \trace_set, \trace_move, \trace_fail].do { |k|
        var d;
        d = OSCdef(k);
        if(d.notNil) { d.free };
    };
    "[TRACE] node notifications removed.".postln;
};

// export handles
~mpbTrace_install  = install;
~mpbTrace_uninstall = uninstall;
~mpbTrace_snapshot  = snapshot;
~mpbTrace_switch    = switchAndTrace;

// auto-install
install.();
)
===== test 31tp8ve.scd =====
// test 31tp8ve.scd
//

(
var baseFreq = 220.0; // A3
var stepsPerOctave = 31;
var numSteps = 62; // two octaves
var dur = 0.2;
var gap = 0.05;

Routine({
    numSteps.do { |step|
        var freq = baseFreq * (2 ** (step / stepsPerOctave));
        Synth(\play31tone, [\freq, freq]);
        dur.wait;
        gap.wait;
    };
}).play;

SynthDef(\play31tone, { |freq=220|
    var env = EnvGen.kr(Env.perc(0.01, 0.19), doneAction:2);
    var sig = SinOsc.ar(freq) * 0.2 * env;
    Out.ar(0, sig!2);
}).add;
)
===== troubleshooting/00_Reset_KnownClean_State.scd =====
// 00_Reset_KnownClean_State.scd
// v1.0.1
// MD 20250929-0918

(
// Purpose
// - Close MagicDisplay windows; free HUD OSCdefs/bridges/probes.
// - Stop Ndefs; clear server tree; clear HUD dictionaries.
// Style
// - var-first; no server.sync; server ops in Server.default.bind; UI via AppClock.

var closeMagicDisplayWindows, freeHudReceivers, stopNdefs, clearGlobals;

closeMagicDisplayWindows = {
    var wins, i, w, nm;
    wins = Window.allWindows; i = 0;
    while { i < wins.size } {
        w = wins[i];
        nm = w.tryPerform(\name);
        if(nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }) { w.close };
        i = i + 1;
    };
};

freeHudReceivers = {
    [ \md_levels_hud, \md_levels_gui_bridge, \probe_levels, \probe_levels_gui, \probe_levels_bus ].do { |k|
        var d = OSCdef.all.at(k);
        if(d.notNil) { d.free };
    };
};

stopNdefs = {
    Server.default.bind({
        [ \chainA, \chainB, \testmelody, \ts0 ].do { |k|
            if(Ndef(k).isPlaying) { Ndef(k).stop };
        };
        s.defaultGroup.freeAll;
    });
};

clearGlobals = {
    ~md_levelsById   = IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
    ~md_busTapA = nil; ~md_busTapB = nil;
    ~system = nil; ~mpb = nil; ~gui = nil;
};

closeMagicDisplayWindows.value;
freeHudReceivers.value;
stopNdefs.value;
clearGlobals.value;

"✅ Reset: GUI closed, OSCdefs freed, Ndefs stopped, globals cleared.".postln;
)

===== troubleshooting/01b_StartHere_NoReboot.scd =====
// 01b_StartHere_NoReboot.scd
// v0.6.3
// MD 20250929-12:25

(
// Purpose
// - Bring up LivePedalboardSuite when the server is already running (beep booted it).
// - Avoids reboot races; opens the single GUI window; enables GUI taps.
// Style
// - var-first; no server.sync; Server.default.bind; AppClock for UI.

var systemRef, windowRef;
var ensureAudioProxies, startSystem, findMagicDisplayWindow, frontWindow, afterBringUp;
var ensureGui; // NEW

ensureAudioProxies = {
    Server.default.bind({
        if(Ndef(\chainA).source.isNil) { Ndef(\chainA, { \in.ar(2) }) };
        if(Ndef(\chainB).source.isNil) { Ndef(\chainB, { \in.ar(2) }) };
        if(Ndef(\ts0   ).source.isNil) { Ndef(\ts0,    { Silent.ar(2) }) };
        if(Ndef(\testmelody).source.isNil) {
            Ndef(\testmelody, {
                // initial testmelody (will be replaced by a centered one in 02D)
                var trig = Impulse.kr(2.4);
                var sel  = Demand.kr(trig, 0, Dwhite(0, 4, inf));
                var scale = [60, 62, 64, 67, 69];
                var f = Select.kr(sel, scale).midicps;
                var env = Decay2.kr(trig, 0.01, 0.35);
                var pan = 0.0; // neutral here; will be overridden anyway
                Pan2.ar(SinOsc.ar(f) * env * 0.22, pan)
            });
        };
        Ndef(\chainA).ar(2); Ndef(\chainB).ar(2);
        Ndef(\ts0).ar(2);    Ndef(\testmelody).ar(2);
    });
};

startSystem = {
    if(s.serverRunning.not) { "⚠️ Server not running; run 03_Sanity_Beep first.".postln };
    systemRef = LivePedalboardSystem.new(nil);
    systemRef.bringUpAll; // PerfHUD if present; else GridDemo
    ~system = systemRef;
    ~mpb    = systemRef.pedalboard;
    ~gui    = systemRef.statusDisplay; // may be nil when PerfHUD is used
};

findMagicDisplayWindow = {
    Window.allWindows.detect({ |w|
        var nm = w.tryPerform(\name);
        nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
    })
};

frontWindow = { |w|
    if(w.notNil) {
        AppClock.sched(0.0, { w.front; nil });
    };
    w
};

afterBringUp = { |lps|
    if(lps.respondsTo(\installAdapterBridge)) { lps.installAdapterBridge };
    if(lps.respondsTo(\enableAutoMeters))     { lps.enableAutoMeters(24, 0.35) };
    frontWindow.(findMagicDisplayWindow.());
};

// NEW — ensure we always have a usable ~gui handle for later HUD steps.
// - If statusDisplay was set (GridDemo path), keep it.
// - If nil (PerfHUD path), detect the window shortly after creation.
// - If still nil, fallback to a new GridDemo and bind it to the pedalboard.
ensureGui = {
    var giveUpAt;
    // 1) quick capture if bringUpAll already assigned a controller
    if(~gui.notNil) { ^~gui };

    // 2) short polling window to catch PerfHUD’s window (built on AppClock)
    giveUpAt = SystemClock.seconds + 0.80;
    AppClock.sched(0.00, {
        if(~gui.isNil) {
            ~gui = findMagicDisplayWindow.(); // this will be a Window (PerfHUD)
        };
        if(~gui.isNil and: { SystemClock.seconds < giveUpAt }) { 0.05 } {
            // 3) fallback to GridDemo controller (exposes highlightCurrentColumn/setOperations)
            if(~gui.isNil) {
                // Close any stray MagicDisplay windows to keep a single instance policy
                Window.allWindows
                .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
                .do(_.close);

                ~gui = MagicDisplayGUI_GridDemo.new;  // controller object
                if(~mpb.notNil and: { ~mpb.respondsTo(\setDisplay) }) {
                    ~mpb.setDisplay(~gui);
                };
                ~gui.window.front.alwaysOnTop_(true);
            };
            nil
        }
    });
};

// ——— bring-up sequence ———

ensureAudioProxies.value;
startSystem.value;

// Bring the window to front and arm meters
windowRef = afterBringUp.(systemRef);

// Ensure ~gui is bound for later HUD test steps (02B / 02F)
ensureGui.value;

// Return a window for your “-> a Window” acceptance pattern
windowRef
)

===== troubleshooting/01b.1_HUD_EnsureGridDemo.scd =====
// THIS IS NOT WHAT WE WANT. It's using the old GridDemo window, which does not have working meters.

//01b.1_HUD_EnsureGridDemo.scd
//v0.1.0
//MD 20250929-12:42

/* Purpose
   - Enforce MagicDisplayGUI_GridDemo (non-pulsing) and set ~gui to its controller.
   - Close any existing "MagicDisplayGUI..." windows first to keep a single window.
Style
   - var-first; AppClock-only for UI; no server.sync; idempotent.
*/

(
var closeOldWindows, makeGridDemo, frontIt;

closeOldWindows = {
    AppClock.sched(0.00, {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        nil
    });
};

makeGridDemo = {
    // Create GridDemo controller; its .window is the Qt window
    ~gui = MagicDisplayGUI_GridDemo.new;
    // Optional, visually useful
    if(~gui.respondsTo(\window)) {
        ~gui.window.alwaysOnTop_(true);
    };
};

frontIt = {
    if(~gui.notNil and: { ~gui.respondsTo(\window) }) {
        ~gui.window.front;
    };
    if(~gui.respondsTo(\showExpectation)) {
        ~gui.showExpectation("GridDemo ready (A/B static highlight, no pulsing)", 0);
    };
};

closeOldWindows.value;
AppClock.sched(0.08, { makeGridDemo.value; AppClock.sched(0.04, { frontIt.value; nil }); nil });
)

===== troubleshooting/02_ForceMeters_FromBuses.scd =====
// 02_ForceMeters_FromBuses.scd
// v0.1.1
// MD 20250928-1935

(
// Purpose
// - Bypass older meter paths. Tap Ndef buses directly and send on "/md/levels_bus".
// - Correct parsing: SendReply => msg[0]=path, msg[1]=nodeID, msg[2]=replyID, msg[3]=L, msg[4]=R.
// Style
// - var-first; no server.sync; server ops in Server.default.bind.

var makeTapDefOnce, installBusTaps, installHudReceiver, aBus, bBus, tBus;

makeTapDefOnce = {
    SynthDef(\md_busTap2, { |inBus=0, rate=24, replyID=2001|
        var sig, aL, aR;
        sig = In.ar(inBus, 2);
        aL  = Amplitude.kr(sig[0], 0.01, 0.20).clip(0, 1);
        aR  = Amplitude.kr(sig[1], 0.01, 0.20).clip(0, 1);
        SendReply.kr(Impulse.kr(rate), "/md/levels_bus", [aL, aR], replyID);
    }).add;
    "🔧 SynthDef \\md_busTap2 installed.".postln;
};

installBusTaps = {
    Server.default.bind({
        aBus = Ndef(\chainA).bus.index;
        bBus = Ndef(\chainB).bus.index;
        tBus = Ndef(\testmelody).bus.index;
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        if(~md_busTapT.notNil) { ~md_busTapT.free; ~md_busTapT = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, aBus, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, bBus, \rate, 24, \replyID, 2002]);
        ~md_busTapT = Synth.tail(s.defaultGroup, \md_busTap2, [\inBus, tBus, \rate, 24, \replyID, 1001]);
        "📡 Bus taps active (A=2001 / B=2002 / Test=1001).".postln;
    });
};

installHudReceiver = {
    var key;
    key = \md_levels_hud;
    if(OSCdef.all.at(key).notNil) { OSCdef(key).free };

    ~md_levelsById   = ~md_levelsById ? IdentityDictionary.new;
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;

    OSCdef(key, { |msg|
        var id, l, r;
        if(msg.size < 5) { nil } {
            id = msg[2].asInteger;         // 2001 / 2002 / 1001
            l  = msg[3].asFloat.clip(0,1); // left
            r  = msg[4].asFloat.clip(0,1); // right
            ~md_levelsById.put(id, [l, r]);
            ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        };
        nil
    }, "/md/levels_bus", recvPort: NetAddr.langPort);

    "[HUD] listening /md/levels_bus (key=md_levels_hud; ids 2001/2002/1001)".postln;
};

makeTapDefOnce.value;
installBusTaps.value;
installHudReceiver.value;
"✅ Forced bus meters installed; HUD bridged to dict.".postln;
)

===== troubleshooting/02B_HUD_AB_StrictAOnly.scd =====
// 02B_HUD_AB_StrictAOnly.scd
// v0.1.4
// MD 2025-09-29 13:20 BST

/* Purpose
 - Force the HUD to show Chain A as ACTIVE with a solid (non‑pulsing) highlight.
 - If ~gui is nil, bring up GridDemo and set ~gui first (single window).
Style
 - var-first; AppClock UI; no server.sync; nil-safe responders; idempotent.
*/

(
var ensureGui, applySolidA;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

applySolidA = {
    if(~gui.respondsTo(\highlightCurrentColumn)) {
        ~gui.highlightCurrentColumn(\chainA);
    };
    // Shut off any optional demo overlays if present (nil-safe)
    if(~gui.respondsTo(\testMeter_stop)) { ~gui.testMeter_stop };
    if(~gui.respondsTo(\testMarker_clear)) { ~gui.testMarker_clear };
};

AppClock.sched(0.00, { ensureGui.value; applySolidA.value; nil });
)

===== troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02D_TestSource_CenteredStereo.scd =====
// 02D_TestSource_CenteredStereo_Pulsed.scd
// v0.1.1
// MD 20250929-0948

(
// Purpose
// - Centered stereo pulses (equal L/R), easy to see on meters without drone.
// Style
// - var-first; server ops in Server.default.bind.

var install;

install = {
    Server.default.bind({
        Ndef(\testmelody, {
            var trig = Impulse.kr(2);                // 2 pulses per second
            var env  = Decay2.kr(trig, 0.01, 0.22);  // short visual envelope
            var sig  = SinOsc.ar(440) * env * 0.30;  // moderate level
            [sig, sig]                               // equal L/R
        });
        Ndef(\testmelody).ar(2);
    });
    "🎛️ testmelody set to centered stereo pulses (equal L/R).".postln;
};

install.value;
)

===== troubleshooting/02F_HUD_TestContent_StateChoicesIncoming.scd =====
// 02F_HUD_TestContent_StateChoicesIncoming.scd
// v0.1.5
// MD 2025-09-29 13:28 BST

/* Purpose
 - Write demo text to the HUD via overlay helpers created by 02H/02M:
   • STATE line
   • CHOICES multiline
Style
 - var-first; AppClock-only UI; no server.sync; idempotent.
*/

(
var ensureOverlayThenPush;

ensureOverlayThenPush = {
    var host, overlay;

    // Ensure ~gui and overlay exist
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        ~gui.window.front.alwaysOnTop_(true);
    };

    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });

    if(overlay.isNil) {
        // run 02H inline if needed (minimal version)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;
        r = host.bounds; width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
    };

    // ——— Actual content push ———
    (~hud_setState !? { ~hud_setState.("Mode: treeNav · A=ACTIVE") });
    (~hud_setChoices !? {
        ~hud_setChoices.([
            "fret 3 → add",
            "fret 5 → timebased",
            "fret 7 → modulation",
            "fret 9 → filter"
        ])
    });
};

AppClock.sched(0.00, { ensureOverlayThenPush.value; nil });
)

===== troubleshooting/02H_GridDemo_MinHUD_Overlay.scd =====
// 02H_GridDemo_MinHUD_Overlay.scd
// v0.1.3
// MD 2025-09-29 13:42 BST

/* Purpose
 - Add a compact overlay HUD (STATE line + CHOICES list) to the GridDemo window,
   without touching GridDemo’s privates. Uses StaticText for guaranteed visibility.
 - Export helpers: ~hud_setState.(string), ~hud_setChoices.([lines]),
   and ~hud_moveTopRight.(marginInt) to re-anchor after resize.
Style
 - var-first; AppClock-only for UI; no server.sync; idempotent; single MagicDisplayGUI window.
*/

(
var ensureGui, killOld, mkOverlay, positionTopRight, hookResize, frontHud;

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

killOld = {
    var host;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.notNil) {
        host.children.select({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" }).do(_.remove);
    };
    ~hud_setState = nil;
    ~hud_setChoices = nil;
    ~hud_moveTopRight = nil;
};

mkOverlay = {
    var host, r, panel, title, stateLabel, choicesLabel, choicesBox;
    var pad, width, height, titleH, stateH, lineH;

    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02H: host view is nil; aborting.".warn; ^nil };

    r = host.bounds;
    width = 360;                       // room for multi-line CHOICES
    height = 190;                      // compact but readable
    pad = 8;
    titleH = 16;
    stateH = 18;
    lineH = 14;

    panel = CompositeView(host).name_("MDG_MINHUD");
    panel.background = Color(0,0,0,0.30);
    panel.bounds = Rect(r.width - (width + 12), 10, width, height);
    panel.border = 1;
    panel.borderColor = Color(1,1,1,0.25);
    panel.front;

    title = StaticText(panel)
        .string_("MIN-HUD")
        .font_(Font("Monaco", 12))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad, width - 2*pad, titleH));

    stateLabel = StaticText(panel)
        .string_("(state)")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.95))
        .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

    choicesLabel = StaticText(panel)
        .string_("CHOICES:")
        .font_(Font("Monaco", 11))
        .stringColor_(Color(1,1,1,0.85))
        .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, lineH));

    choicesBox = StaticText(panel)
        .string_("(choices)")
        .align_(\topLeft)
        .font_(Font("Monaco", 10))
        .stringColor_(Color(0.95,0.95,0.95))
        .bounds_(Rect(
            pad,
            pad + titleH + 4 + stateH + 6 + lineH + 2,
            width - 2*pad,
            height - (titleH + 4 + stateH + 6 + lineH + 2 + pad)
        ));

    // ——— Helpers (exported) ———
    ~hud_setState = { arg textString;
        AppClock.sched(0.0, {
            stateLabel.string = textString.asString;
            nil
        });
    };

    ~hud_setChoices = { arg linesArray;
        var s;
        s = (linesArray ? []).collect(_.asString).join("\n");
        AppClock.sched(0.0, {
            choicesBox.string = s.size > 0 ? s : "—";
            nil
        });
    };

    positionTopRight = { arg margin = 10;
        var rb;
        rb = host.bounds;
        AppClock.sched(0.0, {
            panel.bounds = Rect(rb.width - (width + margin), margin, width, height);
            panel.front;
            nil
        });
    };
    ~hud_moveTopRight = positionTopRight;
    positionTopRight.value(10);
};

hookResize = {
    var win;
    win = ~gui.tryPerform(\window);
    if(win.notNil) {
        win.onResize = { (~hud_moveTopRight !? { ~hud_moveTopRight.(10) }) };
    };
};

frontHud = {
    if(~gui.respondsTo(\window)) { ~gui.window.front };
    (~hud_setState !? { ~hud_setState.("HUD ready (GridDemo overlay)") });
    (~hud_setChoices !? { ~hud_setChoices.(["(no choices yet)"]) });
};

AppClock.sched(0.00, { ensureGui.value; killOld.value; mkOverlay.value; hookResize.value; frontHud.value; nil });
)

===== troubleshooting/02M_GridDemo_AttachMeters_And_ShowDebugBar.scd =====
//////////////////////////////////////////////////////////////
// 02M_GridDemo_AttachMeters_And_ShowDebugBar.scd
// v0.1.1
// MD 20250929-13:02
/* Purpose
   - Attach meter Synths to tap busses (A=2001, B=2002), emitting /ampA,/ampB.
//  - Display a small moving bar inside GridDemo (right panel) via TestMeter ext.
Style
   - var-first; Server.default.bind for synths; AppClock for UI; no server.sync.
*/

(
var aBus, bBus, mkMeters, stopOld, showBar, ensure;

aBus = 2001;  bBus = 2002;

ensure = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
        if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
    };
};

stopOld = {
    if(~meterA.notNil) { ~meterA.free; ~meterA = nil };
    if(~meterB.notNil) { ~meterB.free; ~meterB = nil };
};

mkMeters = {
    Server.default.bind({
        ~meterA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // → /ampA
        ~meterB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // → /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

showBar = {
    if(~gui.respondsTo(\testMeter_attach)) {
        ~gui.testMeter_attach(\A);   // or \B to view NEXT
        if(~gui.respondsTo(\showExpectation)) {
            ~gui.showExpectation("Debug meter (A) attached at 24 Hz", 0);
        };
    }{
        "02M: GridDemo TestMeter extension not found; no debug bar.".warn;
    };
};

ensure.value;
stopOld.value;
mkMeters.value;
AppClock.sched(0.02, { showBar.value; nil });
)

===== troubleshooting/02M_GridDemo_SimpleBusMeters.scd =====
// 02M_GridDemo_SimpleBusMeters.scd
// v0.1.2
// MD 2025-09-29 13:28 BST

/* Purpose
 - Display a simple horizontal meter bar in the MIN-HUD overlay, driven by your taps.
 - Uses MagicDisplay’s \busMeterA/\busMeterB SynthDefs (SendReply → /ampA,/ampB).
 - Avoids GridDemo’s TestMeter extension (which errors in your build).
Style
 - var-first; Server.default.bind for synths; AppClock-only for UI; no server.sync; idempotent.
*/

(
var aBus, bBus, whichChain;
var ensureGui, ensureOverlay, killOld, ensureSynths, mkBar, startOsc;

aBus = 2001;            // confirmed by your taps step
bBus = 2002;
whichChain = \A;        // set to \B to watch NEXT

ensureGui = {
    if(~gui.isNil) {
        Window.allWindows
        .select({ |w| (w.tryPerform(\name) ? "").asString.beginsWith("MagicDisplayGUI") })
        .do(_.close);
        ~gui = MagicDisplayGUI_GridDemo.new;
    };
    if(~gui.respondsTo(\window)) { ~gui.window.front.alwaysOnTop_(true) };
};

ensureOverlay = {
    var host, overlay;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    if(host.isNil) { "02M: host view is nil; aborting.".warn; ^nil };
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) {
        // Create overlay quickly (same geometry as 02H)
        var r, panel, title, stateBox, choicesBox;
        var pad, width, height, titleH, stateH;

        r = host.bounds;
        width = 320; height = 170; pad = 8; titleH = 16; stateH = 18;

        panel = CompositeView(host).name_("MDG_MINHUD");
        panel.background = Color(0,0,0,0.28);
        panel.border = 1; panel.borderColor = Color(1,1,1,0.25);
        panel.bounds = Rect(r.width - (width + 12), 10, width, height);
        panel.front;

        title = StaticText(panel).string_("MIN-HUD").font_(Font("Monaco", 12))
                .stringColor_(Color(1,1,1,0.82))
                .bounds_(Rect(pad, pad, width - 2*pad, titleH));

        stateBox = TextView(panel).string_("(state)").font_(Font("Monaco", 11))
                   .background_(Color(0,0,0,0.10)).stringColor_(Color.white)
                   .bounds_(Rect(pad, pad + titleH + 4, width - 2*pad, stateH));

        choicesBox = TextView(panel).string_("(choices)").editable_(false)
                     .font_(Font("Monaco", 10)).background_(Color(0,0,0,0.10))
                     .stringColor_(Color(0.93,0.93,0.93))
                     .bounds_(Rect(pad, pad + titleH + 4 + stateH + 6, width - 2*pad, height - (titleH + 4 + stateH + 6 + pad)));

        ~hud_setState = { arg textString; AppClock.sched(0.0, { stateBox.string = textString.asString; nil }) };
        ~hud_setChoices = { arg linesArray; var s = (linesArray ? []).collect(_.asString).join("\n");
                            AppClock.sched(0.0, { choicesBox.string = s; nil }) };
        ~hud_moveTopRight = { arg margin = 10;
            AppClock.sched(0.0, { panel.bounds = Rect(r.width - (width + margin), margin, width, height); panel.front; nil })
        };
    };
};

killOld = {
    if(~mdg_meterSynthA.notNil) { ~mdg_meterSynthA.free; ~mdg_meterSynthA = nil };
    if(~mdg_meterSynthB.notNil) { ~mdg_meterSynthB.free; ~mdg_meterSynthB = nil };
    if(~mdg_meterOSC.notNil)    { ~mdg_meterOSC.free; ~mdg_meterOSC = nil };
    if(~mdg_meterView.notNil)   { ~mdg_meterView.remove; ~mdg_meterView = nil };
    ~mdg_meterVal = 0.0;
};

ensureSynths = {
    Server.default.bind({
        ~mdg_meterSynthA = Synth(\busMeterA, [\inBus, aBus, \rate, 24]);  // emits /ampA
        ~mdg_meterSynthB = Synth(\busMeterB, [\inBus, bBus, \rate, 24]);  // emits /ampB
    });
    "02M: A/B bus meters attached to 2001/2002.".postln;
};

mkBar = {
    var host, overlay, bar, bnds, pad, h;
    host = ~gui.tryPerform(\window).tryPerform(\view);
    overlay = host.children.detect({ |v| (v.tryPerform(\name) ? "") == "MDG_MINHUD" });
    if(overlay.isNil) { "02M: overlay missing; aborting.".warn; ^nil };

    bnds = overlay.bounds; pad = 8; h = 8;

    bar = UserView(overlay);
    bar.name = "MDG_SIMPLE_METER";
    bar.bounds = Rect(pad, bnds.height - (h + pad), bnds.width - 2*pad, h);
    bar.background = Color(0,0,0,0.15);
    bar.drawFunc = { |uv|
        var w, val;
        w = uv.bounds.width;
        val = (~mdg_meterVal ? 0.0).clip(0, 1);
        Pen.fillColor = Color(0.2, 0.8, 0.3, 0.90);
        Pen.fillRect(Rect(0, 0, (w * val).max(1), h));
    };
    bar.front;
    ~mdg_meterView = bar;
};

startOsc = {
    var ampPath, oscKey;
    ampPath = (whichChain == \A).if({ '/ampA' }, { '/ampB' });
    oscKey  = ("mdg_simple_" ++ ampPath.asString).asSymbol;

    ~mdg_meterOSC = OSCdef(oscKey, { |msg|
        var l, r, m;
        l = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        r = (msg.size > 4).if({ msg[4] }, { l }).asFloat;
        m = ((l + r) * 0.5).clip(0, 1);
        ~mdg_meterVal = ((~mdg_meterVal ? 0.0) * 0.7) + (m * 0.3); // smooth
        AppClock.sched(0.0, { ~mdg_meterView.tryPerform(\refresh); nil });
    }, ampPath);
};

// Run
AppClock.sched(0.00, {
    ensureGui.value;
    ensureOverlay.value;
    killOld.value;
    ensureSynths.value;
    AppClock.sched(0.05, { mkBar.value; startOsc.value; nil });
    nil
});
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd =====
// 02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
// v0.1.1
// MD 20250929-1120

/* Purpose
   - Assert stereo + playing for Ndef(\chainA) and Ndef(\chainB) WITHOUT muting/rewiring.
   - (Re)install safe visual taps that send /md/levels (replyIDs A=2001, B=2002).
   - Use unique filter keys and ALWAYS return 'in' (pure pass-through).
   - No server.sync; Server.default.bind for server ops; var-first; lowercase.

   Notes
   - This script does NOT touch sources, OSCdefs, or HUD listeners.
   - If an older tap with the same key exists, .filter replaces it safely.
*/

(
var rateHz, atk, rel, floorAmp, path;
var busA, busB, playA, playB, chA, chB, warn;

rateHz   = 24;
atk      = 0.01;
rel      = 0.20;
floorAmp = 1e-5;
path     = "/md/levels";

warn = { |txt| ("[02S_SAFE] " ++ txt).warn };

// --- assert stereo/playing & re-tap (no frees, no stops)
Server.default.bind({
    // ensure AR 2-ch busses are alive
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);

    // quick diagnostics (posts only; never mutates play state)
    busA = Ndef(\chainA).bus;
    busB = Ndef(\chainB).bus;
    playA = Ndef(\chainA).isPlaying;
    playB = Ndef(\chainB).isPlaying;
    chA = busA.notNil.if({ busA.numChannels }, { -1 });
    chB = busB.notNil.if({ busB.numChannels }, { -1 });

    ("[02S_SAFE] A: playing=" ++ playA ++ " ch=" ++ chA).postln;
    ("[02S_SAFE] B: playing=" ++ playB ++ " ch=" ++ chB).postln;

    if(chA != 2) { warn.("chainA bus is not stereo (" ++ chA ++ "); enforcing ar(2)"); Ndef(\chainA).ar(2); };
    if(chB != 2) { warn.("chainB bus is not stereo (" ++ chB ++ "); enforcing ar(2)"); Ndef(\chainB).ar(2); };

    // --- SAFE visual taps (A=2001, B=2002); return 'in'
    Ndef(\chainA).filter(\mdVisTapA, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2001);
        in
    });

    Ndef(\chainB).filter(\mdVisTapB, { |in|
        var sig, aL, aR;
        sig = in.isArray.if({ in }, { [in, in] });
        aL = Amplitude.kr(sig[0], atk, rel).clip(floorAmp, 1.0);
        aR = Amplitude.kr(sig[1], atk, rel).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHz), path, [aL, aR], 2002);
        in
    });
});
"[*] 02S_SAFE: stereo asserted; taps (A=2001,B=2002) sending to /md/levels".postln;
)

===== troubleshooting/02S_AssertStereo_ChainAB_and_Retap.scd =====
// 02S_AssertStereo_ChainAB_and_Retap.scd
// v0.1.0
// MD 20250929-0948

(
// Purpose
// - Force chainA/chainB to allocate *stereo* busses, then rewire A and reattach dB taps.
// - Clears stale 1001 (“test”) dict entry so HUD only shows A/B.
// Style
// - var-first; server ops in Server.default.bind.

var makeStereoBusses, rewireA, restartTaps, clearOldTestDict;

makeStereoBusses = {
    Server.default.bind({
        // Force stereo allocation by setting explicit stereo sources first
        Ndef(\chainA, { Silent.ar(2) }); Ndef(\chainA).ar(2);
        Ndef(\chainB, { Silent.ar(2) }); Ndef(\chainB).ar(2);
        // Materialize bus width
        Ndef(\chainA).play;
        Ndef(\chainB).stop;
    });
    "🛠️ Stereo busses asserted for chainA/chainB.".postln;
};

rewireA = {
    // Keep your exact operator
    Ndef(\chainA) <<> Ndef(\testmelody);
    "🔗 Rewired: testmelody -> chainA.".postln;
};

restartTaps = {
    // Reinstall dB taps using existing SynthDef \md_busTap_db
    Server.default.bind({
        if(~md_busTapA.notNil) { ~md_busTapA.free; ~md_busTapA = nil };
        if(~md_busTapB.notNil) { ~md_busTapB.free; ~md_busTapB = nil };
        ~md_busTapA = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainA).bus.index, \rate, 24, \replyID, 2001]);
        ~md_busTapB = Synth.tail(s.defaultGroup, \md_busTap_db, [\inBus, Ndef(\chainB).bus.index, \rate, 24, \replyID, 2002]);
    });
    "📡 dB taps restarted on asserted stereo busses (A/B).".postln;
};

clearOldTestDict = {
    ~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
    ~md_levelsById.removeAt(1001);  // remove “test” so HUD can’t mirror it
    ~md_lastMsgStamp = SystemClock.seconds.asFloat;
};

makeStereoBusses.value;
rewireA.value;
restartTaps.value;
clearOldTestDict.value;

"✅ Stereo confirmed, taps reattached. Expect both A bars moving, B near zero.".postln;
)

===== troubleshooting/03_Sanity_Beep.scd =====
// 03_Sanity_Beep.scd
// v0.1.0
// MD 20250929-0918

(
// Purpose: Prove server + audio device are OK (audible 1-second beep).
// Style: var-first; no server.sync.

var playBeep;

playBeep = {
    if(s.serverRunning.not) { s.boot; s.waitForBoot({ "🔁 Server booted for beep.".postln; }) };
    {
        var env = Env.perc(0.005, 0.9).ar(doneAction:2);
        var sig = SinOsc.ar(880) * 0.1 * env;
        Out.ar(0, sig.dup);
    }.play;
    "🔊 Beep should be audible for ~1s.".postln;
};

playBeep.();
)

===== troubleshooting/99_PerfHUD_MetersFromBusses.scd =====
// 99_PerfHUD_MetersFromBusses.scd
// v0.1.1
// MD 2025-09-29 15:22 BST
(
/* Purpose
   - Bridge two 2-ch AUDIO buses (A and B) into the PerfHUD UI via OSC:
       • '/md/levels_gui'  → linear amplitudes (0..1)  [A L, A R, B L, B R]
       • '/md/levels_db'   → dBFS values (≈ -inf..0)   [A L, A R, B L, B R]
       • '/ampA', '/ampB'  → linear pairs for legacy listeners
   - Provide optional test pattern (fixed values) to prove the UI is controllable.
   - Optionally print a few lines of dB to the console to validate input sanity.

Style
   - var-first everywhere; descriptive lowercase names; no single-letter locals.
   - Server.default.bind for server ops; AppClock for UI; no server.sync; no non-local returns.
*/

var busIndexA, busIndexB;
var attackSeconds, releaseSeconds, updateRateHz;
var useTestPattern, testValueAL, testValueAR, testValueBL, testValueBR;
var printDbLinesCount;

var installSynthDefinitions, startMeterBridge, nudgeHudOnce, installDbConsolePrinter;

// --- Configuration (edit these if needed) ------------------------------------
busIndexA        = 2001;        // your A-tap bus index (2 channels expected)
busIndexB        = 2002;        // your B-tap bus index (2 channels expected)
attackSeconds    = 0.01;        // Amplitude.kr attack time
releaseSeconds   = 0.20;        // Amplitude.kr release time
updateRateHz     = 24;          // OSC update rate for GUI

useTestPattern   = false;       // set true to drive meters with fixed values
testValueAL      = 0.25;        // A left (linear 0..1)
testValueAR      = 0.50;        // A right
testValueBL      = 0.75;        // B left
testValueBR      = 0.50;        // B right

printDbLinesCount = 6;          // number of dB lines to print to console (0 disables)

// --- Definitions --------------------------------------------------------------
installSynthDefinitions = {
    var synthAdder;

    synthAdder = {
        // Two-bus (stereo+stereo) → linear + dB, with optional test pattern
        SynthDef(\md_levels4_from_busses, {
            arg inBusA = 2001, inBusB = 2002, updatesPerSecond = 24,
                ampAttack = 0.01, ampRelease = 0.20,
                enableTestPattern = 0,
                patternAL = 0.25, patternAR = 0.50, patternBL = 0.75, patternBR = 0.50;

            var inputStereoA, inputStereoB;
            var ampLinearAL, ampLinearAR, ampLinearBL, ampLinearBR;
            var linearAL, linearAR, linearBL, linearBR;
            var dbAL, dbAR, dbBL, dbBR;
            var updateTrigger;
            var minLinearFloor;

            // Read 2 channels from each bus
            inputStereoA = In.ar(inBusA, 2);
            inputStereoB = In.ar(inBusB, 2);

            // Measure linear amplitude at control rate
            ampLinearAL = Amplitude.kr(inputStereoA[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearAR = Amplitude.kr(inputStereoA[1], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBL = Amplitude.kr(inputStereoB[0], ampAttack, ampRelease).clip(0.0, 1.0);
            ampLinearBR = Amplitude.kr(inputStereoB[1], ampAttack, ampRelease).clip(0.0, 1.0);

            // Select measured vs. test pattern
            linearAL = Select.kr(enableTestPattern, [ampLinearAL, patternAL]);
            linearAR = Select.kr(enableTestPattern, [ampLinearAR, patternAR]);
            linearBL = Select.kr(enableTestPattern, [ampLinearBL, patternBL]);
            linearBR = Select.kr(enableTestPattern, [ampLinearBR, patternBR]);

            // Convert to dB (guard the floor to avoid -inf)
            minLinearFloor = 1e-7;
            dbAL = (max(linearAL, minLinearFloor)).log10 * 20.0;
            dbAR = (max(linearAR, minLinearFloor)).log10 * 20.0;
            dbBL = (max(linearBL, minLinearFloor)).log10 * 20.0;
            dbBR = (max(linearBR, minLinearFloor)).log10 * 20.0;

            // Tick and send
            updateTrigger = Impulse.kr(updatesPerSecond);

            // Linear for GUI
            SendReply.kr(updateTrigger, '/md/levels_gui', [linearAL, linearAR, linearBL, linearBR]);

            // dB for console or dB-aware GUIs
            SendReply.kr(updateTrigger, '/md/levels_db',  [dbAL, dbAR, dbBL, dbBR]);

            // Legacy: per-chain linear pairs
            SendReply.kr(updateTrigger, '/ampA', [linearAL, linearAR]);
            SendReply.kr(updateTrigger, '/ampB', [linearBL, linearBR]);
        }).add;
    };

    Server.default.bind(synthAdder);
    "99: SynthDef \\md_levels4_from_busses installed.".postln;
};

startMeterBridge = {
    var freeOld, startNew;

    freeOld = {
        if(~md_levelsSynth.notNil) {
            ~md_levelsSynth.free;
            ~md_levelsSynth = nil;
        };
    };

    startNew = {
        Server.default.bind({
            ~md_levelsSynth = Synth(
                \md_levels4_from_busses,
                [
                    \inBusA,          busIndexA,
                    \inBusB,          busIndexB,
                    \updatesPerSecond, updateRateHz,
                    \ampAttack,        attackSeconds,
                    \ampRelease,       releaseSeconds,
                    \enableTestPattern, (useTestPattern.if({ 1 }, { 0 })),
                    \patternAL,        testValueAL,
                    \patternAR,        testValueAR,
                    \patternBL,        testValueBL,
                    \patternBR,        testValueBR
                ]
            );
        });
        ("99: Started md_levels4_from_busses on A=" ++ busIndexA
            ++ "  B=" ++ busIndexB
            ++ "  testPattern=" ++ useTestPattern).postln;
    };

    freeOld.();
    startNew.();
};

nudgeHudOnce = {
    var doIt;

    doIt = {
        if(~gui.notNil and: { ~gui.respondsTo(\highlightCurrentColumn) }) {
            ~gui.highlightCurrentColumn(\chainA);
        };
        if(~gui.notNil and: { ~gui.respondsTo(\showExpectation) }) {
            ~gui.showExpectation("HUD: meters bridged from A/B buses", 0);
        };
        nil
    };

    AppClock.sched(0.10, doIt);
};

installDbConsolePrinter = {
    var oscKeyName, linesRemaining;

    oscKeyName     = \md_levels_db_console_printer;
    linesRemaining = printDbLinesCount.max(0).asInteger;

    // Optional: print a few dB lines then auto-stop
    if(linesRemaining > 0) {
        OSCdef(oscKeyName, { arg message;
            var dbLeftA, dbRightA, dbLeftB, dbRightB, lineText;

            if(message.size >= 5) {
                // ['/md/levels_db', nodeID, replyID, dB_AL, dB_AR, dB_BL, dB_BR] (nodeID/replyID vary by build)
                dbLeftA   = message[3].round(0.1);
                dbRightA  = message[4].round(0.1);
                dbLeftB   = message[5].round(0.1);
                dbRightB  = message[6].round(0.1);

                lineText = "[dB]  A: L=" ++ dbLeftA  ++ " dB  R=" ++ dbRightA
                         ++ "   |   B: L=" ++ dbLeftB ++ " dB  R=" ++ dbRightB;
                lineText.postln;

                linesRemaining = linesRemaining - 1;
                if(linesRemaining <= 0) {
                    OSCdef(oscKeyName).free;
                    "[dB] console printer finished.".postln;
                };
            };
        }, '/md/levels_db');
    };
};

// --- Run sequence -------------------------------------------------------------
installSynthDefinitions.();
installDbConsolePrinter.();               // prints a few lines if printDbLinesCount > 0
AppClock.sched(0.05, {
    startMeterBridge.();
    nudgeHudOnce.();
    nil
});
)

===== troubleshooting/99_PerfHUD_MetersNow.scd =====
// 99_PerfHUD_MetersNow.scd
// v0.1.0
// MD 2025-09-29 14:40 BST

/* Purpose
 - Make PerfHUD meters MOVE immediately without touching the GUI or audio routing.
 - Step 1 (2s): emit a visible ramp to /md/levels_bus and /ampA/B (proof meters react).
 - Step 2 (continuous): bridge your real /md/levels & /md/levels_gui to /md/levels_bus (+ /ampA/B).
Style
 - var-first; AppClock-only; no server.sync; idempotent; nil-safe.
*/

(
var out, freeAll, startProof, stopProof, startBridge, stopBridge, lastPost;

// 0) local OSC sender (language port)
out = NetAddr("127.0.0.1", NetAddr.langPort);

// 1) Clean up any previous helpers
freeAll = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    if(~md_probe_perf.notNil)    { ~md_probe_perf.free;    ~md_probe_perf    = nil };
    if(~md_proof_task.notNil)    { ~md_proof_task.stop;    ~md_proof_task    = nil };
};

// 2) SHORT PROOF: drive a ramp so you SEE the meters move now
startProof = {
    var t = 0.0, dt = 1/24, secs = 2.0, steps = (secs / dt).round(1);
    var stepCount = 0, ramp;
    ramp = {
        // 0..1 triangle for A, inverse for B (obvious visual motion)
        var a = ( (stepCount % 24) / 24 );
        var b = 1.0 - a;
        out.sendMsg('/md/levels_bus', a, a, b, b);  // [lA, rA, lB, rB]
        out.sendMsg('/ampA', 0, a, a);
        out.sendMsg('/ampB', 0, b, b);
        stepCount = stepCount + 1;
    };
    ~md_proof_task = Task({
        steps.do({
            ramp.value;
            dt.wait;
        });
    }).play(AppClock);
    "99: PROOF running for 2s → watch meters MOVE now…".postln;
};

stopProof = {
    if(~md_proof_task.notNil) { ~md_proof_task.stop; ~md_proof_task = nil };
    "99: PROOF stopped.".postln;
};

// 3) BRIDGE real levels → /md/levels_bus (+ mirror to /ampA/B)
startBridge = {
    var postThrottle;

    postThrottle = { arg txt;
        var now = SystemClock.seconds;
        if((now - (lastPost ? 0.0)) > 0.5) { txt.postln; lastPost = now };
    };

    ~md_bridge_levels = OSCdef(\md_bridge_levels, { |msg|
        var floats, lA, rA, lB, rB;

        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);

        // heuristics: last 4 floats are [lA,rA,lB,rB]; fallback if fewer
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
        }{
            lA = (floats.first ? 0.0); rA = (floats.drop(1).first ? lA);
            lB = lA; rB = rA;
        };

        // forward to paths PerfHUD commonly consumes
        out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
        out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
        out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));

        postThrottle.value("99: bridged → levels_bus A=("
            ++ lA.round(0.01) ++ "," ++ rA.round(0.01) ++ ")  B=("
            ++ lB.round(0.01) ++ "," ++ rB.round(0.01) ++ ")");
    }, '/md/levels');

    ~md_bridge_gui = OSCdef(\md_bridge_gui, { |msg|
        var floats, lA, rA, lB, rB;
        floats = msg.select({ |x| x.isNumber }).collect(_.asFloat);
        if(floats.size >= 4) {
            lA = floats.at(floats.size - 4); rA = floats.at(floats.size - 3);
            lB = floats.at(floats.size - 2); rB = floats.at(floats.size - 1);
            out.sendMsg('/md/levels_bus', lA.clip(0,1), rA.clip(0,1), lB.clip(0,1), rB.clip(0,1));
            out.sendMsg('/ampA', 0, lA.clip(0,1), rA.clip(0,1));
            out.sendMsg('/ampB', 0, lB.clip(0,1), rB.clip(0,1));
        };
    }, '/md/levels_gui');

    "99: BRIDGE active (levels → levels_bus + ampA/B).".postln;
};

stopBridge = {
    if(~md_bridge_levels.notNil) { ~md_bridge_levels.free; ~md_bridge_levels = nil };
    if(~md_bridge_gui.notNil)    { ~md_bridge_gui.free;    ~md_bridge_gui    = nil };
    "99: BRIDGE stopped.".postln;
};

// 4) Optional: tiny probe (prints any level/amp paths for 2s)
~md_probe_perf = OSCdef(\md_probe_perf, { |msg|
    var p = msg[0];
    if(p == '/md/levels' or: { p == '/md/levels_gui' } or: { p == '/md/levels_bus' } or: { p == '/ampA' } or: { p == '/ampB' }) {
        ("[probe] " ++ p ++ " size=" ++ msg.size).postln;
    };
}, nil);

// RUN
freeAll.value;
startProof.value;
AppClock.sched(2.05, { stopProof.value; startBridge.value; nil });
)

===== troubleshooting/Accept_Meters_QuickCheck.scd =====
// Accept_Meters_QuickCheck.scd
// v0.1.0  MD 2025-09-26 15:58 BST

/* Purpose
   Lightweight acceptance: count /md/levels for 0.5 s and print one line.
*/

(
var key, counts, lastA, lastB, lastT;
counts = IdentityDictionary[ 2001 -> 0, 2002 -> 0, 1001 -> 0 ];
lastA = [0.0, 0.0]; lastB = [0.0, 0.0]; lastT = [0.0, 0.0];

key = \md_levels_accept_once;
if(OSCdef.all.at(key).notNil) { OSCdef.all.at(key).free };
OSCdef(key, { arg msg;
    var id, l, r;
    if(msg.size < 5) { ^nil };
    id = msg[2]; l = msg[3].asFloat; r = msg[4].asFloat;
    if(id == 2001) { counts.put(2001, counts[2001] + 1); lastA = [l, r] };
    if(id == 2002) { counts.put(2002, counts[2002] + 1); lastB = [l, r] };
    if(id == 1001) { counts.put(1001, counts[1001] + 1); lastT = [l, r] };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

AppClock.sched(0.5, {
    var d = OSCdef.all.at(key), okLine;
    if(d.notNil) { d.free };
    okLine = "[ACCEPT] A=" ++ counts[2001].asString ++ " " ++ lastA.asString
           ++ "  B=" ++ counts[2002].asString ++ " " ++ lastB.asString
           ++ "  T=" ++ counts[1001].asString ++ " " ++ lastT.asString;
    okLine.postln;
    nil
});
"[ACCEPT] counting /md/levels for 0.5 s…".postln;
)

===== troubleshooting/INSTALL_AmpA_AmpB_Responders_Min.scd =====
// INSTALL_AmpA_AmpB_Responders_Min.scd
// v0.1.0
// MD 2025-09-29

(
var ensureModelReady, installAmpResponders, updatesToLog, logKeyA, logKeyB;

updatesToLog = 6;
logKeyA = \ampA_to_model_log_once;
logKeyB = \ampB_to_model_log_once;

ensureModelReady = {
    ~md_levelsById   = ~md_levelsById   ? IdentityDictionary.new;
    ~md_lastMsgStamp = ~md_lastMsgStamp ? SystemClock.seconds.asFloat;
    nil
};

installAmpResponders = {
    var existingA, existingB;

    existingA = OSCdef.all.at(\ampA_to_model);
    if(existingA.notNil) { existingA.free };

    existingB = OSCdef.all.at(\ampB_to_model);
    if(existingB.notNil) { existingB.free };

    OSCdef(\ampA_to_model, { arg oscMessage;
        var leftLinear, rightLinear, logText;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2001, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;

        if(updatesToLog > 0) {
            logText = "[ampA_to_model] A: L=" ++ leftLinear.round(0.01)
                ++ "  R=" ++ rightLinear.round(0.01);
            logText.postln;
            updatesToLog = updatesToLog - 1;
            if(updatesToLog <= 0) { "ampA/B model logging done.".postln };
        };
        nil
    }, "/ampA", recvPort: NetAddr.langPort);

    OSCdef(\ampB_to_model, { arg oscMessage;
        var leftLinear, rightLinear;
        leftLinear  = (oscMessage.size >= 4).if({ oscMessage[3] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        rightLinear = (oscMessage.size >= 5).if({ oscMessage[4] }, { 0.0 }).asFloat.clip(0.0, 1.0);
        ~md_levelsById.put(2002, [leftLinear, rightLinear]);
        ~md_lastMsgStamp = SystemClock.seconds.asFloat;
        nil
    }, "/ampB", recvPort: NetAddr.langPort);

    "[HUD] ampA/ampB responders installed -> ~md_levelsById".postln;
};

ensureModelReady.();
installAmpResponders.();
)

===== troubleshooting/MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd =====
// MD_MinBringUp_FeedA_SimpleMeters_GridDemo.scd
// v0.1.2
// MD 2025-09-26 18:58 BST

/* Purpose / Style
   Purpose:
     • Loud console header + step banners so you can see it ran.
     • Clean-boot bring-up: server, single MagicDisplayGUI GridDemo window, modest-level test source.
     • Feed chain A from testmelody using your operator: Ndef(left) <<> Ndef(right).
     • Install simple raw Amplitude taps to /md/levels (A=2001, B=2002).
     • Print exactly 6 lines (1 Hz) and auto-stop; no console spam.
     • Final expression returns → a Window.
   Style:
     • Single () block; VAR-FIRST in every block/closure; ≥3-char lowercase descriptive names;
       no single-letter locals; no server.sync; AppClock-only for GUI; known-good SC syntax.
*/

(
var postBanner, freeOscIfPresent, stopRoutineIfPresent, findWindowByPrefix, ensureGridDemoWindow;
var serverRef, oscKeyLevels, reporterRoutine, linesRemaining, guiWindow, systemRef, commandManagerRef;

// —— header ————————————————————————————————————————————————————————————————
postBanner = {
    var headerText;
    headerText = "=== MD_MIN_BRINGUP_FEEDA_SIMPLEMETERS_GRIDDEMO ===";
    headerText.postln;
};

// —— helpers (VAR-FIRST inside closures) ————————————————————————————————
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MD: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineRef, labelString;
    var canStopRoutine;
    canStopRoutine = routineRef.notNil and: { routineRef.respondsTo(\stop) };
    if(canStopRoutine) { routineRef.stop; (labelString ++ ": stopped").postln };
};

findWindowByPrefix = { arg prefixString;
    var windowsList, indexCount, indexLimit, windowRef, titleString, foundWindow;
    windowsList = Window.allWindows;
    indexCount = 0; indexLimit = windowsList.size; foundWindow = nil;
    while({ indexCount < indexLimit }, {
        windowRef = windowsList[indexCount];
        titleString = windowRef.tryPerform(\name);
        if(titleString.notNil and: { titleString.asString.beginsWith(prefixString) }) {
            foundWindow = windowRef;
            // do not use ^ ; just set foundWindow and let the closure return last expression
            indexCount = indexLimit; // break
        } {
            indexCount = indexCount + 1;
        };
    });
    foundWindow
};

ensureGridDemoWindow = {
    var oldWindow, guiObj, newWindow;
    "STEP GUI: ensuring a single MagicDisplayGUI window (GridDemo)…".postln;

    oldWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(oldWindow.notNil) {
        oldWindow.close;
        "GUI: closed existing MagicDisplayGUI".postln;
    };

    guiObj = MagicDisplayGUI_GridDemo.new; // safe fallback GUI

    systemRef = ~system; // if user has a system object, bind display
    if(systemRef.notNil) {
        commandManagerRef = systemRef.commandManager;
        if(commandManagerRef.notNil and: { commandManagerRef.display.isNil }) {
            commandManagerRef.display = guiObj;
            "GUI: bound CommandManager.display to GridDemo".postln;
        };
    };

    newWindow = findWindowByPrefix.("MagicDisplayGUI");
    if(newWindow.isNil) { "⚠️ GUI: no MagicDisplayGUI window found after creation".warn };
    newWindow
};

// —— run ————————————————————————————————————————————————————————————————
postBanner.();

// Server bring-up (allowed here)
serverRef = Server.default;
"STEP S: booting server…".postln;
serverRef.waitForBoot;
"STEP S: server booted".postln;

// GUI
guiWindow = ensureGridDemoWindow.();

// Source: testmelody (modest level; generated audio only)
"STEP SRC: defining Ndef(\\testmelody)…".postln;
Server.default.bind({
    Ndef(\testmelody, {
        var triggerCtl, freqCtl, envCtl, panCtl, midiScale, indexCtl, pairSig;
        triggerCtl = Impulse.kr(2.0);
        midiScale  = [60, 62, 64, 67, 69];
        indexCtl   = Demand.kr(triggerCtl, 0, Dwhite(0, midiScale.size, inf));
        freqCtl    = Select.kr(indexCtl, midiScale).midicps;
        envCtl     = Decay2.kr(triggerCtl, 0.01, 0.40);
        panCtl     = LFNoise1.kr(0.25).range(-0.6, 0.6);
        pairSig    = Pan2.ar(SinOsc.ar(freqCtl) * envCtl * 0.18, panCtl); // modest level
        pairSig
    });
    Ndef(\testmelody).ar(2);
});

// Feed chain A from testmelody (your operator)
"STEP FEED: using Ndef(left) <<> Ndef(right): A <<> testmelody".postln;
Server.default.bind({
    Ndef(\chainA).ar(2);
    Ndef(\chainB).ar(2);
    Ndef(\chainA) <<> Ndef(\testmelody);
});

// Simple raw amplitude taps to /md/levels
"STEP TAPS: install raw amplitude taps (/md/levels A=2001, B=2002)…".postln;
oscKeyLevels = \md_levels_sniffer_finite;
freeOscIfPresent.(oscKeyLevels);

Server.default.bind({
    var rateHertz, attackSec, releaseSec, floorAmp;

    rateHertz  = 24;
    attackSec  = 0.01;
    releaseSec = 0.20;
    floorAmp   = 1e-5;

    Ndef(\chainA).filter(\mdSimpleTapA, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2001);
        inSig
    });

    Ndef(\chainB).filter(\mdSimpleTapB, { arg inSig;
        var inputPair, ampLeft, ampRight;
        inputPair = inSig.isArray.if({ inSig }, { [inSig, inSig] });
        ampLeft   = Amplitude.kr(inputPair[0], attackSec, releaseSec).clip(floorAmp, 1.0);
        ampRight  = Amplitude.kr(inputPair[1], attackSec, releaseSec).clip(floorAmp, 1.0);
        SendReply.kr(Impulse.kr(rateHertz), "/md/levels", [ampLeft, ampRight], 2002);
        inSig
    });
});

// Finite 6-line sniffer (auto-free)
"STEP MTR: printing 6 lines (1 Hz) then auto-stop…".postln;
linesRemaining = 6;
OSCdef(oscKeyLevels, { arg oscMessage;
    var replyId, leftVal, rightVal, meterLabel, linesDone;

    if(oscMessage.size >= 5) {
        replyId = oscMessage[2];
        leftVal  = oscMessage[3];
        rightVal = oscMessage[4];

        leftVal  = (leftVal.isNumber  and: { leftVal.isNaN.not })  .if({ leftVal.clip(0,1) }, { 0.0 });
        rightVal = (rightVal.isNumber and: { rightVal.isNaN.not }) .if({ rightVal.clip(0,1) }, { 0.0 });

        meterLabel = if(replyId == 2001) { "A" } { if(replyId == 2002) { "B" } { replyId.asString } };
        ("MDMTR: " ++ meterLabel ++ " (L,R)=(" ++ leftVal.round(0.01) ++ "," ++ rightVal.round(0.01) ++ ")").postln;

        linesRemaining = linesRemaining - 1;
        linesDone = linesRemaining <= 0;
        if(linesDone) {
            var oscRef2;
            oscRef2 = OSCdef.all.at(oscKeyLevels);
            if(oscRef2.notNil) { oscRef2.free; "MDMTR: listener freed.".postln };
        };
    };
    nil
}, "/md/levels", recvPort: NetAddr.langPort);

// Bring GUI front and return → a Window
if(guiWindow.notNil) { guiWindow.front };
guiWindow  // → a Window
)

===== troubleshooting/MD_Taps_Clear_All.scd =====
// MD_Taps_Clear_All.scd
// v0.1.0
// MD timestamp: 2025-09-28 10:45 GMT+1

/*
Purpose
- Remove any previously attached /md/levels taps on chainA/chainB/testmelody
  so only one producer drives A=2001 / B=2002.

Style
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var cleared;

Server.default.bind({
    // Remove known tap filter keys if present
    Ndef(\chainA).filter(\eodTapA, nil);
    Ndef(\chainB).filter(\eodTapB, nil);
    Ndef(\testmelody).filter(\proofTap, nil);
});

cleared = "[TAPS] cleared filters: chainA(\\eodTapA), chainB(\\eodTapB), testmelody(\\proofTap)";
cleared.postln;
cleared
)

===== troubleshooting/PERFHUD_InlineTaps_On_ChainAB.scd =====
// PERFHUD_InlineTaps_On_ChainAB.scd
// v0.1.0
// MD 2025-09-29 15:26 BST

(
/* Purpose
   - Replace bus-based bridge (silent because no buses exist) with inline taps on Ndef(\chainA/\chainB).
   - Send linear amplitudes for PerfHUD via '/ampA' and '/ampB' (2 values each, L/R).
   - Also send dB readings via '/md/levels_db' with replyIDs A=2001, B=2002 for console sanity.
Style
   - var-first; descriptive lowercase variable names; Server.default.bind for server ops; AppClock for UI only.
   - No server.sync; no non-local returns; idempotent (re-running replaces the taps).
*/

var freeBusBridgeIfPresent, installInlineTaps, installDbSniffer, printLinesRemaining;
var attackSeconds, releaseSeconds, updateRateHz, minLinearFloor;
var oscKeyDb;

attackSeconds   = 0.01;
releaseSeconds  = 0.20;
updateRateHz    = 24;
minLinearFloor  = 1e-7;
printLinesRemaining = 6;
oscKeyDb = \perfHud_db_sniff;

// 1) Free the bus-bridge synth (if any), to avoid double feeds
freeBusBridgeIfPresent = {
    if(~md_levelsSynth.notNil) {
        ~md_levelsSynth.free;
        ~md_levelsSynth = nil;
        "99: Freed md_levels4_from_busses (bus bridge) — switching to inline taps.".postln;
    };
};

// 2) Install inline taps on chainA and chainB
installInlineTaps = {
    Server.default.bind({
        // chainA → '/ampA' (linear pair) and '/md/levels_db' (dB; replyID=2001)
        Ndef(\chainA).filter(\perfHudTapA, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            // normalize to a stereo pair (duplicate if mono)
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampA', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2001);

            // return audio unchanged
            localSignal
        });

        // chainB → '/ampB' (linear pair) and '/md/levels_db' (dB; replyID=2002)
        Ndef(\chainB).filter(\perfHudTapB, { arg inputSignal;
            var localSignal, pairArray, linearLeft, linearRight, linearPair, dbLeft, dbRight, updateTrigger;
            localSignal = inputSignal;
            pairArray = localSignal.asArray;
            if(pairArray.size < 2) { pairArray = [pairArray[0], pairArray[0]] };

            linearLeft  = Amplitude.kr(pairArray[0], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearRight = Amplitude.kr(pairArray[1], attackSeconds, releaseSeconds).clip(0.0, 1.0);
            linearPair  = [linearLeft, linearRight];

            dbLeft  = (max(linearLeft,  minLinearFloor)).log10 * 20.0;
            dbRight = (max(linearRight, minLinearFloor)).log10 * 20.0;

            updateTrigger = Impulse.kr(updateRateHz);

            // For PerfHUD legacy listeners:
            SendReply.kr(updateTrigger, '/ampB', linearPair);

            // For console / optional HUD consumers:
            SendReply.kr(updateTrigger, '/md/levels_db', [dbLeft, dbRight], 2002);

            // return audio unchanged
            localSignal
        });
    });

    "99: Inline taps installed on chainA/chainB → '/ampA' & '/ampB' (+ dB on '/md/levels_db').".postln;
};

// 3) Short-lived dB console sniffer (6 lines total), then auto-free
installDbSniffer = {
    // clean any previous instance
    if(OSCdef(oscKeyDb).notNil) { OSCdef(oscKeyDb).free };

    OSCdef(oscKeyDb, { arg message;
        var replyId, dbLeft, dbRight, labelText;
        if(message.size >= 5) {
            replyId = message[2];
            dbLeft  = message[3].round(0.1);
            dbRight = message[4].round(0.1);
            labelText = "[dB inline " ++ replyId.asString ++ "] L=" ++ dbLeft ++ " dB  R=" ++ dbRight ++ " dB";
            labelText.postln;

            printLinesRemaining = printLinesRemaining - 1;
            if(printLinesRemaining <= 0) {
                OSCdef(oscKeyDb).free;
                "[dB inline] sniff done.".postln;
            };
        };
    }, '/md/levels_db');
};

// Execute
freeBusBridgeIfPresent.();
installInlineTaps.();
installDbSniffer.();
)

===== troubleshooting/RMS_IsolatedHUD.scd =====
// RMS_IsolatedHUD.scd
// v0.1.0
// MD 2025-09-29 19:25 BST

/* WORKING
Run:
troubleshooting/00_Reset_KnownClean_State.scd
troubleshooting/01b_StartHere_NoReboot.scd
(Optional) troubleshooting/02S_AssertStereo_ChainAB_and_Retap_SAFE.scd
Start a source (e.g. troubleshooting/02D_TestSource_CenteredStereo_Pulsed.scd)
Run troubleshooting/RMS_IsolatedHUD.scd → -> a Window, bars move with RMS (dB).

*/


/* Purpose
   Display RMS (dBFS) measured at the *ends* of chainA and chainB in a new, isolated GUI window.
   - Reads Ndef(\chainA/\chainB) output busses directly with In.ar(bus, 2).
   - RMS per channel using RMS.ar(sig, 500) (your specification).
   - Converts to dBFS and maps dB→0..1 for bar height (adjustable floor/top).
   - Uses a private OSC path for UI updates; does not touch PerfHUD/GridDemo responders.

Style
   - var-first; descriptive lowercase names; AppClock for GUI; Server.default.bind for server ops.
   - No server.sync; no non-local returns. On success, returns '-> a Window'.
*/

(
var // calibration (you can tweak live after launch via ~rms_isolated_floor_db / ~rms_isolated_top_db)
    defaultFloorDb, defaultTopDb, updateRateHz,

    // ui
    rmsWindow, labelTitle, labelDbA, labelDbB,
    meterAL, meterAR, meterBL, meterBR, updateRoutine,

    // latest measured dB (model for UI)
    currentDbAL, currentDbAR, currentDbBL, currentDbBR,

    // synth plumbing
    installSynthDef, startRmsSynthAtTail, stopRmsSynth,
    oscKeyName, installRmsListener,

    // bus discovery
    discoverBussesAndStart, getProxyBusInfo,
    chainAInfo, chainBInfo, busIndexA, busIndexB, triesLeft;

// ---- defaults (you can change live via the ~globals below) ----
defaultFloorDb = -72.0;    // visual floor (dBFS)
defaultTopDb   =   0.0;    // 0 dBFS → 1.0 (try +3.0 for extra visual headroom at full scale)
updateRateHz   =  15;      // UI update cadence (Hz)

// allow live calibration overrides
~rms_isolated_floor_db = ~rms_isolated_floor_db ? defaultFloorDb;
~rms_isolated_top_db   = ~rms_isolated_top_db   ? defaultTopDb;

// ---- UI: simple absolute layout (no layout shorthands to avoid asView errors) ----
rmsWindow = Window("RMS_IsolatedHUD — chain ends (A/B) — RMS dB", Rect(100, 100, 440, 210)).front;

labelTitle = StaticText(rmsWindow, Rect(10, 8, 420, 18))
    .string_("RMS @ chain ends  (RMS.ar(sig, 500), dBFS)")
    .font_(Font("Helvetica", 13));

meterAL = LevelIndicator(rmsWindow, Rect( 40, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterAR = LevelIndicator(rmsWindow, Rect(120, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBL = LevelIndicator(rmsWindow, Rect(230, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);
meterBR = LevelIndicator(rmsWindow, Rect(310, 40, 60, 110)).drawsPeak_(false).warning_(0.95).critical_(1.0).value_(0.0);

StaticText(rmsWindow, Rect( 40, 155, 60, 16)).string_("A L").align_(\center);
StaticText(rmsWindow, Rect(120, 155, 60, 16)).string_("A R").align_(\center);
StaticText(rmsWindow, Rect(230, 155, 60, 16)).string_("B L").align_(\center);
StaticText(rmsWindow, Rect(310, 155, 60, 16)).string_("B R").align_(\center);

labelDbA = StaticText(rmsWindow, Rect(10, 175, 210, 18)).string_("A: L=-∞  R=-∞");
labelDbB = StaticText(rmsWindow, Rect(220, 175, 210, 18)).string_("B: L=-∞  R=-∞");

// initialize model values
currentDbAL = -140.0; currentDbAR = -140.0;
currentDbBL = -140.0; currentDbBR = -140.0;

// ---- SynthDef: read chain busses, compute RMS dB, SendReply (private path) ----
installSynthDef = {
    Server.default.bind({
        SynthDef(\md_rms_isolated_from_busses, {
            arg inBusA = 0, inBusB = 0, fps = 15;
            var sigA, sigB, aLeft, aRight, bLeft, bRight;
            var rmsAL, rmsAR, rmsBL, rmsBR;
            var dbAL, dbAR, dbBL, dbBR;
            var tick, minLinear;

            sigA = In.ar(inBusA, 2);
            sigB = In.ar(inBusB, 2);

            aLeft  = sigA[0];
            aRight = (sigA.size > 1).if({ sigA[1] }, { sigA[0] });
            bLeft  = sigB[0];
            bRight = (sigB.size > 1).if({ sigB[1] }, { sigB[0] });

            // RMS per channel with 500 Hz smoothing (as requested)
            rmsAL = RMS.ar(aLeft,  500);
            rmsAR = RMS.ar(aRight, 500);
            rmsBL = RMS.ar(bLeft,  500);
            rmsBR = RMS.ar(bRight, 500);

            // dBFS with guard floor
            minLinear = 1e-9;
            dbAL = (max(rmsAL, minLinear)).log10 * 20.0;
            dbAR = (max(rmsAR, minLinear)).log10 * 20.0;
            dbBL = (max(rmsBL, minLinear)).log10 * 20.0;
            dbBR = (max(rmsBR, minLinear)).log10 * 20.0;

            tick = Impulse.kr(fps);

            // Private OSC payload: [A_L_dB, A_R_dB, B_L_dB, B_R_dB]
            SendReply.kr(tick, "/md/rms_isolated_dB", [dbAL, dbAR, dbBL, dbBR]);
        }).add;
    });
    "[RMS HUD] SynthDef \\md_rms_isolated_from_busses installed.".postln;
};

// Start the reader **at tail** so it runs AFTER the chains write to their busses
stopRmsSynth = {
    if(~rms_isolated_synth.notNil) {
        ~rms_isolated_synth.free; ~rms_isolated_synth = nil;
        "[RMS HUD] previous synth stopped.".postln;
    };
};

startRmsSynthAtTail = { arg busIndexForA, busIndexForB;
    AppClock.sched(0.20, {   // small delay after .add; no server.sync per your rules
        Server.default.bind({
            ~rms_isolated_synth = Synth.tail(Server.default, \md_rms_isolated_from_busses, [
                \inBusA, busIndexForA,
                \inBusB, busIndexForB,
                \fps, updateRateHz
            ]);
        });
        ("[RMS HUD] (tail) started on A=" ++ busIndexForA ++ "  B=" ++ busIndexForB).postln;
        nil
    });
};

// ---- Listener: receive private dB and update the UI model ----
oscKeyName = \md_rms_isolated_listener;

installRmsListener = {
    var existing;
    existing = OSCdef.all.at(oscKeyName);
    if(existing.notNil) { existing.free };

    OSCdef(oscKeyName, { arg msg;
        if(msg.size >= 7) {
            currentDbAL = msg[3].asFloat;
            currentDbAR = msg[4].asFloat;
            currentDbBL = msg[5].asFloat;
            currentDbBR = msg[6].asFloat;
        };
        nil
    }, '/md/rms_isolated_dB', recvPort: NetAddr.langPort);

    "[RMS HUD] listener installed (/md/rms_isolated_dB)".postln;
};

// ---- AppClock ticker: map dB -> 0..1 and set meters + labels ----
updateRoutine = Routine({
    var waitSeconds, floorDbLive, topDbLive, mapDbToUi;
    waitSeconds = 1.0 / updateRateHz;

    mapDbToUi = { arg dbValue, floorDb, topDb;
        ((dbValue - floorDb) / (topDb - floorDb)).clip(0.0, 1.0)
    };

    while({ rmsWindow.notNil and: { rmsWindow.isClosed.not } }) {
        floorDbLive = ~rms_isolated_floor_db ? defaultFloorDb;
        topDbLive   = ~rms_isolated_top_db   ? defaultTopDb;

        meterAL.value = mapDbToUi.(currentDbAL, floorDbLive, topDbLive);
        meterAR.value = mapDbToUi.(currentDbAR, floorDbLive, topDbLive);
        meterBL.value = mapDbToUi.(currentDbBL, floorDbLive, topDbLive);
        meterBR.value = mapDbToUi.(currentDbBR, floorDbLive, topDbLive);

        labelDbA.string = ("A: L=" ++ currentDbAL.round(0.1) ++ " dB  R=" ++ currentDbAR.round(0.1) ++ " dB");
        labelDbB.string = ("B: L=" ++ currentDbBL.round(0.1) ++ " dB  R=" ++ currentDbBR.round(0.1) ++ " dB");

        waitSeconds.yield;
    };
}).play(AppClock);

// ---- bus discovery: wait until chainA/B expose busses, then start ----
getProxyBusInfo = { arg chainSymbol;
    var proxy, busObject, info;
    proxy = Ndef(chainSymbol);
    busObject = proxy.bus;
    info = (
        symbol: chainSymbol,
        playing: proxy.isPlaying,
        numChannels: proxy.numChannels,
        busIndex: busObject.notNil.if({ busObject.index }, { nil })
    );
    info
};

discoverBussesAndStart = {
    triesLeft = 20;
    Routine({
        var resolved;
        resolved = false;
        while({ triesLeft > 0 and: { resolved.not } }) {
            chainAInfo = getProxyBusInfo.(\chainA);
            chainBInfo = getProxyBusInfo.(\chainB);
            busIndexA  = chainAInfo[\busIndex];
            busIndexB  = chainBInfo[\busIndex];

            if(busIndexA.notNil and: { busIndexB.notNil }) {
                ("[RMS HUD] chainA bus=" ++ busIndexA ++ " ch=" ++ chainAInfo[\numChannels]
                    ++ "  |  chainB bus=" ++ busIndexB ++ " ch=" ++ chainBInfo[\numChannels]).postln;
                installSynthDef.();
                stopRmsSynth.();
                startRmsSynthAtTail.(busIndexA, busIndexB);  // **TAIL START** ensures correct node order
                resolved = true;
            }{
                if(triesLeft == 20) { "[RMS HUD] waiting for chainA/chainB busses...".postln };
                0.25.wait; triesLeft = triesLeft - 1;
            };
        };

        if(resolved.not) {
            "⚠️ [RMS HUD] could not resolve busses (chains not playing?). Start a source and re-evaluate this file.".warn;
        };
    }).play(AppClock);
};

// ---- wire up listener and start discovery ----
installRmsListener.();
discoverBussesAndStart.();

// ---- cleanup on close ----
rmsWindow.onClose_({
    if(OSCdef(oscKeyName).notNil) { OSCdef(oscKeyName).free };
    if(~rms_isolated_synth.notNil) { ~rms_isolated_synth.free; ~rms_isolated_synth = nil };
    if(updateRoutine.notNil) { updateRoutine.stop; updateRoutine = nil };
    "[RMS HUD] closed and cleaned up.".postln;
});

// return window so you see '-> a Window'
rmsWindow;
)

===== troubleshooting/startheres/MD_Cleanup_ChainA_Unfeed.scd =====
// MD_Cleanup_ChainA_Unfeed.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Stop audio; clear and recreate Ndef(\chainA) so the pedalboard can drive it again.
*/

(
var done;
Server.default.bind({
    Ndef(\chainA).stop;
    Ndef(\chainA).clear;
    Ndef(\chainA).ar(2);
});
done = "Cleaned chainA—pedalboard can drive it again.";
done.postln;
done
)

===== troubleshooting/startheres/MD_Meters_PhaseC_Audio.scd =====
// MD_Meters_PhaseC_Audio.scd
// v0.1.0
// MD timestamp: 2025-09-27 19:58 GMT+1

/*
Purpose
- Feed a sine into Ndef(\chainA), attach taps that SendReply /md/levels (A=2001, B=2002).
- Print expected RMS (A/√2) and measured A levels in console for 5s.
*/

(
var hz, testFreq, testAmp, expectedRMS, banner, ensureProxy, attachTap, makeTaps;

hz = 12;
testFreq = 220;
testAmp  = 0.20;
expectedRMS = (testAmp / (2.sqrt)); // ≈0.1414 for 0.2

banner = { arg text; var t; t = text; ("[MD_A_AUDIO] " ++ t).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var chans, l, r, ampL, ampR, trig;
        chans = inSig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l });
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(hz);
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);  // replyID in 4th arg (correct)
        inSig
    });
};

makeTaps = {
    Server.default.bind({
        ensureProxy.(\chainA, 2);
        ensureProxy.(\chainB, 2);
        attachTap.(\chainA, \eodTapA, 2001);
        attachTap.(\chainB, \eodTapB, 2002);
    });
    banner.("Taps attached A=2001, B=2002 @" ++ hz ++ " Hz");
};

// Feed test tone and play
Server.default.bind({
    var sig;
    sig = SinOsc.ar(testFreq ! 2) * testAmp;
    Ndef(\testmelody, { sig });
    Ndef(\chainA) <<> Ndef(\testmelody);
    Ndef(\chainA).play;
});

makeTaps.();

OSCdef(\mdSpyA).free;  // ensure clean
OSCdef(\mdSpyA, { arg msg;
    var isA, l, r, line;
    isA = (msg.size >= 5) and: { msg[2] == 2001 };  // replyID position
    isA.if({
        l = msg[3].asFloat; r = msg[4].asFloat;
        line = "A_meas (L,R)=(" ++ l.round(0.001) ++ "," ++ r.round(0.001)
            ++ ")  vs expected_RMS≈" ++ expectedRMS.round(0.001);
        line.postln;
    });
}, '/md/levels');

AppClock.sched(5.0, {
    OSCdef(\mdSpyA).free;
    banner.("done (audio still playing; run MD_Cleanup_ChainA_Unfeed to stop).");
    nil
});

banner.("freq=" ++ testFreq ++ " Hz  amp=" ++ testAmp
    ++ "  expected_RMS≈" ++ expectedRMS.round(0.0001));
"-> MD_Meters_PhaseC_Audio scheduled."
)

===== troubleshooting/startheres/Taps_Stable_Runtime_Shim.scd =====

===== troubleshooting/Taps_Stable_Runtime_Shim.scd =====
// Taps_Stable_Runtime_Shim.scd
// v0.1.1 (fix SendReply replyID position)
// MD timestamp: 2025-09-27 19:35 GMT+1

/*
Purpose
- Publish /md/levels with replyID in proper slot (msg[2]) so listeners match A=2001 / B=2002.

Style / Guard Rails
- Single () block; VAR-FIRST; no non-local returns; no server.sync.
*/

(
var server, rateHz, attachTap, ensureProxy, banner;

server = Server.default;
rateHz = 12;

banner = { arg text; ("[TAPS] " ++ text).postln; };

ensureProxy = { arg name, numCh;
    (Ndef(name).rate != \audio).if({
        Ndef(name).clear;
        Ndef(name).ar(numCh ? 2);
    });
};

attachTap = { arg name, key, replyID;
    Ndef(name).filter(key, { arg inSig;
        var sig, chans, l, r, ampL, ampR, trig;
        sig = inSig;
        chans = sig.asArray;
        l = (chans.size >= 1).if({ chans[0] }, { Silent.ar });
        r = (chans.size >= 2).if({ chans[1] }, { l }); // mono -> duplicate
        ampL = Lag.kr(Amplitude.kr(l, 0.01, 0.2), 0.08);
        ampR = Lag.kr(Amplitude.kr(r, 0.01, 0.2), 0.08);
        trig = Impulse.kr(rateHz);

        // *** Correct: replyID is the 4th arg, values exclude replyID
        SendReply.kr(trig, '/md/levels', [ampL, ampR], replyID);

        sig
    });
};

Server.default.bind({
    ensureProxy.(\chainA, 2);
    ensureProxy.(\chainB, 2);
    attachTap.(\chainA, \eodTapA, 2001);
    attachTap.(\chainB, \eodTapB, 2002);
});

banner.("Taps active (/md/levels) — A=2001, B=2002 at " ++ rateHz ++ " Hz.");
"-> Taps_Stable_Runtime_Shim ready".postln;
Window.allWindows.detect({ |w| w.name.asString.beginsWith("MagicDisplayGUI") }) ? nil;
)

===== utilities/DEMO20250923.scd =====
// DEMO20250923.scd ----------------------------


//Add delay → /add/delay
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 1);  // add
~nav_handleFret.(4, 1);  // delay (leaf → applies)


//Switch → /switch
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 3);  // switch (leaf → applies)


//Bypass delay ON / OFF
// ON
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 2);  // bypass
~nav_handleFret.(4, 1);  // delay
~nav_handleFret.(3, 2);  // on (leaf)
// OFF
~nav_handleFret.(6,10);
~nav_handleFret.(5, 2);
~nav_handleFret.(4, 1);
~nav_handleFret.(3, 3);  // off (leaf)


//Set source testmelody → /setSource/testmelody
~nav_handleFret.(6,10);  // commands
~nav_handleFret.(5, 4);  // setSource
~nav_handleFret.(4, 1);  // testmelody (leaf)

===== utilities/Inspect_And_Queue_AddDelay_AutoRoute.scd =====
// Inspect_And_Queue_AddDelay_AutoRoute.scd
// v1.0.0
// MD 2025-09-23 14:10 BST

/* Purpose
   - With no hardware, locate the node named "delay" anywhere in the CommandTree,
     derive the name-route from root, navigate with your builder (by name),
     and queue the SHORT canonical "/add/delay" (Step 2 ONLY; no send).
   - Prints available children at each navigation step for clarity.

   Style
   - var-first in every block; descriptive variable names.
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTree, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var findFirstPathByNameDFS, discoveredPathNames, navigationSucceeded;
var longPathString, queueListText, canonicalPathString, displayRef;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil }
  and: { ~system.commandManager.tree.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager      = ~system.commandManager;
commandTree         = commandManager.tree;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helper: status to GUI / console ---
showStatusMessage = { |messageText|
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// --- helper: print current children (name + fret) ---
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    "[SIM] No current node.".postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil
};

// --- helper: one step by name, with diagnostics ---
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// --- helper: navigate a full sequence of names from root ---
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// --- helper: DFS to find a node by name; returns ['root', ..., name] or nil ---
findFirstPathByNameDFS = { |targetNameString|
  var foundPathNames, traverseDepthFirst;

  foundPathNames = nil;

  traverseDepthFirst = { |nodeRef, pathSoFar|
    var newPath, childIdx, childNode, pathDone;
    if(foundPathNames.notNil) { ^nil }; // already found
    newPath = pathSoFar.add(nodeRef.name.asString);
    if(nodeRef.name.asString == targetNameString.asString) {
      foundPathNames = newPath.deepCopy; // include 'root' up to the target
      ^nil;
    };
    // iterate children
    childIdx = 0;
    while({ childIdx < nodeRef.children.size and: { foundPathNames.isNil } }, {
      childNode = nodeRef.children[childIdx];
      traverseDepthFirst.(childNode, newPath.copy);
      childIdx = childIdx + 1;
    });
    ^nil;
  };

  traverseDepthFirst.(commandTree.root, List.new);
  ^foundPathNames; // may be nil
};

// --- find a path to "delay" and navigate it ---
discoveredPathNames = findFirstPathByNameDFS.("delay");

if(discoveredPathNames.isNil) {
  "❌ Could not find a node named 'delay' in the current CommandTree.".warn;
  "Tip: run TestLogging_CommandTree.scd to print the structure, or tell me the exact branch where 'delay' lives.".postln;
  ^nil;
};

// drop the 'root' element; builder expects only child names from root downward
discoveredPathNames = if(discoveredPathNames.size > 1) {
  discoveredPathNames.copyRange(1, discoveredPathNames.size - 1)
}{
  [] // degenerate (shouldn't happen for a leaf)
};

showStatusMessage.("Simulating Step 2: navigating to " ++ discoveredPathNames.asString);

navigationSucceeded = navigateSequenceWithDiagnostics.(discoveredPathNames);

if(navigationSucceeded.not) {
  "❌ Navigation failed following the discovered path. Check the printed children.".warn;
  ^nil;
};

// post long path (informational)
longPathString = "/" ++ discoveredPathNames.join("/");
("[SIM] long=" ++ longPathString).postln;

// Step 2 requirement: QUEUE the SHORT canonical "/add/delay"
canonicalPathString = "/add/delay";
commandQueue.enqueueCommand(canonicalPathString);

// refresh GUI text fields
queueListText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");
AppClock.sched(0.0, {
  var canUpdate;
  canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
  if(canUpdate) {
    displayRef.updateTextField(\state, "Mode: queue (simulated)");
    displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListText);
    displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  }{
    ("[SIM] queued:\n" ++ queueListText).postln;
  };
  nil
});

// Optional: if you want to SEND immediately (Step 3), un-comment:
// if(commandManager.queueExportCallback.notNil) {
//   commandManager.queueExportCallback.value(canonicalPathString);
// };
)

===== utilities/Install_QuietProxyMeters.scd =====
// Install_QuietProxyMeters_NoRound.scd
// v0.1
// MD 20250923-1606

/* Purpose
   Install quiet meter taps inside Ndef(\chainA/\chainB) via .filter:
   - Low-rate sampling (Impulse.kr) and threshold gate (no rounding).
   - Sends OSC '/ampA' '/ampB' messages only when above threshold.
   - No console printing by default (no OSCdef printers are installed).

   Style
   - var-first; Server.default.bind for server ops; no server.sync; descriptive names.
*/

(
var serverRef, sampleRateHz, postThreshold, ensureProxyReady, installTapFor;

serverRef      = Server.default;
sampleRateHz   = 2.0;   // messages per second
postThreshold  = 0.02;  // ignore tiny levels

ensureProxyReady = { |proxyName|
  Server.default.bind({ Ndef(proxyName).ar(2) });
};

installTapFor = { |proxyName, oscPath|
  Server.default.bind({
    var proxyRef;
    proxyRef = Ndef(proxyName);
    proxyRef.ar(2);

    // Replace/insert a named filter; pass-through audio unchanged
    proxyRef.filter(\__meterTap__, { |inSig|
      var leftIn, rightIn, ampL, ampR, tick, gate;

      leftIn  = (inSig.size >= 1).if({ inSig[0] }, { 0 });
      rightIn = (inSig.size >= 2).if({ inSig[1] }, { leftIn });

      // Per-channel amplitude followers
      ampL = Amplitude.kr(leftIn, 0.01, 0.15);
      ampR = Amplitude.kr(rightIn, 0.01, 0.15);

      // Low-rate sampler and threshold gate (any channel above threshold triggers a send)
      tick = Impulse.kr(sampleRateHz);
      gate = tick * (((ampL > postThreshold) or: (ampR > postThreshold)).lag(0)); // boolean to 0/1

      // Send only when gate is 1
      SendReply.kr(gate, oscPath, [ampL, ampR]);

      // Pass-through
      inSig
    });
  });
};

// Ensure proxies exist and install taps
ensureProxyReady.(\chainA);
ensureProxyReady.(\chainB);
installTapFor.(\chainA, '/ampA');
installTapFor.(\chainB, '/ampB');

"✅ Quiet proxy meter taps installed on Ndef(\\chainA/\\chainB). No console prints by default.".postln;
)

===== utilities/Make_Project_Inventory.scd =====
// Make_Project_Inventory.scd
// v0.2.2
// MD 20251006-0849

/*
Purpose
- Scan the LivePedalboardSuite tree (default depth = 2), list files, and
  include the first N header lines from each .sc / .scd file.
- Write to a new IDE Document (no file I/O). The FIRST line is the intended
  filename for manual save.

Style
- var-first; descriptive lowercase names; no single-letter locals.
- STRICT: no non-local returns (^) in this script; only final-expression returns.
- Known-good sclang only. Cross-platform paths via PathName. No server.sync.
*/

(
var nowStamp, userExtDir, suiteRoot, maxDepth, headerLines, ignoreNames;
var isScFile, takeFirstNLines, toRelPath, sorter, collectFiles, buildDocText;
var entries, lines, doc, intendedName, divider;

// ----- configuration -----
nowStamp    = Date.getDate.stamp;
userExtDir  = Platform.userExtensionDir;
suiteRoot   = (userExtDir ++ "/LivePedalboardSuite").standardizePath; // canonical
maxDepth    = 2;          // directory recursion depth
headerLines = 3;          // first N lines from .sc/.scd headers
ignoreNames = [".DS_Store", ".git", ".cache", "build", "out", "node_modules", "_archived"];

// ----- helpers -----
isScFile = { arg path;
    var p;
    p = path.asString;
    (p.endsWith(".sc") or: { p.endsWith(".scd") })
};

takeFirstNLines = { arg pathString, n = 3;
    var text, parts, firstN;
    text = "";
    parts = #[];
    firstN = #[];
    File.use(pathString, "r", { arg f;
        text = f.readAllString;
    });
    parts = (text ? "").split(Char.nl);
    firstN = if(parts.size == 0) {
        #[]
    } {
        parts.copyRange(0, (n-1).clip(0, parts.size-1))
    };
    firstN
};

// safer relative path (no unknown selectors)
toRelPath = { arg fullPath, rootPath;
    var norm, root, rel;
    norm = fullPath.standardizePath;
    root = rootPath.standardizePath;
    rel = if(norm.beginsWith(root)) {
        norm.copyRange(root.size, norm.size - 1)
    } {
        norm
    };
    rel
};

// simple “by-string” sorter that works on Arrays and PathName lists
sorter = { arg coll, keyFunc;
    var arr;
    arr = coll.asArray.copy;
    arr.sort({ arg a, b;
        var ka, kb;
        ka = keyFunc.value(a).asString.toLower;
        kb = keyFunc.value(b).asString.toLower;
        ka < kb
    });
    arr
};

collectFiles = { arg rootPath, depthLimit = 2;
    var out, walk;
    out = List.new;

    walk = { arg pn, level;
        var name, okToEnter, children;
        name = pn.fileName.asString;
        okToEnter = ignoreNames.any({ arg bad; name == bad }).not;

        if(okToEnter) {
            if(pn.isFile) {
                out.add(pn.fullPath);
            } {
                if(level < depthLimit) {
                    // sort children by fileName with only known-good calls
                    children = sorter.value(pn.entries, { arg x; x.fileName.asString });
                    children.do({ arg child; walk.value(child, level + 1) });
                };
            };
        };
        nil // explicit last expression; no ^ in scripts
    };

    walk.value(PathName(rootPath), 0);
    sorter.value(out, { arg p; p.asString })
};

buildDocText = { arg rootPath, filesArray;
    var linesOut, div;
    linesOut = List.new;
    div = String.fill(88, $-);

    // header metadata
    linesOut.add("Make_Project_Inventory.scd - Project Inventory");
    linesOut.add("Generated: " ++ nowStamp);
    linesOut.add("UserExtensionDir: " ++ userExtDir);
    linesOut.add("Chosen suite root: " ++ rootPath);
    linesOut.add(div);
    linesOut.add("===== Directory tree (depth " ++ maxDepth + ") =====");
    linesOut.add("ROOT: " ++ rootPath);
    linesOut.add(div);

    // flat listing
    filesArray.do({ arg fullPath;
        var rel;
        rel = toRelPath.value(fullPath, rootPath);
        linesOut.add("- " ++ rel);
    });

    linesOut.add(div);
    linesOut.add("===== File headers (.sc / .scd; first " ++ headerLines + " line(s)) =====");

    // file header previews
    filesArray.do({ arg fullPath;
        var rel, previewLines, blockSep;
        if(isScFile.value(fullPath)) {
            rel = toRelPath.value(fullPath, rootPath);
            previewLines = takeFirstNLines.value(fullPath, headerLines);
            blockSep = String.fill(72, $=);
            linesOut.add(blockSep);
            linesOut.add(rel);
            linesOut.addAll(previewLines);
        };
    });

    linesOut.join(Char.nl.asString) // final expression return
};

// ----- run -----
divider = String.fill(88, $-);
intendedName = "Project_Inventory_" ++ nowStamp.replace($:, $_) ++ ".txt";

// collect & sort
entries = collectFiles.value(suiteRoot, maxDepth);

// build text & open a Document (first line = intended filename)
lines = List.new;
lines.add(intendedName);
lines.add(buildDocText.value(suiteRoot, entries));

doc = Document.new("Project Inventory (" ++ nowStamp ++ ")", lines.join(Char.nl.asString));
doc.front;

// tidy locals (optional)
lines = nil; entries = nil; doc = nil;
)
===== utilities/MD_Stop_All_MeterDiagnostics.scd =====
// MD_Stop_All_MeterDiagnostics.scd
// v0.1.1
// MD 2025-09-26 18:05 BST

/* Purpose / Style
   Purpose: Quiet the console by freeing known OSCdef listeners and stopping any reporter routines
            we may have created during diagnostics. Safe to run multiple times. Auto-stops.
   Style:   single () block; var-first everywhere; descriptive lowercase names; AppClock-only where used;
            no server.sync; no single-letter locals; returns nil.
*/

(
var freeOscIfPresent, stopRoutineIfPresent, freedCount, oscKeys, indexCount, indexLimit;
var reporterStoppedCount, oscObj, routineRef;

// —— helpers (var-first in closures)
freeOscIfPresent = { arg keySymbol;
    var oscRef;
    oscRef = OSCdef.all.at(keySymbol);
    if(oscRef.notNil) { oscRef.free; ("MDSTOP: freed OSCdef " ++ keySymbol.asString).postln };
};

stopRoutineIfPresent = { arg routineVar, labelString;
    var canStop;
    canStop = routineVar.notNil and: { routineVar.respondsTo(\stop) };
    if(canStop) { routineVar.stop; (labelString ++ ": stopped").postln };
};

// —— free known listeners (only if present)
freedCount = 0;
oscKeys = [
    \md_levels_sniffer_fixed,    // finite/continuous sniffers
    \md_levels_inline,           // overlay listener (if any)
    \md_levels_dbg_sniffer,      // debug taps listener
    \md_levels_gui_listener,     // if we created a GUI-only listener
    \md_levels_hud               // HUD listener (optional – remove if you want it kept)
];
indexCount = 0; indexLimit = oscKeys.size;
while({ indexCount < indexLimit }, {
    var keySym, exists;
    keySym = oscKeys[indexCount];
    exists = OSCdef.all.at(keySym).notNil;
    if(exists) { freeOscIfPresent.(keySym); freedCount = freedCount + 1 };
    indexCount = indexCount + 1;
});

// —— stop known reporter routines (only if present)
reporterStoppedCount = 0;
stopRoutineIfPresent.(~md_levels_dbg_reporter, "md_levels_dbg_reporter"); reporterStoppedCount = reporterStoppedCount + 1;
stopRoutineIfPresent.(~md_simple_reporter,     "md_simple_reporter");     reporterStoppedCount = reporterStoppedCount + 1;

// —— clear diagnostic dictionaries (safe)
~md_levelsById = ~md_levelsById ? IdentityDictionary.new;
~md_levels_dbg = ~md_levels_dbg ? IdentityDictionary.new;

("MDSTOP: freed=" ++ freedCount.asString
 ++ " stopped=" ++ reporterStoppedCount.asString).postln;
nil
)

===== utilities/MIDI_Log_Console.scd =====
// MIDI_Log_Console.scd
// v0.1.0
// MD 20250922-1420

/*
Purpose
- Log incoming MIDI messages (noteOn, noteOff, CC) to the console with the source device.
- Minimal and non-intrusive: separate MIDIdef keys; no interaction with your handlers.

Style
- var-first; lowercase names; no server.sync; no try/protect; no single-letter vars.
*/

// --- install once (safe to re-evaluate) ---
(
var buildSourceMap, nameForSrc, passesFilter, postLine;

// user-tunable filters (nil = accept all)
~midiLog_srcFilter = ~midiLog_srcFilter ? nil;    // Symbol or Array of Symbols (e.g. [\MD_IAC_to_SC])
~midiLog_chanFilter = ~midiLog_chanFilter ? nil;  // Integer 0..15

// uid -> \Device_Name_Endpoint_Name
~midiLog_sources = ~midiLog_sources ? Dictionary.new;

// rebuild map from MIDIClient.sources
buildSourceMap = {
    var map;
    map = Dictionary.new;
    MIDIClient.init;        // idempotent
    MIDIClient.sources.do { |ep|
        var label;
        label = (ep.device ++ "_" ++ ep.name)
            .replace(" ", "_")
            .replace("-", "_")
            .replace("/", "_")
            .asSymbol;
        map[ep.uid] = label;
    };
    ~midiLog_sources = map;
    "🔎 [MIDI-LOG] source map built (% entries)".format(map.size).postln;
    map.keysValuesDo { |uid, sym| ("  - % -> %".format(uid, sym)).postln };
};

// resolve uid -> label; if unknown, rebuild once
nameForSrc = { |srcID|
    var label;
    label = ~midiLog_sources[srcID];
    if(label.isNil) { buildSourceMap.value; label = ~midiLog_sources[srcID] ?? ("uid:" ++ srcID) };
    ^label
};

// basic filter (source + channel)
passesFilter = { |srcID, chan|
    var srcOk, chOk, srcLabel, setOrVal;
    srcLabel = nameForSrc.value(srcID);
    srcOk = if(~midiLog_srcFilter.isNil) { true } {
        setOrVal = ~midiLog_srcFilter;
        if(setOrVal.isKindOf(Array)) { setOrVal.includes(srcLabel) } { srcLabel == setOrVal }
    };
    chOk = (~midiLog_chanFilter.isNil) or: { chan == ~midiLog_chanFilter };
    ^(srcOk and: chOk)
};

// one-liner formatter
postLine = { |kind, chan, srcID, a, b|
    var srcName, text;
    srcName = nameForSrc.value(srcID);
    text = "[MIDI] %-8s src=%-24s ch=%2d  a=%-4s  b=%-4s"
        .format(kind, srcName, chan, a, b);
    text.postln;
};

// install / replace MIDIdefs
MIDIdef.noteOn(\mdLog_noteOn,   { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOn", chan, srcID, num, vel) };
});
MIDIdef.noteOff(\mdLog_noteOff, { |vel, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("noteOff", chan, srcID, num, vel) };
});
MIDIdef.cc(\mdLog_cc,           { |val, num, chan, srcID|
    if(passesFilter.value(srcID, chan)) { postLine.value("cc", chan, srcID, num, val) };
});

// build initial map and announce
buildSourceMap.value;
"✅ [MIDI-LOG] active. Set ~midiLog_srcFilter or ~midiLog_chanFilter to narrow output. Call ~midiLog_stop.() to remove.".postln;

// global helpers
~midiLog_refresh = { buildSourceMap.value };
~midiLog_stop = {
    ["mdLog_noteOn","mdLog_noteOff","mdLog_cc"].do { |k|
        var key = k.asSymbol;
        var def = MIDIdef(key);
        if(def.notNil) { def.free };
    };
    "🛑 [MIDI-LOG] stopped.".postln;
};
)

===== utilities/Queue_AddDelay_DirectCanonical.scd =====
// Queue_AddDelay_DirectCanonical.scd
// v0.1
// MD 20250923-1302

(
var environmentReady, commandManager, commandQueue, statusDisplayRef;
var canonicalPathString, queueListAsText;

environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) { "⚠️ Bring-up first (Option B).".warn; ^nil };

commandManager       = ~system.commandManager;
commandQueue         = commandManager.queue;
statusDisplayRef     = commandManager.display;
canonicalPathString  = "/add/delay";

commandQueue.clearQueue; "🧹 Queue cleared".postln;
commandQueue.enqueueCommand(canonicalPathString);
("📥 Command added: " ++ canonicalPathString).postln;
("📦 Current queue: " ++ commandQueue.commandList.asString).postln;

AppClock.sched(0.0, {
  if(statusDisplayRef.notNil and: { statusDisplayRef.respondsTo(\updateTextField) }) {
    var listAsText = commandQueue.commandList.collect({ |s| "- " ++ s.asString }).join("\n");
    statusDisplayRef.updateTextField(\state, "Mode: queue (simulated)");
    statusDisplayRef.updateTextField(\queue, "Current Queue:\n" ++ listAsText);
    statusDisplayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
  };
  nil
});
)

===== utilities/Quick_Switch_Toggle.scd =====
// Quick_Switch_Toggle.scd
// v0.1.0  MD 2025-09-26 15:28 BST
(
var systemRef, commandManagerRef, callbackFunc, didRun;
systemRef = ~system; if(systemRef.isNil) { "⚠️ ~system is nil; bring-up first.".warn; ^nil };
commandManagerRef = systemRef.commandManager; if(commandManagerRef.isNil) { "⚠️ CommandManager is nil.".warn; ^nil };
callbackFunc = commandManagerRef.queueExportCallback;
if(callbackFunc.isKindOf(Function).not) {
    if(systemRef.respondsTo(\installAdapterBridge)) { systemRef.installAdapterBridge };
    callbackFunc = commandManagerRef.queueExportCallback;
};
if(callbackFunc.isKindOf(Function)) { callbackFunc.value("/switch"); "[Switch] '/switch' sent.".postln } { "⚠️ queueExportCallback missing.".warn };
)

===== utilities/SimNav_Bridge_ApplyLeafPayload_FIX.scd =====
// SimNav_Bridge_ApplyLeafPayload_FIX.scd
// v0.1.2
// MD 2025-09-23 10:45 BST
/* Purpose
 - Make ~nav_handleFret update MagicDisplayGUI choices and apply leaf payloads.
 - Reuse the CommandManager's builder so CommandManager.updateDisplay works.
 - Show canonical path in the GUI before applying via the adapter.
Style
 - var-first; lowercase method names; AppClock-only UI; no server.sync.
*/

(
var haveSystem, manager, builderRef, displayRef, applyPath, choiceLinesFor, setChoicesInGui, showInGui;

// Preconditions (reuse what LivePedalboardSystem created)
haveSystem = ~system.notNil;
if(haveSystem.not) {
    "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)".warn; ^nil;
};
manager    = ~system.commandManager;
builderRef = manager.builder; // use the manager’s builder so updateDisplay works
displayRef = ~system.statusDisplay;

// Apply a canonical path using your adapter signature (path, mpb, gui)
applyPath = { |canonical|
    var mpb = ~system.pedalboard;
    if(mpb.isNil) { "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln; ^nil };
    ~ct_applyOSCPathToMPB.(canonical, mpb, displayRef);
};

// Build "fret X → Name" lines for the GUI’s Choices panel
choiceLinesFor = { |node|
    var lines;
    lines = List.new;
    if(node.notNil and: { node.children.notEmpty }) {
        node.children.do { |ch|
            lines.add("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString);
        };
    };
    lines
};

// Push choices text into MagicDisplayGUI (uses your setOperations extension)
setChoicesInGui = { |node|
    var lines = choiceLinesFor.(node);
    if(displayRef.notNil and: { displayRef.respondsTo(\setOperations) }) {
        displayRef.setOperations(lines.asArray);
    };
};

// Show a one-liner in the GUI’s expectation area
showInGui = { |text|
    if(displayRef.notNil and: { displayRef.respondsTo(\showExpectation) }) {
        displayRef.showExpectation(text, 0);
    };
};

// Public API: reset + handleFret using the manager’s builder
~nav_reset = {
    builderRef.resetNavigation;
    manager.updateDisplay; // refresh GUI choices at root
    "[BRIDGE] nav reset".postln;
};

~nav_handleFret = { |stringNum, fretNum|
    // navigate
    builderRef.navigateByFret(stringNum, fretNum);
    // reflect state in GUI immediately
    manager.updateDisplay; // will call setOperations under the hood

    // Leaf? -> apply payload; otherwise just keep showing choices
    if(builderRef.currentNode.notNil and: { builderRef.currentNode.isLeaf }) {
        var payloadString = builderRef.getCurrentPayload.asString; // canonical "/verb/arg..."
        showInGui.("Apply → " ++ payloadString);
        applyPath.(payloadString);
        ~nav_reset.();
    };
};

"[BRIDGE] SimNav patch ready — use ~nav_handleFret.(string,fret); ~nav_reset.()".postln;

// Initial GUI refresh
manager.updateDisplay;
)

===== utilities/SimNav_Bridge_ApplyLeafPayload.scd =====
// SimNav_Bridge_ApplyLeafPayload.scd
// v0.1.1
// MD 20250923-1021

(
/*
Purpose
- Bridge the MIDI simulation to CommandTree navigation; on leaf under "commands",
  apply its canonical payload ("/add/delay", "/switch", etc.) via the adapter to MagicPedalboardNew.

Style
- var-first; lowercase methods; no server.sync; .scd-safe (no caret returns).
*/

var jsonPath, tree, ok, proceed, builder;
var requireOk, ensureAdapter, applyPath;

// ---- small utilities --------------------------------------------------------
requireOk = { |cond, msg|
  if(cond.not) { msg.postln };
  cond
};

ensureAdapter = {
  var candidates, i, p;
  if(~ct_applyOSCPathToMPB.isNil) {
    candidates = List[
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd",
      Platform.userExtensionDir ++ "/LivePedalboardSuite/MagicPedalboard/adapter_commandtree_to_magicpedalboard.scd"
    ];
    i = 0;
    while({ i < candidates.size }, {
      p = candidates[i].standardizePath;
      if(File.exists(p)) { p.load };
      i = i + 1;
    });
  };
  ~ct_applyOSCPathToMPB.notNil
};

applyPath = { |p|
  var pedalboardRef, guiRef;
  pedalboardRef = nil; guiRef = nil;
  if(~system.notNil) {
    pedalboardRef = ~system.pedalboard;
    guiRef = ~system.statusDisplay;
  };
  if(pedalboardRef.isNil) {
    "[BRIDGE] no ~system.pedalboard (bring-up needed)".postln;
  }{
    ("[BRIDGE] apply → " ++ p).postln;
    ~ct_applyOSCPathToMPB.(p, pedalboardRef, guiRef);
  };
};

// ---- 1) preconditions: bring-up + adapter ----------------------------------
proceed = true;
proceed = proceed and: { requireOk.(~system.notNil, "⚠️ Bring-up first: Start_LivePedalboardSystem.scd (Option B)") };
proceed = proceed and: { requireOk.(ensureAdapter.(), "⚠️ Adapter missing; evaluate adapter_* file") };

// ---- 2) load the same JSON that LivePedalboardSystem uses -------------------
if(proceed) {
  jsonPath = Platform.userExtensionDir
    ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
  tree = MDCommandTree.new("root");
  ok = tree.importJSONFile(jsonPath);
  ("[BRIDGE] import ok → " ++ ok).postln;
  proceed = ok;
};

// ---- 3) create builder and expose simple API --------------------------------
if(proceed) {
  builder = MDCommandBuilder.new(tree);

  ~nav_reset = {
    builder.reset;
    "[BRIDGE] nav reset".postln;
  };

  ~nav_handleFret = { |stringNum, fretNum|
    var node, payloadString;
    builder.navigateToChild(stringNum, fretNum);
    node = builder.currentNode;

    if(node.notNil and: { node.isLeaf }) {
      // 'commands' leaves already carry canonical string payloads (set by your editor)
      payloadString = builder.getCurrentCommand.asString;
      applyPath.(payloadString);
      ~nav_reset.();
    }{
      // optional: list children at this level to see available frets
      builder.listChildren;
    };
  };

  "[BRIDGE] ready — call ~nav_handleFret.(string, fret); use ~nav_reset.() to restart.".postln;
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay_Robust.scd =====
// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.4
// MD 2025-09-23 14:08 BST

/* Purpose
   Emulate Step 2 without hardware:
   - Try likely routes to "delay", printing children BEFORE and AFTER each step.
   - Queue SHORT canonical "/add/delay" when any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block; descriptive var names; AppClock-only UI; no server.sync.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenOf, navigateOneStepByName, navigateSequenceVerbose;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print a node's children (name + fret)
printChildrenOf = { |labelText|
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) {
    ("[SIM] " ++ labelText ++ ": <no current node>").postln; ^nil
  };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    ("[SIM] " ++ labelText ++ ": <no children>").postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] " ++ labelText ++ ":\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate one step by name; logs before/after child lists
navigateOneStepByName = { |childNameToSelect, stepIndex, totalSteps|
  var nextNodeAfterStep, header;
  header = "[SIM] step " ++ (stepIndex+1).asString ++ "/" ++ totalSteps.asString
         ++ ": selecting '" ++ childNameToSelect ++ "'";
  header.postln;

  printChildrenOf.("Children BEFORE");

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  printChildrenOf.("Children AFTER");
  ^true;
};

// Navigate full sequence; returns true on success
navigateSequenceVerbose = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName   = nameSequence[currentIndex];
    stepSucceeded = navigateOneStepByName.(currentName, currentIndex, sequenceLength);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for logging only)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Map long → short canonical understood by MPB
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;

      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) {
        ^("/add/" ++ pathSegments.last.asString);
      };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegments.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue;

targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceVerbose.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, queue the short canonical form explicitly:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: send now (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Paste the BEFORE/AFTER children for the failing step and we'll adapt.");
};
)

===== utilities/Simulate_CommandTree_Queue_AddDelay.scd =====
// Simulate_CommandTree_Queue_AddDelay.scd
// v1.0.0
// MD 20250923-12:36

// Simulate_CommandTree_Queue_AddDelay_Robust.scd
// v1.0.3
// MD 2025-09-23 13:55 BST

/* Purpose
   Robustly emulate Step 2 with no hardware:
   - Try likely navigation sequences to reach "delay":
       [ "chain","add","delay" ]  (first choice)
       [ "chain","add","timebased","delay" ]
       [ "audio","timebased","delay" ]
   - Print children (name + fret) at each step for visibility.
   - Enqueue the SHORT canonical "/add/delay" once any route succeeds.
   - Does NOT send; purely queues as per Step 2.

   Style
   - var-first in every block or method.
   - descriptive variable names.
   - AppClock-only for GUI updates; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue;
var showStatusMessage, printChildrenHere, navigateOneStepByName, navigateSequenceWithDiagnostics;
var candidateSequences, chosenSequence, routeSucceeded;
var targetEffectName, longPathString, canonicalPathString;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;

// --- environment guards ---
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first: evaluate Start_LivePedalboardSystem.scd (Option B).".warn;
  ^nil;
};

// --- shorthands ---
commandManager     = ~system.commandManager;
commandTreeBuilder = commandManager.builder;
commandQueue       = commandManager.queue;

// --- helpers ---

showStatusMessage = { |messageText|
  var displayRef;
  displayRef = commandManager.display;
  AppClock.sched(0.0, {
    var canShow;
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

// Pretty-print the current node's children (name + fret)
printChildrenHere = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] No current node.".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] No children at this node.".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")"
    }).join("\n");
    ("[SIM] Available children:\n" ++ childLines).postln;
  };
  ^nil;
};

// Navigate a single step by name; returns true/false and prints diagnostics if it fails.
navigateOneStepByName = { |childNameToSelect|
  var nextNodeAfterStep;
  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  if(nextNodeAfterStep.isNil or: { nextNodeAfterStep.name.asString != childNameToSelect.asString }) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    printChildrenHere.();
    ^false;
  };
  ^true;
};

// Navigate a full sequence; prints children at each step.
navigateSequenceWithDiagnostics = { |nameSequence|
  var stepSucceeded, currentIndex, sequenceLength, currentName;
  stepSucceeded  = true;
  currentIndex   = 0;
  sequenceLength = nameSequence.size;

  commandTreeBuilder.resetNavigation; // restart from root for each attempt

  while({ currentIndex < sequenceLength and: { stepSucceeded } }, {
    currentName = nameSequence[currentIndex];
    ("[SIM] step " ++ (currentIndex+1).asString ++ "/" ++ sequenceLength.asString
      ++ ": selecting '" ++ currentName ++ "'").postln;
    printChildrenHere.();
    stepSucceeded = navigateOneStepByName.(currentName);
    currentIndex  = currentIndex + 1;
  });

  ^stepSucceeded;
};

// Build long internal path (for visibility/logging)
buildLongPathFromBuilder = {
  var namesFromRoot, filteredNames, rawPathString;
  namesFromRoot  = commandTreeBuilder.currentNode.getPathToRoot;
  filteredNames  = if(namesFromRoot.size > 1) { namesFromRoot.copyRange(1, namesFromRoot.size - 1) } { [] };
  rawPathString  = "/" ++ filteredNames.join("/");
  ^rawPathString;
};

// Long → short canonical path (same rules you use elsewhere)
canonicalizeLongPath = { |rawPathString|
  var pathSegments, firstSegment, secondSegment;
  pathSegments  = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegments.size == 0) { ^rawPathString.asString };
  firstSegment = pathSegments[0].asString;

  if(firstSegment == "switch") { ^"/switch" };

  if(firstSegment == "chain") {
    if(pathSegments.size >= 3) {
      secondSegment = pathSegments[1].asString;
      if(secondSegment == "add" and: { pathSegments[2].asString == "audio" }) { ^("/add/" ++ pathSegments.last.asString) };
      if(secondSegment == "setsource"
        and: { pathSegments.size >= 5 }
        and: { pathSegments[2].asString == "audio" }
        and: { pathSegments[3].asString == "source" }) { ^("/setSource/" ++ pathSegments.last.asString) };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegment)) {
    ^("/" ++ pathSegments.join("/"));
  };

  ^rawPathString.asString;
};

// Enqueue canonical string and refresh GUI
enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsText, displayRef;
  displayRef = commandManager.display;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsText = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    var canUpdate;
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsText);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsText).postln;
    };
    nil
  });
};

// --- simulate Step 2 (robust) ---

commandQueue.clearQueue; // start fresh
targetEffectName  = "delay";
candidateSequences = [
  [ "chain", "add", targetEffectName ],
  [ "chain", "add", "timebased", targetEffectName ],
  [ "audio", "timebased", targetEffectName ]
];

showStatusMessage.("Simulating Step 2: queue '/add/delay' (trying multiple routes)");

chosenSequence = nil;
routeSucceeded = false;

candidateSequences.do({ |nameSequence|
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequence.asString).postln;
    routeSucceeded = navigateSequenceWithDiagnostics.(nameSequence);
    if(routeSucceeded) { chosenSequence = nameSequence.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString      = buildLongPathFromBuilder.();
  canonicalPathString = canonicalizeLongPath.(longPathString);

  // Regardless of route, queue the canonical short for Step 2:
  canonicalPathString = "/add/" ++ targetEffectName;

  ("[SIM] navigation OK via: " ++ chosenSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalPathString).postln;

  enqueueCanonicalPath.(canonicalPathString);

  // Optional: auto-send immediately (uncomment if you want Step 3 here):
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalPathString) };

}{
  showStatusMessage.("Navigation failed for all candidates. Use the printed child lists to adjust the route.");
};
)


===== utilities/Simulate_Step2_NavigateAndQueue_AddDelay.scd =====
// Simulate_Step2_NavigateAndQueue_AddDelay.scd
// v1.0.0
// MD 20250923-1258

/* Purpose
   Step 2 without hardware:
   - Navigate CommandTree to reach "delay" via real structure:
       (a) chain → add → delay        (preferred if present)
       (b) chain → add → timebased → delay
   - Print children BEFORE and AFTER each selection for visibility.
   - Queue SHORT canonical "/add/delay" (no send; Step 2 only).

   Style
   - var-first in every block or method.
   - descriptive variable names (no segs/eff/arg/pb).
   - AppClock-only for GUI; no server.sync; no SoundIn.
   - Uses only ~system; assumes Start_LivePedalboardSystem.scd (Option B) has run.
*/

(
var environmentReady, commandManager, commandTreeBuilder, commandQueue, displayRef;
var showStatusMessage, printChildrenOfCurrentNode, navigateOneStepByName, navigateSequenceVerbose;
var buildLongPathFromBuilder, canonicalizeLongPath, enqueueCanonicalPath;
var preferredSequences, selectedSequence, routeSucceeded;
var longPathString, canonicalFromPathString, canonicalToQueueString;

// --- guards & shorthands ----------------------------------------------------
environmentReady = (~system.notNil)
  and: { ~system.commandManager.notNil }
  and: { ~system.commandManager.builder.notNil }
  and: { ~system.commandManager.queue.notNil };

if(environmentReady.not) {
  "⚠️ Bring-up first (Start_LivePedalboardSystem.scd, Option B).".warn;
  ^nil;
};

commandManager      = ~system.commandManager;
commandTreeBuilder  = commandManager.builder;
commandQueue        = commandManager.queue;
displayRef          = commandManager.display;

// --- helpers ----------------------------------------------------------------
showStatusMessage = { |messageText|
  var canShow;
  AppClock.sched(0.0, {
    canShow = displayRef.notNil and: { displayRef.respondsTo(\showExpectation) };
    if(canShow) { displayRef.showExpectation(messageText, 0) } { ("[SIM] " ++ messageText).postln };
    nil
  });
};

printChildrenOfCurrentNode = {
  var childrenArray, childLines;
  if(commandTreeBuilder.currentNode.isNil) { "[SIM] <no current node>".postln; ^nil };
  childrenArray = commandTreeBuilder.currentNode.children ? [];
  if(childrenArray.isEmpty) {
    "[SIM] <no children>".postln;
  }{
    childLines = childrenArray.collect({ |childNode|
      var lineText;
      lineText = "  • " ++ childNode.name.asString ++ "  (fret " ++ childNode.fret.asString ++ ")";
      lineText
    }).join("\n");
    ("[SIM] Children:\n" ++ childLines).postln;
  };
  ^nil;
};

navigateOneStepByName = { |childNameToSelect, stepIndexInteger, totalStepsInteger|
  var nextNodeAfterStep, headerText, stepOk;
  var canPrint;
  headerText = "[SIM] step " ++ (stepIndexInteger+1).asString ++ "/" ++ totalStepsInteger.asString
             ++ ": selecting '" ++ childNameToSelect ++ "'";
  headerText.postln;

  "  BEFORE".postln;
  printChildrenOfCurrentNode.();

  nextNodeAfterStep = commandTreeBuilder.navigateByName(nil, childNameToSelect);
  stepOk = (nextNodeAfterStep.notNil) and: { nextNodeAfterStep.name.asString == childNameToSelect.asString };
  if(stepOk.not) {
    ("❌ navigation failed at '" ++ childNameToSelect ++ "'").warn;
    ^false;
  };

  "  AFTER".postln;
  printChildrenOfCurrentNode.();
  ^true;
};

navigateSequenceVerbose = { |nameSequenceArray|
  var stepSucceeded, currentIndexInteger, totalStepsInteger, currentNameString;
  stepSucceeded       = true;
  currentIndexInteger = 0;
  totalStepsInteger   = nameSequenceArray.size;

  commandTreeBuilder.resetNavigation;

  while({ currentIndexInteger < totalStepsInteger and: { stepSucceeded } }, {
    currentNameString  = nameSequenceArray[currentIndexInteger];
    stepSucceeded      = navigateOneStepByName.(currentNameString, currentIndexInteger, totalStepsInteger);
    currentIndexInteger = currentIndexInteger + 1;
  });

  ^stepSucceeded;
};

buildLongPathFromBuilder = {
  var namesFromRootArray, filteredNamesArray, rawPathStringLocal;
  namesFromRootArray  = commandTreeBuilder.currentNode.getPathToRoot; // ["root", ...]
  filteredNamesArray  = if(namesFromRootArray.size > 1) { namesFromRootArray.copyRange(1, namesFromRootArray.size - 1) } { [] };
  rawPathStringLocal  = "/" ++ filteredNamesArray.join("/");
  ^rawPathStringLocal;
};

canonicalizeLongPath = { |rawPathString|
  var pathSegmentsArray, firstSegmentString, secondSegmentString;
  pathSegmentsArray   = rawPathString.asString.split($/).reject({ |s| s.size == 0 });
  if(pathSegmentsArray.size == 0) { ^rawPathString.asString };
  firstSegmentString  = pathSegmentsArray[0].asString;

  if(firstSegmentString == "switch") { ^"/switch" };

  if(firstSegmentString == "chain") {
    if(pathSegmentsArray.size >= 3) {
      secondSegmentString = pathSegmentsArray[1].asString;

      // /chain/add/audio/.../<effect> → /add/<effect>
      if(secondSegmentString == "add" and: { pathSegmentsArray[2].asString == "audio" }) {
        ^("/add/" ++ pathSegmentsArray.last.asString);
      };

      // /chain/setsource/audio/source/<src> → /setSource/<src>
      if(secondSegmentString == "setsource"
        and: { pathSegmentsArray.size >= 5 }
        and: { pathSegmentsArray[2].asString == "audio" }
        and: { pathSegmentsArray[3].asString == "source" }) {
        ^("/setSource/" ++ pathSegmentsArray.last.asString);
      };
    };
    ^rawPathString.asString;
  };

  if(#["add","remove","clear","bypass","swap","setSource","switch"].includes(firstSegmentString)) {
    ^("/" ++ pathSegmentsArray.join("/"));
  };

  ^rawPathString.asString;
};

enqueueCanonicalPath = { |canonicalPathString|
  var queueListAsTextString, canUpdate;
  commandQueue.enqueueCommand(canonicalPathString);
  queueListAsTextString = commandQueue.commandList.collect({ |cmdString| "- " ++ cmdString.asString }).join("\n");

  AppClock.sched(0.0, {
    canUpdate = displayRef.notNil and: { displayRef.respondsTo(\updateTextField) };
    if(canUpdate) {
      displayRef.updateTextField(\state, "Mode: queue (simulated)");
      displayRef.updateTextField(\queue, "Current Queue:\n" ++ queueListAsTextString);
      displayRef.updateTextField(\lastCommand, "Last Added: " ++ canonicalPathString);
    }{
      ("[SIM] queued:\n" ++ queueListAsTextString).postln;
    };
    nil
  });
};

// --- run (Step 2) -----------------------------------------------------------
commandQueue.clearQueue;

preferredSequences = [
  [ "chain", "add", "delay" ],
  [ "chain", "add", "timebased", "delay" ]
];

showStatusMessage.("Step 2: queue '/add/delay' (navigating real tree; trying preferred routes)");

selectedSequence = nil;
routeSucceeded   = false;

preferredSequences.do({ |nameSequenceArray|
  var attemptOk;
  if(routeSucceeded.not) {
    ("[SIM] trying path: " ++ nameSequenceArray.asString).postln;
    attemptOk = navigateSequenceVerbose.(nameSequenceArray);
    if(attemptOk) { routeSucceeded = true; selectedSequence = nameSequenceArray.deepCopy };
  };
});

if(routeSucceeded) {
  longPathString          = buildLongPathFromBuilder.();
  canonicalFromPathString = canonicalizeLongPath.(longPathString);

  // For Step 2, always queue the SHORT canonical for the effect we want:
  canonicalToQueueString  = "/add/delay";

  ("[SIM] navigation OK via: " ++ selectedSequence.asString).postln;
  ("[SIM] long="  ++ longPathString).postln;
  ("[SIM] short=" ++ canonicalToQueueString
    ++ "  (from path→ " ++ canonicalFromPathString ++ ")").postln;

  enqueueCanonicalPath.(canonicalToQueueString);

  // Optional: send immediately (Step 3). Un-comment if desired:
  // if(commandManager.queueExportCallback.notNil) { commandManager.queueExportCallback.value(canonicalToQueueString) };

}{
  // Could not navigate (e.g., effect nested under other category) → still complete Step 2 by queuing canonical.
  "[SIM] falling back: could not navigate to 'delay'; queuing short canonical anyway".warn;
  canonicalToQueueString = "/add/delay";
  enqueueCanonicalPath.(canonicalToQueueString);
};
)

