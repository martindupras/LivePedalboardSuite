// LivePedalboardSystem.sc
// v0.3.2
// MD 2025-10-02 1350
// Purpose: Bring-up MagicPedalboard + CommandManager + single LPDisplayLayoutWindow
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

/*
Supplementary header — What this class does & key dependencies
----------------------------------------------------------------
Overview
- Orchestrates a complete bring-up sequence for the live pedalboard prototype:
  1) ensure server is up & tree is clean (when freshly booted),
  2) open a single MagicDisplay GUI window (avoid duplicates),
  3) construct & bind the MagicPedalboard,
  4) construct the CommandManager (tree-driven command layer),
  5) ensure audio is audible (safe test sources) and enable meters after initial rebuild.

Primary responsibilities
- Window hygiene (one GUI only), predictable boot order, defensive binding between GUI ↔ pedalboard ↔ command system,
  and conservative “ensureAudioOn” to guarantee an audible current chain.

Relies on (classes / files assumed present on the classpath)
- MagicPedalboard (core pedalboard implementation).
- Command tree stack: CommandManager, MDCommandTree, MDCommandBuilder, MDCommandQueue, MIDIInputManager.
- MagicDisplay / MagicDisplayGUI_GridDemo (status & meters), and MagicDisplay.ensureMeterDefs.
- MDMiniLogger (logging).
- SuperCollider primitives used here: Window, AppClock, Server, Ndef, Platform.userExtensionDir.

External data
- JSON command tree at:
  Platform.userExtensionDir ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json"

Notes
- Methods added in this version: class-side *help, *api, *test (non-invasive; do not change runtime behavior).
- This file intentionally avoids server.sync. s.waitForBoot is used only inside ensureServerReady() on first boot.
*/

LivePedalboardSystem : Object {
    var <>pedalboard;
    var <>pedalboardGUI;
    var <>commandManager;
    var <>statusDisplay; // this will hold a MagicDisplayGUI
	var <> lpDisplay; // THE NEW WINDOW
    var <>logger;
    var <>treeFilePath;
/*  *new { arg treePath;
        ^super.new.init(treePath);
    } */
     *new { arg treePath;
        var resolvedPath;
        resolvedPath = LivePedalboardSystem.resolveTreePath(treePath);
        ^super.new.init(resolvedPath);
    }
    init { arg treePath;
        var defaultPath;
        logger = MDMiniLogger.get;
        // Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
        defaultPath = Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
        treeFilePath = treePath.ifNil { defaultPath };
        ^this;
    }
    bringUpAll {
        // ✅ Make sure the server is up and the tree is clean *before* we create MPB
        this.ensureServerReady;
        this.bringUpMagicDisplayGUI; // 1) GUI first
        this.bringUpPedalboard; // 2) create MPB (it will create groups)
        this.bringUpCommandSystem; // 3) hook command system
        this.ensureAudioOn; // 4) prime sources + play current (no tree reset here)
        // meters last (you already moved this)
/*      if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
            statusDisplay.enableMeters(true);
        };*/
        //v0.2.8
        AppClock.sched(0.35, { // 350 ms is enough to outlive the initial MPB rebuild
            if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
                statusDisplay.enableMeters(true);
            };
            nil
        });
        logger.info("LivePedalboardSystem", "✅ System is ready.");
        ^this;
    }

    bringUpPedalboard {
        // new pedalboard bound to display (if ctor supports it)
        pedalboard = if (statusDisplay.notNil) {
            MagicPedalboard.new(statusDisplay)
        } {
            MagicPedalboard.new
        };
        // be defensive: wire after construction too, if there is a setter
        if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
            pedalboard.setDisplay(statusDisplay);
        };
        // remove runner usage; it's not needed for the new GUI path
        pedalboardGUI = nil;
        logger.info("Pedalboard", "MagicPedalboard initialized and bound to display.");
    }

    //newer:
     bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;
        // temporary callback: log only; the bridge will overwrite this
        cm.queueExportCallback = { |path|
            MDMiniLogger.get.info("Integration", "Queued path: " ++ path.asString);
        };
        commandManager = cm;
        MDMiniLogger.get.info("CommandSystem", "CommandManager initialized (bridge pending).");
        ^this
    }

// --- DISABLED FOR REPLACEMENT WITH LPDisplay
/*    // --- Single MagicDisplayGUI window, with meters enabled ---
    bringUpMagicDisplayGUI {
        // close any previous MagicDisplayGUI windows to avoid duplicates
        this.closeExistingMagicDisplayWindows;
statusDisplay = LPDisplayLayoutWindow.new;  // ⬅️ replaced MagicDisplayGUI_GridDemo with LPDisplayLayoutWindow (v0.3.0)
        //REMOVED: statusDisplay.showExpectation("System ready.", 0);
        // share GUI with CommandManager so CommandManager:setStatus can target it
        if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };
        this.ensureMeterDefs;
        // meters are enabled later in bringUpAll to avoid node races
    }*/
// ---END DISABLED FOR REPLACEMENT WITH LPDisplay


	bringUpMagicDisplayGUI {
    // close any previous MagicDisplayGUI windows to avoid duplicates
    this.closeExistingMagicDisplayWindows;

    // ⬇️ replaced MagicDisplayGUI_GridDemo with LPDisplayLayoutWindow
    statusDisplay = LPDisplayLayoutWindow.new;

    // ⬇️ LPDisplay does not support showInit or showExpectation
    statusDisplay.sendPaneText(\system, "System ready.");
    statusDisplay.sendPaneText(\diag, "Chains initialized.");
    statusDisplay.setConsoleLevelsOn(true); // optional: enable A/B level prints

    // share GUI with CommandManager so CommandManager:setStatus can target it
    if (commandManager.respondsTo(\display_)) {
        commandManager.display = statusDisplay;
    };

    // LPDisplay uses SendPeakRMS taps; no meter SynthDefs needed
}

    // --- Provide \busMeterA / \busMeterB if they don't exist yet ---
    // replaced with the below, which uses MagicDisplay meters instead:
/*    ensureMeterDefs {
        MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
    }*/
	// CHANGE FOR LPDisplay
	ensureMeterDefs {
    // LPDisplay uses SendPeakRMS taps; no meter SynthDefs needed
}


    ensureAudioOn {
        var s;
        s = Server.default;
        // Define sources/sinks idempotently
        Server.default.bind({
            if (Ndef(\testmelody).source.isNil) {
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f = Demand.kr(trig, 0, seq);
                    var env = Decay2.kr(trig, 0.01, 0.35);
                    var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                    Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
                });
            };
            Ndef(\testmelody).ar(2);
            if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
            // Ensure sink proxies exist at audio rate; MPB wires them
            Ndef(\chainA).ar(2);
            Ndef(\chainB).ar(2);
        });
        // Route CURRENT to \testmelody + Option A
        if (pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(\testmelody);
        };
        if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
        };
        // Make sure CURRENT sink is actually playing; stop the other
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
            });
        };
        // --- Make sure CURRENT sink is actually playing (single deferred assert) ---
        AppClock.sched(0.25, { // allow the temp SynthDef add to complete
            if (pedalboard.respondsTo(\playCurrent)) {
                pedalboard.playCurrent; // MPB decides which (A/B) should be audible
            } {
                Server.default.bind({
                    if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                    if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                });
            };
            nil
        });
        if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
        logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
    }
    ensureServerReady {
        var s, didBoot;
        s = Server.default;
        didBoot = false;
        if (s.serverRunning.not) {
            s.boot;
            s.waitForBoot; // permitted in your safe-reset pattern
            didBoot = true;
        };
        if (didBoot) {
            // Only wipe the tree on fresh boot, before MPB is constructed
            Server.default.bind({
                s.initTree;
                s.defaultGroup.freeAll;
            });
        };
        ^didBoot
    }
    tryPlayNdefs { arg syms;
        syms.do { arg sym;
            var nd = Ndef(sym);
            if (nd.notNil) { nd.play; };
        };
    }
    showStatus {
        logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
            pedalboard, commandManager
        ));
    }
/*  shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/
    closeExistingMagicDisplayWindows {
        var wins;
        wins = Window.allWindows.select({ |w|
            var nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        AppClock.sched(0.0, {
            wins.do({ |w| w.close });
            nil
        });
        ^this
    }
    shutdownAll {
        var runnerClosed;
        runnerClosed = false;
        if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
            pedalboard.free;
        };
        if (pedalboardGUI.notNil) {
            if (pedalboardGUI.respondsTo(\close)) {
                pedalboardGUI.close; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
                pedalboardGUI.stop; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
                pedalboardGUI.free; runnerClosed = true;
            };
        };
        if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
            statusDisplay.close;
        };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }

    // --- Added in v0.2.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
LivePedalboardSystem.help  —  quick guide

Bring-up (headless UI + one LPDisplay/MagicDisplay window)
----------------------------------------------------------
(
var lps;
lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;           // ensure server, open GUI, build pedalboard & command system, enable meters
)

Key instance methods
- bringUpAll(), bringUpPedalboard(), bringUpCommandSystem(), bringUpMagicDisplayGUI()
- ensureMeterDefs(), ensureAudioOn(), ensureServerReady()
- tryPlayNdefs(symbolArray), showStatus(), shutdownAll()

Notes
- Expects the command-tree JSON at:
  Platform.userExtensionDir ++ \"/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json\"
- Avoids duplicate GUI windows and avoids server.sync (uses Server.default.bind & AppClock).
";
        text.postln;
        ^text
    }

    *api {
        var api;
        api = IdentityDictionary[
            \ctor      -> "LivePedalboardSystem.new(treePathOrNil)  // resolves JSON path if nil",
            \bringUp   -> "bringUpAll()  // full bring-up in safe order",
            \gui       -> "bringUpMagicDisplayGUI(), closeExistingMagicDisplayWindows()",
            \pedalboard-> "bringUpPedalboard(), shutdownAll()",
            \command   -> "bringUpCommandSystem()",
            \audio     -> "ensureAudioOn(), ensureMeterDefs(), ensureServerReady(), tryPlayNdefs([...])",
            \status    -> "showStatus()",
            \jsonPath  -> "init(treePath) stores -> this.treeFilePath"
        ];
        api.postln;
        ^api
    }

    *test {
        var lps;
        lps = LivePedalboardSystem.new(nil);
        lps.bringUpAll;
        ^lps
    }



	//----
	// integrated 20251006:
	    autoBindLPDisplayIfPresent {
        var controller, cm, adapter;

        // 1) require the LPDisplay controller from your bring-up block
        controller = ~guiLP;
        if(controller.isNil) { ^this };  // nothing to bind yet

        // 2) resolve the real CM via your accessor (ivar-first, then pedalboard.*)
        cm = this.commandManager;
        if(cm.isNil) { ^this };

        // 3) reuse existing adapter if available; else create a new one
        adapter = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(controller) });
        ~lp_adapter = adapter;

        // 4) bind once and refresh panes
        cm.display = adapter;
        cm.updateDisplay;

        // 5) optional durable note
        (~md_log.notNil).if({ ~md_log.("System-side auto-bind OK (LPDisplayAdapter)") });

        ^this
    }

    // optional wrapper: full bring-up then auto-bind
    bringUpAllWithLPDisplayAutoBind {
        var selfRef;
        selfRef = this.bringUpAll;
        this.autoBindLPDisplayIfPresent;
        ^selfRef
    }
	//----

/*	    commandManager {
        var cmLocal, pb, candidates, found;

        // 1) Prefer the real ivar on this object (NOTE: do NOT write 'this.commandManager' here)
        cmLocal = commandManager;  // ivar access
        if(cmLocal.notNil and: { cmLocal.respondsTo(\updateDisplay) and: { cmLocal.respondsTo(\builder) } }) {
            ^cmLocal
        };

        // 2) Fallback: probe under pedalboard.* with common names
        pb = this.tryPerform(\pedalboard);
        if(pb.notNil) {
            candidates = [\commandManager, \cmdManager, \cm, \manager, \commandCenter, \commandCentre];
            found = candidates.detect({ arg sel;
                var cand = pb.tryPerform(sel);
                cand.notNil and: { cand.respondsTo(\updateDisplay) and: { cand.respondsTo(\builder) } }
            });
            if(found.notNil) { ^pb.perform(found) };
        };

        ^nil
    }

    cmdManager { ^this.commandManager }
    cm         { ^this.commandManager }
    manager    { ^this.commandManager }*/
	//---

}