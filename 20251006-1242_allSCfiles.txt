===== CommandTree/CircularSaves.sc =====
// circularSaves.sc
// v1.2.1
// MD 20250819

// This allows me to save the last ten trees in a folder, and keep track of the last one. Versions are named after date/time.


CircularFileSave {
	var <>prefix, <>folderPath, <>maxVersions, <fileList;

/*    *new { |prefix = "myTree", folderPath = "~/TreeSaves", maxVersions = 10|
        ^super.new.init(prefix, folderPath, maxVersions);
    }*/

	*new { |prefix = "myTree", folderPath, maxVersions = 10|
		var userStateFolder;

		userStateFolder = (Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/TreeSaves").standardizePath;

		folderPath = (folderPath ? userStateFolder).standardizePath;
		super.new.init(prefix, folderPath, maxVersions)
	}


	init { |prefix, folderPath, maxVersions|
		this.prefix = prefix;
		this.folderPath = folderPath.standardizePath;
		this.maxVersions = maxVersions;
		this.ensureFolderExists;
		this.refreshFileList;
	}

	ensureFolderExists {
		File.mkdir(folderPath);
	}

/*    refreshFileList {
        fileList = PathName(folderPath).entries.select { |f|
            f.fileName.beginsWith(prefix ++ "-") and: { f.fileName.endsWith(".json") }
        };
    }*/

	// 20250922
/*	refreshFileList {
		var pn, entries;
		pn = PathName(folderPath.standardizePath);
		if (pn.isFolder.not) { File.mkdir(pn.fullPath) };

		entries = pn.entries
		.select(_.isFile)
		.select({ |p| p.fileName.beginsWith(prefix) and: { p.fileName.endsWith(".json") } });

		// robust boolean comparator; no key-function; no .at on PathName
		entries = entries.asArray.sort({ |a, b| a.fileName > b.fileName });

		fileList = entries; // keep PathName objects; callers can use .fullPath / .fileName
		^this
	}*/
// 20250924
	refreshFileList {
    var pathNameRef, entries;

    pathNameRef = PathName(folderPath.standardizePath);
    if (pathNameRef.isFolder.not) { File.mkdir(pathNameRef.fullPath) };

    entries = pathNameRef.entries
        .select({ arg entry; entry.isFile })
        .select({ arg pn; pn.fileName.beginsWith(prefix) and: { pn.fileName.endsWith(".json") } });

    // newest-first assuming timestamped filenames
    entries = entries.asArray.sort({ arg a, b; a.fileName > b.fileName });

    fileList = entries;
    this
}


	saveVersion { |content|
		var timestamp = Date.getDate.stamp;
		var filename = "%-%".format(prefix, timestamp) ++ ".json";
		var path = folderPath +/+ filename;

		File.use(path, "w", { |f| f.write(content) });

		fileList.addFirst(PathName(path));

		if(fileList.size > maxVersions) {
			var toDelete = fileList.copyRange(maxVersions, fileList.size - 1);
			toDelete.do(_.delete);
			fileList = fileList.copyRange(0, maxVersions - 1);
		};

		path.postln;
	}

	listVersions {
		fileList.collect(_.fileName).do(_.postln);
	}

	loadVersion { |index|
		var file, content;

		if(index >= fileList.size or: { index < 0 }) {
			"Invalid index: % (available: 0 to %)".format(index, fileList.size - 1).warn;
			^nil;
		};

		file = fileList[index];
		if(file.isNil) {
			"No file found at index %".format(index).warn;
			^nil;
		};

		File.use(file.fullPath, "r", { |f|
			content = f.readAllString;
		});
		^content;
	}

	latestVersion {
		^this.loadVersion(0);
	}
}


===== CommandTree/CommandManager.sc =====
// CommandManager.sc
// v1.6
// MD 20250921-22:40

// Purpose: Central controller; uses injected display (MagicDisplayGUI), does NOT create windows.
// Style: var-first, AppClock.defer for UI, no server.sync. Tree path is configurable in *new/init.

CommandManager {
	var <>currentState;
	var <>tree;
	var <>builder;
	var <>queue;
	var <>display, <>displayText;
	var <>filePath;
	var <>midiManager;
	var <>parentCommandManager;
	var <>saver;
	var <>queueExportCallback;

	var launchpadHandlerRef, footHandlerRef, guitarHandlerRef, dawHandlerRef;

	var <>launchpadID, <>footControllerID, <>guitarID;

	*new { arg treePath;
		^super.new.init(treePath);
	}


	init { arg treePath;
		var defaultPath, savedPath, stateDir, stateFile;
		var explicitOk, savedOk;

		currentState = \idle;
		// saver = CircularFileSave.new("myTree", "~/CommandTreeSavefiles", 10);
		saver = CircularFileSave.new("myTree", nil, 10);
// or simply: saver = CircularFileSave.new("myTree");


		stateDir  = Platform.userExtensionDir ++ "/LivePedalboardSuite/.state";
		stateFile = stateDir ++ "/LastCommandTreePath.txt";

		defaultPath = Platform.userExtensionDir
		++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

		savedPath = this.readLastPath(stateFile); // <- empty/whitespace -> nil

		explicitOk = treePath.isString and: { treePath.size > 0 };
		savedOk    = savedPath.isString and: { savedPath.size > 0 } and: { File.exists(savedPath) };

		filePath = if (explicitOk) { treePath } { if (savedOk) { savedPath } { defaultPath } };

		if (filePath.isString and: { filePath.size > 0 }) {
			this.writeLastPath(stateDir, stateFile, filePath);
		};

		this.createNewTree;        // will harden path again inside
		this.createBuilder;
		this.createCommandQueue;

		// midiManager = MIDIInputManager.new(builder, nil, nil, nil);
		midiManager = MIDIInputManager.new(builder, nil, nil, nil, nil);

		midiManager.parentCommandManager = this;


		^this
	}



	// --- Build pieces --------------------------------------------------------

	createNewTree {
		var usePath;
		// final guard before import: ensure a usable String path
		usePath = filePath;
		if (usePath.isString.not or: { usePath.size <= 0 }) {
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};
		if (File.exists(usePath).not) {
			// last resort: keep going with default even if missing (import will warn gracefully)
			usePath = Platform.userExtensionDir
			++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
		};

		tree = MDCommandTree.new("root");
		tree.importJSONFile(usePath);

		if (tree.notNil) {
			"📥 Tree imported from ".post; usePath.postln;
		}{
			"📥 Couldn't create/import tree.".postln;
		};
		^this
	}

	createBuilder {
		builder = MDCommandBuilder.new(tree);
		if (builder.notNil) {
			if (true) { "🔮 Builder created".postln };
		}{
			"🔮 Couldn't create builder".postln;
		}
	}

	createCommandQueue {
		queue = MDCommandQueue.new;
		if (queue.notNil) {
			if (true) { "📦 Queue created".postln };
		}{
			"📦 Couldn't create queue".postln;
		}
	}

	// --- Display passthrough -------------------------------------------------

	setStatus { arg text;
		// If a MagicDisplayGUI is injected, use showExpectation (no updateStatus in that class)
		if (display.notNil and: { display.respondsTo(\showExpectation) }) {
			display.showExpectation(text, 0);
		}{
			("Status: " ++ text).postln;
		}
	}

	// Optional hot-reload from a new path
	reloadTreeFromPath { arg path;
		if (path.notNil) { filePath = path; };
		this.createNewTree;
		builder = MDCommandBuilder.new(tree);
		this.setStatus("✅ Tree reloaded from: " ++ filePath);
	}

	// --- tiny helpers (inside the same class) ---

	writeLastPath { arg dirPath, filePath, pathToWrite;
		var okDir;
		// guard: do nothing if not a non-empty String
		if (pathToWrite.isString.not or: { pathToWrite.size <= 0 }) { ^this };

		okDir = PathName(dirPath).isFolder;
		if (okDir.not) { File.mkdir(dirPath) };

		File.use(filePath, "w", { |fh| fh.write(pathToWrite) });
		^this
	}

	readLastPath { arg filePath;
		var content, cleaned, hasNonSpace;
		if (File.exists(filePath)) {
			File.use(filePath, "r", { |fh| content = fh.readAllString });
			// collapse whitespace-only to nil
			cleaned = content ? "";
			hasNonSpace = false;
			cleaned.do { |ch|
				if ((ch != $\ ) and: { ch != $\t } and: { ch != $\n } and: { ch != $\r }) {
					hasNonSpace = true;
				}
			};
			if (hasNonSpace.not) { content = nil };
		};
		^content
	}


/*	updateDisplay {
		var guiRef, modeText, choiceLines;

		guiRef = display;   // may be nil
		if (guiRef.isNil) { ^this };

		modeText = "Mode: " ++ (currentState ? \idle).asString;

		// build "fret X → Name" lines from the builder's current node
		choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
			builder.currentNode.children.collect({ |ch|
				("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString)
			})
		} { [] };

		{
			if (guiRef.respondsTo(\showExpectation)) {
				guiRef.showExpectation(modeText, 0);
			};
			if (guiRef.respondsTo(\updateTextField)) {
				guiRef.updateTextField(\state, modeText);
				guiRef.updateTextField(\choices, choiceLines.join("\n"));
			};
			// NEW: update choices panel in MagicDisplayGUI if present
			if (guiRef.respondsTo(\setOperations)) {
				guiRef.setOperations(choiceLines);
			};
		}.defer;

		^this
	}*/

// updated 20250924-1209
	updateDisplay {
    var guiRef, modeText, choiceLines;
    guiRef = display; // may be nil
    if (guiRef.isNil) { ^this };
    modeText = "Mode: " ++ (currentState ? \idle).asString;

    // build "fret X → Name" lines from the builder's current node
    choiceLines = if (builder.notNil and: { builder.currentNode.notNil }) {
        builder.currentNode.children.collect({ arg ch;
            ("fret " ++ ch.fret.asString ++ " → " ++ ch.name.asString)
        })
    } { [] };

    {
        if (guiRef.respondsTo(\showExpectation)) {
            guiRef.showExpectation(modeText, 0);
        };
        if (guiRef.respondsTo(\updateTextField)) {
            guiRef.updateTextField(\state, modeText);
            guiRef.updateTextField(\choices, choiceLines.join("\n"));
        };
        if (guiRef.respondsTo(\setOperations)) {
            guiRef.setOperations(choiceLines);
        };
    }.defer;
    ^this
}

}

// Back-compat alias
MDCommandMC : CommandManager {}

===== CommandTree/Logging/MDLogFacade.sc =====
// MDLogFacade
// v1.0.0
// MD 2025-09-22 09:52 BST

/*
Purpose
- See file comments for details.
Style
- var-first; lowercase methods; no server.sync; class extensions only.
*/


// Minimal logging facade so any object can call: this.mdlog(level, label, message)
+ Object {
    mdlog { |level = 2, label = "GENERIC", message = ""|
        var logger = MDMiniLogger.get;
        switch(level,
            0, { logger.error(label, message) },
            1, { logger.warn(label, message) },
            2, { logger.info(label, message) },
            3, { logger.debug(label, message) },
            4, { logger.trace(label, message) }
        );
        ^this
    }
}

===== CommandTree/MDCommandBuilder.sc =====
// MDCommandBuilder.sc
// v0.2
// MD 20250924-1008

/*
Purpose
- Fold mdlog instrumentation into the base class (Option A).
- Keep existing console messages; add small legacy shims so old tests keep working.
Style
- var-first; descriptive variable names; no single-letter locals; lowercase; no server.sync.
- Minimal changes; preserve your current behavior.
*/

MDCommandBuilder {
    var <>tree, <>currentNode, <>currentCommand, <>fretPath;
    var <>navigationComplete = false;

    *new { arg argTree;  ^super.new.init(argTree); }

    init { arg argTree;
        tree = argTree;
        currentNode = tree.root;
        fretPath = List[0];
        "CommandBuilder initialized".postln;
        ^this
    }

/*    printChildren {
        var childrenNames;

        if (currentNode.children.notEmpty) {
            currentNode.children.do({ arg childItem;
                ("🎚️ Fret: " ++ childItem.fret ++ " → " ++ childItem.name).postln;
            });
            childrenNames = currentNode.children.collect({ arg childItem; childItem.name });
            this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
        } {
            "⚠️ No children".postln;
            this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
        };
        ^childrenNames
    }*/

/*    navigateByFret { arg stringLevel, fretNumber;
        var nextNode;

        this.mdlog(2, "CommandBuilder",
            "🎸 navigateByFret fret=" ++ fretNumber ++ " stringLevel=" ++ stringLevel);

        ("🎸 Navigating by fret: " ++ fretNumber).postln;
        nextNode = currentNode.getChildByFret(fretNumber);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
        } {
            ("⚠️ No child found for fret: " ++ fretNumber).postln;
            this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
        };
        ^currentNode
    }*/

/*    navigateByName { arg stringLevel, childName;
        var nextNode;

        nextNode = currentNode.getChildByName(childName);

        if (nextNode.notNil) {
            currentNode = nextNode;
            fretPath.add(currentNode.fret);
            ("Current node: " ++ currentNode.name).postln;
            ("Path: " ++ currentNode.getFullPathString).postln;
            this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
            this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
        } {
            var availableNames;
            availableNames = currentNode.children.collect({ arg childItem; childItem.name }).join(", ");
            ("⚠️ Available children: " ++ availableNames).postln;
            this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
        };
        ^currentNode
    }*/

/*    printPathToRoot {
        currentNode.getPathToRoot.postln;
        this.mdlog(3, "CommandBuilder", "📍 path=" ++ currentNode.getPathToRoot);
        ^this
    }*/

/*    getCurrentName {
        currentNode.name.postln;
        this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
        ^currentNode.name
    }*/

/*    getCurrentPayload {
        ("Current payload: " ++ currentNode.payload).postln;
        this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
        ^currentNode.payload
    }*/

    isAtLeaf {
        ^currentNode.children.isEmpty
    }

/*    resetNavigation {
        currentNode = tree.root;
        fretPath = List[0];
        navigationComplete = false;  // important; reset the flag
        "🔄 Navigation reset".postln;
        this.mdlog(2, "CommandBuilder", "navigation reset");
        ^this
    }*/

//superseded
/*    printfretPath {
        ("Fret path: " ++ fretPath).postln;
        this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
        ^this
    }*/

    // ---- Legacy shims (keep old tests working) ----

    // Old: listChildren -> New: printChildren
    listChildren {
        ^this.printChildren
    }

    // Old: navigateToChild(fret) OR navigateToChild(string, fret)
    navigateToChild { arg legacyArgA, legacyArgB = nil;
        var stringLevel, fretNumber;

        if (legacyArgB.isNil) {
            stringLevel = nil;
            fretNumber  = legacyArgA;
        }{
            stringLevel = legacyArgA;
            fretNumber  = legacyArgB;
        };

        ^this.navigateByFret(stringLevel, fretNumber)
    }

    // Old: printCurrentPath -> New: printPathToRoot
    printCurrentPath {
        ^this.printPathToRoot
    }

    // Old: getCurrentCommand -> New: getCurrentPayload
    getCurrentCommand {
        ^this.getCurrentPayload
    }

    // Old: reset -> New: resetNavigation
    reset {
        ^this.resetNavigation
    }

	// newer 20250924 ------
	printChildren {
    var childrenNames;

    if (currentNode.children.notEmpty) {
      currentNode.children.do({ arg item;
        // existing console output
        ("🎚️ Fret: " ++ item.fret ++ " → " ++ item.name).postln;
      });
      childrenNames = currentNode.children.collect(_.name);
      this.mdlog(3, "CommandBuilder", "children=" ++ childrenNames);
    } {
      "⚠️ No children".postln;
      this.mdlog(1, "CommandBuilder", "no children at node=" ++ currentNode.name);
    };
    ^childrenNames
  }

  navigateByFret { arg stringLevel, fretNumber;
    var nextNode;

    this.mdlog(2, "CommandBuilder", "🎸 navigateByFret: " ++ fretNumber
      ++ " (stringLevel=" ++ stringLevel ++ ")");

    nextNode = currentNode.getChildByFret(fretNumber);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
    } {
      ("⚠️ No child found for fret: " ++ fretNumber).postln;
      this.mdlog(1, "CommandBuilder", "no child for fret=" ++ fretNumber);
    };
    ^currentNode
  }

  navigateByName { arg stringLevel, childName;
    var nextNode;

    nextNode = currentNode.getChildByName(childName);

    if (nextNode.notNil) {
      currentNode = nextNode;
      fretPath.add(currentNode.fret);
      ("Current node: " ++ currentNode.name).postln;
      ("Path: " ++ currentNode.getFullPathString).postln;
      this.mdlog(2, "CommandBuilder", "current=" ++ currentNode.name);
      this.mdlog(3, "CommandBuilder", "path=" ++ currentNode.getFullPathString);
    } {
      var availableNames;
      availableNames = currentNode.children.collect(_.name).join(", ");
      ("⚠️ Available children: " ++ availableNames).postln;
      this.mdlog(1, "CommandBuilder", "not found; available=" ++ availableNames);
    };
    ^currentNode
  }

  printPathToRoot {
    currentNode.getPathToRoot.postln;
    this.mdlog(3, "CommandBuilder", "📍 path=" ++ currentNode.getPathToRoot);
    ^this
  }

  getCurrentName {
    currentNode.name.postln;
    this.mdlog(3, "CommandBuilder", "currentName=" ++ currentNode.name);
    ^currentNode.name
  }

  getCurrentPayload {
    ("Current payload: " ++ currentNode.payload).postln;
    this.mdlog(3, "CommandBuilder", "payload=" ++ currentNode.payload);
    ^currentNode.payload
  }

  resetNavigation {
    currentNode = tree.root;
    fretPath = List[0];
    navigationComplete = false;
    "🔄 Navigation reset".postln;
    this.mdlog(2, "CommandBuilder", "navigation reset");
    ^this
  }

  printfretPath {
    ("Fret path: " ++ fretPath).postln;
    this.mdlog(3, "CommandBuilder", "fretPath=" ++ fretPath);
    ^this
  }



}

===== CommandTree/MDCommandNode_FixIntegrity+DepthTag.sc =====
// MDCommandNode_FixIntegrity+DepthTag.sc
// v1.0 — 2025-09-21 MD

// Purpose
// - Accept SortedList in checkIntegrity.
// - Add tagByDepth(depth) used by MDCommandTree.tagDepths.
// Style
// - var-first; lowercase; no server.sync.

+ MDCommandNode {
    // Accept List OR SortedList
    checkIntegrity {
        var failedChild;
        if( (this.children.isKindOf(List).not) && (this.children.isKindOf(SortedList).not) ) {
            ("❌ Integrity check failed at node '" ++ this.name ++ "': children is " ++ children.class).postln;
            ^false;
        };
        failedChild = this.children.detect { |c| c.checkIntegrity.not };
        if(failedChild.notNil) {
            ("❌ Integrity failed in child: " ++ failedChild.name).postln;
            ^false;
        };
        ^true
    }

    // annotate nodes with a 'depth' entry in payload (non-destructive)
    tagByDepth { |depth|
        var nextDepth = (depth ? 0).asInteger.max(0);
        // if payload is nil or a String, wrap in a simple Event to attach depth safely
        if(this.payload.isNil or: { this.payload.isKindOf(String) }) {
            this.payload = (name: this.name, depth: nextDepth);
        }{
            // if payload is e.g., an Event/Dict, set depth if slot exists
            this.payload.put(\depth, nextDepth);
        };
        this.children.do { |child| child.tagByDepth(nextDepth + 1) };
        ^this
    }
}

===== CommandTree/MDCommandNode.sc =====
// MDCommandNode.sc
// v1.0.1
// MD 20250924

MDCommandNode {
	var <>name, <>id, <>fret, <>parent, <>children;
	var <> payload; // the "command" that will be inserted in the tree


	*new { |name = "default", id = 1, fret = 1, parent = nil|
		^super.new.init(name, id, fret, parent);
	}

	init { |name, id, fret, parent = nil|
		this.name = name;
		this.id = id;
		this.fret = fret;
		this.parent = parent;
		//this.children = List.new; // updated to following:
		this.children = SortedList.new(nil, { |a, b| a.fret < b.fret });

		//if (children.isKindOf(List).not) updated to following:
		if (this.children.isKindOf(SortedList).not) {
			{
				("⚠️ Children is not a SortedList in node '" ++ name ++ "'! It is: " ++ children.class).postln;
			};

			^this
		}
	}

	// ───── Child Management ─────

/*	removeChildByName { |nameToRemove|
		var index = children.findIndex { |c| c.name == nameToRemove };
		if (index.notNil) { children.removeAt(index); }
	}*/


	// ───── Child Lookup ─────

/*	getChildByName { |name|
		if (name.isKindOf(String).not) {
			("❌ getChildByName error: name must be a String").warn;
			^nil;
		};
		^children.detect { |c| c.name == name }
	}*/

	//getChildById { |id| ^children.detect { |c| c.id == id } }

	// getChildByFret { |fret| ^children.detect { |c| c.fret == fret } }

	childNameExists { |name| ^children.any { |c| c.name == name } }

	// ───── Tree Navigation ─────

	getPathToRoot {
		var path = List.new;
		var current = this;
		while { current.notNil } {
			path.addFirst(current.name);
			current = current.parent;
		};
		^path
	}

	printPathToRoot {
		("📍 Path: " ++ this.getPathToRoot.join(" → ")).postln;
	}

/*	getNodeByNamePath { |nameList|
		var current = this;
		nameList.do { |name|
			current = current.getChildByName(name);
			if (current.isNil) {
				("❌ Node not found at path segment: " ++ name).postln;
				^nil;
			}
		};
		("✅ Found node: " ++ current.name).postln;
		^current
	}*/

	getDepth {
		^this.parent.notNil.if({ this.parent.getDepth + 1 }, { 0 })
	}

	// ───── Tree Analysis ─────

	isLeaf {
		^this.children.size == 0
	}


	hasChild { |node|
		^this.children.any { |c| c === node }
	}
	countDescendants {
		if (this.isLeaf) { ^1 } {
			^this.children.sum { |c| c.countDescendants }
		}
	}

	countLeavesOnly {
		^this.isLeaf.if({ 1 }, {
			this.children.sum { |c| c.countLeavesOnly }
		})
	}

	getFullPathString {
		^this.getPathToRoot.join(" → ");
	}

	//newer:
	checkIntegrity {
		var okType, failedChild;
		okType = this.children.isKindOf(List) or: { this.children.isKindOf(SortedList) };
		if(okType.not) {
			("❌ Integrity check failed at node '" ++ this.name
				++ "': children is " ++ children.class).postln;
			^false;
		};
		failedChild = this.children.detect { |c| c.checkIntegrity.not };
		if(failedChild.notNil) {
			("❌ Integrity failed in child: " ++ failedChild.name).postln;
			^false;
		};
		^true;
	}

	// ───── Tree Display ─────
/*	printTreePretty { |level = 0, isLast = true, prefix = ""|
		var sortedChildren, connector, newPrefix;

		// Print current node
		connector = if (level == 0) { "" } { if (isLast) { "└── " } { "├── " } };
		(prefix ++ connector ++ this.name ++
			" (fret: " ++ this.fret ++
			", id: " ++ this.id ++
			", payload: " ++ this.payload ++ ")").postln;

		// Prepare prefix for children
		newPrefix = if (level == 0) { "" } {
			prefix ++ if (isLast) { "    " } { "│   " }
		};

		// Use existing sortedChildren logic
		sortedChildren = this.children;

		// Recursively print children
		sortedChildren.do { |child, i|
			var last = (i == (sortedChildren.size - 1));
			child.printTreePretty(level + 1, last, newPrefix);
		};
	}*/

	printTreePretty { |level = 0, isLast = true, prefix = ""|
    var childList, connector, nextPrefix;

    connector = if (level == 0) { "" } { if (isLast) { "└── " } { "├── " } };
    (prefix ++ connector ++ this.name
        ++ " (fret: " ++ this.fret
        ++ ", id: " ++ this.id
        ++ ", payload: " ++ this.payload ++ ")").postln;

    nextPrefix = if (level == 0) { "" } { prefix ++ if (isLast) { "    " } { "│   " } };
    childList = this.children;

    childList.do({ arg child, index;
        var lastFlag;
        lastFlag = (index == (childList.size - 1));
        child.printTreePretty(level + 1, lastFlag, nextPrefix);
    });

    this
}


	// ───── Serialization for exporting ─────

	asDictRecursively {
		var childrenDicts;

		childrenDicts = this.children.collect({ arg childNode;
			childNode.asDictRecursively
		});

		^(
			id:       this.id,
			name:     this.name,
			fret:     this.fret,
			payload:  this.payload,    // ← Added: keep payload in exports
			children: childrenDicts
		)
	}

	addChild { arg child;
		if (child.isKindOf(MDCommandNode)) {
			child.parent = this;
			children.add(child);
			this.mdlog(2, "CommandNode", "➕ added child '" ++ child.name
				++ "' under '" ++ name ++ "'");
		} {
			"⚠️ Attempted to add a non-node child.".warn;
			this.mdlog(1, "CommandNode", "attempted to add non-node child");
		}
	}

	createChild { arg name, id, fret;
		var child;

		if (name.isKindOf(String).not or: { id.isKindOf(Integer).not } or: { fret.isKindOf(Integer).not }) {
			"❌ Invalid arguments for createChild".warn;
			this.mdlog(1, "CommandNode", "invalid args for createChild");
			^nil;
		};

		child = this.getChildByName(name);

		if (child.isNil) {
			child = MDCommandNode.new(name, id, fret);
			this.addChild(child);
			("✅ Created new child node: " ++ name
				++ " (ID: " ++ id ++ ", Fret: " ++ fret ++ ")").postln;
			this.mdlog(2, "CommandNode", "created '" ++ name
				++ "' (id:" ++ id ++ " fret:" ++ fret ++ ")");
		} {
			("ℹ️ Child node already exists: " ++ name).postln;
			this.mdlog(2, "CommandNode", "child already exists: " ++ name);
		};

		^child
	}

	removeChildById { arg idToRemove;
		var childToRemove;

		childToRemove = children.detect({ arg nodeRef; nodeRef.id == idToRemove });

		if (childToRemove.notNil) {
			children.remove(childToRemove);
			"🗑 Child removed".postln;
			this.mdlog(2, "CommandNode", "removed id=" ++ idToRemove);
		} {
			"⚠️ ID not found".postln;
			this.mdlog(1, "CommandNode", "id not found: " ++ idToRemove);
		}
	}






	removeChildByName { |nameToRemove|
		var index;

		index = children.findIndex({ arg c; c.name == nameToRemove });
		if (index.notNil) { children.removeAt(index) };
		this
	}

	getChildByName { |name|
		var result;

		if (name.isKindOf(String).not) {
			"❌ getChildByName error: name must be a String".warn;
			result = nil;
		} {
			result = children.detect({ arg c; c.name == name });
		};
		result
	}

	getChildById { |id|
		var result;
		result = children.detect({ arg c; c.id == id });
		result
	}

	getChildByFret { |fret|
		var result;
		result = children.detect({ arg c; c.fret == fret });
		result
	}

	getNodeByNamePath { |nameList|
		var current, ok;

		current = this;
		ok = true;

		nameList.do({ arg segmentName;
			var nextNode;
			nextNode = current.getChildByName(segmentName);
			if (nextNode.isNil) {
				"❌ Node not found at path segment: ".post; segmentName.postln;
				ok = false;
			} {
				current = nextNode;
			};
		});

		if (ok) {
			("✅ Found node: " ++ current.name).postln;
			current
		} {
			nil
		}
	}
}
===== CommandTree/MDCommandQueue_Compat_AddAlias.sc =====
// CommandTree/MDCommandQueue_Compat_AddAlias.sc
// v1.0.1
// MD 20250924-1249
/*
Purpose:
- Keep older tests working: addCommand -> enqueueCommand.
*/

+ MDCommandQueue {
    addCommand { |command|
        var result;
        result = this.enqueueCommand(command);
        result
    }
}

===== CommandTree/MDCommandQueue.sc =====
// MDCommandQueue.sc
// Refactored for clarity and consistency
// MD 20250818



MDCommandQueue {
    var <>commandList;

    *new { ^super.new.init(); }

    init {
        commandList = List.new(8);
        Verbosity.postIf(1, "✅ CommandQueue initialized");
        ^this
    }

    enqueueCommand { |command|
        commandList.add(command);
        Verbosity.postIf(1, "📥 Command added: " ++ command);
        Verbosity.postIf(2, "📦 Current queue: " ++ commandList);
        ^commandList
    }

    dequeueLastCommand {
        if (commandList.notEmpty) {
            commandList.removeAt(commandList.size - 1);
            Verbosity.postIf(1, "🗑 Last command removed");
        } {
            Verbosity.postIf(0, "⚠ No command to remove");
        };
        ^commandList
    }

    clearQueue {
        commandList.clear;
        Verbosity.postIf(1, "🧹 Queue cleared");
        ^this
    }

    exportAsOSCPath {
        var oscPath;

        oscPath = "/" ++ commandList.collect { |cmd|
            cmd.asString;
        }.join("/");

        ~commandToSend = oscPath;
        Verbosity.postIf(2, "🚀 Exported OSC path: " ++ oscPath);
        ^oscPath
    }
}

// MDCommandQueue {
// 	var <>commandList;
//
// 	*new { ^super.new.init(); }
//
// 	init {
// 		commandList = List.new(8);
// 		"CommandQueue initialized".postln;
// 		^this
// 	}
//
// 	enqueueCommand { |command|
// 		commandList.add(command);
// 		("Command added: " ++ command).postln;
// 		("Current queue: " ++ commandList).postln;
// 		^commandList
// 	}
//
// 	dequeueLastCommand {
// 		if (commandList.notEmpty) {
// 			commandList.removeAt(commandList.size - 1);
// 			"Last command removed".postln;
// 		} {
// 			"⚠No command to remove".postln;
// 		};
// 		^commandList
// 	}
//
// 	clearQueue {
// 		commandList.clear;
// 		"🧹 Queue cleared".postln;
// 		^this
// 	}
//
//
// 	exportAsOSCPath {
// 		var oscPath;
//
// 		oscPath = "/" ++ commandList.collect { |cmd|
// 			cmd.asString;
// 		}.join("/");
//
// 		~commandToSend = oscPath;
// 		("Exported OSC path: " ++ oscPath).postln;
// 		^oscPath
// 	}
// }
===== CommandTree/MDCommandTree.sc =====
// MDCommandTree.sc
// v1.0.1
// MD 20250924-1230

MDCommandTree {
	var <>root, <>nodeLimit = 200, <>nodeCount = 0, <>nodeMap;
	var <>saver;

	*new { |rootName = "root", rootId = 0, nodeLimit|
		^super.new.init(rootName, rootId, nodeLimit);
	}


/*	*fromDict { |dict|
		var tree;

		// Use a default node limit, or extract from dict if available
		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ?? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				tree.rebuildTreeFromDict(childDict, tree.root);
			};
		};
		tree.root.payload = dict[\payload];

		^tree;
	}*/

	*fromDict { |dict|
		var tree;

		tree = MDCommandTree.new(dict[\name], dict[\id], dict[\nodeLimit] ? 200);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do({ arg childDict;
				tree.rebuildTreeFromDict(childDict, tree.root);
			});
		};

		tree.root.payload = dict[\payload];
		tree
	}

	init { |rootName, rootId, limit|
		root = MDCommandNode.new(rootName, rootId);
		nodeLimit = limit;
		nodeCount = 1;

		nodeMap = IdentityDictionary.new(100);
		nodeMap.put(rootId, root);

		saver = CircularFileSave.new("myTree", "~/TreeSaves", 10); // this is what will manage saves

		^this
	}

	rebuildTreeFromDict { |dict, parent|
		var node;

		node = MDCommandNode.new(dict[\name], dict[\id], dict[\fret]);
		parent.addChild(node);

		nodeMap.put(node.id, node);
		nodeCount = node.id.max(nodeCount);

		if (dict[\children].isKindOf(Array)) {
			dict[\children].do { |childDict|
				this.rebuildTreeFromDict(childDict, node);
			};
		};

		node.payload = dict[\payload];

		^node;
	}

/*	printTreePretty {
		root.printTreePretty;
		^this;
	}*/

	tagDepths {
		root.tagByDepth(0);
		^this;
	}

/*	findNodeByName { |name|
		var found;
		found = nodeMap.values.detect { |node| node.name == name };
		if (found.notNil) {
			("🔍 Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			^found
		} {
			"⚠️ Node not found".postln;
			^nil
		}
	}*/

/*	getNodeByNamePath { |nameList|
		var found;
		found = root.getNodeByNamePath(nameList);
		if (found.notNil) {
			^found
		} {
			("⚠️ Node not found at path: " ++ nameList.join(" → ")).postln;
			^nil
		}
	}*/

	addNode { |parentId, name, fret|
		var newId, parentNode, newNode;

		newId = nodeCount + 1;
		parentNode = nodeMap.at(parentId);

		if (parentNode.notNil) {
			nodeCount = newId;
			newNode = MDCommandNode.new(name, newId, fret);
			newNode.parent = parentNode;
			parentNode.addChild(newNode);
			nodeMap.put(newId, newNode);
			^newNode
		} {
			("⚠️ Invalid parent ID: " ++ parentId).postln;
			^nil
		}
	}

	removeNode { |nodeId|
		var nodeToRemove, parentNode, found;

		nodeToRemove = nodeMap.at(nodeId);
		parentNode = nodeToRemove.parent;

		if (parentNode.notNil) {
			found = parentNode.children.detect { |c| c === nodeToRemove };
			if (found.notNil) {
				parentNode.removeChildById(found.id);
				nodeMap.removeAt(nodeId);
				("🗑 Node " ++ nodeId ++ " removed.").postln;
				^nodeToRemove
			} {
				"⚠️ Node not found in parent's children".postln;
				^nil
			}
		} {
			"⚠️ Cannot remove root node".postln;
			^nil
		}
	}

	swapNodes { |nodeId1, nodeId2|
		var node1, node2, parent1, parent2;

		node1 = nodeMap.at(nodeId1);
		node2 = nodeMap.at(nodeId2);
		parent1 = node1.parent;
		parent2 = node2.parent;

		if (parent1.isNil or: { parent2.isNil }) {
			"⚠️ Both nodes must have parents to swap".postln;
			^nil
		};

		node1 = removeNode(nodeId1);
		node2 = removeNode(nodeId2);

		if (node1.isNil or: { node2.isNil }) {
			"⚠️ Failed to remove nodes for swapping".postln;
			^nil
		};

		parent1.addChild(node2);
		parent2.addChild(node1);

		"🔄 Nodes swapped".postln;
		^nil
	}

/*	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("📤 Tree exported to " ++ path).postln;
		} {
			"⚠️ Failed to open file for writing.".warn;
		}
	}*/

	// importJSONFile { |path|
	// 	var jsonString, dict, newTree;
	//
	// 	if (File.exists(path).not) {
	// 		"❌ File does not exist: %".format(path).postln;
	// 		^false;
	// 	};
	//
	// 	jsonString = File(path, "r").readAllString;
	//
	// 	if (jsonString.isNil or: { jsonString.isEmpty }) {
	// 		"⚠️ File is empty or unreadable.".postln;
	// 		^false;
	// 	};
	//
	// 	dict = JSONlib.convertToSC(jsonString);
	//
	// 	if (dict.isNil) {
	// 		"⚠️ Failed to parse JSON.".postln;
	// 		^false;
	// 	};
	//
	// 	newTree = MDCommandTree.fromDict(dict);
	// 	this.root = newTree.root;
	// 	this.nodeMap = newTree.nodeMap;
	// 	this.nodeCount = newTree.nodeCount;
	//
	// 	("📥 Tree imported from " ++ path).postln;
	// 	^true;
	// }

	// NEW - added to manage circular saves
/*	saveVersioned {
		var json = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(json);
		"Tree saved to versioned file.".postln;
	}*/
	//---

	// NEW - added to manage circular saves
/*	loadLatestVersion {
		var json = saver.latestVersion;
		var dict, newTree;

		if(json.isNil or: { json.isEmpty }) {
			"⚠️ No saved version found.".postln;
			^false;
		};

		dict = JSONlib.convertToSC(json);

		if(dict.isNil) {
			"⚠️ Failed to parse JSON.".postln;
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root = newTree.root;
		this.nodeMap = newTree.nodeMap;
		this.nodeCount = newTree.nodeCount;

		"📥 Tree loaded from latest version.".postln;
		^true;
	}*/
	//---

	// NEW - added to manage circular saves
	listSavedVersions {
		saver.listVersions;
	}

	//---







	// THIS IS NEW. This is so that (for now) we can copy the name of the node into the payload instance variable.
	assignPayloads {
		var assignRecursively;

		assignRecursively = { |node|
			node.payload = node.name;
			node.children.do { |child|
				assignRecursively.(child);
			};
		};

		assignRecursively.(this.root);
		"🧠 Payloads assigned to all nodes in tree.".postln;
		^this;
	}

	printPayloads {
		var printRecursively;

		printRecursively = { |node, level = 0|
			var indent = "  " ! level;
			(indent.join ++ node.name ++ " → Payload: " ++ node.payload).postln;
			node.children.do { |child|
				printRecursively.(child, level + 1);
			};
		};

		printRecursively.(this.root);
		^this;
	}

	printTreePretty {
		root.printTreePretty;
		this.mdlog(3, "CommandTree", "pretty-print finished");
		^this;
	}

	exportJSONFile { |path|
		var jsonString, file;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		file = File(path, "w");

		if (file.isOpen) {
			file.write(jsonString);
			file.close;
			("📤 Tree exported to " ++ path).postln;
			this.mdlog(2, "CommandTree", "exported=" ++ path);
		} {
			"⚠️ Failed to open file for writing.".warn;
			this.mdlog(1, "CommandTree", "failed open for write: " ++ path);
		};
		^this
	}

/*	importJSONFile { |path|
		var jsonString, dict, newTree;

		if (File.exists(path).not) {
			("❌ File does not exist: %".format(path)).postln;
			this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
			^false;
		};

		jsonString = File(path, "r").readAllString;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"⚠️ File is empty or unreadable.".postln;
			this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"⚠️ Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		("📥 Tree imported from " ++ path).postln;
		this.mdlog(2, "CommandTree", "imported=" ++ path);
		^true;
	}*/

	importJSONFile { arg path;
    var jsonString, dict;

    // Basic I/O and parsing guards
    if (File.exists(path).not) {
        ("❌ File does not exist: %".format(path)).postln;
        this.mdlog(0, "CommandTree", "file does not exist: " ++ path);
        ^false;
    };

    jsonString = File(path, "r").readAllString;

    if (jsonString.isNil or: { jsonString.isEmpty }) {
        "⚠️ File is empty or unreadable.".postln;
        this.mdlog(1, "CommandTree", "empty/unreadable: " ++ path);
        ^false;
    };

    dict = JSONlib.convertToSC(jsonString);

    if (dict.isNil) {
        "⚠️ Failed to parse JSON.".postln;
        this.mdlog(0, "CommandTree", "failed to parse: " ++ path);
        ^false;
    };

    // ---- Build *this* tree in-place: reset containers first
    {
        var rootName, rootId, children;

        // tolerant root fields (work even if JSON doesn't carry name/id)
        rootName = dict[\name] ? "root";
        rootId   = (dict[\id] ? 0).asInteger;

        // fresh root + maps
        root = MDCommandNode.new(rootName.asString, rootId, 0);
        nodeMap = IdentityDictionary.new(128);
        nodeMap.put(rootId, root);
        nodeCount = rootId.max(1);

        // recursively build from children if present
        children = dict[\children];
        if (children.isKindOf(Array)) {
            children.do({ |childDict| this.rebuildTreeFromDict(childDict, root) });
        };

        // preserve payload at root if present
        root.payload = dict[\payload];

    }.value;

    ("📥 Tree imported from " ++ path).postln;
    this.mdlog(2, "CommandTree", "imported=" ++ path);
    ^true;
}



	saveVersioned {
		var jsonString;

		jsonString = JSONlib.convertToJSON(root.asDictRecursively);
		saver.saveVersion(jsonString);
		"Tree saved to versioned file.".postln;
		this.mdlog(2, "CommandTree", "versioned save complete");
	}

	loadLatestVersion {
		var jsonString, dict, newTree;

		jsonString = saver.latestVersion;

		if (jsonString.isNil or: { jsonString.isEmpty }) {
			"⚠️ No saved version found.".postln;
			this.mdlog(1, "CommandTree", "no saved version found");
			^false;
		};

		dict = JSONlib.convertToSC(jsonString);

		if (dict.isNil) {
			"⚠️ Failed to parse JSON.".postln;
			this.mdlog(0, "CommandTree", "failed to parse saved JSON");
			^false;
		};

		newTree = MDCommandTree.fromDict(dict);
		this.root     = newTree.root;
		this.nodeMap  = newTree.nodeMap;
		this.nodeCount= newTree.nodeCount;

		"📥 Tree loaded from latest version.".postln;
		this.mdlog(2, "CommandTree", "loaded latest version");
		^true;
	}

/*  validateTree {
    var seenNames, validFlag;

    seenNames = Set.new;
    validFlag = true;

    nodeMap.values.do({ |nodeRef|
      if (seenNames.includes(nodeRef.name)) {
        ("⚠️ Duplicate node name: " ++ nodeRef.name).postln;
        this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
        validFlag = false;
      };
      seenNames.add(nodeRef.name);
    });

    this.mdlog(validFlag.if(2,0), "CommandTree",
      validFlag.if("✅ validation passed", "❌ validation failed"));

    ^validFlag;
  }*/

	findNodeByName { |name|
		var found;

		found = nodeMap.values.detect({ arg nodeRef; nodeRef.name == name });
		if (found.notNil) {
			("🔍 Found node '" ++ found.name ++ "' at ID " ++ found.id).postln;
			found
		} {
			"⚠️ Node not found".postln;
			nil
		}
	}

	getNodeByNamePath { |nameList|
		var found;

		found = root.getNodeByNamePath(nameList);
		if (found.notNil) { found } {
			("⚠️ Node not found at path: " ++ nameList.join(" → ")).postln;
			nil
		}
	}

	validateTree {
		var seenNames, validFlag;

		seenNames = Set.new;
		validFlag = true;

		nodeMap.values.do({ arg nodeRef;
			if (seenNames.includes(nodeRef.name)) {
				("⚠️ Duplicate node name: " ++ nodeRef.name).postln;
				this.mdlog(1, "CommandTree", "duplicate node name: " ++ nodeRef.name);
				validFlag = false;
			};
			seenNames.add(nodeRef.name);
		});

		this.mdlog(validFlag.if(2, 0), "CommandTree",
			validFlag.if("✅ validation passed", "❌ validation failed"));

		validFlag
	}
}

===== CommandTree/MIDIHandlers.sc =====
//MIDIHandlers.sc
// MD 20250818
// taken out of MIDIInputManager.sc to make smaller file and cleaner organisation.

MIDIInputHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}

LaunchpadHandler  {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
	}
}

LaunchpadDAWHandler {
	var <>inputManager;

	*new { |inputManager| ^super.new.init(inputManager); }

	init { |inputManager|
		this.inputManager = inputManager;
		^this
	}

	handleMessage { |channel, type, value|
		// Intentionally left blank to ignore DAW messages
	}
}

FootControllerHandler {
	var <>inputManager;

	*new { |inputManager|
		if (inputManager.isNil) {
			Error("FootControllerHandler requires a inputManager").throw;
		};
		^super.new.init(inputManager);
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("✅ FootControllerHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, value|
		("🧪 inputManager class is: " ++ inputManager.class).postln;


		if (type === \noteOn) {
			switch (value,
				36, { inputManager.setMode(inputManager.modes[\idle]) },
				38, { inputManager.setMode(inputManager.modes[\prog]) },
				40, { inputManager.setMode(inputManager.modes[\queue]) },
				41, { inputManager.setMode(inputManager.modes[\send]) },
				{ ("⚠️ No action for note: " ++ value).postln }
			);
		}
	}
}

GuitarMIDIHandler {
	var <>inputManager;

	*new { |inputManager|
		var instance = super.new;
		instance.init(inputManager);
		^instance
	}

	init { |inputManager|
		this.inputManager = inputManager;
		("✅ GuitarMIDIHandler received inputManager: " ++ inputManager).postln;
		^this
	}

	handleMessage { |channel, type, pitch|
		var stringBasePitches, basePitch, fret, stringNumber;

		// ✅ Confirm method is being called
		("📥 handleMessage called with channel: " ++ channel ++ ", type: " ++ type ++ ", pitch: " ++ pitch).postln;

		// ✅ Check type
		if (type === \noteOn) {
			"✅ type is noteOn".postln;
		} {
			"❌ type is not noteOn".postln;
		};

		// ✅ Check current mode
		if (inputManager.currentMode == inputManager.modes[\prog]) {
			"✅ currentMode is prog".postln;

			stringBasePitches = (
				0: 40, // E string (6th)
				1: 45, // A
				2: 50, // D
				3: 55, // G
				4: 59, // B
				5: 64  // E (1st)
			);

			basePitch = stringBasePitches[channel];
			if (basePitch.notNil) {
				fret = pitch - basePitch;
				stringNumber = 6 - channel;

				("🎸 Received MIDI note: " ++ pitch ++
					" on channel: " ++ channel ++
					" → string: " ++ stringNumber ++
					", base pitch: " ++ basePitch ++
					", calculated fret: " ++ fret).postln;

				// ✅ Navigation logic
				if (inputManager.waitingForString == stringNumber) {
					inputManager.waitingForString = nil;
					inputManager.navigationCallback.value(fret);
				};
			} {
				("⚠️ Unrecognized channel: " ++ channel ++ ". No base pitch defined.").postln;
			}
		} {
			("❌ currentMode is: " ++ inputManager.currentMode).postln;
		};

		{ inputManager.parentCommandManager.updateDisplay; }.defer;
	}
}
===== CommandTree/MIDIInputManager.sc =====
// MIDIInputManager.sc
// v1.1.1
// v1.1 added things in send mode for LivePedalboardSystem
// MD 20250817-1926

MIDIInputManager {
	var <>deviceUIDs;         // Dict: symbolic name -> srcID
	var <>deviceHandlers;     // Dict: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <> builder, <>queue;
	var <> parentCommandManager;
	var <> modes;
	var <>waitingForString, <>navigationCallback;
	var <>lastEnqueuedPayload;


	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	/*
	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|

		this.modes = IdentityDictionary[
			\idle -> \idle,
			\prog -> \prog,
			\queue -> \queue,
			\send -> \send,
			\play -> \play,
			\numeric -> \numeric,
			\capture -> \capture,
			\record -> \record
		];

		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		// this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		// this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		//DEBUG:
		("footControllerHandler manager is: " ++ footControllerHandler.inputManager).postln;

		// this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		// this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;


		this.launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this) };
		this.footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
		this.guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this) };
		this.launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this) };


		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getDeviceSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}
*/

	init { arg argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW;
    var defined;

    // -- modes + basics
    this.modes = IdentityDictionary[
        \idle -> \idle, \prog -> \prog, \queue -> \queue, \send -> \send,
        \play -> \play, \numeric -> \numeric, \capture -> \capture, \record -> \record
    ];
    this.builder = argBuilder;
    this.queue   = MDCommandQueue.new;

    // --- 1) CREATE HANDLERS FIRST (safe fallbacks)
    launchpadHandler      = argLaunchpad      ?? { LaunchpadHandler.new(this)      };
    footControllerHandler = argFootController ?? { FootControllerHandler.new(this) };
    guitarHandler         = argGuitarMIDI     ?? { GuitarMIDIHandler.new(this)     };
    launchpadDAWHandler   = argLaunchpadDAW   ?? { LaunchpadDAWHandler.new(this)   };

    // --- 2) MIDI client + device scan/bind
    MIDIClient.init;
    MIDIIn.connectAll;

    deviceUIDs     = Dictionary.new;
    deviceHandlers = Dictionary.new;
    this.scanDevices;

    launchpadID      = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
    launchpadDAWID   = this.getDeviceSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out);
    footControllerID = this.getDeviceSrcID(\nanoKEY2_KEYBOARD);
    guitarID         = this.getDeviceSrcID(\MD_IAC_to_SC);

    // Bind (guarded inside bindDevice)
    this.bindDevice(launchpadID,      launchpadHandler);
    this.bindDevice(footControllerID, footControllerHandler);
    this.bindDevice(guitarID,         guitarHandler);
    this.bindDevice(launchpadDAWID,   launchpadDAWHandler);

    // --- 3) Optional debug (after creation; nil-safe)
    ("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;
    ("footControllerHandler manager is: "
        ++ (footControllerHandler.notNil.if({ footControllerHandler.inputManager }, { "nil" }))
    ).postln;

    // --- 4) Final MIDIdef
    this.setupMIDIDef;

    ^this
}

	setMode { |newMode|
		currentMode = newMode;
		parentCommandManager.currentState = newMode;
		this.handleModeChange(newMode);
		{ parentCommandManager.updateDisplay }.defer;
	}

	handleModeChange { |mode|
		switch(mode,
			modes[\idle], {
				queue.clear;
				builder.resetNavigation;
				"Tree navigation reset.".postln;
			},

			modes[\prog], {
				var root;

				builder.resetNavigation;

				root = builder.tree.root; // get the root
				if (root.notNil) {
					root.children.do { |child| ("• " ++ child.name).postln };
				};

				this.startNavigationFromString(6);

				"Tree navigation started.".postln;
			},

			//---


			modes[\queue], {
				var queueText, canonicalPath;

				// NEW: derive canonical short path from current CommandTree selection
				canonicalPath = parentCommandManager.canonicalPathFromBuilder(builder);

				if (canonicalPath != lastEnqueuedPayload) { // reuse dedupe guard
					("Current canonical to queue: " ++ canonicalPath).postln;
					queue.enqueueCommand(canonicalPath);
					lastEnqueuedPayload = canonicalPath;

					if (builder.isAtLeaf) {
						parentCommandManager.setStatus("🌿 Leaf → " ++ canonicalPath);
					} {
						parentCommandManager.setStatus("📥 Queued node: " ++ canonicalPath);
					};

					queueText = queue.commandList.collect({ arg cmd; "- " ++ cmd.asString }).join("\n");
					{
						parentCommandManager.display.updateTextField(\state, "Mode: queue");
						parentCommandManager.display.updateTextField(\queue, "Current Queue:\n" ++ queueText);
						parentCommandManager.display.updateTextField(\lastCommand, "Last Added: " ++ canonicalPath);
					}.defer;

				} {
					("⚠️ Duplicate canonical ignored: " ++ canonicalPath).postln;
					parentCommandManager.setStatus("⚠️ Duplicate canonical ignored");
				};

				builder.resetNavigation;
				"Added canonical to queue and restarted navigation.".postln;
				this.setMode(modes[\prog]); // unchanged
			},

			//---

/*			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;

				("Sent queue as OSC: " ++ path).postln;
				queue.clear;
			},*/

			modes[\send], {
				var path = queue.exportAsOSCPath;
				("Queue contents before export: " ++ queue.commandList).postln;
				("Sent queue as OSC: " ++ path).postln;
				if (parentCommandManager.notNil and: { parentCommandManager.queueExportCallback.notNil }) {
					parentCommandManager.queueExportCallback.value(path);
				};
				queue.clear;
			},

			modes[\play], {
				"🎸 Play mode: no interaction.".postln;
			},
			modes[\numeric], {
				"🔢 Numeric input mode (not yet implemented).".postln;
			},
			modes[\capture], {
				"🎼 Capture mode (not yet implemented).".postln;
			},
			modes[\record], {
				"🔴 Record mode (not yet implemented).".postln;
			}
		);
	}
	startNavigationFromString { |stringNum|
		if (stringNum < 1) {
			builder.navigationComplete = true;
			"✅ Navigation complete.".postln;
			^this;
		};

		this.listenForNoteFromString(stringNum, { |fret|
			builder.navigateByFret(stringNum, fret);
			this.startNavigationFromString(stringNum - 1);
		});
	}

	listenForNoteFromString { |stringNum, callback|
		waitingForString = stringNum;
		navigationCallback = callback;
		("🎧 Waiting for note on string " ++ stringNum).postln;
	}

	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"🎛 Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getDeviceSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " → UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getDeviceSrcID(keyOrID);
			symbol = keyOrID;
		}{
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("⚠️ Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("⚠️ No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("🔗 Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}

	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("⚠️ No handler bound for srcID: " + srcID).postln;
			}
		});
	}

} // end of MIDIInputManager class


===== CommandTree/Verbosity.sc =====
// Verbosity.sc
// MD 20250819

// used to manage verbosity levels of my debugging messages

// Verbosity Levels:
// 0 → Errors only
// 1 → Actions
// 2 → Input/Output
// 3 → Object and type reporting
// 4 → Full debug (everything)






// Verbosity.sc
Verbosity {
    classvar <level = 2; // Default level

	*help {
    "Verbosity Levels:".postln;
    "0 → Errors only".postln;
    "1 → Actions".postln;
    "2 → Input/Output".postln;
    "3 → Object and type reporting".postln;
    "4 → Full debug (everything)".postln;
}


    *setLevel { |newLevel|
        level = newLevel;
        ("🔧 Verbosity level set to: " ++ level).postln;
    }

    *shouldPost { |requiredLevel|
        ^level >= requiredLevel;
    }

    *postIf { |requiredLevel, msg|
        if (level >= requiredLevel) {
            msg.postln;
        };
    }
}

===== LivePedalboardSystem/LivePedalboardSystem-AdapterBridge.sc =====
// LivePedalboardSystem-AdapterBridge.sc
// v0.1.5-displayOnly
// MD 20251005-1633

/*
Purpose
- DISPLAY-ONLY bridge:
  • Forward canonical paths from CommandManager to MagicPedalboard via adapter.
  • Update LPDisplay ACTIVE/NEXT on "/switch".
- No audio "ensure", no source fiddling, no exclusivity enforcement here.
Style
- var-first; lowercase names; no server.sync; AppClock for UI only; no non-local returns.
*/

+ LivePedalboardSystem {
    installAdapterBridge {
        var commandManager, pedalboardRef, statusDisplayRef;
        var adapterAvailable, adapterPath;

        commandManager   = this.commandManager;
        pedalboardRef    = this.pedalboard;
        statusDisplayRef = this.statusDisplay;

        if(commandManager.isNil or: { pedalboardRef.isNil }) {
            "[LPS] installAdapterBridge (display-only): commandManager or pedalboard is nil; skipping.".warn;
            ^this;
        };

        // ensure the CommandTree -> MagicPedalboard adapter function exists
        adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
        if(adapterAvailable.not) {
            adapterPath = (Platform.userExtensionDir
                ++ "/LivePedalboardSuite/MagicPedalboard/adapter_CommandTree_to_MagicPedalboard.scd"
            ).standardizePath;
            if(File.exists(adapterPath)) {
                adapterPath.load;
                adapterAvailable = (~ct_applyOSCPathToMPB.notNil);
            };
        };
        if(adapterAvailable.not) {
            "[LPS] installAdapterBridge (display-only): adapter not found; keeping existing queueExportCallback.".warn;
            ^this;
        };

        commandManager.queueExportCallback = { |canonicalPathString|
            var pathString, isSwitchPath, displayObj;

            pathString = canonicalPathString.asString;

            // 1) apply to MPB via adapter
            ~ct_applyOSCPathToMPB.(pathString, pedalboardRef, statusDisplayRef);

            // 2) if "/switch", flip ACTIVE/NEXT visual only (no audio actions)
            isSwitchPath = pathString.beginsWith("/switch");
            if(isSwitchPath) {
                if(~md_toggleCurrentChain.isKindOf(Function)) {
                    ~md_toggleCurrentChain.();
                }{
                    ~md_currentChain = ~md_currentChain ? \A;
                    ~md_currentChain = (~md_currentChain == \A).if({ \B }, { \A });
                };

                displayObj = commandManager.tryPerform(\display);
                if(displayObj.notNil) {
                    displayObj.tryPerform(\setActiveChainVisual, (~md_currentChain ? \A));
                };
                ("[LPS] ACTIVE chain toggled to " ++ (~md_currentChain ? \A).asString
                ++ " (display-only)").postln;
            };
            nil
        };

        "[LPS] installAdapterBridge: display-only bridge active (v0.1.5-displayOnly).".postln;
        ^this
    }
}
===== LivePedalboardSystem/LivePedalboardSystem-AutoMeters.sc =====
// LivePedalboardSystem-AutoMeters.sc
// v0.2.1
// MD 20251003-1539

/*
Purpose
- Put SendPeakRMS taps directly inside Ndef(\chainA) and Ndef(\chainB) so LPDisplay meters
  update via OSC paths /peakrmsA and /peakrmsB with replyIDs A=1, B=2.
- No separate "retap" scripts; taps reinstall automatically after "/switch".
Style
- Class extension only; var-first; lowercase methods; Server.default.bind for server ops;
  AppClock for GUI; no server.sync; no non-local returns.
*/

+ LivePedalboardSystem {

    enableAutoMeters { arg rate = 18, postSwitchDelay = 0.35;
        var installTaps, rearmGui, wrapAdapter;

        installTaps = {
            Server.default.bind({
                [\chainA, \chainB].do({ arg key, index;
                    var addr, replyId, r;
                    // 1) Clear any prior tap keys (compat with older builds)
                    if(Ndef(key).notNil) {
                        Ndef(key).clear(\ampTap);
                        Ndef(key).clear(\meterTap);
                    };
                    // 2) Configure address + reply id per chain
                    addr = (index == 0).if({ '/peakrmsA' }, { '/peakrmsB' });
                    replyId = (index == 0).if({ 1 }, { 2 });
                    r = rate.clip(1, 60);

                    // 3) Inline peak/RMS UGen tap (pass-through)
                    Ndef(key).filter(\meterTap, { arg in;
                        var sig;
                        sig = in.isArray.if({ in }, { [in, in] }); // mono-safe: duplicate to stereo
                        // LPDisplay expects SendPeakRMS with the usual /peakrmsA/B paths
                        SendPeakRMS.kr(sig, r, 3, addr, replyId);
                        in
                    });
                });
            });
        };

        rearmGui = {
            AppClock.sched(0.05, {
                var g, p;
                g = this.statusDisplay;
                p = this.pedalboard;
                if(g.notNil and: { g.respondsTo(\enableMeters) }) {
                    g.enableMeters(false);
                    g.enableMeters(true);
                };
                if(p.notNil and: { p.respondsTo(\printChains) }) { p.printChains };
                nil
            });
        };

        wrapAdapter = {
            // Only if the CommandTree -> MPB adapter is present
            if(~ct_applyOSCPathToMPB.isNil) {
                "⚠️ [AutoMeters] adapter not loaded; run installAdapterBridge first".warn;
            }{
                // Preserve raw adapter once
                if(~ct_applyOSCPathToMPB_raw.isNil) { ~ct_applyOSCPathToMPB_raw = ~ct_applyOSCPathToMPB };
                // Wrap once so taps are reinstalled after "/switch"
                if(~ct_applyOSCPathToMPB_withMeters.isNil) {
                    ~ct_applyOSCPathToMPB_withMeters = { arg pathString, mpb, gui;
                        var p, res;
                        p = pathString.asString;
                        res = ~ct_applyOSCPathToMPB_raw.(p, mpb, gui);
                        if(p == "/switch") {
                            AppClock.sched(postSwitchDelay, { installTaps.(); rearmGui.(); nil });
                        };
                        res
                    };
                    ~ct_applyOSCPathToMPB = ~ct_applyOSCPathToMPB_withMeters;
                    "[AutoMeters] post-switch reinstaller active".postln;
                };
            };
        };

        // One-shot now, and set up the post-switch hook
        installTaps.();
        rearmGui.();
        wrapAdapter.();
        "[AutoMeters] PeakRMS taps installed (rate=%), GUI re-armed".format(rate).postln;
        ^this
    }
}
===== LivePedalboardSystem/LivePedalboardSystem-Pathing.sc =====
// LivePedalboardSystem-Pathing.sc
// v0.3.1
// MD 20250923-0959

/*
Purpose
- Make LivePedalboardSystem default to a JSON tree INSIDE the repo so a fresh clone runs.
- Allow optional, per-user overrides in Extensions/MDclasses or UserState.
- Preserve explicit constructor path as the highest priority.

Style
- var-first; lowercase method names; no server.sync.
- Class extension only; pure path logic here.
*/

+ LivePedalboardSystem {

    // 1) Repo default (shipped in Git)
    *defaultTreePath {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 2) Optional per-user override in MDclasses (not in Git)
    *userOverrideMDclasses {
        ^Platform.userExtensionDir
        ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";
    }

    // 3) Optional per-user override alongside the code (normally .gitignored)
    *userOverrideUserState {
        ^Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";
    }

  *resolveTreePath { arg maybePath;
    var candidateUserState, candidateRepoDefault, candidateMdLegacy, resolvedPath;

    // 0) explicit path (caller responsibility)
    resolvedPath = maybePath;
    if (resolvedPath.notNil) { ^resolvedPath };

    // 1) per-user override alongside the code (usually .gitignored)
    candidateUserState   = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/UserState/MagicPedalboardCommandTree.json";

    // 2) repo default (shipped in Git / symlinked into Extensions)
    candidateRepoDefault = Platform.userExtensionDir
      ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    // 3) legacy (deprecated) MDclasses location
    candidateMdLegacy    = Platform.userExtensionDir
      ++ "/MDclasses/LivePedalboardSystem/MagicPedalboardCommandTree.json";

    if (File.exists(candidateUserState))   { ^candidateUserState };
    if (File.exists(candidateRepoDefault)) { ^candidateRepoDefault };
    if (File.exists(candidateMdLegacy)) {
      MDMiniLogger.get.warn("Pathing",
        "[deprecated] Using MDclasses copy: " ++ candidateMdLegacy);
      ^candidateMdLegacy
    };

    // Last resort: return repoDefault even if missing; importer will warn gracefully.
    ^candidateRepoDefault;
  }

}

===== LivePedalboardSystem/LivePedalboardSystem.sc =====
// LivePedalboardSystem.sc
// v0.3.0
// MD 2025-10-02 1350
// Purpose: Bring-up MagicPedalboard + CommandManager + single LPDisplayLayoutWindow
// Style: var-first, logger-enabled, AppClock-safe, Server.default.bind for server ops, no server.sync.

/*
Supplementary header — What this class does & key dependencies
----------------------------------------------------------------
Overview
- Orchestrates a complete bring-up sequence for the live pedalboard prototype:
  1) ensure server is up & tree is clean (when freshly booted),
  2) open a single MagicDisplay GUI window (avoid duplicates),
  3) construct & bind the MagicPedalboard,
  4) construct the CommandManager (tree-driven command layer),
  5) ensure audio is audible (safe test sources) and enable meters after initial rebuild.

Primary responsibilities
- Window hygiene (one GUI only), predictable boot order, defensive binding between GUI ↔ pedalboard ↔ command system,
  and conservative “ensureAudioOn” to guarantee an audible current chain.

Relies on (classes / files assumed present on the classpath)
- MagicPedalboard (core pedalboard implementation).
- Command tree stack: CommandManager, MDCommandTree, MDCommandBuilder, MDCommandQueue, MIDIInputManager.
- MagicDisplay / MagicDisplayGUI_GridDemo (status & meters), and MagicDisplay.ensureMeterDefs.
- MDMiniLogger (logging).
- SuperCollider primitives used here: Window, AppClock, Server, Ndef, Platform.userExtensionDir.

External data
- JSON command tree at:
  Platform.userExtensionDir ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json"

Notes
- Methods added in this version: class-side *help, *api, *test (non-invasive; do not change runtime behavior).
- This file intentionally avoids server.sync. s.waitForBoot is used only inside ensureServerReady() on first boot.
*/

LivePedalboardSystem : Object {
    var <>pedalboard;
    var <>pedalboardGUI;
    var <>commandManager;
    var <>statusDisplay; // this will hold a MagicDisplayGUI
	var <> lpDisplay; // THE NEW WINDOW
    var <>logger;
    var <>treeFilePath;
/*  *new { arg treePath;
        ^super.new.init(treePath);
    } */
     *new { arg treePath;
        var resolvedPath;
        resolvedPath = LivePedalboardSystem.resolveTreePath(treePath);
        ^super.new.init(resolvedPath);
    }
    init { arg treePath;
        var defaultPath;
        logger = MDMiniLogger.get;
        // Minimal change: use LivePedalboardSuite (symlinked in Extensions) as canonical default
        defaultPath = Platform.userExtensionDir
        ++ "/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json";
        treeFilePath = treePath.ifNil { defaultPath };
        ^this;
    }
    bringUpAll {
        // ✅ Make sure the server is up and the tree is clean *before* we create MPB
        this.ensureServerReady;
        this.bringUpMagicDisplayGUI; // 1) GUI first
        this.bringUpPedalboard; // 2) create MPB (it will create groups)
        this.bringUpCommandSystem; // 3) hook command system
        this.ensureAudioOn; // 4) prime sources + play current (no tree reset here)
        // meters last (you already moved this)
/*      if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
            statusDisplay.enableMeters(true);
        };*/
        //v0.2.8
        AppClock.sched(0.35, { // 350 ms is enough to outlive the initial MPB rebuild
            if(statusDisplay.notNil and: { statusDisplay.respondsTo(\enableMeters) }) {
                statusDisplay.enableMeters(true);
            };
            nil
        });
        logger.info("LivePedalboardSystem", "✅ System is ready.");
        ^this;
    }
/*  bringUpPedalboard {
        pedalboard = MagicPedalboard.new;
        pedalboardGUI = MagicPedalboardTestRunner.new(pedalboard, nil);
        pedalboardGUI.bringUp;
        logger.info("Pedalboard", "Pedalboard and GUI initialized.");
    }*/
/*  bringUpPedalboard {
        // new pedalboard bound to display (if ctor supports it)
        pedalboard = if (statusDisplay.notNil) {
            MagicPedalboard.new(statusDisplay)
        } {
            MagicPedalboard.new
        };
        // be defensive: wire after construction too, if there is a setter
        if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
            pedalboard.setDisplay(statusDisplay);
        };
        // remove runner usage; it's not needed for the new GUI path
        pedalboardGUI = nil;
        logger.info("Pedalboard", "MagicPedalboard initialized and bound to display.");
    }*/
    bringUpPedalboard {
        // new pedalboard bound to display (if ctor supports it)
        pedalboard = if (statusDisplay.notNil) {
            MagicPedalboard.new(statusDisplay)
        } {
            MagicPedalboard.new
        };
        // be defensive: wire after construction too, if there is a setter
        if (statusDisplay.notNil and: { pedalboard.respondsTo(\setDisplay) }) {
            pedalboard.setDisplay(statusDisplay);
        };
        // remove runner usage; it's not needed for the new GUI path
        pedalboardGUI = nil;
        logger.info("Pedalboard", "MagicPedalboard initialized and bound to display.");
    }
/*  bringUpCommandSystem {
        commandManager = CommandManager.new(treeFilePath);
        // inject GUI so updateDisplay() can actually update something
        commandManager.display = statusDisplay;
        // Queue export -> pedalboard
        commandManager.queueExportCallback = { |oscPath|
            pedalboard.handleCommand(oscPath);
            logger.info("Integration", "Sent command to pedalboard: " ++ oscPath);
            // If GUI is up, show last command
            if (statusDisplay.notNil and: { statusDisplay.respondsTo(\showExpectation) }) {
                statusDisplay.showExpectation("Sent: " ++ oscPath, 0);
            };
        };
        logger.info("CommandSystem", "CommandManager initialized and connected.");
    }*/
    //newer:
     bringUpCommandSystem {
        var cm;
        cm = CommandManager.new(treeFilePath);
        cm.display = statusDisplay;
        // temporary callback: log only; the bridge will overwrite this
        cm.queueExportCallback = { |path|
            MDMiniLogger.get.info("Integration", "Queued path: " ++ path.asString);
        };
        commandManager = cm;
        MDMiniLogger.get.info("CommandSystem", "CommandManager initialized (bridge pending).");
        ^this
    }
    // --- Single MagicDisplayGUI window, with meters enabled ---
    bringUpMagicDisplayGUI {
        // close any previous MagicDisplayGUI windows to avoid duplicates
        this.closeExistingMagicDisplayWindows;
statusDisplay = LPDisplayLayoutWindow.new;  // ⬅️ replaced MagicDisplayGUI_GridDemo with LPDisplayLayoutWindow (v0.3.0)
        //REMOVED: statusDisplay.showExpectation("System ready.", 0);
        // share GUI with CommandManager so CommandManager:setStatus can target it
        if (commandManager.respondsTo(\display_)) { commandManager.display = statusDisplay; };
        this.ensureMeterDefs;
        // meters are enabled later in bringUpAll to avoid node races
    }
    // --- Provide \busMeterA / \busMeterB if they don't exist yet ---
    // replaced with the below, which uses MagicDisplay meters instead:
    ensureMeterDefs {
        MagicDisplay.ensureMeterDefs(2); // or MagicDisplay.setMeterChannels(2)
    }
    // --- Conservative "make sure something is audible" ---
/*  ensureAudioOn {
        var started;
        started = false;
        if (pedalboard.respondsTo(\start)) { pedalboard.start; started = true; }
        { if (pedalboard.respondsTo(\play)) { pedalboard.play; started = true; } };
        if (started.not) {
            this.tryPlayNdefs([\chainA, \chainB, \testmelody]);
        };
        logger.info("Audio", "ensureAudioOn called (started: %).".format(started));
    }*/
    ensureAudioOn {
        var s;
        s = Server.default;
        // Define sources/sinks idempotently
        Server.default.bind({
            if (Ndef(\testmelody).source.isNil) {
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f = Demand.kr(trig, 0, seq);
                    var env = Decay2.kr(trig, 0.01, 0.35);
                    var pan = ToggleFF.kr(trig).linlin(0,1,-0.6,0.6);
                    Pan2.ar(SinOsc.ar(f) * env * 0.25, pan)
                });
            };
            Ndef(\testmelody).ar(2);
            if (Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
            // Ensure sink proxies exist at audio rate; MPB wires them
            Ndef(\chainA).ar(2);
            Ndef(\chainB).ar(2);
        });
        // Route CURRENT to \testmelody + Option A
        if (pedalboard.respondsTo(\setSourceCurrent)) {
            pedalboard.setSourceCurrent(\testmelody);
        };
        if (pedalboard.respondsTo(\enforceExclusiveCurrentOptionA)) {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
        };
        // Make sure CURRENT sink is actually playing; stop the other
        if (pedalboard.respondsTo(\playCurrent)) {
            pedalboard.playCurrent;
        } {
            Server.default.bind({
                if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
            });
        };
        // --- Make sure CURRENT sink is actually playing (single deferred assert) ---
        AppClock.sched(0.25, { // allow the temp SynthDef add to complete
            if (pedalboard.respondsTo(\playCurrent)) {
                pedalboard.playCurrent; // MPB decides which (A/B) should be audible
            } {
                Server.default.bind({
                    if (Ndef(\chainA).isPlaying.not) { Ndef(\chainA).play(numChannels: 2) };
                    if (Ndef(\chainB).isPlaying) { Ndef(\chainB).stop };
                });
            };
            nil
        });
        if (pedalboard.respondsTo(\printChains)) { pedalboard.printChains };
        logger.info("Audio", "Primed CURRENT with \\testmelody; ensured CURRENT is playing (Option A).");
    }
    ensureServerReady {
        var s, didBoot;
        s = Server.default;
        didBoot = false;
        if (s.serverRunning.not) {
            s.boot;
            s.waitForBoot; // permitted in your safe-reset pattern
            didBoot = true;
        };
        if (didBoot) {
            // Only wipe the tree on fresh boot, before MPB is constructed
            Server.default.bind({
                s.initTree;
                s.defaultGroup.freeAll;
            });
        };
        ^didBoot
    }
    tryPlayNdefs { arg syms;
        syms.do { arg sym;
            var nd = Ndef(sym);
            if (nd.notNil) { nd.play; };
        };
    }
    showStatus {
        logger.info("SystemStatus", "Pedalboard: %, CommandManager: %".format(
            pedalboard, commandManager
        ));
    }
/*  shutdownAll {
        pedalboard.free;
        pedalboardGUI.close;
        if (statusDisplay.notNil) { statusDisplay.close };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }*/
    closeExistingMagicDisplayWindows {
        var wins;
        wins = Window.allWindows.select({ |w|
            var nm = w.tryPerform(\name);
            nm.notNil and: { nm.asString.beginsWith("MagicDisplayGUI") }
        });
        AppClock.sched(0.0, {
            wins.do({ |w| w.close });
            nil
        });
        ^this
    }
    shutdownAll {
        var runnerClosed;
        runnerClosed = false;
        if (pedalboard.notNil and: { pedalboard.respondsTo(\free) }) {
            pedalboard.free;
        };
        if (pedalboardGUI.notNil) {
            if (pedalboardGUI.respondsTo(\close)) {
                pedalboardGUI.close; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\stop) }) {
                pedalboardGUI.stop; runnerClosed = true;
            };
            if (runnerClosed.not and: { pedalboardGUI.respondsTo(\free) }) {
                pedalboardGUI.free; runnerClosed = true;
            };
        };
        if (statusDisplay.notNil and: { statusDisplay.respondsTo(\close) }) {
            statusDisplay.close;
        };
        logger.warn("Shutdown", "LivePedalboardSystem shut down.");
    }

    // --- Added in v0.2.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
LivePedalboardSystem.help  —  quick guide

Bring-up (headless UI + one LPDisplay/MagicDisplay window)
----------------------------------------------------------
(
var lps;
lps = LivePedalboardSystem.new(nil);
lps.bringUpAll;           // ensure server, open GUI, build pedalboard & command system, enable meters
)

Key instance methods
- bringUpAll(), bringUpPedalboard(), bringUpCommandSystem(), bringUpMagicDisplayGUI()
- ensureMeterDefs(), ensureAudioOn(), ensureServerReady()
- tryPlayNdefs(symbolArray), showStatus(), shutdownAll()

Notes
- Expects the command-tree JSON at:
  Platform.userExtensionDir ++ \"/LivePedalboardSuite/LivePedalboardSystem/MagicPedalboardCommandTree.json\"
- Avoids duplicate GUI windows and avoids server.sync (uses Server.default.bind & AppClock).
";
        text.postln;
        ^text
    }

    *api {
        var api;
        api = IdentityDictionary[
            \ctor      -> "LivePedalboardSystem.new(treePathOrNil)  // resolves JSON path if nil",
            \bringUp   -> "bringUpAll()  // full bring-up in safe order",
            \gui       -> "bringUpMagicDisplayGUI(), closeExistingMagicDisplayWindows()",
            \pedalboard-> "bringUpPedalboard(), shutdownAll()",
            \command   -> "bringUpCommandSystem()",
            \audio     -> "ensureAudioOn(), ensureMeterDefs(), ensureServerReady(), tryPlayNdefs([...])",
            \status    -> "showStatus()",
            \jsonPath  -> "init(treePath) stores -> this.treeFilePath"
        ];
        api.postln;
        ^api
    }

    *test {
        var lps;
        lps = LivePedalboardSystem.new(nil);
        lps.bringUpAll;
        ^lps
    }



	//----
	// integrated 20251006:
	    autoBindLPDisplayIfPresent {
        var controller, cm, adapter;

        // 1) require the LPDisplay controller from your bring-up block
        controller = ~guiLP;
        if(controller.isNil) { ^this };  // nothing to bind yet

        // 2) resolve the real CM via your accessor (ivar-first, then pedalboard.*)
        cm = this.commandManager;
        if(cm.isNil) { ^this };

        // 3) reuse existing adapter if available; else create a new one
        adapter = (~lp_adapter.notNil).if({ ~lp_adapter }, { LPDisplayAdapter.new(controller) });
        ~lp_adapter = adapter;

        // 4) bind once and refresh panes
        cm.display = adapter;
        cm.updateDisplay;

        // 5) optional durable note
        (~md_log.notNil).if({ ~md_log.("System-side auto-bind OK (LPDisplayAdapter)") });

        ^this
    }

    // optional wrapper: full bring-up then auto-bind
    bringUpAllWithLPDisplayAutoBind {
        var selfRef;
        selfRef = this.bringUpAll;
        this.autoBindLPDisplayIfPresent;
        ^selfRef
    }
	//----

/*	    commandManager {
        var cmLocal, pb, candidates, found;

        // 1) Prefer the real ivar on this object (NOTE: do NOT write 'this.commandManager' here)
        cmLocal = commandManager;  // ivar access
        if(cmLocal.notNil and: { cmLocal.respondsTo(\updateDisplay) and: { cmLocal.respondsTo(\builder) } }) {
            ^cmLocal
        };

        // 2) Fallback: probe under pedalboard.* with common names
        pb = this.tryPerform(\pedalboard);
        if(pb.notNil) {
            candidates = [\commandManager, \cmdManager, \cm, \manager, \commandCenter, \commandCentre];
            found = candidates.detect({ arg sel;
                var cand = pb.tryPerform(sel);
                cand.notNil and: { cand.respondsTo(\updateDisplay) and: { cand.respondsTo(\builder) } }
            });
            if(found.notNil) { ^pb.perform(found) };
        };

        ^nil
    }

    cmdManager { ^this.commandManager }
    cm         { ^this.commandManager }
    manager    { ^this.commandManager }*/
	//---

}
===== LPDisplay/LPDisplayAdapter_ActiveForward.sc =====
// LPDisplayAdapter_ActiveForward.sc
// v0.1.0
// MD 20251004-17:58

/* Purpose
- Forward ACTIVE/NEXT visual calls from the adapter to the LPDisplayLayoutWindow controller.
- Keeps LPDisplayLayoutWindow_ActiveHighlight.sc fully decoupled from AdapterBridge.
*/

+ LPDisplayAdapter {
    setActiveChainVisual { |which|
        if(controller.notNil) {
            controller.tryPerform(\setActiveChainVisual, which);
        };
        ^this
    }
}
===== LPDisplay/LPDisplayAdapter_SetController.sc =====
// LPDisplayAdapter_SetController.sc
// v0.1.0
// MD 20251004-1820

/* Purpose
- Provide a setter so we can assign the actual LPDisplayLayoutWindow instance to the adapter.
*/

+ LPDisplayAdapter {
    setController { |controllerRef|
        controller = controllerRef;
        ^this
    }
}
===== LPDisplay/LPDisplayAdapter.sc =====
// LPDisplayAdapter.sc
// v1.1.0
// MD 20251003-1315

/* Purpose / Style
- Adapter so CommandManager.display.respondsTo(...) is true.
- Map legacy GUI calls to LPDisplay panes via controller.sendPaneText.
- Adds non-destructive highlightCurrentColumn -> Diag pane.
- Style: var-first; lowercase; no server.sync; descriptive names.
*/

LPDisplayAdapter {
    var controller;

    *new { arg controllerRef;  ^super.new.init(controllerRef) }

    init { arg controllerRef;
        controller = controllerRef;
        ^this
    }

    showExpectation { arg text, idx = 0;
        var msg = text.asString;
        if(controller.notNil) { controller.sendPaneText(\system, msg) };
        ^this
    }

    updateTextField { arg box, msg;
        var pane, target, txt;
        pane = box.asSymbol;
        txt  = msg.asString;
        target = (pane == \state).if({ \system }, { (pane == \choices).if({ \choices }, { \diag }) });
        if(controller.notNil) { controller.sendPaneText(target, txt) };
        ^this
    }

    setOperations { arg lines;
        var joined = ((lines ? []) collect: _.asString).join(Char.nl.asString);
        if(controller.notNil) { controller.sendPaneText(\choices, joined) };
        ^this
    }

    // NEW: non-destructive active-side indicator in Diag
    highlightCurrentColumn { arg which;
        var label = which.asString.toLower;
        var text  = (label.contains("a") or: { label.contains("current") })
            .if({ "Active chain: A" }, { "Active chain: B" });
        if(controller.notNil) { controller.sendPaneText(\diag, text) };
        ^this
    }

    enableMeters { arg flag = true; ^this }
}
===== LPDisplay/LPDisplayHudMap.sc =====
// LPDisplayHudMap.sc
// v0.9.7.2 — dB→UI mapping (top/floor/gamma) + preview/print
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local variable names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Map raw linear RMS (0..1) from SendPeakRMS into a UI-friendly 0..1 value using a dB window
 *   (topDb/floorDb) and a perceptual gamma curve. This is optional in the display window:
 *   passing nil for the HUD map means "use raw RMS 0..1".
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; numeric helpers return raw values.
 */

LPDisplayHudMap {
    classvar classVersion = "0.9.7.2";

    // Defaults for headroom window and perceptual curve
    classvar defaultTopDb   = -6.0;
    classvar defaultFloorDb = -60.0;
    classvar defaultGamma   = 1.0;

    // Instance configuration
    var topDb;     // dB at which UI reaches 1.0 (top of meter)
    var floorDb;   // dB at which UI reaches 0.0 (floor of meter)
    var gamma;     // perceptual exponent applied in UI domain

    *initClass {
        ("LPDisplayHudMap v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |topDbArg, floorDbArg, gammaArg|
        // If any parameter is omitted, fall back to defaults above.
        ^super.new.init(
            topDbArg   ?? { defaultTopDb },
            floorDbArg ?? { defaultFloorDb },
            gammaArg   ?? { defaultGamma }
        )
    }

    init { |topDbInit, floorDbInit, gammaInit|
        // Store parameters and keep gamma numerically safe.
        topDb   = topDbInit.asFloat;
        floorDb = floorDbInit.asFloat;
        gamma   = gammaInit.asFloat.max(1e-6);

        // Ensure a valid window (top must be above floor).
        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB to keep mapping valid.".postln;
        };
        ^this
    }

    set { |key, value|
        // Small setter to tweak parameters at runtime (e.g., \top -> -9, \gamma -> 1.2).
        var paramKey = key.asSymbol;
        var paramVal = value.asFloat;

        if (paramKey == \top)   { topDb = paramVal };
        if (paramKey == \floor) { floorDb = paramVal };
        if (paramKey == \gamma) { gamma = paramVal.max(1e-6) };

        if (topDb <= floorDb) {
            topDb = floorDb + 0.1;
            "LPDisplayHudMap: adjusted top to floor+0.1 dB.".postln;
        };
        ^this
    }

    mapLinToUi { |linearRms|
        /*
         * Convert a raw linear RMS (0..1) into a UI fraction (0..1):
         * 1) Convert linear amplitude to dBFS.
         * 2) Clip to [floorDb, topDb] window.
         * 3) Normalize to [0,1] and apply gamma.
         */
        var linearClamped      = linearRms.max(1e-9);  // avoid -inf dB
        var amplitudeDb        = linearClamped.ampdb;  // linear -> dBFS
        var topDbLimit         = topDb.asFloat;
        var floorDbLimit       = floorDb.asFloat;
        var gammaLocal         = gamma.asFloat.max(1e-6);
        var uiValue;

        amplitudeDb = amplitudeDb.clip(floorDbLimit, topDbLimit);
        uiValue     = (amplitudeDb - floorDbLimit) / (topDbLimit - floorDbLimit);
        uiValue     = uiValue.pow(gammaLocal);
        ^uiValue.clip(0.0, 1.0)
    }

    preview { |rmsDbValue|
        // Convenience: preview the UI value you’d get for a given RMS dB input.
        var linearFromDb             = rmsDbValue.dbamp.clip(1e-9, 1.0);
        var uiValue                  = this.mapLinToUi(linearFromDb);
        ("HUD UI -> " ++ uiValue.round(0.003) ++ " for " ++ rmsDbValue ++ " dBFS RMS").postln;
        ^uiValue
    }

    print {
        ("HUD: top=" ++ topDb ++ " dB, floor=" ++ floorDb ++ " dB, gamma=" ++ gamma).postln;
        ^this
    }


	/////



	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplayHudMap — purpose:",
        "  Map raw linear RMS (0..1) to UI (0..1) using a dB headroom window and gamma.",
        "",
        "Constructor:",
        "  LPDisplayHudMap.new(topDb = -6, floorDb = -60, gamma = 1.0)",
        "",
        "Key methods:",
        "  .set(\\top|\\floor|\\gamma, value)  // tweak mapping",
        "  .mapLinToUi(linearRms)              // 0..1 -> 0..1 UI",
        "  .preview(rmsDb)                     // prints & returns UI for a dB value",
        "  .print()                            // print current mapping",
        "",
        "Tip: In LPDisplayLayoutWindow, setHudMap(nil) disables mapping (raw 0..1)."
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplayHudMap.apihelp — quick recipes:",
        "  h = LPDisplayHudMap.new(-6, -60, 1.0);",
        "  h.preview(-9);                // see UI at -9 dB RMS",
        "  h.set(\\top, -9).print;        // move top to -9 dB RMS",
        "  h.set(\\gamma, 1.2).print;     // increase perceptual curvature",
        "  // In the layout window:",
        "  //  ~inst.setHudMap(h);         // enable mapping",
        "  //  ~inst.setHudMap(nil);       // disable mapping (raw 0..1)"
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var hud, dbCases, lastUi, passAll;
    hud = this.new(-6, -60, 1.0);
    dbCases = [-60, -30, -18, -12, -9, -6, -3, 0]; // typical points
    lastUi = -1.0;
    passAll = true;

    "LPDisplayHudMap.test — monotonicity & bounds:".postln;
    dbCases.do({ |dbVal|
        var uiVal;
        uiVal = hud.preview(dbVal); // prints & returns
        if (uiVal < lastUi) { passAll = false };
        if ((uiVal < 0.0) or: { uiVal > 1.0 }) { passAll = false };
        lastUi = uiVal;
    });

    if (passAll) {
        "LPDisplayHudMap.test: PASS".postln;
    } {
        "LPDisplayHudMap.test: FAIL (non-monotonic or out-of-bounds)".postln;
    };
    ^passAll
}
}
===== LPDisplay/LPDisplayLayoutWindow_ActiveHighlight.sc =====
// LPDisplayLayoutWindow_ActiveHighlight.sc
// v0.1.1
// MD 20251004-1718

/*
Purpose
- Add a small API to LPDisplayLayoutWindow to show ACTIVE/NEXT visually.
API
- setActiveChainVisual(\A|\B)          // main entry (colors + titles)
- setTopPaneTitle(\A|\B, string)       // optional helper
- setTopPaneStyle(\A|\B, activeBool)   // optional helper

Style
- var-first; lowercase; AppClock.defer for UI; no server.sync.
*/

+ LPDisplayLayoutWindow {

    activePaneColor { ^Color.fromHexString("#2ecc71") }   // bright green
    nextPaneColor   { ^Color.fromHexString("#2c3e50") }   // dark slate
    brightText      { ^Color.white }
    dimText         { ^Color.fromHexString("#bdc3c7") }

    setTopPaneTitle { |which, str|
        var tgt, st;
        tgt = which.asSymbol;
        st  = (tgt == \A).if({ topLeftText }, { topRightText });
        if(st.notNil) { { st.string_(str.asString) }.defer };
        ^this
    }

    setTopPaneStyle { |which, isActive=true|
        var tgt, st, pane, bg, tc;
        tgt = which.asSymbol;
        st  = (tgt == \A).if({ topLeftText }, { topRightText });
        pane = st.notNil.if({ st.parent }, { nil });
        bg = isActive.if({ this.activePaneColor }, { this.nextPaneColor });
        tc = isActive.if({ this.brightText }, { this.dimText });
        if(pane.notNil and: { pane.respondsTo(\background_) }) { { pane.background_(bg) }.defer };
        if(st.notNil) { { st.stringColor_(tc) }.defer };
        ^this
    }

    summaryAfterDash { |labelObj|
        var s, idx;
        s = (labelObj ? "").asString;
        idx = s.find("—");
        ^(idx.notNil).if({ " — " ++ s.copyRange(idx+1, s.size-1).trim }, { "" })
    }

    setActiveChainVisual { |which=\A|
        var activeIsA, summaryA, summaryB;
        activeIsA = (which.asSymbol == \A);
        summaryA = this.summaryAfterDash(topLeftText);
        summaryB = this.summaryAfterDash(topRightText);
        this.setTopPaneStyle(\A, activeIsA);
        this.setTopPaneStyle(\B, activeIsA.not);
        this.setTopPaneTitle(\A, (activeIsA.if("Chain A ACTIVE","Chain A NEXT") ++ summaryA));
        this.setTopPaneTitle(\B, (activeIsA.if("Chain B NEXT","Chain B ACTIVE") ++ summaryB));
        ^this
    }
}

===== LPDisplay/LPDisplayLayoutWindow_DisableDemoAudio.sc =====
// LPDisplayLayoutWindow_DisableDemoAudio.sc
// v0.1.0
// MD 20251005-1633

/*
Purpose
- Add a convenience method to LPDisplayLayoutWindow to silence its demo sources.
Style
- var-first; lowercase; no server.sync.
*/

+ LPDisplayLayoutWindow {
    disableDemoAudio {
        var demoNames;
        demoNames = [\srcA, \srcB, \srcC, \srcZ, \outA, \outB];
        Server.default.bind({
            demoNames.do { |sym|
                var nd = Ndef(sym);
                if(nd.notNil, { nd.stop; });
            };
            if(Ndef(\ts0).source.isNil) { Ndef(\ts0, { Silent.ar(2) }) };
            Ndef(\ts0).ar(2);
        });
        "[LPDisplay] Demo audio disabled and \\ts0 materialized.".postln;
        ^this
    }
}
===== LPDisplay/LPDisplayLayoutWindow.sc =====
// LPDisplayLayoutWindow.sc
// v0.9.7.4 — Grid window with A/B chains, meters via SendPeakRMS, console prints gated
// MD 2025-10-01
/*
 * 0.9.7.4 add consoleLevelsOn flag (default false) to gate console prints
 * 0.9.7.3 move class-side utility methods (*help, *apihelp, *test) to class scope (compile fix)
 * 0.9.7.2 clearer variable names + explanatory comments; NO logic changes (doc-only)
 * 0.9.7.1 moved makePane out of buildWindow as new method -- cleaner
 * 0.9.7
 - builds a 6‑pane grid GUI with two moving LevelIndicator meters at the top,
 - sets up two signal chains (A and B) built with JITLib Ndef(left) <<> Ndef(right),
 - receives /peakrmsA and /peakrmsB via SendPeakRMS and updates the meters,
 - posts decimated level prints to the console for A/B (~1 Hz),
 - has methods
   open, close
   setSourceA(\sym), setSourceB(\sym) — swap the tail source per chain
   sendPaneText(\diag, "…") — set any pane text
   setHudMap(mapOrNil), printHud — optional meter UI mapping
Works with:
 LPDisplaySigChain — the little wrapper that wires JITLib symbols into a playing chain.
 LPDisplayHudMap — optional linear→UI mapping (dB headroom + gamma) for the meters.
Notes:
 - The optional HUD map (LPDisplayHudMap) maps raw linear RMS (0..1) to UI (0..1) using a dB window
   (top/floor) and gamma. If you pass nil (or later set nil), the meters display raw 0..1 values.
 - SendPeakRMS ‘replyID’ is kept as A=1 and B=2 for continuity with earlier console dumps/tools.
   This preserves compatibility with any previous log parsing that keyed on replyID rather than address.
*/
LPDisplayLayoutWindow {
    classvar classVersion = "0.9.7.4"; // printed at class-load time

    // --- UI
    var window;
    var paneColor;
    var topLeftText, topLeftMeter;
    var topRightText, topRightMeter;
    var systemText, diagText, choicesText, recvText;

    // --- Chains
    var chainA; // LPDisplaySigChain
    var chainB; // LPDisplaySigChain

    // --- OSC
    var oscNameA, oscNameB, oscConsoleA, oscConsoleB;
    var firstDumpA = true, firstDumpB = true;
    var countA = 0, countB = 0;

    // NEW: console print gate (default OFF)
    var consoleLevelsOn;

    // --- Meter mapping (optional)
    // 'meterHudMap' holds an optional LPDisplayHudMap instance. If nil, meters use raw SendPeakRMS RMS (0..1).
    var meterHudMap;

    *initClass {
        ("LPDisplayLayoutWindow v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |meterHudMapInstance|
        // 'meterHudMapInstance' is an INSTANCE of LPDisplayHudMap (or nil). It is not a name/symbol.
        ^super.new.init(meterHudMapInstance)
    }

    *open { |meterHudMapInstance|
        // Convenience: build+open in one call. You can pass nil to use raw meter values without HUD mapping.
        ^this.new(meterHudMapInstance).open
    }

    init { |meterHudMapInstance|
        // Store optional HUD mapping object; nil means "use raw 0..1 RMS for meters".
        meterHudMap = meterHudMapInstance;
        paneColor = Color(0.0, 0.35, 0.0);

        // OSCdef keys (names) for GUI and console responders
        oscNameA = \rmsA_toGUI;
        oscNameB = \rmsB_toGUI;
        oscConsoleA = \rmsA_console;
        oscConsoleB = \rmsB_console;

        // NEW: default OFF
        consoleLevelsOn = false;

        ^this
    }

    // --- Public API -----------------------------------------------------------

    open {
        Window.allWindows.do { |existingWindow|
            if (existingWindow.name == "Layout Test") { existingWindow.close }
        }; // ensure only one with this title
        this.buildWindow;
        this.bootAndBuildGraph;
        ^window // -> a Window
    }

    close {
        // Free any live OSCdefs and stop sinks before closing the window
        var oscGuiDefA = OSCdef(oscNameA);
        var oscGuiDefB = OSCdef(oscNameB);
        var oscConsoleDefA = OSCdef(oscConsoleA);
        var oscConsoleDefB = OSCdef(oscConsoleB);

        if (oscGuiDefA.notNil) { oscGuiDefA.free };
        if (oscGuiDefB.notNil) { oscGuiDefB.free };
        if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
        if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

        if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
        if (chainB.notNil) { Ndef(chainB.symbols.first).stop };

        if (window.notNil) {
            // prevent recursive cleanup: onClose will not call back into close()
            window.onClose = { };
            window.close;
            window = nil;
        };
        ^this
    }

    setSourceA { |sourceSymbol|
        if (chainA.notNil) {
            chainA.setTailSource(sourceSymbol);
            {
                if (topLeftText.notNil) { topLeftText.string_(chainA.chainToString) };
            }.defer;
        };
        ^this
    }

    setSourceB { |sourceSymbol|
        if (chainB.notNil) {
            chainB.setTailSource(sourceSymbol);
            {
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;
        };
        ^this
    }

    sendPaneText { |paneKey, aString|
        var paneKeySymbol = paneKey.asSymbol;
        var textString = aString.asString;
        {
            if (paneKeySymbol == \left   and: { topLeftText.notNil  }) { topLeftText.string_(textString) };
            if (paneKeySymbol == \right  and: { topRightText.notNil }) { topRightText.string_(textString) };
            if (paneKeySymbol == \system and: { systemText.notNil   }) { systemText.string_(textString) };
            if (paneKeySymbol == \diag   and: { diagText.notNil     }) { diagText.string_(textString) };
            if (paneKeySymbol == \choices and: { choicesText.notNil }) { choicesText.string_(textString) };
            if (paneKeySymbol == \recv   and: { recvText.notNil     }) { recvText.string_(textString) };
        }.defer;
        ^this
    }

    setHudMap { |hudMapOrNil|
        // Plug/unplug the HUD mapping. Pass an LPDisplayHudMap instance to enable perceptual scaling,
        // or nil to use raw RMS values from SendPeakRMS (0..1) directly.
        meterHudMap = hudMapOrNil;
        ^this
    }

    printHud {
        if (meterHudMap.notNil) { meterHudMap.print } { "HUD mapping: none (raw 0..1)".postln };
        ^this
    }

    // NEW: convenience setter to toggle console prints
    setConsoleLevelsOn { |flag = false|
        consoleLevelsOn = flag.asBoolean;
        ^this
    }

    // --- Internal build steps -------------------------------------------------

    /* Make one labeled pane (internal helper)
     * Returns a UserView that draws a border and hosts a label + provided content.
     */
    makePane { |content, label|
        var labelView, inner, pane, inset;
        labelView = StaticText()
            .string_(label)
            .align_(\center)
            .stringColor_(Color.white)
            .background_(paneColor);
        inner = VLayout(labelView, content);
        pane  = UserView().layout_(inner);
        pane.drawFunc_({ |view|
            inset = 0.5;
            Pen.use {
                Pen.color = paneColor;
                Pen.width = 1;
                Pen.addRect(Rect(
                    inset, inset,
                    view.bounds.width - (2 * inset),
                    view.bounds.height - (2 * inset)
                ));
                Pen.stroke;
            };
        });
        ^pane
    }

    buildWindow {
        // Pre-create all views explicitly (prevents nil during deferred updates)
        topLeftText  = TextView().editable_(false);
        topLeftMeter = LevelIndicator().fixedWidth_(30);
        topRightText = TextView().editable_(false);
        topRightMeter= LevelIndicator().fixedWidth_(30);
        systemText   = TextView();
        diagText     = TextView();
        choicesText  = TextView();
        recvText     = TextView();

        window = Window("Layout Test", Rect(100, 100, 800, 600))
            .background_(Color.white)
            .front;

        window.layout = GridLayout.rows(
            [
                this.makePane(HLayout(topLeftText,  topLeftMeter),  "Top Left Pane"),
                this.makePane(HLayout(topRightText, topRightMeter), "Top Right Pane")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), systemText), "System State"),
                this.makePane(VLayout(StaticText().align_(\center), diagText),   "Diagnostic Messages")
            ],
            [
                this.makePane(VLayout(StaticText().align_(\center), choicesText), "Choices"),
                this.makePane(VLayout(StaticText().align_(\center), recvText),    "Receiving Commands")
            ]
        );

        window.onClose = {
            // Free resources only; do not call window.close here to avoid recursion
            var oscGuiDefA = OSCdef(oscNameA);
            var oscGuiDefB = OSCdef(oscNameB);
            var oscConsoleDefA = OSCdef(oscConsoleA);
            var oscConsoleDefB = OSCdef(oscConsoleB);

            if (oscGuiDefA.notNil) { oscGuiDefA.free };
            if (oscGuiDefB.notNil) { oscGuiDefB.free };
            if (oscConsoleDefA.notNil) { oscConsoleDefA.free };
            if (oscConsoleDefB.notNil) { oscConsoleDefB.free };

            if (chainA.notNil) { Ndef(chainA.symbols.first).stop };
            if (chainB.notNil) { Ndef(chainB.symbols.first).stop };
        };
        ^this
    }

    bootAndBuildGraph {
        Server.default.waitForBoot({
            var extractLinearRmsFromOscMessage;
            this.defineDefaultSourcesAndSinks;

            // Initial chains
            chainA = LPDisplaySigChain.new([\outA, \srcA]).rebuild;
            chainB = LPDisplaySigChain.new([\outB, \srcB]).rebuild;

            // Show full chain strings in the GUI (nil-safe)
            {
                if (topLeftText.notNil)  { topLeftText.string_(chainA.chainToString) };
                if (topRightText.notNil) { topRightText.string_(chainB.chainToString) };
            }.defer;

            // Avoid duplicates on re-eval
            { OSCdef(oscNameA).free; OSCdef(oscNameB).free; OSCdef(oscConsoleA).free; OSCdef(oscConsoleB).free; }.value;

            // Robust extraction: pick the last numeric in message (typically final RMS per SendPeakRMS)
            extractLinearRmsFromOscMessage = { |oscMessage|
                var linearRms = 0.0, messageSize;
                if (oscMessage.notNil) {
                    messageSize = oscMessage.size;
                    if (messageSize >= 4) { linearRms = oscMessage[messageSize - 1].asFloat };
                };
                linearRms.clip(0.0, 1.0)
            };

            // GUI meters (20 Hz), nil-safe; apply HUD mapping if present, else raw RMS
            OSCdef(oscNameA, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topLeftMeter.notNil) { topLeftMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsA');

            OSCdef(oscNameB, { |oscMessage|
                var linearRms = extractLinearRmsFromOscMessage.(oscMessage);
                var meterValueUi = (meterHudMap.notNil).if({ meterHudMap.mapLinToUi(linearRms) }, { linearRms });
                {
                    if (topRightMeter.notNil) { topRightMeter.value_(meterValueUi) };
                }.defer;
            }, '/peakrmsB');

            // Console prints (~1 Hz via decimation), now gated by 'consoleLevelsOn'
            OSCdef(oscConsoleA, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpA) {
                        ("A first msg: %".format(oscMessage)).postln;
                        firstDumpA = false;
                    };
                    countA = countA + 1;
                    if (countA >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("A level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countA = 0;
                    };
                } {
                    // printing disabled — keep counters steady or reset if you prefer
                    countA = 0;
                };
            }, '/peakrmsA');

            OSCdef(oscConsoleB, { |oscMessage|
                var linearRmsForConsole;
                if (consoleLevelsOn) {
                    if (firstDumpB) {
                        ("B first msg: %".format(oscMessage)).postln;
                        firstDumpB = false;
                    };
                    countB = countB + 1;
                    if (countB >= 20) {
                        linearRmsForConsole = extractLinearRmsFromOscMessage.(oscMessage).max(1e-6);
                        ("B level: " ++ (linearRmsForConsole.ampdb.round(0.1))
                            ++ " dB (" ++ linearRmsForConsole.round(0.003) ++ ")").postln;
                        countB = 0;
                    };
                } {
                    // printing disabled — keep counters steady or reset if you prefer
                    countB = 0;
                };
            }, '/peakrmsB');
        });
        ^this
    }

    defineDefaultSourcesAndSinks {
        // SOURCES (stereo)
        Ndef(\srcZ, { Silent.ar(numChannels: 2) });
        Ndef(\srcA, { PinkNoise.ar(0.10 ! 2) });
        Ndef(\srcB, { SinOsc.ar([300, 301], mul: 0.20) });
        Ndef(\srcC, { LFSaw.ar([167, 171]).tanh * 0.18 });

        // SINKS (\in.ar(2)) + SendPeakRMS (A=1, B=2)
        // Note on replyID: A=1 and B=2 are kept intentionally for continuity with earlier dumps/log parsers.
        // The OSC addresses also differ (/peakrmsA vs /peakrmsB), so replyID isn't strictly required,
        // but keeping these IDs preserves compatibility with prior tools and logs.
        Ndef(\outA, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsA', 1); // replyID 1 == chain A
            sig
        });
        Ndef(\outB, {
            var sig = \in.ar(2);
            SendPeakRMS.kr(sig, 20, 3, '/peakrmsB', 2); // replyID 2 == chain B
            sig
        });
        ^this
    }

    // --- Utility: docs & smoke test (add-only) --------------------------------

    *help {
        var lines;
        lines = [
            "LPDisplayLayoutWindow — purpose:",
            " Build a 6-pane grid window with top-left/right meters driven by SendPeakRMS,",
            " wire two JITLib chains (A/B), print decimated levels, and offer simple control methods.",
            "",
            "Constructor & convenience:",
            " w = LPDisplayLayoutWindow.new( LPDisplayHudMap.new(-6, -60, 1.0) ).open; // -> a Window",
            " w = LPDisplayLayoutWindow.open(nil); // raw meters (no HUD mapping)",
            "",
            "Key methods (instance):",
            " .open -> a Window .close",
            " .setSourceA(\\sym) .setSourceB(\\sym)",
            " .sendPaneText(\\diag, \"...\")",
            " .setHudMap( mapOrNil ) .printHud",
            "",
            "Notes:",
            " - 'replyID' kept as A=1, B=2 for continuity with earlier dumps/tools.",
            " - Pass nil HUD to use raw 0..1 meter values (bypass perceptual mapping)."
        ];
        lines.do(_.postln);
        ^this
    }

    *apihelp {
        var lines;
        lines = [
            "LPDisplayLayoutWindow.apihelp — useful snippets:",
            " // bring-up (HUD mapped):",
            " ~hud = LPDisplayHudMap.new(-6, -60, 1.0);",
            " ~inst = LPDisplayLayoutWindow.new(~hud);",
            " ~win = ~inst.open; // -> a Window",
            "",
            " // swap sources:",
            " ~inst.setSourceA(\\srcC);",
            " ~inst.setSourceB(\\srcA);",
            "",
            " // pane text:",
            " ~inst.sendPaneText(\\diag, \"Ready @ \" ++ Date.getDate.stamp);",
            "",
            " // HUD on/off:",
            " ~inst.setHudMap(nil);",
            " ~inst.setHudMap(LPDisplayHudMap.new(-9, -60, 1.0)).printHud;",
            "",
            " // console levels on/off:",
            " ~inst.setConsoleLevelsOn(true);   // enable A/B level prints",
            " ~inst.setConsoleLevelsOn(false);  // disable prints (default)",
            "",
            " // class-side one-liner:",
            " LPDisplayLayoutWindow.open(nil); // raw meters"
        ];
        lines.do(_.postln);
        ^this
    }

    *test {
        var inst, win, passOsc, posted;
        inst = this.new(nil); // raw meters (no HUD)
        win  = inst.open;     // -> a Window
        // After a short delay, check GUI OSCdefs exist, then flip sources & post a diag line.
        AppClock.sched(0.5, {
            passOsc = OSCdef(\rmsA_toGUI).notNil and: { OSCdef(\rmsB_toGUI).notNil };
            inst.setSourceA(\srcC);
            inst.setSourceB(\srcA);
            inst.sendPaneText(\diag, "Self-test OK @ " ++ Date.getDate.stamp);
            AppClock.sched(1.0, {
                inst.close;
                posted = "LPDisplayLayoutWindow.test: " ++ (passOsc.if("PASS", "WARN (GUI OSC not found)"));
                posted.postln;
                nil
            });
            nil
        });
        ^win // handy if you want to keep the window reference
    }
}
===== LPDisplay/LPDisplaySigChain.sc =====
// LPDisplaySigChain.sc
// v0.9.7.2 — minimal [sink, ..., source] JITLib chain wrapper
// MD 2025-10-01
/*
 * 0.9.7.2 clearer local/parameter names + explanatory comments; NO logic changes (doc-only)
 *
 * Purpose
 * - Manage a simple symbol chain [sink, ..., source] using JITLib wiring:
 *   Ndef(left) <<> Ndef(right), where the left node reads \in.ar(2).
 * - Ensure stereo busses prior to wiring; play the sink.
 *
 * Typical usage
 *   LPDisplaySigChain.new([\outA, \srcA]).rebuild;       // wires and plays sink
 *   chain.setTailSource(\srcC).rebuild;                  // swap just the tail
 *   chain.chainToString  // "srcC → outA"
 *
 * Conventions
 * - *new returns ^super.new.init(...)
 * - Methods return ^this where appropriate; getters return values.
 */

LPDisplaySigChain {
    classvar classVersion = "0.9.7.2";

    var chainSymbols;  // Array(Symbol): [sink, ..., source]

    *initClass {
        ("LPDisplaySigChain v" ++ classVersion ++ " loaded (LivePedalboardDisplay)").postln;
    }

    *new { |chainSymbolsArray|
        ^super.new.init(chainSymbolsArray ?? { [] })
    }

    init { |chainSymbolsArray|
        chainSymbols = chainSymbolsArray.copy;
        ^this
    }

    size {
        ^chainSymbols.size
    }

    ensureStereo { |ndefKey|
        /*
         * Pre-arm an Ndef as a 2-channel audio node if its bus is missing or not stereo.
         * This prevents wiring failures when we connect nodes with <<>.
         */
        var ndefBus = Ndef(ndefKey).bus;
        if (ndefBus.isNil or: { ndefBus.rate != \audio } or: { ndefBus.numChannels != 2 }) {
            Ndef(ndefKey).ar(2);
        };
        ^this
    }

    rebuild {
        /*
         * Wire the chain left-to-right:
         *   chainSymbols = [sink, mid1, mid2, source]
         * becomes:
         *   Ndef(sink) <<> Ndef(mid1);  Ndef(mid1) <<> Ndef(mid2);  Ndef(mid2) <<> Ndef(source)
         * and then play the sink stereo.
         */
        var chainSize  = chainSymbols.size;
        var linkIndex  = 0;

        if (chainSize < 2) {
            "LPDisplaySigChain: need at least [sink, source]".postln;
            ^this
        };

        chainSymbols.do { |ndefSymbol| this.ensureStereo(ndefSymbol) };

        while({ linkIndex < (chainSize - 1) }, {
            Ndef(chainSymbols[linkIndex]) <<> Ndef(chainSymbols[linkIndex + 1]);
            linkIndex = linkIndex + 1;
        });

        Ndef(chainSymbols[0]).play(numChannels: 2);  // play the sink
        ^this
    }

    chainToString {
        // For display we show "source → ... → sink"
        var forwardList = chainSymbols.copy.reverse;
        ^forwardList.collect(_.asString).join(" → ")
    }

    setTailSource { |tailSourceSymbol|
        // Replace/append the final element (source) and keep the chain consistent.
        var newSourceSymbol = tailSourceSymbol.asSymbol;

        if (chainSymbols.size >= 2) {
            chainSymbols[chainSymbols.size - 1] = newSourceSymbol;
        } {
            chainSymbols = chainSymbols.add(newSourceSymbol);
        };

        ^this.rebuild
    }

    symbols {
        // Read-only copy so external code doesn’t mutate internal state.
        var symbolsCopy = chainSymbols.copy;
        ^symbolsCopy
    }



	////////
	// --- Utility: docs & smoke test (add-only) -----------------------------

*help {
    var lines;
    lines = [
        "LPDisplaySigChain — purpose:",
        "  Wrap a symbol chain [sink, ..., source] and wire via:",
        "    Ndef(left) <<> Ndef(right)  (sink reads \\in.ar(2))",
        "",
        "Constructor:",
        "  LPDisplaySigChain.new([\\outA, \\srcA])",
        "",
        "Key methods:",
        "  .rebuild()                   // ensure stereo, wire, play sink",
        "  .setTailSource(\\srcC)       // swap the final source and rebuild",
        "  .chainToString               // e.g., 'srcC → outA'",
        "  .symbols                     // copy of [sink, ..., source]",
        ""
    ];
    lines.do(_.postln);
    ^this
}

*apihelp {
    var lines;
    lines = [
        "LPDisplaySigChain.apihelp — quick recipes:",
        "  c = LPDisplaySigChain.new([\\outA, \\srcA]).rebuild;",
        "  c.setTailSource(\\srcC);",
        "  c.chainToString.postln;  // 'srcC → outA'",
        "",
        "Note: Ensure sinks read \\in.ar(2) and that sources produce stereo."
    ];
    lines.do(_.postln);
    ^this
}

*test {
    var srcKey, sinkKey, chain, okFlag;

    // Use single-backslash for Symbol literals:
    srcKey  = \_lpdisp_test_src;
    sinkKey = \_lpdisp_test_sink;

    okFlag  = true;

    Server.default.waitForBoot({
        // ephemeral test nodes
        Ndef(srcKey,  { PinkNoise.ar(0.02 ! 2) });  // quiet stereo
        Ndef(sinkKey, {
            var sig = \in.ar(2);
            // no SendPeakRMS here to keep test minimal
            sig
        });

        chain = this.new([sinkKey, srcKey]).rebuild;

        // brief run, then cleanup
        AppClock.sched(0.4, {
            var busOk;
            busOk = Ndef(sinkKey).bus.notNil and: { Ndef(sinkKey).isPlaying };
            if (busOk.not) { okFlag = false };

            Ndef(sinkKey).stop;
            Ndef(srcKey).clear(0.2);  // fade out

            ("LPDisplaySigChain.test: " ++ (okFlag.if("PASS", "FAIL"))).postln;
            nil
        });
    });
    ^this
}

}
===== MagicPedalboard/compat/Compat_MagicDisplayGUI_QueueUi_Ext.sc =====
// Compat_MagicDisplayGUI_QueueUi_Ext.sc
// v0.1.1
// MD 2025-09-23

+MagicDisplayGUI {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

+MagicDisplayGUI_GridDemo {
    queueUi { |taskOrText|
        var doIt;
        doIt = {
            if(taskOrText.isKindOf(Function)) {
                taskOrText.value;
            }{
                if(this.respondsTo(\showExpectation)) {
                    this.showExpectation(taskOrText.asString, 0);
                }{
                    taskOrText.asString.postln;
                };
            };
            nil
        };
        AppClock.sched(0.0, doIt);
        ^this
    }
}

===== MagicPedalboard/MagicDisplay.sc =====
/* MagicDisplay.sc  v0.1.3
   Console display adaptor for MagicPedalboardNew.
   Prints structured messages now; later you can subclass with a real GUI.
   // MD 20250912-1345
*/

MagicDisplay : Object {

	classvar < version, < metersReady, < meterChannels;

	var < logLevel;  // 0 = silent, 1 = normal, 2 = verbose


	*initClass {
		version = "v0.1.3";
		("MagicDisplay " ++ version).postln;

		// default compile-time meter channel count
		meterChannels = 2;
		metersReady = false;

		// define (or re-define) the meter SynthDefs now
		this.ensureMeterDefs(meterChannels);
	}


	*new { |level = 1|
		^super.new.init(level)
	}

	init { |level|
		var initialLevel;
		initialLevel = level ? 1;
		logLevel = initialLevel;
		^this
	}

	help {
		var text;
		text = "MagicDisplay " ++ version
		++ "\nMethods:\n"
		++ "  showInit(pedalboard, versionString, current, next)\n"
		++ "  showRebuild(which, fullChain, effective)\n"
		++ "  showPlay(sink), showStop(sink), showSwitch(oldSink, newSink, current, next)\n"
		++ "  showMutation(action, args, nextChain)\n"
		++ "  showBypass(which, key, state, chain, bypassKeys)\n"
		++ "  showReset(current, next), showChains(current, next, bypassA, bypassB)\n"
		++ "  showChainsDetailed(current, next, bypassA, bypassB, effCurrent, effNext)\n"
		++ "  showError(message)\n";
		text.postln;
	}

	showInit { |pedalboard, versionString, current, next|
		if(logLevel > 0) { ("[MPB:init] " ++ versionString ++ "  current=" ++ current ++ "  next=" ++ next).postln };
	}

	showRebuild { |which, fullChain, effective|
		if(logLevel > 0) { ("[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ "  effective=" ++ effective).postln };
	}

	showPlay { |sinkKey|
		if(logLevel > 0) { ("[MPB:play] sink=" ++ sinkKey).postln };
	}

	showStop { |sinkKey|
		if(logLevel > 0) { ("[MPB:stop] sink=" ++ sinkKey).postln };
	}

	showSwitch { |oldSink, newSink, current, next|
		if(logLevel > 0) {
			("[MPB:switch] " ++ oldSink ++ " → " ++ newSink
				++ "  current=" ++ current ++ "  next=" ++ next).postln;
		};
	}

	showMutation { |action, args, nextChain|
		if(logLevel > 0) { ("[MPB:mutate] " ++ action ++ " " ++ args ++ "  next=" ++ nextChain).postln };
	}

	showBypass { |which, key, state, chain, bypassKeys|
		if(logLevel > 0) {
			("[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state
				++ "  chain=" ++ chain ++ "  activeBypass=" ++ bypassKeys).postln;
		};
	}

	showReset { |current, next|
		if(logLevel > 0) { ("[MPB:reset] current=" ++ current ++ "  next=" ++ next).postln };
	}

	showChains { |current, next, bypassAKeys, bypassBKeys|
		if(logLevel > 0) {
			"MagicPedalboardNew.printChains:".postln;
			("A: " ++ current ++ "   bypassA: " ++ bypassAKeys).postln;
			("B: " ++ next    ++ "   bypassB: " ++ bypassBKeys).postln;
		};
	}

	showChainsDetailed { |current, next, bypassAKeys, bypassBKeys, effCurrent, effNext|
		var header, formatOne;

		if(logLevel <= 0) { ^this };

		header = { |titleString| ("==== " ++ titleString ++ " ====").postln };

		formatOne = { |titleString, listRef, bypassKeys, effective|
			var sinkKey, sourceKey, lastIndex, indexCounter, lineText;

			lastIndex = listRef.size - 1;
			sinkKey = listRef[0];
			sourceKey = listRef[lastIndex];

			header.(titleString);
			("sink : " ++ sinkKey).postln;

			indexCounter = 1;
			if(listRef.size > 2) {
				"procs:".postln;
				listRef.copyRange(1, lastIndex - 1).do { |procKey|
					var isBypassed, mark;
					isBypassed = bypassKeys.includes(procKey);
					mark = if(isBypassed) { "BYP" } { "ON " };
					lineText = ("  [" ++ indexCounter ++ "] " ++ procKey ++ "  (" ++ mark ++ ")");
					lineText.postln;
					indexCounter = indexCounter + 1;
				};
			}{
				"procs: (none)".postln;
			};

			("src  : " ++ sourceKey).postln;
			("eff  : " ++ effective.join("  ->  ")).postln;
			"".postln;
		};

		formatOne.("CURRENT", current, bypassAKeys, effCurrent);
		formatOne.("NEXT",    next,    bypassBKeys, effNext);
	}

	showError { |message|
		("[MPB:error] " ++ message).warn;
	}

	// ----- meter SynthDefs (class-level) -----

	*ensureMeterDefs { arg ch = 2;
		var n;
		// clamp to a sensible positive integer
		n = ch.asInteger.max(1);
		meterChannels = n;

		// Define (or re-define) once per class init (safe to call again after recompile).
		// Uses compile-time channel count 'n' inside the UGen graph.
		Server.default.bind({
			SynthDef(\busMeterA, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);                 // compile-time 'n'
				var amp  = Amplitude.ar(sig).clip(0, 1);    // per-channel amplitude
				SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
			}).add;

			SynthDef(\busMeterB, { arg inBus, rate = 15;
				var sig  = In.ar(inBus, n);
				var amp  = Amplitude.ar(sig).clip(0, 1);
				SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
			}).add;
		});

		metersReady = true;
	}

	*setMeterChannels { arg ch = 2;
		// convenience: re-emit defs with a new compile-time channel count
		this.ensureMeterDefs(ch);
	}

}

===== MagicPedalboard/MagicDisplayGUI_Ext_VisualOnly.sc =====
// MagicDisplayGUI_Ext_VisualOnly.sc
// v0.1.1 (fixed: no ivar; uses window property bag instead)
// MD 20250919-08:05 BST

/*
Purpose
- Add "visual-only" layout controls to MagicDisplayGUI without modifying the class file.
- setVisualOnly(true): hides Ops area; recomputes A/B panel heights so they stop above
  the expectation/countdown block; meters group remains at the bottom.
- relayoutVisualOnly: recompute bounds; attachResize wires window.onResize -> relayout.

Style
- AppClock for UI; no server.sync; methods live in a class extension.
- Uses window.setProperty/getProperty(\visualOnlyFlag) instead of new ivars.
*/

+ MagicDisplayGUI {

    // -- helpers to read/write the visual-only flag using the window as property bag
    getVisualOnlyFlag {
        var v;
        v = false;
        if(window.notNil) {
            v = window.getProperty(\visualOnlyFlag) ? false;
        };
        ^v
    }

    setVisualOnly { arg flag = true;
        var on;
        on = flag ? true;
        this.queueUi({
            if(window.notNil) { window.setProperty(\visualOnlyFlag, on) };

            // Hide or show ops widgets
            if(opsListView.notNil)   { opsListView.visible_(on.not) };
            if(opsNextButton.notNil) { opsNextButton.visible_(on.not) };
            if(opsStatusText.notNil) { opsStatusText.visible_(on.not) };

            this.relayoutVisualOnly;  // recompute layout now
        });
        ^this
    }

    relayoutVisualOnly {
        var pad, metersH, expH, expGap, countH, winRect, colGap;
        var visualOnly, rightW, usableW, colW, colH, leftX, rightX;
        var groupLeft, groupTop, groupW, labelW, barW;

        // Geometry constants (aligned to your class)
        pad     = 10;
        metersH = 86;   // meters block height in your class
        expH    = 52;   // expectation text height
        expGap  = 6;    // spacing between expectation and countdown bar row
        countH  = 20;   // countdown row height
        colGap  = 40;   // gap between columns

        visualOnly = this.getVisualOnlyFlag;

        // Window rect fallback if not created yet
        winRect = (window.notNil).if({ window.view.bounds }, { Rect(0, 0, 980, 520) });

        // If visual-only, reclaim the ops panel width
        rightW  = (visualOnly ? 0 : 320);

        // Compute column widths
        usableW = winRect.width - (2 * pad) - rightW - colGap;
        colW    = (usableW / 2).max(220);

        // Compute column heights so panels stop ABOVE the expectation + countdown region
        colH = winRect.height
            - (2 * pad)   // top + bottom padding
            - metersH     // meters area at bottom
            - expH        // expectation text
            - expGap      // spacing
            - countH      // countdown row
            - 12;         // small margin

        colH = colH.max(120);

        leftX  = pad;
        rightX = pad + colW + colGap;

        this.queueUi({
            // Left/right column panels
            if(leftPanel.notNil)  { leftPanel.bounds  = Rect(leftX,  pad, colW, colH) };
            if(rightPanel.notNil) { rightPanel.bounds = Rect(rightX, pad, colW, colH) };

            // Expectation + countdown spans both columns
            if(expectationText.notNil) {
                expectationText.bounds = Rect(leftX, leftPanel.bounds.bottom + 6, colW*2 + colGap, expH)
            };
            if(countdownLabel.notNil)   {
                countdownLabel.bounds    = Rect(leftX, expectationText.bounds.bottom + expGap, 120, 20)
            };
            if(countdownBarView.notNil) {
                countdownBarView.bounds  = Rect(leftX + 130, expectationText.bounds.bottom + expGap,
                                                (colW*2 + colGap) - 140, 20)
            };

            // Ops area only when not visual-only
            if(visualOnly.not and: { opsListView.notNil }) {
                opsListView.bounds = Rect(expectationText.bounds.right + pad, pad,
                                          rightW - pad, winRect.height - 2 * pad);
                if(opsStatusText.notNil) {
                    opsStatusText.bounds = Rect(opsListView.bounds.left,
                                                opsListView.bounds.bottom - 52,
                                                opsListView.bounds.width - 110, 20)
                };
                if(opsNextButton.notNil) {
                    opsNextButton.bounds = Rect(opsListView.bounds.right - 100,
                                                opsListView.bounds.bottom - 56, 100, 28)
                };
            };

            // Meters group: reuse the parent of meterViewA/B
            if(meterViewA.notNil and: { meterViewB.notNil } and: { meterViewA.parent.notNil }) {
                groupLeft = pad;
                groupTop  = winRect.height - metersH - pad;
                groupW    = winRect.width  - 2*pad;
                meterViewA.parent.bounds = Rect(groupLeft, groupTop, groupW, metersH);

                // child bars
                labelW = 60;
                barW   = groupW - labelW - 10;
                meterViewA.bounds = Rect(labelW + 6, 4, barW, 20);
                meterViewB.bounds = Rect(labelW + 6, 4 + 38, barW, 20);
            };
        });

        ^this
    }

    attachResize {
        this.queueUi({
            if(window.notNil) {
                window.onResize = { this.relayoutVisualOnly };
            };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_FixChoicesColors_Ext.sc =====
// MagicDisplayGUI_FixChoicesColors_Ext.sc
// v0.1.2  — MD 2025-09-24 23:10 BST
/*
Purpose
- Make the "Choices" text high-contrast no matter how it is updated:
  updateTextField(\choices, ...) or setOperations([...]).
Style
- Class extension only; NO new ivars; var-first in every method; AppClock UI; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {

    ensureChoicesPanel {
        var host, build;
        host = this.window.tryPerform(\view);
        if(host.isNil) { ^this };

        build = {
            var x, y, w, h;
            x = host.bounds.width - 360; y = 8; w = 352; h = 200;

            this.choicesPanel = this.choicesPanel ?? { CompositeView(host) };
            this.choicesPanel
                .background_(Color(0.15, 0.15, 0.15))
                .resize_(5)
                .bounds_(Rect(x, y, w, h));

            this.choicesTitle = this.choicesTitle ?? { StaticText(this.choicesPanel) };
            this.choicesTitle
                .string_("Choices")
                .stringColor_(Color(0.85, 0.85, 0.85))
                .align_(\left)
                .bounds_(Rect(8, 6, w - 16, 20));

            this.choicesText = this.choicesText ?? { TextView(this.choicesPanel) };
            this.choicesText
                .background_(Color(0.15, 0.15, 0.15))
                .stringColor_(Color.white)
                .font_(Font("Monaco", 12))
                .autoscroll_(true)
                .editable_(false)
                .bounds_(Rect(8, 28, w - 16, h - 36));
        };

        AppClock.sched(0.0, { build.value; nil });
        ^this
    }

    md_applyChoicesText { arg textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            this.ensureChoicesPanel;
            if(this.choicesText.notNil) {
                this.choicesText.stringColor_(Color.white);  // force high contrast
                this.choicesText.string_(txt);
            };
            nil
        });
        ^this
    }

    updateTextField { arg key, textString;
        var txt;
        txt = textString.asString;
        AppClock.sched(0.0, {
            switch(key,
                \choices, { this.md_applyChoicesText(txt) },
                \state,   { if(this.expectationView.notNil) { this.expectationView.string = txt } },
                \queue,   { if(this.expectationView.notNil) { this.expectationView.string = "Queue:\n" ++ txt } },
                \lastCommand, { if(this.expectationView.notNil) { this.expectationView.string = "Last: " ++ txt } },
                { /* no-op */ }
            );
            nil
        });
        ^this
    }

    setOperations { arg itemsArray;
        var s;
        s = (itemsArray ? []).collect(_.asString).join("\n");
        this.md_applyChoicesText(s);
        ^this
    }

    // optional manual nudge
    forceHighContrastChoices {
        this.md_applyChoicesText(this.choicesText.tryPerform(\string) ? "");
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_SetOperations.sc =====
// MagicDisplayGUI_GridDemo_Ext_SetOperations.sc
// v0.1.0
// MD 2025-09-22 22:36 BST

/* Purpose
   - Let CommandManager.updateDisplay push the current fret→choice list
     into MagicDisplayGUI_GridDemo's "Choices" panel.
   Style
   - AppClock-only UI; var-first; lowercase; no server.sync.
*/

+ MagicDisplayGUI_GridDemo {
    setOperations { |lines|
        var text;
        text = (lines ? []).join("\n");
        this.queueUi({
            if(choicesText.notNil) { choicesText.string = text };
        });
        ^this
    }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMarker.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMarker.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw unambiguous landmarks INSIDE the right CURRENT/NEXT panel (middle-right column):
  • Fuchsia border built from 4 thin CompositeViews (no drawFunc)
  • Yellow highlight inside the 'eff' row (anchor)
  • Marker bar near 'eff': ORANGE below (clamped) or SKY-BLUE above (clamped)
- Absolutely no layout mutations; no drawing math inside drawFuncs; only known-good SC GUI.

Style
- Class extension; var-first in all methods; descriptive variable names.
- Views are created as named children of rightPanel so we can remove them safely.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- helpers: find/remove named child on rightPanel ----------
  tm_findChildByName { arg childNameString;
    var foundView, childCount, childIndex, childView, childNameMaybe;
    foundView = nil;
    if(rightPanel.notNil) {
      childCount = rightPanel.children.size;
      childIndex = 0;
      childCount.do({
        childView = rightPanel.children[childIndex];
        childNameMaybe = if(childView.respondsTo(\name), { childView.name }, { nil });
        if(childNameMaybe == childNameString) { foundView = childView };
        childIndex = childIndex + 1;
      });
    };
    ^foundView
  }

  tm_removeChildByName { arg childNameString;
    var viewToRemove;
    viewToRemove = this.tm_findChildByName(childNameString);
    if(viewToRemove.notNil) { viewToRemove.remove };
    ^this
  }

  // ---------- clear all test markers/borders ----------
  testMarker_clear {
    this.tm_removeChildByName("MDG_TM_BORDER_TOP");
    this.tm_removeChildByName("MDG_TM_BORDER_BOTTOM");
    this.tm_removeChildByName("MDG_TM_BORDER_LEFT");
    this.tm_removeChildByName("MDG_TM_BORDER_RIGHT");
    this.tm_removeChildByName("MDG_TM_EFF_HI");
    this.tm_removeChildByName("MDG_TM_MARKER");
    ^this
  }

  // ---------- show a bold fuchsia border (4 thin views) ----------
  testMarker_showPanelBorder {
    var ensureFunc;

    if(rightPanel.isNil) { "testMarker_showPanelBorder: rightPanel is nil".warn; ^this };

    ensureFunc = {
      var panelBounds, thickness, topView, bottomView, leftView, rightView, colorFuchsia;

      // clean previous
      this.testMarker_clear;

      panelBounds   = rightPanel.bounds;
      thickness     = 3;
      colorFuchsia  = Color(1.0, 0.0, 1.0, 0.85);

      topView = CompositeView(rightPanel).name_("MDG_TM_BORDER_TOP");
      topView.background = colorFuchsia;
      topView.bounds = Rect(0, 0, panelBounds.width, thickness);

      bottomView = CompositeView(rightPanel).name_("MDG_TM_BORDER_BOTTOM");
      bottomView.background = colorFuchsia;
      bottomView.bounds = Rect(0, panelBounds.height - thickness, panelBounds.width, thickness);

      leftView = CompositeView(rightPanel).name_("MDG_TM_BORDER_LEFT");
      leftView.background = colorFuchsia;
      leftView.bounds = Rect(0, 0, thickness, panelBounds.height);

      rightView = CompositeView(rightPanel).name_("MDG_TM_BORDER_RIGHT");
      rightView.background = colorFuchsia;
      rightView.bounds = Rect(panelBounds.width - thickness, 0, thickness, panelBounds.height);

      // bring to front in a stable order
      topView.front; bottomView.front; leftView.front; rightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- highlight the 'eff' row (yellow translucent) ----------
  testMarker_highlightEff {
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_highlightEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var effBounds, highlightView, colorYellow;

      // remove old eff highlight only
      this.tm_removeChildByName("MDG_TM_EFF_HI");

      effBounds = rightEff.bounds;
      colorYellow = Color(1.0, 1.0, 0.0, 0.45);

      highlightView = CompositeView(rightPanel).name_("MDG_TM_EFF_HI");
      highlightView.background = colorYellow;
      highlightView.bounds = Rect(
        effBounds.left + 2,
        effBounds.top + 2,
        (effBounds.width - 4).max(4),
        (effBounds.height - 4).max(4)
      );
      highlightView.front;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- place a marker bar NEAR the 'eff' row (positionSymbol: \below or \above) ----------
  testMarker_showNearEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMarker_showNearEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var panelBounds, effBounds, leftInset, rightInset, gapPixels;
      var desiredTop, finalTop, finalHeight, markerRect, markerView;
      var colorOrange, colorSkyBlue, markerColor;

      // remove any previous marker (keep border/eff highlight)
      this.tm_removeChildByName("MDG_TM_MARKER");

      panelBounds = rightPanel.bounds;
      effBounds   = rightEff.bounds;

      leftInset   = 6;
      rightInset  = 6;
      gapPixels   = 4;
      colorOrange = Color(1.0, 0.50, 0.0, 0.90);
      colorSkyBlue= Color(0.10, 0.65, 1.0, 0.90);

      if(positionSymbol == \below) {
        markerColor = colorOrange;
        desiredTop  = effBounds.bottom + gapPixels;
        finalHeight = barHeight.max(8);
        if(desiredTop + finalHeight > panelBounds.height) {
          finalHeight = (panelBounds.height - desiredTop).max(8);
        };
        finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
      } {
        markerColor = colorSkyBlue;  // \above
        finalHeight = barHeight.max(8);
        desiredTop  = effBounds.top - gapPixels - finalHeight;
        if(desiredTop < 0) {
          finalHeight = (effBounds.top - gapPixels).max(8);
          desiredTop  = 0;
        };
        finalTop = desiredTop;
      };

      markerRect = Rect(
        leftInset,
        finalTop,
        (panelBounds.width - (leftInset + rightInset)).max(8),
        finalHeight
      );

      markerView = CompositeView(rightPanel).name_("MDG_TM_MARKER");
      markerView.background = markerColor;
      markerView.bounds = markerRect;
      markerView.front;

      "—— TestMarker ——".postln;
      ("rightPanel.bounds: " ++ panelBounds).postln;
      ("rightEff.bounds:   " ++ effBounds).postln;
      ("marker.bounds:     " ++ markerRect).postln;
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo_Ext_TestMeter.sc =====
// MagicDisplayGUI_GridDemo_Ext_TestMeter.sc
// v0.1.0
// MD 2025-09-24 23:59 BST

/*
Purpose
- Draw a small horizontal "debug meter" inside the right CURRENT/NEXT panel (middle-right column),
  positioned relative to the 'eff:' row (just BELOW by default; clamped to stay inside the panel).
- Step 1: run with a smoothed RANDOM driver to prove GUI refresh + horizontal motion.
- Step 2: attach to live audio via SendReply.kr paths '/ampA' or '/ampB'.

Style
- Class extension; known-good SuperCollider only.
- Var-first in all blocks; descriptive variable names (>=3 chars).
- Minimal state stored in Library under category \MD_TM and key this.identityHash.
*/

+ MagicDisplayGUI_GridDemo {

  // ---------- tiny state bag in Library (per GUI instance) ----------
  tm2_state {
    var categorySymbol, keyInt, dict;
    categorySymbol = \MD_TM;
    keyInt = this.identityHash;
    dict = Library.at(categorySymbol, keyInt);
    if(dict.isNil) {
      dict = IdentityDictionary.new;
      Library.put(categorySymbol, keyInt, dict);
    };
    ^dict
  }

  tm2_put { arg keySymbol, valueObject;
    var stateDict;
    stateDict = this.tm2_state;
    stateDict.put(keySymbol, valueObject);
    ^this
  }

  tm2_get { arg keySymbol, defaultValue = nil;
    var stateDict;
    stateDict = this.tm2_state;
    ^(stateDict.includesKey(keySymbol).if({ stateDict.at(keySymbol) }, { defaultValue }))
  }

  // ---------- compute the meter rectangle relative to 'eff' (below or above) ----------
  tm2_computeMeterRect { arg positionSymbol = \below, barHeight = 24;
    var panelBounds, effBounds;
    var leftInset, rightInset, gapPixels;
    var desiredTop, finalTop, finalHeight, rectResult;

    if(rightPanel.isNil or: { rightEff.isNil }) { ^Rect(0,0,0,0) };

    panelBounds = rightPanel.bounds;
    effBounds   = rightEff.bounds;

    leftInset   = 6;
    rightInset  = 6;
    gapPixels   = 4;

    if(positionSymbol == \below) {
      desiredTop  = effBounds.bottom + gapPixels;
      finalHeight = barHeight.max(8);
      if(desiredTop + finalHeight > panelBounds.height) {
        finalHeight = (panelBounds.height - desiredTop).max(8);
      };
      finalTop = desiredTop.min(panelBounds.height - finalHeight).max(0);
    } {
      // \above
      finalHeight = barHeight.max(8);
      desiredTop  = effBounds.top - gapPixels - finalHeight;
      if(desiredTop < 0) {
        finalHeight = (effBounds.top - gapPixels).max(8);
        desiredTop  = 0;
      };
      finalTop = desiredTop;
    };

    rectResult = Rect(
      leftInset,
      finalTop,
      (panelBounds.width - (leftInset + rightInset)).max(8),
      finalHeight
    );
    ^rectResult
  }

  // ---------- create the meter UserView at the computed rectangle ----------
  testMeter_showAtEff { arg positionSymbol = \below, barHeight = 24;
    var ensureFunc;

    if(rightPanel.isNil or: { rightEff.isNil }) {
      "testMeter_showAtEff: rightPanel or rightEff is nil".warn; ^this
    };

    ensureFunc = {
      var meterRect, meterUserView;

      // remove any previous meter view
      this.testMeter_remove;

      meterRect = this.tm2_computeMeterRect(positionSymbol, barHeight);

      meterUserView = UserView(rightPanel).name_("MDG_TM2_METER");
      meterUserView.background = Color.clear;
      meterUserView.bounds = meterRect;

      // drawFunc: trough + horizontal fill
      meterUserView.drawFunc = { arg viewLocal;
        var viewBounds, padPixels, troughRect, valueNow, fillWidth, fillRect;

        viewBounds = viewLocal.bounds;
        padPixels  = 2;

        troughRect = Rect(
          padPixels, padPixels,
          viewBounds.width  - (padPixels * 2),
          viewBounds.height - (padPixels * 2)
        );

        // trough
        Pen.color = Color(0.80, 0.82, 0.86, 0.60);
        Pen.addRect(troughRect); Pen.fill;

        // horizontal fill
        valueNow  = (this.tm2_get(\meterVal, 0.0)).clip(0, 1);
        fillWidth = (troughRect.width * valueNow).max(0);
        fillRect  = Rect(troughRect.left, troughRect.top, fillWidth, troughRect.height);

        Pen.color = Color(0.15, 0.65, 0.25, 0.95);  // green-ish
        Pen.addRect(fillRect); Pen.fill;

        // border
        Pen.color = Color.gray(0.20);
        Pen.strokeRect(Rect(0.5, 0.5, viewBounds.width - 1, viewBounds.height - 1));
      };

      meterUserView.front;

      this.tm2_put(\meterView, meterUserView);
      this.tm2_put(\meterVal, 0.0);
    };

    AppClock.sched(0.0, { ensureFunc.value; nil });
    ^this
  }

  // ---------- random driver (prove GUI refresh + orientation) ----------
  testMeter_startRandom {
    var startFunc;

    startFunc = {
      var existingTask, meterUserView, meterTaskRoutine;

      // stop any prior driver
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_startRandom: meter not shown—call testMeter_showAtEff first.".warn; ^this };

      meterTaskRoutine = Routine({
        var currentVal, targetVal, stepSeconds;
        currentVal = this.tm2_get(\meterVal, 0.0);
        stepSeconds = 0.06;  // ~16 Hz
        inf.do {
          targetVal  = 1.0.rand;
          currentVal = (currentVal * 0.75) + (targetVal * 0.25);
          this.tm2_put(\meterVal, currentVal);
          AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
          stepSeconds.wait;
        }
      });

      this.tm2_put(\meterTask, meterTaskRoutine);
      meterTaskRoutine.play(AppClock);
    };

    AppClock.sched(0.0, { startFunc.value; nil });
    ^this
  }

  // ---------- attach to live audio via '/ampA' or '/ampB' ----------
  testMeter_attach { arg whichChain = \A;
    var attachFunc;

    attachFunc = {
      var meterUserView, oscKeyA, oscKeyB, oscDefAmpA, oscDefAmpB;

      this.testMeter_stop;  // stop prior drivers

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.isNil) { "testMeter_attach: meter not shown—call testMeter_showAtEff first.".warn; ^this };

      // unique OSCdef keys per GUI instance
      oscKeyA = ("mdTmAmpA_" ++ this.identityHash).asSymbol;
      oscKeyB = ("mdTmAmpB_" ++ this.identityHash).asSymbol;

      oscDefAmpA = OSCdef(oscKeyA, { arg msg;
        var leftVal, rightVal, peakVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        peakVal  = max(leftVal, rightVal).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (peakVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampA');

      oscDefAmpB = OSCdef(oscKeyB, { arg msg;
        var leftVal, rightVal, meanVal, smoothVal;
        leftVal  = (msg.size > 3).if({ msg[3] }, { 0 }).asFloat;
        rightVal = (msg.size > 4).if({ msg[4] }, { leftVal }).asFloat;
        meanVal  = ((leftVal + rightVal) * 0.5).clip(0, 1);
        smoothVal = (this.tm2_get(\meterVal, 0.0) * 0.7) + (meanVal * 0.3);
        this.tm2_put(\meterVal, smoothVal);
        AppClock.sched(0.0, { var uv = this.tm2_get(\meterView); if(uv.notNil){ uv.refresh }; nil });
      }, '/ampB');

      this.tm2_put(\oscA, oscDefAmpA);
      this.tm2_put(\oscB, oscDefAmpB);

      // enable only one path
      if(whichChain == \A) { oscDefAmpB.disable } { oscDefAmpA.disable };
    };

    AppClock.sched(0.0, { attachFunc.value; nil });
    ^this
  }

  // ---------- stop drivers (random and OSC) ----------
  testMeter_stop {
    var stopFunc;

    stopFunc = {
      var existingTask, oscDefA, oscDefB;

      existingTask = this.tm2_get(\meterTask);
      if(existingTask.notNil) { existingTask.stop; this.tm2_put(\meterTask, nil) };

      oscDefA = this.tm2_get(\oscA);
      if(oscDefA.notNil) { oscDefA.free; this.tm2_put(\oscA, nil) };

      oscDefB = this.tm2_get(\oscB);
      if(oscDefB.notNil) { oscDefB.free; this.tm2_put(\oscB, nil) };
    };

    AppClock.sched(0.0, { stopFunc.value; nil });
    ^this
  }

  // ---------- remove the meter view ----------
  testMeter_remove {
    var removeFunc;

    removeFunc = {
      var meterUserView;
      // stop activity first
      this.testMeter_stop;

      meterUserView = this.tm2_get(\meterView);
      if(meterUserView.notNil) { meterUserView.remove; this.tm2_put(\meterView, nil) };
    };

    AppClock.sched(0.0, { removeFunc.value; nil });
    ^this
  }
}

===== MagicPedalboard/MagicDisplayGUI_GridDemo.sc =====
// MagicDisplayGUI_GridDemo.sc
// v0.1.6
// MD 20250919-10:46 BST

/*
Purpose
- GridLayout-based GUI for VISUAL-ONLY demos (no audio, meters disabled).
- Row 0: CURRENT | NEXT (two equal columns).
- Rows 1..4: full-width using addSpanning (expectation, countdown, thin meters=30px, processors).
- Extra height only goes to Row 0 (chains row).

Debug
- debugGuides(true): overlays red outlines + row labels; postLayoutReport() prints rects.

Style
- var-first; lowercase; AppClock-only UI ops; no caret returns in closures; no server.sync.
*/

MagicDisplayGUI_GridDemo : MagicDisplay {
	classvar <versionGUI;
	var <window;

	// root + top-level row views (children of window.view)
	var rootLayout;
	var leftPanel, rightPanel;
	var expectationView, countdownHolder, meterStrip, bottomHudView;

	// children within panels
	var leftHeader, leftListView, leftEff;
	var rightHeader, rightListView, rightEff;
	var countdownLabel, countdownBar;
	var bottomCurText, bottomNextText;

	// debug overlay
	var debugOn = false;
	var overlayRow0, overlayRow1, overlayRow2, overlayRow3, overlayRow4;

	var metersEnabled;

	//new
	var <choicesPanel, <choicesTitle, <choicesText;
	var buildChoices;

	*initClass {
		var s;
		versionGUI = "v0.1.5";
		s = "MagicDisplayGUI_GridDemo " ++ versionGUI;
		s.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var reqW, reqH, sb, maxW, maxH, winW, winH, rect;
		var metersRowH, hudRowH;
		var buildLeft, buildRight, buildExpectation, buildCountdown, buildMeters, buildBottomHud;

		// window sizing (fits iPad side-screen limit)
		reqW = 1200; reqH = 760;
		sb   = Window.screenBounds ? Rect(0, 0, 1920, 1080);
		maxW = (2560).min(sb.width);
		maxH = (1666).min(sb.height);
		winW = reqW.clip(640, maxW);
		winH = reqH.clip(480, maxH);
		rect = Rect(
			sb.left + ((sb.width - winW) * 0.5),
			sb.top  + ((sb.height - winH) * 0.5),
			winW, winH
		);

		metersRowH = 30;   // thin strips
		hudRowH    = 88;

		window = Window("MagicDisplayGUI – GridDemo", rect).front.alwaysOnTop_(true);
		metersEnabled = false;

		// root GridLayout on the VIEW (not the Window)
		rootLayout = GridLayout.new;
		window.view.layout = rootLayout;

		// equal columns globally (row 0 uses them)
		rootLayout.setColumnStretch(0, 1);
		rootLayout.setColumnStretch(1, 1);

		// ---- Row 0: CURRENT / NEXT (two equal columns) ----
		buildLeft = {
			var grid;
			grid = GridLayout.new;
			leftPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			leftPanel.layout = grid;

			leftHeader   = StaticText(leftPanel).string_("CHAIN A ACTIVE").align_(\center);
			leftListView = ListView(leftPanel).items_([]);
			leftEff      = StaticText(leftPanel).string_("eff: —").align_(\center);

			grid.add(leftHeader,   0, 0);
			grid.add(leftListView, 1, 0);
			grid.add(leftEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildRight = {
			var grid;
			grid = GridLayout.new;
			rightPanel = CompositeView(window.view).background_(Color(0.92, 0.92, 0.92));
			rightPanel.layout = grid;

			rightHeader   = StaticText(rightPanel).string_("CHAIN B NEXT").align_(\center);
			rightListView = ListView(rightPanel).items_([]);
			rightEff      = StaticText(rightPanel).string_("eff: —").align_(\center);

			grid.add(rightHeader,   0, 0);
			grid.add(rightListView, 1, 0);
			grid.add(rightEff,      2, 0);
			grid.setRowStretch(0, 0);
			grid.setRowStretch(1, 1);
			grid.setRowStretch(2, 0);
		};

		buildLeft.value;
		buildRight.value;
		rootLayout.add(leftPanel,  0, 0);
		rootLayout.add(rightPanel, 0, 1);
		rootLayout.setRowStretch(0, 1); // only row allowed to grow

		// ---- Row 1: expectation (FULL width) ----
		buildExpectation = {
			expectationView = TextView(window.view)
			.background_(Color(1, 1, 0.9))
			.string_("Command:");
		};
		buildExpectation.value;
		// rootLayout.addSpanning(expectationView, 1, 0, 1, 2);
		// rootLayout.setRowStretch(1, 0);
		// rootLayout.setMinRowHeight(1, 36);

		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
		// rootLayout.add(choicesPanel, 4, 0);     // left column
		// rootLayout.add(bottomHudView, 4, 1);    // right column

		// Tweaks for row/column growth
		// rootLayout.setRowStretch(4, 0);         // fixed height for bottom row
		// rootLayout.setMinRowHeight(4, hudRowH); // keep same height as before


		// ---- Row 2: countdown (FULL width) ----
		buildCountdown = {
			var sub;
			countdownHolder = CompositeView(window.view);
			sub = GridLayout.new; countdownHolder.layout = sub;
			countdownLabel = StaticText(countdownHolder).string_("Ready");
			countdownBar   = UserView(countdownHolder);
			sub.add(countdownLabel, 0, 0);
			sub.add(countdownBar,   0, 1);
			sub.setColumnStretch(0, 0);
			sub.setColumnStretch(1, 1);
		};
		buildCountdown.value;
		rootLayout.addSpanning(countdownHolder, 2, 0, 1, 2);
		rootLayout.setRowStretch(2, 0);
		rootLayout.setMinRowHeight(2, 24);

		// ---- Row 3: meters (FULL width; 30 px) ----
		buildMeters = {
			meterStrip = UserView(window.view);
			meterStrip.background = Color(0.96, 0.96, 0.96);
			meterStrip.drawFunc = { |view|
				var b, pad, h, barH, top1, top2;
				b   = view.bounds;
				pad = 8;
				h   = b.height;
				barH = (h - (pad * 2) - 4) / 2;
				barH = barH.clip(8, 14);
				top1 = pad;
				top2 = pad + barH + 4;
				Pen.color = Color.gray(0.3);
				Pen.addRect(Rect(pad, top1, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.5);
				Pen.addRect(Rect(pad, top2, b.width - pad*2, barH)); Pen.fill;
				Pen.color = Color.gray(0.7);
				Pen.strokeRect(Rect(0.5, 0.5, b.width - 1, b.height - 1));
			};
		};
		buildMeters.value;
		rootLayout.addSpanning(meterStrip, 3, 0, 1, 2);
		rootLayout.setRowStretch(3, 0);
		rootLayout.setMinRowHeight(3, metersRowH);

		// new
		// --- Row 4 (left column): Choices panel (new) ---

		buildChoices = {
			var sub; // nested layout for the choices panel

			choicesPanel = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));

			// install a GridLayout into the choices panel
			sub = GridLayout.new;
			choicesPanel.layout = sub;

			choicesTitle = StaticText(choicesPanel)
			.string_("Choices")
			.stringColor_(Color(0.96, 0.96, 0.96));  // was Color(0.12,0.12,0.12) ... what a pain that was.

			choicesText  = TextView(choicesPanel)
			.string_("—")
			.editable_(false)
			.stringColor_(Color(0.96,0.96,0.96))     // add this line
			.hasVerticalScroller_(true)
			.background_(Color(0.98, 0.98, 0.98, 0.96))  // very light
			.stringColor_(Color(0.10, 0.10, 0.10))       // near-black text
			.font_(Font("Menlo", 12));





			// add to nested grid: title on row 0, text on row 1 (stretches)
			sub.add(choicesTitle, 0, 0);
			sub.add(choicesText, 1, 0);
			sub.setRowStretch(0, 0);   // title fixed
			sub.setRowStretch(1, 1);   // text grows to fill
			sub.setColumnStretch(0, 1);
		};
		///////
		buildChoices.value;


		// ---- Row 4: processors (FULL width) ----
		buildBottomHud = {
			var grid, title, curLabel, nextLabel;
			bottomHudView = CompositeView(window.view).background_(Color(0.12, 0.12, 0.12, 0.92));
			grid = GridLayout.new; bottomHudView.layout = grid;

			title          = StaticText(bottomHudView).string_("Processors").stringColor_(Color(0.95, 0.95, 0.95));
			curLabel       = StaticText(bottomHudView).string_("CURRENT:").stringColor_(Color(0.90, 0.90, 0.90));
			bottomCurText  = StaticText(bottomHudView).string_("–").stringColor_(Color(0.90, 0.90, 0.90));
			nextLabel      = StaticText(bottomHudView).string_("NEXT:").stringColor_(Color(0.80, 0.80, 0.80));
			bottomNextText = StaticText(bottomHudView).string_("–").stringColor_(Color(0.80, 0.80, 0.80));

			grid.add(title,          0, 0, 1, 2);
			grid.add(curLabel,       1, 0);
			grid.add(bottomCurText,  1, 1);
			grid.add(nextLabel,      2, 0);
			grid.add(bottomNextText, 2, 1);
			grid.setColumnStretch(0, 0);
			grid.setColumnStretch(1, 1);
			grid.hSpacing = 10;
			grid.vSpacing = 4;
		};

		/////////
		buildBottomHud.value;

		// rootLayout.add(choicesPanel, 4, 0);   // left column
		// rootLayout.add(bottomHudView, 4, 1);  // right column
		rootLayout.setRowStretch(4, 0);
		rootLayout.setMinRowHeight(4, hudRowH);

/*        rootLayout.addSpanning(bottomHudView, 4, 0, 1, 2);
        rootLayout.setRowStretch(4, 0);
        rootLayout.setMinRowHeight(4, hudRowH);*/

		//new
		// Put Choices (left) and Processors HUD (right) side-by-side on Row 4
/*		rootLayout.add(choicesPanel, 4, 0);     // left column
		rootLayout.add(bottomHudView, 4, 1);    // right column
		rootLayout.setRowStretch(4, 0);         // fixed bottom-row height
		rootLayout.setMinRowHeight(4, hudRowH);*/


		this.attachResizeHandler;
		^this
	}

	// -------- Public (visual-only) --------
	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var fmt, effCText, effNText, aIsCurrent;

		fmt = { arg listRef, bypassKeys, effList;
			var itemsOut, lastIndex, processors, indexCounter;
			itemsOut = Array.new;
			lastIndex = listRef.size - 1;
			itemsOut = itemsOut.add("src : " ++ listRef[lastIndex]);
			if(listRef.size > 2) {
				itemsOut = itemsOut.add("procs:");
				processors = listRef.copyRange(1, lastIndex - 1).reverse;
				indexCounter = 1;
				processors.do({ arg key;
					var byp, badge, lineText;
					byp = bypassKeys.includes(key);
					badge = byp.if({ "[BYP]" }, { "[ON]" });
					lineText = " [" ++ indexCounter ++ "] " ++ key ++ " " ++ badge;
					itemsOut = itemsOut.add(lineText);
					indexCounter = indexCounter + 1;
				});
			}{
				itemsOut = itemsOut.add("procs: (none)");
			};
			itemsOut = itemsOut.add("sink : " ++ listRef[0]);
			itemsOut
		};

		effCText = "eff: " ++ effCurrent.join(" -> ");
		effNText = "eff: " ++ effNext.join(" -> ");

		if(leftListView.notNil)  { leftListView.items_(fmt.value(current, bypassAKeys, effCurrent)) };
		if(rightListView.notNil) { rightListView.items_(fmt.value(next,    bypassBKeys, effNext))    };
		if(leftEff.notNil)  { leftEff.string_(effCText) };
		if(rightEff.notNil) { rightEff.string_(effNText) };

		aIsCurrent = (current[0] == \chainA);
		if(leftHeader.notNil)  { leftHeader.string_((aIsCurrent).if({ "CHAIN A ACTIVE" }, { "CHAIN A NEXT" })) };
		if(rightHeader.notNil) { rightHeader.string_((aIsCurrent).if({ "CHAIN B NEXT"   }, { "CHAIN B ACTIVE" })) };

		// no .trim (SC String has no trim); keep plain join
		if(bottomCurText.notNil)  { bottomCurText.string_(" " ++ effCurrent.copyRange(1, effCurrent.size-1).join(" -> ")) };
		if(bottomNextText.notNil) { bottomNextText.string_(" " ++ effNext.copyRange(1, effNext.size-1).join(" -> ")) };

		^this
	}

	highlightCurrentColumn { arg currentSinkSym;
		var greenBg, neutralBg, isA;
		greenBg   = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		isA = (currentSinkSym == \chainA);
		if(leftPanel.notNil)  { leftPanel.background_((isA).if({ greenBg }, { neutralBg })) };
		if(rightPanel.notNil) { rightPanel.background_((isA).if({ neutralBg }, { greenBg })) };
		^this
	}

/*    showExpectation { arg textString, seconds = 0;
        var secs;
        secs = seconds ? 0;
        if(expectationView.notNil) { expectationView.string_(textString.asString) };
        if(countdownLabel.notNil)  { countdownLabel.string_((secs > 0).if({ "Listen in… (" ++ secs ++ "s)" }, { "Ready" })) };
        ^this
    }*/

	showExpectation { |text, seconds = 0|
		var messageText;

		messageText = text.asString;
		this.queueUi({
			if (expectationView.notNil) { expectationView.string = messageText };
		});
		this
	}

	//new:
	// Add inside MagicDisplayGUI_GridDemo class:
	setOperations { arg itemsArray;
		var s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
		AppClock.sched(0.0, {
			if(choicesText.notNil) {
				choicesText.string_( (s.size > 0).if({ s }, { "—" }) );
				// Re-assert color to be safe across themes (match dark/light choice you used)
				choicesText.stringColor_(Color(0.96, 0.96, 0.96));  // dark panel
				// or choicesText.stringColor_(Color(0.10, 0.10, 0.10));  // light panel
			}{
				if(expectationView.notNil) {
					expectationView.string_("Choices:\n" ++ ((s.size > 0).if({ s }, { "—" })));
				};
			};
			nil
		});
		^this
	}




	enableMeters { arg flag = false; metersEnabled = (flag ? false); ^this }

	attachResizeHandler {
		var run;
		run = {
			var v;
			v = window.tryPerform(\view);
			if(v.notNil) {
				v.onResize = {
					if(debugOn) { this.debugGuides(true) };
				};
			};
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	// -------- Debug overlay --------

	debugGuides { arg on = true;
		var mkOverlay, labelText;
		debugOn = (on ? true);

		mkOverlay = { arg ov;
			var out;
			out = ov;
			if(out.isNil or: { out.isClosed }) {
				out = UserView(window.view);
				out.drawFunc = { |v|
					var b;
					b = v.bounds;
					Pen.color = Color(1, 0, 0, 0.35);
					Pen.width = 2;
					Pen.strokeRect(Rect(1, 1, b.width - 2, b.height - 2));
				};
				out.background = Color.clear;
			};
			out
		};

		AppClock.sched(0.00, {
			overlayRow0 = mkOverlay.value(overlayRow0);
			overlayRow1 = mkOverlay.value(overlayRow1);
			overlayRow2 = mkOverlay.value(overlayRow2);
			overlayRow3 = mkOverlay.value(overlayRow3);
			overlayRow4 = mkOverlay.value(overlayRow4);

			rootLayout.addSpanning(overlayRow0, 0, 0, 1, 2);
			rootLayout.addSpanning(overlayRow1, 1, 0, 1, 2);
			rootLayout.addSpanning(overlayRow2, 2, 0, 1, 2);
			rootLayout.addSpanning(overlayRow3, 3, 0, 1, 2);
			rootLayout.addSpanning(overlayRow4, 4, 0, 1, 2);

			AppClock.sched(0.02, {
				var r0, r1, r2, r3, r4;
				var mkLabel;
				mkLabel = { arg parent, text;
					var st;
					st = StaticText(parent).string_(text).stringColor_(Color(1, 0.2, 0.2)).align_(\left);
					st.background = Color(1, 1, 1, 0.20);
					st  // no caret return in closures
				};

				overlayRow0.children.do(_.remove);
				overlayRow1.children.do(_.remove);
				overlayRow2.children.do(_.remove);
				overlayRow3.children.do(_.remove);
				overlayRow4.children.do(_.remove);

				r0 = overlayRow0.bounds; r1 = overlayRow1.bounds; r2 = overlayRow2.bounds; r3 = overlayRow3.bounds; r4 = overlayRow4.bounds;
				mkLabel.value(overlayRow0, "row 0  " ++ r0.width.round(1) ++ "×" ++ r0.height.round(1));
				mkLabel.value(overlayRow1, "row 1  " ++ r1.width.round(1) ++ "×" ++ r1.height.round(1));
				mkLabel.value(overlayRow2, "row 2  " ++ r2.width.round(1) ++ "×" ++ r2.height.round(1));
				mkLabel.value(overlayRow3, "row 3  " ++ r3.width.round(1) ++ "×" ++ r3.height.round(1) ++ " (meters)");
				mkLabel.value(overlayRow4, "row 4  " ++ r4.width.round(1) ++ "×" ++ r4.height.round(1) ++ " (processors)");
				nil
			});
			nil
		});

		^this
	}

	postLayoutReport {
		var run;
		run = {
			var r0, r1, r2, r3, r4, unionRow0;
			unionRow0 = leftPanel.bounds.union(rightPanel.bounds);
			r0 = unionRow0; r1 = expectationView.bounds; r2 = countdownHolder.bounds; r3 = meterStrip.bounds; r4 = bottomHudView.bounds;
			("[layout] row0=" ++ r0).postln;
			("[layout] row1=" ++ r1).postln;
			("[layout] row2=" ++ r2).postln;
			("[layout] row3=" ++ r3).postln;
			("[layout] row4=" ++ r4).postln;
			nil
		};
		AppClock.sched(0.00, { run.value; nil });
		^this
	}

	updateTextField { |box, msg|
		// fallback: write to expectationView only
		if(expectationView.notNil) {
			expectationView.string_("[" ++ box.asString ++ "] " ++ msg.asString);
		};
		^this;
	}



	//new
	// Add inside MagicDisplayGUI_GridDemo class:
	// setOperations { arg itemsArray;
	// 	var s;
	// 	// build a visible list; accept nil and non-strings defensively
	// 	s = (itemsArray ? []).collect({ |x| x.asString }).join("\n");
	// 	if(choicesText.notNil) {
	// 		AppClock.sched(0.0, {
	// 			choicesText.string_( (s.size > 0).if({ s }, { "—" }) );
	// 			nil
	// 		});
	// 	};
	// 	^this
	// }

}

===== MagicPedalboard/MagicDisplayGUI.sc =====
/* MagicDisplayGUI.sc v0.2.7
 CURRENT column highlighted in green; top-down list (src → procs → sink);
 expectation text + visual countdown; operations list with 3s pre-roll;
 embedded meters (A/B). UI-ready queue prevents touching nil views.
 No server.sync; server ops inside Server.default.bind.
 // MD 20250912-1738
*/
MagicDisplayGUI : MagicDisplay {
	classvar <versionGUI;

	var <window;

	// layout elements
	var leftPanel, rightPanel;
	var leftHeader, rightHeader;
	var leftListView, rightListView;
	var leftEffective, rightEffective;

	// expectation + countdown
	var expectationText;
	var countdownLabel, countdownBarView, countdownTask, countdownSecondsDefault;

	// operations panel
	var opsListView, opsNextButton, opsStatusText;
	var opsItems, opsIndexNext, opsCallback, opsCountdownSeconds;

	// meters
	var meterViewA, meterViewB;
	var meterSynthA, meterSynthB, oscA, oscB;
	var enableMetersFlag;

	// ui-ready machinery
	var uiReadyFlag;
	var uiPendingActions;

	*initClass {
		var text;
		versionGUI = "v0.2.7";
		text = "MagicDisplayGUI " ++ versionGUI;
		text.postln;
	}

	*new { arg level = 1;
		var instance;
		instance = super.new(level);
		^instance.initGui;
	}

	initGui {
		var windowRect, panelWidth, listHeight, headerHeight, footerHeight, pad;
		var opsWidth, opsRect;
		var buildWindow;

		windowRect = Rect(100, 100, 980, 520);
		panelWidth = 300;
		listHeight = 300;
		headerHeight = 28;
		footerHeight = 22;
		pad = 10;

		opsWidth = 320;
		opsRect = Rect(2 * pad + 2 * panelWidth + 40, pad, opsWidth, windowRect.height - 2 * pad);

		countdownSecondsDefault = 3.0;
		opsCountdownSeconds = 3.0;
		enableMetersFlag = true;

		uiReadyFlag = false;
		uiPendingActions = Array.new;

		buildWindow = {
			var metersHeight, greenBg, neutralBg;
			var buildColumn, buildMeters, applyInitialHighlight;
			var columnLeftX, columnRightX;
			var columnLeftDict, columnRightDict;

			metersHeight = 86;
			greenBg = Color(0.85, 1.0, 0.85);
			neutralBg = Color(0.92, 0.92, 0.92);

			columnLeftX = pad;
			columnRightX = pad + panelWidth + 40;

			buildColumn = { arg xPos, title;
				var panel, header, listView, effectiveLabel;
				var headerRect, listRect, effRect, resultDict;

				panel = CompositeView(window, Rect(xPos, pad, panelWidth, windowRect.height - 2 * pad - metersHeight));
				panel.background_(neutralBg);

				headerRect = Rect(0, 0, panelWidth, headerHeight);
				header = StaticText(panel, headerRect).string_(title);
				header.align_(\center);

				listRect = Rect(0, headerHeight + 6, panelWidth, listHeight);
				listView = ListView(panel, listRect).items_([]);

				effRect = Rect(0, headerHeight + 6 + listHeight + 6, panelWidth, footerHeight);
				effectiveLabel = StaticText(panel, effRect).string_("eff: —");
				effectiveLabel.align_(\center);

				resultDict = (panel: panel, header: header, list: listView, eff: effectiveLabel);
				resultDict
			};

			buildMeters = {
				var metersGroup, labelA, labelB, row1, row2, labelWidth, barWidth, rowHeight;

				labelWidth = 60;
				barWidth = windowRect.width - 2 * pad - labelWidth - 10;
				rowHeight = 30;

				metersGroup = CompositeView(window, Rect(pad, windowRect.height - metersHeight - pad, windowRect.width - 2 * pad, metersHeight));
				metersGroup.background_(Color(0.96, 0.96, 0.96));

				row1 = CompositeView(metersGroup, Rect(0, 0, metersGroup.bounds.width, rowHeight));
				labelA = StaticText(row1, Rect(0, 4, labelWidth, 20)).string_("chainA");
				meterViewA = LevelIndicator(row1, Rect(labelWidth + 6, 4, barWidth, 20));

				row2 = CompositeView(metersGroup, Rect(0, rowHeight + 8, metersGroup.bounds.width, rowHeight));
				labelB = StaticText(row2, Rect(0, 4, labelWidth, 20)).string_("chainB");
				meterViewB = LevelIndicator(row2, Rect(labelWidth + 6, 4, barWidth, 20));
			};

			applyInitialHighlight = {
				var currentBg, nextBg;
				currentBg = greenBg;
				nextBg = neutralBg;
				if(leftPanel.notNil) { leftPanel.background_(currentBg) };
				if(rightPanel.notNil) { rightPanel.background_(nextBg) };
			};

			window = Window("MagicDisplayGUI – CURRENT / NEXT", windowRect).front.alwaysOnTop_(true);

			columnLeftDict = buildColumn.value(columnLeftX, "CURRENT");
			leftPanel      = columnLeftDict[\panel];
			leftHeader     = columnLeftDict[\header];
			leftListView   = columnLeftDict[\list];
			leftEffective  = columnLeftDict[\eff];

			columnRightDict = buildColumn.value(columnRightX, "NEXT");
			rightPanel      = columnRightDict[\panel];
			rightHeader     = columnRightDict[\header];
			rightListView   = columnRightDict[\list];
			rightEffective  = columnRightDict[\eff];

			expectationText = TextView(window, Rect(pad, leftPanel.bounds.bottom + 6, 2 * panelWidth + 40, 52));
			expectationText.background_(Color(1, 1, 0.9));
			expectationText.string_("Command:");

			countdownLabel = StaticText(window, Rect(pad, expectationText.bounds.bottom + 6, 120, 20)).string_("Ready");

			countdownBarView = UserView(window, Rect(pad + 130, expectationText.bounds.bottom + 6, panelWidth - 10, 20));
			countdownBarView.background_(Color(0.9, 0.9, 0.9));
			countdownBarView.drawFunc_({ arg view;
				var barWidthNow, fullWidth, progressFraction, colorFill, progressStored;
				progressStored = view.getProperty(\progress) ? 0.0;
				progressFraction = progressStored.clip(0, 1);
				fullWidth = view.bounds.width;
				barWidthNow = fullWidth * progressFraction;
				colorFill = Color(0.3, 0.8, 0.3);
				Pen.fillColor = colorFill;
				Pen.addRect(Rect(0, 0, barWidthNow, view.bounds.height));
				Pen.fill;
			});
			countdownBarView.setProperty(\progress, 0.0);

			opsItems = Array.new;
			opsIndexNext = 0;
			opsCallback = nil;

			opsListView = ListView(window, opsRect).items_([]);
			opsStatusText = StaticText(window, Rect(opsRect.left, opsRect.bottom - 52, opsRect.width - 110, 20)).string_("Next: —");
			opsNextButton = Button(window, Rect(opsRect.right - 100, opsRect.bottom - 56, 100, 28))
			.states_([["Next (3s)", Color.white, Color(0, 0.5, 0)]])
			.action_({
				var nextIndexLocal, totalCountLocal, nextLabel;
				nextIndexLocal = opsIndexNext;
				totalCountLocal = opsItems.size;
				if(nextIndexLocal >= totalCountLocal) { "No more operations.".postln; ^nil };
				nextLabel = opsItems[nextIndexLocal];
				this.startCountdown(opsCountdownSeconds, "Next: " ++ nextLabel, {
					var clampedIndex;
					clampedIndex = opsIndexNext.clip(0, opsItems.size - 1);
					this.runNextOperation(clampedIndex);
				});
			});

			buildMeters.value;
			applyInitialHighlight.value;

			uiReadyFlag = true;
			this.flushUiPendingActions;
		};

		AppClock.sched(0, {
			var enableNow;
			buildWindow.value;
			enableNow = enableMetersFlag;
			if(enableNow) { this.enableMeters(true) };
			nil
		});

		^this
	}

	// ui-ready helpers
	queueUi { arg func;
		var fn;
		fn = func;
		if(uiReadyFlag) {
			AppClock.sched(0, { fn.value; nil });
		}{
			uiPendingActions = uiPendingActions.add(fn);
		};
	}

	flushUiPendingActions {
		var actionsToRun;
		actionsToRun = uiPendingActions;
		uiPendingActions = Array.new;
		actionsToRun.do({ arg f;
			AppClock.sched(0, { f.value; nil });
		});
	}


	// visuals

// highlight whichever sink is CURRENT
highlightCurrentColumn { arg currentSinkSym;
    var greenBg, neutralBg, isA;
    greenBg   = Color(0.85, 1.0, 0.85);
    neutralBg = Color(0.92, 0.92, 0.92);
    isA = (currentSinkSym == \chainA);

    this.queueUi({
        if(leftPanel.notNil)  { leftPanel.background_(if(isA) { greenBg } { neutralBg }) };
        if(rightPanel.notNil) { rightPanel.background_(if(isA) { neutralBg } { greenBg }) };
    });
}

/*	highlightCurrentColumn {
		var greenBg, neutralBg;
		greenBg = Color(0.85, 1.0, 0.85);
		neutralBg = Color(0.92, 0.92, 0.92);
		this.queueUi({
			if(leftPanel.notNil) { leftPanel.background_(greenBg) };
			if(rightPanel.notNil) { rightPanel.background_(neutralBg) };
		});
	}*/

	formatListTopDown { arg listRef, bypassKeys, effectiveList;
		var itemsOut, lastIndex, processorsList, indexCounter, sourceKey, sinkKey, isBypassed, badge, lineText;
		itemsOut = Array.new;
		lastIndex = listRef.size - 1;
		sinkKey = listRef[0];
		sourceKey = listRef[lastIndex];

		itemsOut = itemsOut.add("src  : " ++ sourceKey);

		if(listRef.size > 2) {
			itemsOut = itemsOut.add("procs:");
			processorsList = listRef.copyRange(1, lastIndex - 1).reverse;
			indexCounter = 1;
			processorsList.do({ arg procKey;
				isBypassed = bypassKeys.includes(procKey);
				badge = if(isBypassed) { "[BYP]" } { "[ON]" };
				lineText = "  [" ++ indexCounter ++ "] " ++ procKey ++ " " ++ badge;
				itemsOut = itemsOut.add(lineText);
				indexCounter = indexCounter + 1;
			});
		}{
			itemsOut = itemsOut.add("procs: (none)");
		};

		itemsOut = itemsOut.add("sink : " ++ sinkKey);
		itemsOut = itemsOut.add("eff  : " ++ effectiveList.join(" -> "));
		^itemsOut
	}

	// expectation + countdown
	showExpectation { arg textString, seconds = 0;
		var secondsLocal, hasCountdown;
		secondsLocal = seconds ? 0;
		hasCountdown = secondsLocal > 0;

		this.queueUi({
			var labelNow;
			if(expectationText.notNil) { expectationText.string_(textString.asString) };
			if(hasCountdown) {
				this.startCountdown(secondsLocal, "Listen in…", { nil });
			}{
				labelNow = "Ready";
				if(countdownLabel.notNil) { countdownLabel.string_(labelNow) };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, 0.0);
					countdownBarView.refresh;
				};
			};
		});
	}

	startCountdown { arg seconds, labelText, onFinishedFunc;
		var secondsClamped, startTime, stopTime;
		secondsClamped = seconds.clip(0.5, 10.0);
		startTime = Main.elapsedTime;
		stopTime = startTime + secondsClamped;

		if(countdownTask.notNil) { countdownTask.stop; countdownTask = nil };

		this.queueUi({
			var finishedFlag, delaySeconds, updateAndCheckDone;

			if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ secondsClamped.asString ++ "s)") };
			if(countdownBarView.notNil) {
				countdownBarView.setProperty(\progress, 0.0);
				countdownBarView.refresh;
			};

			finishedFlag = false;
			delaySeconds = 0.05;

			updateAndCheckDone = {
				var nowTime, remainingSeconds, progressFraction;
				nowTime = Main.elapsedTime;
				remainingSeconds = (stopTime - nowTime).max(0);
				progressFraction = ((secondsClamped - remainingSeconds) / secondsClamped).clip(0.0, 1.0);

				if(countdownLabel.notNil) { countdownLabel.string_(labelText.asString ++ " (" ++ remainingSeconds.round(0.1).asString ++ "s)") };
				if(countdownBarView.notNil) {
					countdownBarView.setProperty(\progress, progressFraction);
					countdownBarView.refresh;
				};

				if(remainingSeconds <= 0) { finishedFlag = true };
			};

			countdownTask = Task({
				var localFinished;
				localFinished = false;
				while({ localFinished.not }, {
					updateAndCheckDone.value;
					localFinished = finishedFlag;
					delaySeconds.wait;
				});
				if(countdownLabel.notNil) { countdownLabel.string_("Now") };
				if(onFinishedFunc.notNil) { onFinishedFunc.value };
			}, AppClock).play;
		});
	}

	// operations
	setOperations { arg itemsArray;
		var itemsSafe, entryStrings;
		itemsSafe = itemsArray ? Array.new;
		entryStrings = itemsSafe.collect({ arg it; it.asString });

		this.queueUi({
			opsItems = entryStrings;
			if(opsListView.notNil) { opsListView.items_(opsItems) };
			opsIndexNext = 0;
			this.updateOpsHighlight;
		});
	}

	setNextAction { arg func;
		var f;
		f = func;
		opsCallback = f;
	}

	runNextOperation { arg indexToRun;
		var totalCount, nextIndexComputed;
		totalCount = opsItems.size;

		if(opsCallback.notNil) {
			opsCallback.value(indexToRun);
		}{
			("[ops] No callback for index " ++ indexToRun).warn;
		};

		nextIndexComputed = (indexToRun + 1).clip(0, totalCount);
		opsIndexNext = nextIndexComputed;
		this.updateOpsHighlight;
	}

	updateOpsHighlight {
		var totalCount, entryStrings, nextIndexLocal, statusText;
		totalCount = opsItems.size;
		nextIndexLocal = opsIndexNext.min(totalCount);

		entryStrings = opsItems.collect({ arg item, idx;
			var marker;
			marker = if(idx == opsIndexNext) { "→ " } { "   " };
			marker ++ item
		});

		statusText = if(opsIndexNext < totalCount) {
			"Next: " ++ opsItems[opsIndexNext]
		}{
			"Done."
		};

		this.queueUi({
			if(opsListView.notNil) { opsListView.items_(entryStrings) };
			if(opsStatusText.notNil) { opsStatusText.string_(statusText) };
		});
	}

	/////////////////
	// meters
	// --- canonical enableMeters: waits until sinks are audio-rate, then attaches meters ---
// MagicDisplayGUI.sc
// canonical enableMeters: resend SynthDefs every time; wait until sinks are audio-rate

	enableMeters { arg flag = true;
    var shouldEnable, busA, busB;

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        // Guard: wait until sinks are audio-rate and server is up
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        if(
            Server.default.serverRunning.not
            or: { busA.isNil or: { busB.isNil } }
            or: { busA.rate != \audio or: { busB.rate != \audio } }
        ) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };

        // Meters rely on SynthDefs provided by MagicDisplay.ensureMeterDefs(...)
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };
            meterSynthA = Synth(\busMeterA, [\inBus, Ndef(\chainA).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, Ndef(\chainB).bus.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free }; if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');

        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');

        ^this;
    }{
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}

/*
enableMeters { arg flag = true;
    var shouldEnable, aOK, bOK, busA, busB;

    // When enabling, wait until sinks are audio-rate (no control-rate bus warnings)
    if(flag) {
        busA = Ndef(\chainA).bus;
        busB = Ndef(\chainB).bus;
        aOK = busA.notNil and: { busA.rate == \audio };
        bOK = busB.notNil and: { busB.rate == \audio };
        if(aOK.not or: { bOK.not }) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
        // Also guard against server being off
        if(Server.default.serverRunning.not) {
            AppClock.sched(0.20, { this.enableMeters(true); nil });
            ^this;
        };
    };

    shouldEnable = flag ? true;
    enableMetersFlag = shouldEnable;

    if(shouldEnable) {
        Server.default.bind({
            var busA_local, busB_local;

            // Always (re)send SynthDefs so they exist on the server now.
            SynthDef(\busMeterA, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
            }).add;
            SynthDef(\busMeterB, { arg inBus, rate = 15;
                var sig = In.ar(inBus, 2);
                var amp = Amplitude.ar(sig).clip(0, 1);
                SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
            }).add;

            if(meterSynthA.notNil) { meterSynthA.free };
            if(meterSynthB.notNil) { meterSynthB.free };

            busA_local = Ndef(\chainA).bus;
            busB_local = Ndef(\chainB).bus;

            meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
            meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
                target: Server.default.defaultGroup, addAction: \addToTail);
        });

        if(oscA.notNil) { oscA.free };
        if(oscB.notNil) { oscB.free };
        oscA = OSCdef(\ampA, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
        }, '/ampA');
        oscB = OSCdef(\ampB, { arg msg;
            var leftAmp, rightAmp, levelAvg;
            leftAmp = msg[3]; rightAmp = msg[4];
            levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
            AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
        }, '/ampB');
        ^this;

    } {
        Server.default.bind({
            if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
            if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
        });
        if(oscA.notNil) { oscA.free; oscA = nil; };
        if(oscB.notNil) { oscB.free; oscB = nil; };
        AppClock.sched(0, {
            if(meterViewA.notNil) { meterViewA.value_(0.0) };
            if(meterViewB.notNil) { meterViewB.value_(0.0) };
            nil
        });
        ^this;
    };
}*/
//////
/*	enableMeters { arg flag = true;
		var shouldEnable, aOK, bOK, busA, busB;

		// Only guard when enabling
		if(flag) {
			// read buses once
			busA = Ndef(\chainA).bus;
			busB = Ndef(\chainB).bus;
			// both must exist and be audio-rate
			aOK = busA.notNil and: { busA.rate == \audio };
			bOK = busB.notNil and: { busB.rate == \audio };
			if(aOK.not or: { bOK.not }) {
				// retry shortly on AppClock; do not mutate the audio tree here
				AppClock.sched(0.20, { this.enableMeters(true); nil });
				^this;
			};
		};

		shouldEnable = flag ? true;
		enableMetersFlag = shouldEnable;

		if(shouldEnable) {
			// --- enable path (unchanged except for the pre-check above) ---
			Server.default.bind({
				var hasA, hasB, busA_local, busB_local;
				hasA = SynthDescLib.global.at(\busMeterA).notNil;
				hasB = SynthDescLib.global.at(\busMeterB).notNil;
				if(hasA.not) {
					SynthDef(\busMeterA, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampA', A2K.kr(amp));
					}).add;
				};
				if(hasB.not) {
					SynthDef(\busMeterB, { arg inBus, rate = 15;
						var sig, amp;
						sig = In.ar(inBus, 2);
						amp = Amplitude.ar(sig).clip(0, 1);
						SendReply.kr(Impulse.kr(rate), '/ampB', A2K.kr(amp));
					}).add;
				};
				if(meterSynthA.notNil) { meterSynthA.free };
				if(meterSynthB.notNil) { meterSynthB.free };
				// read buses post-guard
				busA_local = Ndef(\chainA).bus;
				busB_local = Ndef(\chainB).bus;
				meterSynthA = Synth(\busMeterA, [\inBus, busA_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
				meterSynthB = Synth(\busMeterB, [\inBus, busB_local.index, \rate, 24],
					target: Server.default.defaultGroup, addAction: \addToTail);
			});

			if(oscA.notNil) { oscA.free };
			if(oscB.notNil) { oscB.free };
			oscA = OSCdef(\ampA, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewA.notNil) { meterViewA.value_(levelAvg) }; nil });
			}, '/ampA');
			oscB = OSCdef(\ampB, { arg msg;
				var leftAmp, rightAmp, levelAvg;
				leftAmp = msg[3]; rightAmp = msg[4];
				levelAvg = ((leftAmp + rightAmp) * 0.5).clip(0, 1);
				AppClock.sched(0, { if(meterViewB.notNil) { meterViewB.value_(levelAvg) }; nil });
			}, '/ampB');
			^this;

		} {
			// --- disable path (unchanged) ---
			Server.default.bind({
				if(meterSynthA.notNil) { meterSynthA.free; meterSynthA = nil; };
				if(meterSynthB.notNil) { meterSynthB.free; meterSynthB = nil; };
			});
			if(oscA.notNil) { oscA.free; oscA = nil; };
			if(oscB.notNil) { oscB.free; oscB = nil; };
			AppClock.sched(0, {
				if(meterViewA.notNil) { meterViewA.value_(0.0) };
				if(meterViewB.notNil) { meterViewB.value_(0.0) };
				nil
			});
			^this;
		};
	}
*/

	///////////////

	// display hooks
	showInit { arg pedalboard, versionString, current, next;
		var titleText;
		titleText = "MagicDisplayGUI – " ++ versionString;
		this.queueUi({
			if(window.notNil) { window.name_(titleText) };
		});
	}

	showRebuild { arg which, fullChain, effective;
		var infoText;
		infoText = "[MPB:rebuild:" ++ which ++ "] full=" ++ fullChain ++ " effective=" ++ effective;
		AppClock.sched(0, { infoText.postln; nil });
	}

	showPlay { arg sinkKey;
		var text;
		text = "[MPB:play] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showStop { arg sinkKey;
		var text;
		text = "[MPB:stop] sink=" ++ sinkKey;
		AppClock.sched(0, { text.postln; nil });
	}

	showSwitch { arg oldSink, newSink, current, next;
    var infoText;
    infoText = "[MPB:switch] " ++ oldSink ++ " → " ++ newSink;
    this.queueUi({
        // was: this.highlightCurrentColumn;
        this.highlightCurrentColumn(newSink);               // <-- pass which sink is now CURRENT

        if(opsStatusText.notNil) {
            opsStatusText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
        }{
            if(expectationText.notNil) {
                expectationText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
            };
        };
    });
    AppClock.sched(0, { infoText.postln; nil });
}

	// showSwitch { arg oldSink, newSink, current, next;
	// 	var infoText;
	// 	infoText = "[MPB:switch] " ++ oldSink ++ " → " ++ newSink;
	// 	this.queueUi({
	// 		// keep window title stable; show transient text in labels instead
	// 		this.highlightCurrentColumn;
	// 		if(opsStatusText.notNil) {
	// 			opsStatusText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
	// 		}{
	// 			if(expectationText.notNil) {
	// 				expectationText.string_("Switched: " ++ oldSink ++ " → " ++ newSink);
	// 			};
	// 		};
	// 	});
	// 	AppClock.sched(0, { infoText.postln; nil });
	// }


	showMutation { arg action, args, nextChain;
		var text;
		text = "[MPB:mutate] " ++ action ++ " " ++ args ++ " next=" ++ nextChain;
		AppClock.sched(0, { text.postln; nil });
	}

	showBypass { arg which, key, state, chain, bypassKeys;
		var text;
		text = "[MPB:bypass:" ++ which ++ "] " ++ key ++ " -> " ++ state ++ " active=" ++ bypassKeys;
		AppClock.sched(0, { text.postln; nil });
	}

	showReset { arg current, next;
		var text;
		text = "[MPB:reset] current=" ++ current ++ " next=" ++ next;
		AppClock.sched(0, { text.postln; nil });
	}

	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
    var currentItems, nextItems, effCurrentText, effNextText, aIsPlaying, bIsPlaying, aIsCurrent;

    currentItems   = this.formatListTopDown(current, bypassAKeys, effCurrent);
    nextItems      = this.formatListTopDown(next,   bypassBKeys, effNext);
    effCurrentText = "eff: " ++ effCurrent.join(" -> ");
    effNextText    = "eff: " ++ effNext.join(" -> ");

    // detect which sink is CURRENT by the actual play state of the sink Ndef
    aIsPlaying = Ndef(\chainA).isPlaying;
    bIsPlaying = Ndef(\chainB).isPlaying;
    aIsCurrent = (aIsPlaying and: { bIsPlaying.not });  // Option A expects XOR; if both stopped, keep previous
    this.queueUi({
        if(leftHeader.notNil)  { leftHeader.string_(if(aIsCurrent) { "CHAIN A ACTIVE" } { "CHAIN A NEXT" }) };
        if(rightHeader.notNil) { rightHeader.string_(if(aIsCurrent) { "CHAIN B NEXT"  } { "CHAIN B ACTIVE" }) };

        if(leftListView.notNil)  { leftListView.items_(currentItems) };
        if(rightListView.notNil) { rightListView.items_(nextItems) };

        if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
        if(rightEffective.notNil) { rightEffective.string_(effNextText) };
    });
}

/*	showChainsDetailed { arg current, next, bypassAKeys, bypassBKeys, effCurrent, effNext;
		var currentItems, nextItems, effCurrentText, effNextText;
		currentItems = this.formatListTopDown(current, bypassAKeys, effCurrent);
		nextItems = this.formatListTopDown(next,   bypassBKeys, effNext);
		effCurrentText = "eff: " ++ effCurrent.join(" -> ");
		effNextText    = "eff: " ++ effNext.join(" -> ");

		this.queueUi({
			if(leftHeader.notNil)  { leftHeader.string_("CHAIN A ACTIVE") };
			if(rightHeader.notNil) { rightHeader.string_("CHAIN B NEXT") };
			if(leftListView.notNil)  { leftListView.items_(currentItems) };
			if(rightListView.notNil) { rightListView.items_(nextItems) };
			if(leftEffective.notNil)  { leftEffective.string_(effCurrentText) };
			if(rightEffective.notNil) { rightEffective.string_(effNextText) };
		});
	}*/

	showError { arg message;
		var text;
		text = "[MPB:error] " ++ message;
		AppClock.sched(0, { text.warn; nil });
	}
}

===== MagicPedalboard/MagicPedalboard.sc =====
/* MagicPedalboard.sc v0.4.9
 A/B pedalboard chain manager built on Ndefs.
 - Chains are Arrays of Symbols ordered [sink, …, source].
 - Uses JITLib embedding: Ndef(left) <<> Ndef(right).
 - Creates two sinks: \chainA and \chainB, and plays the current chain on init.
 - Most mutators act on the next chain; explicit current-chain bypass helpers are provided.
 - Optional display adaptor (MagicDisplay / MagicDisplayGUI) receives notifications, including detailed chain views.
 - Non-destructive rebuilds (no server resets during rebuild). Only .reset performs a safe server-tree reset.
// MD 2025-10-02 13:58
*/

/*
Supplementary header — What this class does & key dependencies
----------------------------------------------------------------
Overview
- Manages two signal chains (CURRENT and NEXT) as symbol arrays [sink, processors..., source],
  built with JITLib NodeProxies (Ndef) and connected using the embedding operator:
  Ndef(left) <<> Ndef(right). Switches are crossfaded; rebuilds are non-destructive.

Core responsibilities
- Materialize and keep \chainA / \chainB sinks alive at audio rate.
- Maintain CURRENT vs NEXT chains, with mutators that operate primarily on NEXT (e.g., add/remove/swap/bypass).
- Provide safe, exclusive playback semantics (NEXT hard-silenced; CURRENT audible) and optional crossfade switch.

Relies on (classes / facilities expected on the classpath)
- JITLib / NodeProxy system: Ndef, embedding via <<>.
- SuperCollider server primitives: Server, Ndef buses, AppClock for light scheduling.
- Optional display adaptor (MagicDisplay / MagicDisplayGUI) for chain prints, status, and meter UX.
- Optional processor library (processorLib) that can .ensureFromChain(list, numChannels).

External interactions
- This class does not reset the server during rebuild; only .reset implements a guarded tree reset.
- Exposes a simple dispatcher .handleCommand(path) that defers to ~ct_applyOSCPathToMPB if present.

Notes
- This update only adds class-side utilities (*help, *api, *test) and a supplementary header.
- No behavior changes to public or internal instance methods (including the existing instance help).
*/

MagicPedalboard : Object {
    // ───────────────────────────────────────────────────────────────
    // class metadata
    // ───────────────────────────────────────────────────────────────
    classvar <version;
    // ───────────────────────────────────────────────────────────────
    // instance state
    // ───────────────────────────────────────────────────────────────
    var < currentChain; // read-only pointer to Array of Symbols
    var <nextChain; // read-only pointer to Array of Symbols
    var chainAList; // [\chainA, ...processors..., source]
    var chainBList; // [\chainB, ...processors..., source]
    var bypassA; // IdentityDictionary: key(Symbol) -> Bool
    var bypassB; // IdentityDictionary: key(Symbol) -> Bool
    var < defaultNumChannels;
    var < defaultSource;
    var < display; // optional display adaptor
    var < processorLib;
    var < ready; // <-- ADD this line
    *initClass {
        var text;
        version = "v0.4.9";
        text = "MagicPedalboard " ++ version;
        text.postln;
    }
    *new { arg disp = nil;
        var instance;
        instance = super.new;
        ^instance.init(disp);
    }
    init { arg disp;
        var sinkFunc;
        display = disp;
        defaultNumChannels = 2;
        defaultSource = \ts0;
        // less good than the version below
        // sinkFunc = { arg inSignal; inSignal };
        sinkFunc = {
            var inputSignal;
            inputSignal = \in.ar(defaultNumChannels);
            inputSignal
        };
        Ndef(\chainA, sinkFunc);
        Ndef(\chainB, sinkFunc);
        // Guarantee sink buses are audio-rate early (prevents kr-meter races)
        Server.default.bind({
            Ndef(\chainA).ar(defaultNumChannels); // typically 2
            Ndef(\chainB).ar(defaultNumChannels);
        });
        chainAList = [\chainA, defaultSource];
        chainBList = [\chainB, defaultSource];
        bypassA = IdentityDictionary.new;
        bypassB = IdentityDictionary.new;
        currentChain = chainAList;
        nextChain = chainBList;
        Server.default.bind({
            this.rebuildUnbound(nextChain); // stays stopped
            this.rebuildUnbound(currentChain); // plays
        });
/*        this.rebuild(currentChain);
        this.rebuild(nextChain);*/
/* Server.default.bind({
 Ndef(\chainA).play(numChannels: defaultNumChannels);
 });*/
        if(display.notNil) {
            display.showInit(this, version, currentChain, nextChain);
        };
        // enforce exclusive invariant (Option A) at first bring-up
        this.enforceExclusiveCurrentOptionA(0.1);
        // set initial state; the poll will flip it once conditions are true
        ready = false;
        // OPTION A: enable background poll (comment out if you prefer Option B)
        this.startReadyPoll;
        ^this
    }
    // ───────────────────────────────────────────────────────────────
    // public API
    // ───────────────────────────────────────────────────────────────
    // add a setter (public)
    setProcessorLib { arg lib;
        processorLib = lib;
    }
    setDisplay { arg disp;
        var shouldShow;
        display = disp;
        shouldShow = display.notNil;
        if(shouldShow) {
            display.showInit(this, version, currentChain, nextChain);
        };
    }
    help {
        var text;
        text = String.new;
        text = text
        ++ "MagicPedalboard " ++ version ++ "\n"
        ++ "Chains are Arrays of Symbols ordered [sink, …, source].\n"
        ++ "On init, creates \\chainA and \\chainB and plays CURRENT.\n\n"
        ++ "Core methods (operate mostly on the *next* chain):\n"
        ++ " printChains\n"
        ++ " playCurrent, stopCurrent, switchChain([fadeTime])\n"
        ++ " add(key), addAt(key, index)\n"
        ++ " removeAt(index), swap(indexA, indexB)\n"
        ++ " bypass(key, state=true), bypassAt(index, state=true)\n"
        ++ " clearChain\n"
        ++ "Current-chain bypass helpers:\n"
        ++ " bypassCurrent(key, state=true), bypassAtCurrent(index, state=true)\n"
        ++ "Diagnostics/helpers:\n"
        ++ " effectiveCurrent, effectiveNext, bypassKeysCurrent, bypassKeysNext, reset\n"
        ++ "Source setters:\n"
        ++ " setSource(key) [next], setSourceCurrent(key) [current]\n";
        text.postln;
    }
    // Detailed printing routed through display if available
    printChains {
        var bypassAKeys, bypassBKeys, effectiveA, effectiveB, hasDisplay;
        var headerFunc, formatOne;
        bypassAKeys = this.bypassKeysForListInternal(chainAList);
        bypassBKeys = this.bypassKeysForListInternal(chainBList);
        effectiveA = this.effectiveListForInternal(chainAList);
        effectiveB = this.effectiveListForInternal(chainBList);
        hasDisplay = display.notNil and: { display.respondsTo(\showChainsDetailed) };
        if(hasDisplay) {
            display.showChainsDetailed(
                chainAList, chainBList,
                bypassAKeys, bypassBKeys,
                effectiveA, effectiveB
            );
        }{
            headerFunc = { arg titleString;
                var lineText;
                lineText = "==== " ++ titleString ++ " ====";
                lineText.postln;
            };
            formatOne = { arg titleString, listRef, bypassKeys, effectiveList;
                var sinkKey, sourceKey, lastIndex, indexCounter, processorsList, lineText, isBypassed, markText;
                lastIndex = listRef.size - 1;
                sinkKey = listRef[0];
                sourceKey = listRef[lastIndex];
                headerFunc.(titleString);
                ("src : " ++ sourceKey).postln;
                if(listRef.size > 2) {
                    "procs:".postln;
                    processorsList = listRef.copyRange(1, lastIndex - 1);
                    indexCounter = 1;
                    processorsList.do({ arg procKey;
                        isBypassed = bypassKeys.includes(procKey);
                        markText = if(isBypassed) { "BYP" } { "ON " };
                        lineText = " [" ++ indexCounter ++ "] " ++ procKey ++ " (" ++ markText ++ ")";
                        lineText.postln;
                        indexCounter = indexCounter + 1;
                    });
                }{
                    "procs: (none)".postln;
                };
                ("sink: " ++ sinkKey).postln;
                ("eff : " ++ effectiveList.join(" -> ")).postln;
                "".postln;
            };
            formatOne.("CURRENT", chainAList, bypassAKeys, effectiveA);
            formatOne.("NEXT", chainBList, bypassBKeys, effectiveB);
        };
    }
    playCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        this.rebuild(currentChain);
        Server.default.bind({
            Ndef(sinkKey).play(numChannels: defaultNumChannels);
        });
        if(display.notNil) {
            display.showPlay(sinkKey);
        };
        // enforce exclusive invariant (Option A) after play
        this.enforceExclusiveCurrentOptionA(0.1);
    }
    stopCurrent {
        var sinkKey, canRun;
        sinkKey = currentChain[0];
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            Ndef(sinkKey).stop;
        });
        if(display.notNil) {
            display.showStop(sinkKey);
        };
    }
    // Crossfading chain switch (default 0.1 s, clamped to ~80–200 ms)
    switchChain { arg fadeTime = 0.1;
        var temporaryList, oldSinkKey, newSinkKey, actualFadeTime, canRun;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        actualFadeTime = fadeTime.clip(0.08, 0.2);
        oldSinkKey = currentChain[0];
        newSinkKey = nextChain[0];
        Server.default.bind({
            // set fade durations
            Ndef(oldSinkKey).fadeTime_(actualFadeTime);
            Ndef(newSinkKey).fadeTime_(actualFadeTime);
            // prebuild NEXT so it is ready, then start it (will fade in)
            this.rebuildUnbound(nextChain);
            Ndef(newSinkKey).play(numChannels: defaultNumChannels);
            // stop OLD (will fade out)
            Ndef(oldSinkKey).stop;
            // swap pointers
            temporaryList = currentChain;
            currentChain = nextChain;
            nextChain = temporaryList;
            // ensure both chains are in correct post-swap state
            this.rebuildUnbound(currentChain);
            this.rebuildUnbound(nextChain);
        });
        // enforce exclusivity post-swap (CURRENT uses actualFadeTime, NEXT silenced)
        this.enforceExclusiveCurrentOptionA(actualFadeTime);
        if(display.notNil) {
            display.showSwitch(oldSinkKey, currentChain[0], currentChain, nextChain);
        };
    }
    // ─── next-chain mutations ─────────────────────────────────────
    add { arg key;
        var insertIndex;
        insertIndex = nextChain.size - 1;
        this.addAt(key, insertIndex);
        if(display.notNil) { display.showMutation(\add, [key], nextChain) };
    }
    addAt { arg key, index;
        var indexClamped, newList;
        indexClamped = index.clip(1, nextChain.size - 1);
        newList = nextChain.insert(indexClamped, key);
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\addAt, [key, indexClamped], nextChain) };
    }
    removeAt { arg index;
        var sizeNow, lastIndex, newList, removedKey;
        sizeNow = nextChain.size;
        lastIndex = sizeNow - 1;
        if(sizeNow <= 2) {
            if(display.notNil) { display.showError("removeAt refused: need at least [sink, source]") }
            { "refuse to remove: need at least [sink, source]".postln };
        }{
            if((index == 0) or: { index == lastIndex }) {
                if(display.notNil) { display.showError("removeAt refused: cannot remove sink or source") }
                { "refuse to remove sink or source".postln };
            }{
                removedKey = nextChain[index];
                newList = nextChain.copy;
                newList.removeAt(index);
                this.setNextListInternal(newList);
                this.bypassDictForListInternal(nextChain).removeAt(removedKey);
                this.rebuild(nextChain);
                if(display.notNil) { display.showMutation(\removeAt, [index, removedKey], nextChain) };
            };
        };
    }
    swap { arg indexAParam, indexBParam;
        var lastIndex, indexA, indexB, newList, tempKey;
        lastIndex = nextChain.size - 1;
        indexA = indexAParam.clip(1, lastIndex - 1);
        indexB = indexBParam.clip(1, lastIndex - 1);
        if(indexA == indexB) {
            // nothing to do
        }{
            newList = nextChain.copy;
            tempKey = newList[indexA];
            newList[indexA] = newList[indexB];
            newList[indexB] = tempKey;
            this.setNextListInternal(newList);
            this.rebuild(nextChain);
            if(display.notNil) { display.showMutation(\swap, [indexA, indexB], nextChain) };
        };
    }
    clearChain {
        var sinkKey, sourceKey, newList;
        if(nextChain.size < 2) { ^this };
        sinkKey = nextChain[0];
        sourceKey = nextChain[nextChain.size - 1];
        newList = [sinkKey, sourceKey];
        this.setNextListInternal(newList);
        this.bypassDictForListInternal(nextChain).clear;
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\clearChain, [], nextChain) };
    }
    bypass { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(nextChain);
        dict[key] = state;
        this.rebuild(nextChain);
        if(display.notNil) {
            display.showBypass(\next, key, state, nextChain, this.bypassKeysForListInternal(nextChain));
        };
    }
    bypassAt { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = nextChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = nextChain[clampedIndex];
        this.bypass(keyAtIndex, state);
    }
    // ─── current-chain bypass ─────────────────────────────────────
    bypassCurrent { arg key, state = true;
        var dict;
        dict = this.bypassDictForListInternal(currentChain);
        dict[key] = state;
        this.rebuild(currentChain);
        if(display.notNil) {
            display.showBypass(\current, key, state, currentChain, this.bypassKeysForListInternal(currentChain));
        };
    }
    bypassAtCurrent { arg index, state = true;
        var lastIndex, clampedIndex, keyAtIndex;
        lastIndex = currentChain.size - 1;
        clampedIndex = index.clip(1, lastIndex - 1);
        keyAtIndex = currentChain[clampedIndex];
        this.bypassCurrent(keyAtIndex, state);
    }
    // ─── source setters ───────────────────────────────────────────
    setSource { arg key;
        var newList, lastIndex;
        lastIndex = nextChain.size - 1;
        newList = nextChain.copy;
        newList[lastIndex] = key;
        this.setNextListInternal(newList);
        this.rebuild(nextChain);
        if(display.notNil) { display.showMutation(\setSource, [key], nextChain) };
    }
    setSourceCurrent { arg key;
        var newList, lastIndex, isAList;
        lastIndex = currentChain.size - 1;
        newList = currentChain.copy;
        newList[lastIndex] = key;
        isAList = (currentChain === chainAList);
        if(isAList) { chainAList = newList; currentChain = chainAList } { chainBList = newList; currentChain = chainBList };
        this.rebuild(currentChain);
        if(display.notNil) { display.showMutation(\setSourceCurrent, [key], currentChain) };
    }
    setSourcesBoth { arg key;
        var k, lastA, lastB, curWasA, nextWasA, newA, newB, sizeOk;
        // pick a sensible key (today we want \testmelody)
        k = key ? \testmelody;
        // guard: require [sink, source] minimum on both chains
        sizeOk = (chainAList.size >= 2) and: { chainBList.size >= 2 };
        if(sizeOk.not) { ^this };
        // remember which concrete list object was CURRENT/NEXT *before* we replace them
        curWasA = (currentChain === chainAList);
        nextWasA = (nextChain === chainAList);
        // compute last indices
        lastA = chainAList.size - 1;
        lastB = chainBList.size - 1;
        // replace the *source symbol* (last position) on both lists
        newA = chainAList.copy; newA[lastA] = k;
        newB = chainBList.copy; newB[lastB] = k;
        // publish new lists and restore CURRENT/NEXT pointers to the matching list
        chainAList = newA;
        chainBList = newB;
        currentChain = if(curWasA) { chainAList } { chainBList };
        nextChain    = if(nextWasA) { chainAList } { chainBList };
        // rebuild both (non-destructive; uses <<> internally in rebuildUnbound)
        this.rebuild(currentChain);
        this.rebuild(nextChain);
        // (optional) inform display
        if(display.notNil and: { display.respondsTo(\showMutation) }) {
            display.showMutation(\setSourcesBoth, [k], nextChain);
        };
        ^this
    }
    setDefaultSource { arg key;
        var k;
        // update the instance default; does not modify existing chains immediately
        k = key ? \testmelody;
        defaultSource = k;
        ^this
    }
    // ─── diagnostics helpers ──────────────────────────────────────
    effectiveCurrent { ^this.effectiveListForInternal(currentChain) }
    effectiveNext { ^this.effectiveListForInternal(nextChain) }
    bypassKeysCurrent { ^this.bypassKeysForListInternal(currentChain) }
    bypassKeysNext { ^this.bypassKeysForListInternal(nextChain) }
    reset {
        var sinkAKey, sinkBKey, canRun;
        sinkAKey = \chainA;
        sinkBKey = \chainB;
        chainAList = [sinkAKey, defaultSource];
        chainBList = [sinkBKey, defaultSource];
        bypassA.clear;
        bypassB.clear;
        currentChain = chainAList;
        nextChain = chainBList;
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            // soft reset: stop both, then rebuild clean connections
            Ndef(sinkAKey).stop;
            Ndef(sinkBKey).stop;
            // Rebuild NEXT first (stays stopped), then CURRENT (plays)
            this.rebuildUnbound(nextChain);
            this.rebuildUnbound(currentChain);
        });
        // enforce exclusive invariant (Option A): CURRENT audible; NEXT silent
        this.enforceExclusiveCurrentOptionA(0.1);
        if(display.notNil) { display.showReset(currentChain, nextChain) };
    }
/* OLDreset {
 var sinkAKey, sinkBKey;
 sinkAKey = \chainA;
 sinkBKey = \chainB;
 chainAList = [sinkAKey, defaultSource];
 chainBList = [sinkBKey, defaultSource];
 bypassA.clear;
 bypassB.clear;
 currentChain = chainAList;
 nextChain = chainBList;
 // SAFE server reset ONLY here, using Server.default.* (not 's')
 Server.default.waitForBoot({
 Server.default.bind({
 Server.default.initTree;
 Server.default.defaultGroup.freeAll;
 this.rebuildUnbound(nextChain);
 this.rebuildUnbound(currentChain);
 Ndef(sinkBKey).stop;
 Ndef(sinkAKey).play(numChannels: defaultNumChannels);
 });
 });
 if(display.notNil) { display.showReset(currentChain, nextChain) };
 } */
    // ───────────────────────────────────────────────────────────────
    // internal helpers (lowercase, no leading underscore)
    // ───────────────────────────────────────────────────────────────
    setNextListInternal { arg newList;
        var isAList;
        isAList = nextChain === chainAList;
        if(isAList) { chainAList = newList; nextChain = chainAList } { chainBList = newList; nextChain = chainBList };
    }
    bypassDictForListInternal { arg listRef;
        ^if(listRef === chainAList) { bypassA } { bypassB }
    }
    bypassKeysForListInternal { arg listRef;
        var dict, keysBypassed;
        dict = this.bypassDictForListInternal(listRef);
        keysBypassed = Array.new;
        dict.keysValuesDo({ arg key, state;
            if(state == true) { keysBypassed = keysBypassed.add(key) };
        });
        ^keysBypassed
    }
    ensureStereoInternal { arg key;
        var proxyBus, needsInit;
        proxyBus = Ndef(key).bus;
        needsInit = proxyBus.isNil or: { proxyBus.rate != \audio } or: { proxyBus.numChannels != defaultNumChannels };
        if(needsInit) {
            Ndef(key).ar(defaultNumChannels);
        };
    }
    // Non-destructive: guard only; do not reset here
    ensureServerTree {
        var serverIsRunning;
        serverIsRunning = Server.default.serverRunning;
        ^serverIsRunning
    }
    //
    // v0.4.6 change
    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust \in.ar, stereo shape pinned, playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).mold(chans, \audio); // authoritative shape
            Ndef(currentSink).fadeTime_(fadeCur);
            if(Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans);
            };
            // NEXT: hard-silence + ensure flag drops
            // 1) silence source, then .stop (no audio either way)
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).mold(chans, \audio);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
            // 2) drop monitor/flag deterministically, then re-establish silent sink
            Ndef(nextSink).end; // frees inner players, "stop listen" (NodeProxy help)
            Ndef(nextSink, { Silent.ar(chans) }); // keep NEXT present & silent for prebuild
            Ndef(nextSink).mold(chans, \audio);
            // do NOT play NEXT
        });
        ^this
    }
/*    enforceExclusiveCurrentOptionA { arg fadeCurrent = 0.1;
        var currentSink, nextSink, chans, fadeCur;
        currentSink = currentChain[0];
        nextSink = nextChain[0];
        chans = defaultNumChannels;
        fadeCur = fadeCurrent.clip(0.05, 0.2);
        Server.default.bind({
            // CURRENT: robust sink that consumes embedded input; ensure playing
            Ndef(currentSink, { \in.ar(chans) });
            Ndef(currentSink).ar(chans);
            Ndef(currentSink).fadeTime_(fadeCur);
            if (Ndef(currentSink).isPlaying.not) {
                Ndef(currentSink).play(numChannels: chans)
            };
            // NEXT: hard silence at the sink source; stop its monitor quickly
            Ndef(nextSink, { Silent.ar(chans) });
            Ndef(nextSink).ar(chans);
            Ndef(nextSink).fadeTime_(0.01);
            Ndef(nextSink).stop;
        });
        ^this
    }*/
    effectiveListForInternal { arg listRef;
        var dict, resultList, lastIndex, isProcessor, isBypassed;
        dict = this.bypassDictForListInternal(listRef);
        resultList = Array.new;
        lastIndex = listRef.size - 1;
        listRef.do({ arg key, indexPosition;
            isProcessor = (indexPosition > 0) and: (indexPosition < lastIndex);
            isBypassed = isProcessor and: { dict[key] == true };
            if((indexPosition == 0) or: { indexPosition == lastIndex }) {
                resultList = resultList.add(key);
            }{
                if(isBypassed.not) { resultList = resultList.add(key) };
            };
        });
        ^resultList
    }
    // Public rebuild: bundles server ops; guard only
    rebuild { arg listRef;
        var whichChain, canRun;
        whichChain = if(listRef === currentChain) { \current } { \next };
        canRun = this.ensureServerTree;
        if(canRun.not) { ^this };
        Server.default.bind({
            this.rebuildUnbound(listRef);
        });
        if(display.notNil) {
            display.showRebuild(whichChain, listRef, this.effectiveListForInternal(listRef));
        };
    }
    // Internal rebuild that assumes we are already inside a server bind (no resets)
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        // (NEW 2D) Ensure Ndefs for symbols present in the *declared* chain (includes bypassed ones)
        if(processorLib.notNil) {
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };
        // From here on, this is your original "effective / do / connect"
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }
/*    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/*    // At end of rebuildUnbound
    rebuildUnbound { arg listRef;
        var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum, shouldPlay, isPlaying;
/*        if(processorLib.notNil) {
            // Ask the lib to make sure each symbol in this chain has an Ndef with a function.
            // It will quietly do nothing for unknown keys.
            processorLib.ensureFromChain(listRef, defaultNumChannels);
        };*/
        hasMinimum = listRef.size >= 2;
        if(hasMinimum.not) { ^this };
        effective = this.effectiveListForInternal(listRef);
        effective.do({ arg keySymbol; this.ensureStereoInternal(keySymbol) });
        indexCounter = 0;
        while({ indexCounter < (effective.size - 1) }, {
            leftKey = effective[indexCounter];
            rightKey = effective[indexCounter + 1];
            Ndef(leftKey) <<> Ndef(rightKey);
            indexCounter = indexCounter + 1;
        });
        sinkKey = effective[0];
        shouldPlay = (listRef === currentChain);
        isPlaying = Ndef(sinkKey).isPlaying;
        if(shouldPlay) {
            if(isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        }{
            if(isPlaying) { Ndef(sinkKey).stop };
        };
    }*/
/* OLD rebuildUnbound { arg listRef;
 var effective, indexCounter, leftKey, rightKey, sinkKey, hasMinimum;
 hasMinimum = listRef.size >= 2;
 if(hasMinimum.not) { ^this };
 effective = this.effectiveListForInternal(listRef);
 effective.do({ arg keySymbol;
 this.ensureStereoInternal(keySymbol);
 });
 indexCounter = 0;
 while({ indexCounter < (effective.size - 1) }, {
 leftKey = effective[indexCounter];
 rightKey = effective[indexCounter + 1];
 Ndef(leftKey) <<> Ndef(rightKey);
 });
        // sinkKey = effective[0];
        // if(listRef === currentChain) {
        //     Ndef(sinkKey).play(numChannels: defaultNumChannels);
        // }{
        //     Ndef(sinkKey).stop;
        // };
        // At the end of rebuildUnbound:
        sinkKey = effective[0];
        if(listRef === currentChain) {
            if(Ndef(sinkKey).isPlaying.not) { Ndef(sinkKey).play(numChannels: defaultNumChannels) };
        } {
            if(Ndef(sinkKey).isPlaying) { Ndef(sinkKey).stop };
        };
 } */
    // ---- Ready helpers (public API) ----
    // boolean snapshot (no server ops)
    isReady {
        ^ready
    }
    // AppClock polling; onReadyFunc is optional
    waitUntilReady { arg timeoutSec = 2.0, pollSec = 0.05, onReadyFunc = nil;
        var startTime, tick;
        startTime = Main.elapsedTime;
        AppClock.sched(0, {
            tick = {
                if(this.readyConditionOk) {
                    ready = true;
                    if(onReadyFunc.notNil) { onReadyFunc.value };
                    nil
                }{
                    if((Main.elapsedTime - startTime) > timeoutSec) {
                        // timed out; leave 'ready' as-is
                        nil
                    }{
                        AppClock.sched(pollSec, tick)
                    }
                }
            };
            tick.value;
            nil
        });
        ^this
    }
    // ---- Ready helpers (internal; no leading underscore) ----
    // light background poll started from init (OPTION A)
    startReadyPoll {
        var alreadyTrue;
        alreadyTrue = this.readyConditionOk;
        if(alreadyTrue) { ready = true; ^this };
        this.waitUntilReady(2.0, 0.05, { nil });
        ^this
    }
    // compute the readiness condition; no server ops here
    readyConditionOk {
        var curSink, nxtSink, serverOk, curBus, nxtBus, busesOk, currentPlaying;
        curSink = currentChain[0];
        nxtSink = nextChain[0];
        serverOk = Server.default.serverRunning;
        curBus = Ndef(curSink).bus;
        nxtBus = Ndef(nxtSink).bus;
        busesOk = curBus.notNil and: { nxtBus.notNil }
        and: { curBus.rate == \audio } and: { nxtBus.rate == \audio };
        currentPlaying = Ndef(curSink).isPlaying;
        ^(serverOk and: { busesOk } and: { currentPlaying })
    }
    // handleCommand { |oscPath|
    //     var path;
    //     path = oscPath.asString;
    //
    //     // Route to your existing mutation logic
    //     // Update this if you use a different handler name
    //     if(this.respondsTo(\applyOSCPath)) {
    //         this.applyOSCPath(path);
    //     } {
    //         ("[MPB] handleCommand: " ++ path ++ " → no handler found").warn;
    //     };
    //
    //     ^this;
    // }
    handleCommand { |oscPath|
     var path;
     path = oscPath.asString;
     if(~ct_applyOSCPathToMPB.notNil) {
     ~ct_applyOSCPathToMPB.(path, this, display);
     } {
     ("[MPB] handleCommand: " ++ path ++ " → no handler found").warn;
     };
     ^this;
    }

    // --- Added in v0.4.9: class-side helpers ---------------------------------

    *help {
        var text;
        text = "
MagicPedalboard.help — quick guide (class-side)

Quick start
-----------
(
var mpb;
mpb = MagicPedalboard.new(nil);  // optional display adaptor may be passed
mpb.printChains;                    // see CURRENT/NEXT
// NEXT-chain edits:
mpb.add(\\delay);                   // append before source
mpb.bypass(\\delay, true);          // bypass in NEXT
mpb.setSource(\\testmelody);        // set NEXT source
// Commit and listen:
mpb.switchChain(0.1);               // crossfade CURRENT<->NEXT (80–200 ms clamp)
// Diagnostics:
mpb.printChains; mpb.effectiveCurrent; mpb.effectiveNext;
)

Design highlights
- Chains are Arrays of Symbols: [sink, processors..., source]
- Embedding: Ndef(left) <<> Ndef(right)
- create sinks \\chainA and \\chainB; CURRENT plays, NEXT is prepared/silenced
- Mutators act on NEXT (add/addAt/removeAt/swap/bypass/bypassAt/clearChain/setSource)
- CURRENT helpers for bypassing and source changes are also available
- Non-destructive rebuilds; .reset is a guarded soft reset
";
        text.postln;
        text
    }

    *api {
        var api;
        api = IdentityDictionary[
            // construction & display
            \ctor         -> "MagicPedalboard.new(displayOrNil)",
            \display      -> "setDisplay(disp), setProcessorLib(lib), setDefaultSource(key)",

            // status & printing
            \status       -> "printChains(), effectiveCurrent(), effectiveNext(), bypassKeysCurrent(), bypassKeysNext()",

            // play control
            \play         -> "playCurrent(), stopCurrent(), switchChain([fadeTime=0.1])",

            // NEXT-chain editing
            \next_edit    -> "add(key), addAt(key, index), removeAt(index), swap(iA, iB), clearChain(), bypass(key[,state]), bypassAt(index[,state]), setSource(key)",

            // CURRENT-chain helpers
            \current_edit -> "bypassCurrent(key[,state]), bypassAtCurrent(index[,state]), setSourceCurrent(key), setSourcesBoth(key)",

            // lifecycle / invariants
            \invariants   -> "enforceExclusiveCurrentOptionA([fade])",
            \reset        -> "reset()  // guarded soft reset with rebuilds",

            // diagnostics / readiness
            \ready        -> "isReady(), waitUntilReady([timeout,poll,onReadyFunc])"
        ];
        api.postln;
        api
    }

    *test {
        var mpb;
        mpb = MagicPedalboard.new(nil);
        // A tiny smoke test that exercises the common NEXT->switch flow.
        mpb.add(\delay);
        mpb.setSource(\testmelody);
        mpb.switchChain(0.1);
        mpb.printChains;
        mpb
    }
}

===== MagicPedalboard/MagicPedalboardNew.sc =====
// MagicPedalboardNew.sc (DEPRECATED SHIM)
// v0.0.2 — shim subclass; warns at compile-time + first construction only
// MD 2025-10-02

MagicPedalboardNew : MagicPedalboard {
    classvar depWarnedAtRuntime;  // no accessor marker + no leading underscore

    *initClass {
        var msg;
        depWarnedAtRuntime = false;
        msg = "DEPRECATION: MagicPedalboardNew is now a shim. Use MagicPedalboard.";
        msg.warn;  // prints once per class library compile
    }

    // Warn once at first *construction* via MagicPedalboardNew in this process.
    *new { arg display = nil;
        var instance, msg;
        if (depWarnedAtRuntime.not) {
            msg = "DEPRECATION (runtime): MagicPedalboardNew was constructed. "
                ++ "Please migrate to MagicPedalboard.new(...).";
            msg.warn;
            depWarnedAtRuntime = true;
        };
        instance = super.new;
        ^instance.init(display)
    }
}

===== MagicPedalboard/MagicPedalboardTestRunner.sc =====
// MagicPedalboardTestRunner.sc
// v0.2.2
// MD 20250919

/*
Purpose:
- Unified bring-up, audio reset, GUI sync, and test runner for MagicPedalboardNew.
- Replaces StartHere_CleanBoot_OneWindow_BringUp.scd.
- Logs all steps using MDMiniLogger.
- Extensible with new test methods.

Style:
- var-first; lowercase methods; no server.sync.
- Server ops inside Server.default.bind; GUI ops on AppClock.
- No single-letter vars; all var declarations at top of each block.
*/

MagicPedalboardTestRunner : Object {
    var <logger, <pedalboard, <>gui;

    *new { arg mpb, gui;
        ^super.new.init(mpb, gui);
    }

    init { arg mpb, gui;
        pedalboard = mpb;
        this.gui = gui;
        logger = MDMiniLogger.new("MagicPedalboardTestRunner");
        ^this;
    }

    bringUp {
        var trigger, sequence, freqDemand, envelope, toneSignal, panPosition;
        var isPlayingA, isPlayingB, currentSink;

        logger.info("Starting full bring-up...");

        Server.default.waitForBoot({
            Server.default.bind({
                Server.default.initTree;
                Server.default.defaultGroup.freeAll;
                logger.info("Server tree initialized.");
            });
        });

        Server.default.bind({
            Ndef(\chainA, { \in.ar(2) }).ar(2);
            Ndef(\chainB, { \in.ar(2) }).ar(2);
            Ndef(\ts0, { Silent.ar(2) }).ar(2);
            Ndef(\testmelody, {
                trigger = Impulse.kr(3.2);
                sequence = Dseq([220, 277.18, 329.63, 392, 329.63, 277.18, 246.94], inf);
                freqDemand = Demand.kr(trigger, 0, sequence);
                envelope = Decay2.kr(trigger, 0.01, 0.35);
                toneSignal = SinOsc.ar(freqDemand) * envelope * 0.25;
                panPosition = ToggleFF.kr(trigger).linlin(0, 1, -0.6, 0.6);
                Pan2.ar(toneSignal, panPosition);
            }).ar(2);
            logger.info("Sinks and sources defined.");
        });

        pedalboard.reset;
        pedalboard.setSourceCurrent(\testmelody);
        pedalboard.playCurrent;
        pedalboard.enforceExclusiveCurrentOptionA(0.1);

        if(gui.notNil) {
            gui.enableMeters(false);
            gui.enableMeters(true);
            gui.window.front;
            gui.showExpectation("System ready", 0);
        };

        pedalboard.printChains;

        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Playback state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
        logger.info("Bring-up complete.");
    }

    audioReset {
        logger.info("Running ~audioReset...");
        if(~audioReset.notNil) {
            ~audioReset.();
            logger.info("~audioReset complete.");
        } {
            logger.warn("~audioReset is not defined.");
        };
    }

    syncGui {
        var currentSink;
        if(gui.notNil) {
            currentSink = pedalboard.effectiveCurrent[0];
            gui.window.front;
            gui.highlightCurrentColumn(currentSink);
            gui.showChainsDetailed(
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext,
                pedalboard.bypassKeysCurrent,
                pedalboard.bypassKeysNext,
                pedalboard.effectiveCurrent,
                pedalboard.effectiveNext
            );
            logger.info("GUI synced with audio state.");
        };
    }

    runAcceptanceTest {
        logger.info("Running acceptance test...");
        pedalboard.add(\delay);
        pedalboard.switchChain(0.12);
        pedalboard.bypassCurrent(\delay, true);
        pedalboard.bypassCurrent(\delay, false);
        pedalboard.switchChain(0.12);
        pedalboard.printChains;
        logger.info("Acceptance test complete.");
    }

    verifyAudioState {
        var isPlayingA, isPlayingB;
        isPlayingA = Ndef(\chainA).isPlaying;
        isPlayingB = Ndef(\chainB).isPlaying;
        logger.info("Audio state: A.playing=" ++ isPlayingA ++ " B.playing=" ++ isPlayingB);
    }

    help {
        "Available methods: bringUp, audioReset, syncGui, runAcceptanceTest, verifyAudioState".postln;
    }
}

===== MagicPedalboard/MagicProcessorLibrary.sc =====
/* MagicProcessorLibrary.sc
   Holds a registry of processor/source functions and can ensure Ndefs exist.
   MD 20250913
*/
MagicProcessorLibrary : Object {
    var <defs;           // IdentityDictionary: Symbol -> Function
    var <defaultNumChannels;

    *new { ^super.new.init }

    init {
        var empty;
        defaultNumChannels = 2;
        empty = IdentityDictionary.new;
        defs = empty;
        ^this
    }

    register { arg key, func;
        defs[key] = func;
        ^this
    }

    has { arg key;
        ^defs.includesKey(key)
    }

    get { arg key;
        ^defs[key]
    }

    keys { ^defs.keys }

    // Create or update an Ndef for key
    ensure { arg key, chans;
        var func, numCh, canRun;
        func = defs[key];
        if(func.isNil) { ^this }; // silently ignore if not registered
        numCh = chans ? defaultNumChannels;
        canRun = Server.default.serverRunning;
        if(canRun) {
            Server.default.bind({
                Ndef(key, func);
                Ndef(key).ar(numCh);
            });
        };
        ^this
    }

    // Ensure many keys at once
    ensureMany { arg keyArray, chans;
        keyArray.do({ arg key; this.ensure(key, chans) });
        ^this
    }

    // Convenience: ensure whatever appears in a chain array
    ensureFromChain { arg chainArray, chans;
        var lastIndex, idx;
        if(chainArray.isNil or: { chainArray.size < 2 }) { ^this };
        lastIndex = chainArray.size - 1;
        idx = 0;
        while({ idx <= lastIndex }, {
            this.ensure(chainArray[idx], chans);
            idx = idx + 1;
        });
        ^this
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_AcceptanceSuites.sc =====
// MPBTest_AcceptanceSuites.sc
// v0.1.1
// MD 20250920-1608

// Purpose
// - Ready-made, extensible step lists for acceptance.
// Style
// - var-first; lowercase; data-only class methods.

MPBTest_AcceptanceSuites : Object {
    *classic { arg fade = 0.12;
        ^[
            (verb:\add,           args:[\delay]),
            (verb:\switch,        args:[fade]),
            (verb:\bypassCurrent, args:[\delay, true]),
            (verb:\bypassCurrent, args:[\delay, false]),
            (verb:\switch,        args:[fade])
        ]
    }

    *mutatorsBasic { arg fade = 0.12;
        ^[
            (verb:\insert,   args:[\chorus]),
            (verb:\addAt,    args:[\reverb, 1]),
            (verb:\swap,     args:[1, 2]),
            (verb:\removeAt, args:[2]),
            (verb:\switch,   args:[fade])
        ]
    }

    *bypassNextCycle {
        ^[
            (verb:\add,    args:[\delay]),
            (verb:\bypass, args:[\delay, \on]),
            (verb:\bypass, args:[\delay, \off]),
            (verb:\switch, args:[0.12])
        ]
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Assertions.sc =====
// MPBTest_Assertions.sc
// v0.1.0
// MD 20250920-1540
//
// Purpose
// - Centralized assertions used across scenarios (A XOR B, single \delay in list, NEXT audible tail...)
// Style
// - var-first; lowercase; no server.sync; no single-letter locals.

MPBTest_Assertions : Object {
    *xorPlaying { arg expectA = true, expectB = false;
        var a, b, ok;
        a = Ndef(\chainA).isPlaying;
        b = Ndef(\chainB).isPlaying;
        ok = (a == expectA) and: { b == expectB };
        ("[ASSERT] XOR A="++a++" B="++b++" expect("++expectA++","++expectB++") -> "++
            (ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }

    *countKey { arg list, key;
        var count = 0;
        list.do({ arg k; if(k == key) { count = count + 1 } });
        ^count
    }

    *exactlyOne { arg list, key, label="count";
        var n, pass;
        n = this.countKey(list, key);
        pass = (n == 1);
        ("[ASSERT] "++label++" '"++key.asString++"' = "++n++" -> "++
            (pass.if({"PASS"},{"FAIL"}))).postln;
        ^pass
    }

    *nextTailNotTs0 { arg mpb;
        var last, ok;
        last = mpb.effectiveNext.last;
        ok = (last != \ts0);
        ("[ASSERT] NEXT tail != \\ts0 -> "++(ok.if({"PASS"},{"FAIL"}))).postln;
        ^ok
    }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_BringUp.sc =====
// MPBTest_BringUp.sc
// v0.1.9
// MD 20250920-1919

// Purpose
// - Fresh-boot bring-up with Grid GUI by default; avoids display=nil and close/create races.
// Style
// - var-first; lowercase; AppClock for GUI; Server.default.bind for audio; no server.sync.

MPBTest_BringUp : Object {
    classvar < version;
    var < logger, < pedalboard, < gui, < readyFlag, < numChannels, < testAmp;

    *initClass { version = "v0.1.9"; ("MPBTest_BringUp " ++ version).postln; }

    *new {
        arg useGui = true, channels = 2, sourceAmp = 0.40, publishToTildes = true,
            freshBoot = true, guiClassSym = \MagicDisplayGUI_GridDemo, closeExistingGUIs = true;
        ^super.new.init(useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs)
    }

    init { arg useGui, channels, sourceAmp, publishToTildes, freshBoot, guiClassSym, closeExistingGUIs;
        var s, doFreshBoot, startBoot, afterBoot, scheduleGuiClose, scheduleGuiCreate;
        var ensureSinks, ensureSources, setSourcesAndPlay, enforceOptionA, attachMeters, postBaseline, maybePublish;

        logger     = MDMiniLogger.new("MPBTest_BringUp");
        readyFlag  = false;
        numChannels = (channels ? 2).asInteger.max(1);
        testAmp     = (sourceAmp ? 0.40).asFloat.clip(0.05, 1.0);
        s = Server.default;

        // --- audio preparation ---
        ensureSinks = {
            Server.default.bind({
                Ndef(\chainA, { \in.ar(numChannels) }); Ndef(\chainA).ar(numChannels);
                Ndef(\chainB, { \in.ar(numChannels) }); Ndef(\chainB).ar(numChannels);
            });
        };

        ensureSources = {
            Server.default.bind({
                Ndef(\testmelody, {
                    var trig = Impulse.kr(3.2);
                    var seq  = Dseq([220,277.18,329.63,392,329.63,277.18,246.94], inf);
                    var f    = Demand.kr(trig, 0, seq);
                    var env  = Decay2.kr(trig, 0.01, 0.35);
                    var pan  = ToggleFF.kr(trig).linlin(0, 1, -0.6, 0.6);
                    Pan2.ar(SinOsc.ar(f) * env * testAmp, pan)
                });
                Ndef(\testmelody).ar(numChannels);
                Ndef(\ts0, { Silent.ar(numChannels) }).ar(numChannels);
            });
        };

        setSourcesAndPlay = {
            pedalboard.setDefaultSource(\testmelody);
            pedalboard.setSourceCurrent(\testmelody);
            pedalboard.playCurrent;
        };

        enforceOptionA = {
            pedalboard.enforceExclusiveCurrentOptionA(0.1);
            Server.default.bind({
                var nextSink = pedalboard.nextChain[0];
                Ndef(nextSink).end;
                Ndef(nextSink).mold(numChannels, \audio);
            });
        };

        attachMeters = {
            if(gui.notNil and: { gui.respondsTo(\enableMeters) }) {
                gui.enableMeters(false); gui.enableMeters(true);
            };
        };

        postBaseline = {
            pedalboard.printChains;
            ("[[PLAY]] A=% B=%".format(Ndef(\chainA).isPlaying, Ndef(\chainB).isPlaying)).postln;
            readyFlag = true;
        };

        maybePublish = {
            if(publishToTildes) { ~bring = this; ~mpb = pedalboard; ~gui = gui };
        };

        // --- GUI sequencing to avoid races ---
        scheduleGuiClose = {
            if(closeExistingGUIs and: { useGui }) {
                AppClock.sched(0.00, {
                    var wins = Window.allWindows.select({ arg w;
                        var nm = w.tryPerform(\name) ? "";
                        nm.asString.beginsWith("MagicDisplayGUI")
                    });
                    wins.do(_.close);
                    nil
                });
            };
        };

        scheduleGuiCreate = {
            if(useGui) {
                AppClock.sched(0.05, {
                    gui = guiClassSym.asClass.new;   // MagicDisplayGUI_GridDemo by default
                    gui.window.front.alwaysOnTop_(true);
                    // Build pedalboard only **after** GUI exists so display is bound at construction
                    pedalboard = MagicPedalboardNew.new(gui);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    attachMeters.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            }{
                // Headless: create pedalboard immediately (no display)
                AppClock.sched(0.00, {
                    pedalboard = MagicPedalboardNew.new(nil);
                    setSourcesAndPlay.value;
                    enforceOptionA.value;
                    postBaseline.value;
                    maybePublish.value;
                    nil
                });
            };
        };

        // --- boot choreography ---
        afterBoot = {
            ensureSinks.value;
            ensureSources.value;
            scheduleGuiClose.value;
            scheduleGuiCreate.value;
        };

        startBoot = {
            s.doWhenBooted({ afterBoot.value });
            if(s.serverRunning.not) { s.boot };
        };

        doFreshBoot = {
            var waitDown;
            if(s.serverRunning) {
                if(gui.notNil and: { gui.respondsTo(\enableMeters) }) { gui.enableMeters(false) };
                s.quit;
                waitDown = {
                    if(s.serverRunning.not) { startBoot.value; nil } {
                        AppClock.sched(0.05, waitDown)
                    }
                };
                AppClock.sched(0.05, waitDown);
            }{
                startBoot.value;
            };
        };

        if(freshBoot) { doFreshBoot.value } { startBoot.value };
        ^this
    }

    isReady { ^readyFlag }
    getPedalboard { ^pedalboard }
    getGui { ^gui }
    getChannels { ^numChannels }
}

===== MagicPedalboard/MPBTest/Classes/MPBTest_Scenario.sc =====
// MPBTest_Scenario.sc
// v0.2.2
// MD 20250920-2015

// Purpose
// - Timed acceptance runner (add/insert/addAt/removeAt/swap/bypass/.../switch/wait)
//   with optional CommandTree path hook via .setPathApplier.
// - Removes caret-returns from AppClock closures to avoid OutOfContextReturnError.
// Style
// - var-first; lowercase; AppClock scheduling; no server.sync.

MPBTest_Scenario : Object {
    classvar < version;
    var < pedalboard, < gui, < logger;
    var pathApplierFunc;

    *initClass { version = "v0.2.2" }

    *new { arg mpb, guiObj = nil; ^super.new.init(mpb, guiObj) }

    init { arg mpb, guiObj;
        var lg;
        pedalboard = mpb;
        gui = guiObj;
        logger = MDMiniLogger.new("MPBTest_Scenario");
        pathApplierFunc = nil;
        ^this
    }

    setPathApplier { arg func;
        pathApplierFunc = func;
        ^this
    }

    useDefaultAdapterIfPresent {
        if(pathApplierFunc.isNil and: { ~ct_applyOSCPathToMPB.notNil }) {
            pathApplierFunc = { arg pathString;
                ~ct_applyOSCPathToMPB.(pathString.asString, pedalboard, gui);
            };
            logger.info("Using ~ct_applyOSCPathToMPB as default path applier.");
        };
        ^this
    }

    run { arg stepsArray;
        var indexCounter, totalCount, runOne;

        this.useDefaultAdapterIfPresent;

        indexCounter = 0;
        totalCount   = stepsArray.size;

        runOne = {
            var stepDict, verb, args, hasMore;

            hasMore = indexCounter < totalCount;

            if(hasMore) {
                stepDict = stepsArray[indexCounter];
                verb = stepDict[\verb];
                args = stepDict[\args] ? [];

                this.applyStep(verb, args);

                indexCounter = indexCounter + 1;

                // Schedule next step tick; explicit \wait steps still add their own delay.
                AppClock.sched(0.20, { runOne.value; nil });
            }{
                // finished; nothing to return from a scheduled closure
                logger.info("scenario complete (" ++ totalCount ++ " steps).");
            };
            nil
        };

        AppClock.sched(0.00, { runOne.value; nil });
        ^this
    }

    applyStep { arg verb, args;
        var v, brief;
        v = verb;
        brief = {
            pedalboard.printChains;
            this.refreshGui;
        };

        switch(v,
            \wait, {
                var delaySec;
                delaySec = (args[0] ? 0.25).asFloat.max(0.0);
                AppClock.sched(delaySec, { nil }); // no return
            },

            \add, {
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \insert, { // alias of add
                var proc;
                proc = args[0];
                pedalboard.add(proc);
                brief.value;
            },

            \addAt, {
                var proc, idx;
                proc = args[0];
                idx  = (args[1] ? 1).asInteger;
                pedalboard.addAt(proc, idx);
                brief.value;
            },

            \removeAt, {
                var idx;
                idx = (args[0] ? 1).asInteger;
                pedalboard.removeAt(idx);
                brief.value;
            },

            \swap, {
                var idxA, idxB;
                idxA = (args[0] ? 1).asInteger;
                idxB = (args[1] ? 2).asInteger;
                pedalboard.swap(idxA, idxB);
                brief.value;
            },

            \bypass, { // NEXT chain
                var key, stateSym, state;
                key = args[0];
                stateSym = args[1] ? \on;
                state = (stateSym == \on) or: { stateSym == \true } or: { stateSym == 1 };
                pedalboard.bypass(key, state);
                brief.value;
            },

            \unbypass, {
                var key;
                key = args[0];
                pedalboard.bypass(key, false);
                brief.value;
            },

            \bypassCurrent, {
                var key, state;
                key   = args[0];
                state = (args[1] ? true);
                pedalboard.bypassCurrent(key, state);
                brief.value;
            },

            \bypassAt, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAt(indexParam, stateParam);
                brief.value;
            },

            \bypassAtCurrent, {
                var indexParam, stateParam;
                indexParam = (args[0] ? 1).asInteger;
                stateParam = (args[1] ? true);
                pedalboard.bypassAtCurrent(indexParam, stateParam);
                brief.value;
            },

            \setSource, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSource(key);
                brief.value;
            },

            \setSourceCurrent, {
                var key;
                key = args[0] ? \testmelody;
                pedalboard.setSourceCurrent(key);
                brief.value;
            },

            \switch, {
                var fade;
                fade = (args[0] ? 0.12).asFloat.clip(0.08, 0.20);
                if(pedalboard.effectiveNext.last == \ts0) {
                    if(pathApplierFunc.notNil) { pathApplierFunc.value("/setSource/testmelody") } {
                        pedalboard.setSource(\testmelody);
                    };
                };
                pedalboard.switchChain(fade);
                this.refreshGui;
            },

            \ctPath, {
                var path;
                path = args[0].asString;
                if(pathApplierFunc.notNil) { pathApplierFunc.value(path) } {
                    logger.warn("[ctPath] adapter missing; ignored: " ++ path);
                };
                this.refreshGui;
            },

            { logger.warn("Unknown step: " ++ v.asString) }
        );
    }

    refreshGui {
        if(gui.notNil and: { gui.respondsTo(\showChainsDetailed) }) {
            var effC, effN;
            effC = pedalboard.effectiveCurrent;
            effN = pedalboard.effectiveNext;
            gui.highlightCurrentColumn(effC[0]);
            gui.showChainsDetailed(effC, effN, pedalboard.bypassKeysCurrent, pedalboard.bypassKeysNext, effC, effN);
        };
    }
}

===== MagicPedalboard/WindowDisplayExamples/SC_GUI_Meters_Summary_v1_0.sc =====
/*
SuperCollider GUI + Meters: Working Pattern & Pitfalls
v1.0
MD 2025-09-25 10:27

============================================================

✅ WHAT MAKES THIS WORK

1) Separate GUI from Audio Boot
   - Build the window and layout first so something is visible immediately.
   - Use s.waitForBoot Ellipsis or a Routine for audio bring‑up; never block the AppClock.
   - Avoid server.sync in GUI paths to prevent freezes and blank windows.

2) Use Layout Managers for Predictability
   - Prefer GridLayout or VLayout/HLayout so panes resize reliably.
   - Avoid manual Rect math unless you need pixel‑perfect control.

3) Draw Borders with UserView.drawFunc
   - CompositeView does not implement drawFunc_.
   - Create a UserView inside the pane to draw colored borders/fills.

4) Var‑first and Descriptive Names
   - Declare all locals at the top of every block (functions, drawFunc, actions).
   - No single‑letter variables; use paneView, meterColumnView, amplitudeBusA, etc.
   - This prevents parser errors like “unexpected VAR”.

5) Atomic Server Operations
   - If you rewire NodeProxies, wrap changes in Server.default.bind Ellipsis.
   - Keep GUI responsive by avoiding synchronous waits.

6) Smooth, Click‑free Level Changes
   - Apply Lag.kr to amplitude controls before multiplying the audio signal.
   - Update LevelIndicator values on AppClock and defer GUI writes with Ellipsis.defer.

7) Clean Meter Updates
   - Use control buses for metering (Out.kr), and read them with .get on AppClock.
   - Always .defer updates to the actual GUI widgets.

8) Deterministic Cleanup
   - In window.onClose_, stop routines, free buses, and stop+clear Ndefs.
   - Also close any previous MagicDisplayGUI windows on start.

------------------------------------------------------------

⚠️ COMMON PITFALLS

• drawFunc_ on CompositeView has no effect → use UserView.
• Multiple assignment to array elements (e.g., #array[i], … = ...) is invalid → assign to locals first, then store.
• server.sync in GUI code blocks the AppClock → freezes or blank windows.
• Non‑var‑first blocks → “unexpected VAR, expecting …” parse errors.
• Updating widgets directly from audio/server callbacks → must .defer GUI writes.
• Leaving old Ndefs and buses running → audio chaos and resource leaks on re‑run.
• Hard‑coded sizes on HiDPI/Sidecar → panes appear tiny; layouts fix scaling.

------------------------------------------------------------

🔍 EASY‑TO‑OVERLOOK DETAILS

• Close prior MagicDisplayGUI windows before building a new one.
• Free control buses used for meters in onClose_.
• Convert dB → linear with .dbamp and clamp to [0, 1] for LevelIndicator.
• Give LevelIndicator a minSize_ (e.g., Size(20, 180)) so layouts don’t collapse it.
• Add small spacers (UserView().minWidth_/minHeight_) in H/V layouts for readable gaps.
• If GUI must appear even when audio fails, build the window first, then boot server.

------------------------------------------------------------

➡️ UPGRADE PATH / NEXT STEPS

1) Keep the proven GUI skeleton (GridLayout or V/HLayout) and slot in top‑row meters.
2) Add one audible Ndef test source; meter its amplitude via a control bus.
3) Layer routing gradually:
   - one source → one effect → one sink;
   - then two sinks with A/B selection (use Lag/XFade2 to avoid clicks);
   - finally expand to 3 sources, 3 effects, 2 sinks, preserving the GUI contract.
4) Only after routing is stable, attach real meters to each chain point as needed.

------------------------------------------------------------

CHEAT SHEET (DO / AVOID)

DO
- window first; audio later (non‑blocking).
- UserView.drawFunc for borders and custom visuals.
- var‑first, descriptive names everywhere.
- AppClock for GUI updates, with .defer inside callbacks.
- Lag.kr for level changes; XFade2 + Lag for A/B.
- onClose_: stop routines, free buses, clear Ndefs.

AVOID
- server.sync in any GUI path.
- drawFunc_ on CompositeView.
- Multiple assignment to array elements.
- Single‑letter variable names; hidden locals mid‑block.
- Direct GUI writes from non‑GUI threads.

============================================================
*/
===== MDMiniLogger/MDMiniLogger.sc =====
// MDMiniLogger.sc
// v0.3.3
// MD 20250919-13:51

// access with MDMiniLogger.get (which creates the instance if there isn't one)
// verbosity levels: 0=ERROR, 1=WARN, 2=INFO, 3=DEBUG, 4=TRACE

MDMiniLogger : Object {
	classvar < logger;
	classvar verbosityNames;
	var < verbosity;
	var < enabled;

	// 3.1 fix
	*initClass {
		verbosityNames = ["ERROR", "WARN", "INFO", "DEBUG", "TRACE"];
		logger = nil; // discard any stale instance after class library recompile
	}

	init {
		verbosity = 2;
		enabled = true;
	}
	*get {
		// return existing, otherwise create one
		^logger ?? { logger = MDMiniLogger.new };
	}

	shouldLog { |msgVerbosity|
		var messageLevel, thresholdLevel, isOn;

		messageLevel   = (msgVerbosity ? 0).clip(0, 4);  // if nil default to 0
		thresholdLevel = (verbosity ? 0).clip(0, 4);     // the logger's current threshold
		isOn = (enabled ? true);
		// Print when:
		//  - logging is enabled, AND
		//  - the message is at least as important as the threshold (lower number = more important)
/*		^(isOn and: { messageLevel <= thresholdLevel });*/

// fix 0.3.2
^((enabled == true) and: { messageLevel <= thresholdLevel });

	}

	setverbosity { |newverbosity| verbosity = (newverbosity ? 0).clip(0, 4); ^verbosity }

	enable  { enabled = true;  ^enabled }

	disable { enabled = false; ^enabled }

	format {|argVerbosity, argLabel, argMessage |
		var line, logVerbosity, logLabel, logMessage;

		// check we have a verbosity
		logVerbosity = (argVerbosity ? 0).clip(0,4); // 0 if nil

		// check we have a label
		logLabel = argLabel ? "GENERIC";

		// check we have a message:
		logMessage = argMessage ? "";

		line = "[" ++ Date.getDate.stamp
		++ " | " ++ verbosityNames.at(logVerbosity)
		++ " | " ++ logLabel ++ "] "
		++ logMessage;
		^line;
	}

	log { |msgVerbosity, label, message|
		if (this.shouldLog(msgVerbosity)) {
			this.format(msgVerbosity, label, message).postln;
		};
		^this
	}

	// helpers

	error { |label, message| ^this.log(0, label, message) }  // ERROR
	warn  { |label, message| ^this.log(1, label, message) }  // WARN
	info  { |label, message| ^this.log(2, label, message) }  // INFO
	debug { |label, message| ^this.log(3, label, message) }  // DEBUG
	trace { |label, message| ^this.log(4, label, message) }  // TRACE

}
===== newClassExtensions/CommandManager_CanonicalPaths.sc =====
// CommandManager_CanonicalPaths.sc
// v1.0 — restore canonical path helpers (non-invasive extension)
// MD 2025-10-02

+ CommandManager {

    buildLongPathFromBuilder { |builderRef|
        var names, filtered;
        if (builderRef.isNil or: { builderRef.currentNode.isNil }) { "/" } {
            names    = builderRef.currentNode.getPathToRoot;        // ["root", ...]
            filtered = (names.size > 1).if({ names.copyRange(1, names.size-1) }, { [] });
            "/" ++ filtered.join("/")
        }
    }

    canonicalizeCommandPath { |rawPath|
        var parts, first;
        parts = rawPath.asString.split($/).reject({ |s| s.size == 0 });
        if (parts.isEmpty) { rawPath.asString } {
            first = parts[0].asString;
            if (#["add","remove","clear","bypass","swap","setSource","switch"].includes(first)) {
                "/" ++ parts.join("/")
            } {
                if (first == "switch") { "/switch" } {
                    if (first == "chain") {
                        if (parts.size >= 3 and: { parts[1] == "add" } and: { parts[2] == "audio" }) {
                            "/add/" ++ parts.last.asString
                        } {
                            if (parts.size >= 5
                                and: { parts[1] == "setsource" }
                                and: { parts[2] == "audio" }
                                and: { parts[3] == "source" }) {
                                "/setSource/" ++ parts.last.asString
                            } {
                                rawPath.asString
                            }
                        }
                    } {
                        rawPath.asString
                    }
                }
            }
        }
    }

    canonicalPathFromBuilder { |builderRef|
        var longPath;
        longPath = this.buildLongPathFromBuilder(builderRef);
        this.canonicalizeCommandPath(longPath)
    }
}

===== newClassExtensions/LivePedalboardSystem_ApplyCanonical.sc =====
// LivePedalboardSystem_ApplyCanonical.sc
// v1.1 — add applyCanonicalPath (adapter shim) mapping canonical verbs to pedalboard
// MD 2025-10-02

+ LivePedalboardSystem {

    applyCanonicalPath { |shortPath|
        var pedalboardRef, parts, verbSymbol, argSymbol, applied, switchCandidates;

        pedalboardRef = this.tryPerform(\pedalboard);
        parts         = shortPath.asString.split($/).reject({ |s| s.size == 0 });
        applied       = false;

        if (pedalboardRef.notNil and: { parts.size > 0 }) {
            verbSymbol = parts[0].asSymbol;
            argSymbol  = (parts.size > 1).if({ parts[1].asSymbol }, { nil });

            switch(verbSymbol,
                \add, {
                    if (pedalboardRef.respondsTo(\add) and: { argSymbol.notNil }) {
                        pedalboardRef.add(argSymbol); applied = true;
                    };
                },
                \setSource, {
                    if (pedalboardRef.respondsTo(\setSource) and: { argSymbol.notNil }) {
                        pedalboardRef.setSource(argSymbol); applied = true;
                    };
                },
                \bypass, {
                    if (pedalboardRef.respondsTo(\bypass) and: { argSymbol.notNil }) {
                        pedalboardRef.bypass(argSymbol); applied = true;
                    };
                },
                \clear, {
                    if (pedalboardRef.respondsTo(\clear)) {
                        pedalboardRef.clear; applied = true;
                    };
                },
                \switch, {
                    // Try likely names; keep this list small and explicit.
                    switchCandidates = [ \switchChain, \switchChains, \toggleAB, \toggleChain, \nextChain ];
                    switchCandidates.do({ |selectorSym|
                        if (applied.not and: { pedalboardRef.respondsTo(selectorSym) }) {
                            pedalboardRef.perform(selectorSym);
                            applied = true;
                        };
                    });
                },
                { } // default — do nothing
            );
        };

        (applied.if({
            ("[LPS] applyCanonicalPath applied: " ++ shortPath).postln;
        },{
            ("[LPS] applyCanonicalPath could not apply: " ++ shortPath).warn;
        }));

        applied
    }
}
===== newClassExtensions/MDCommandBuilder_NavHelpers.sc =====
// MDCommandBuilder_NavHelpers.sc
// v1.0 — add robust navigation helpers with fallback to currentNode_
// MD 2025-10-02

+ MDCommandBuilder {

    navigateByNameOrForce { |parentRef, nameString|
        var beforeNode, afterNode, children, targetNode, didSet;
        beforeNode = this.currentNode;
        this.navigateByName(parentRef, nameString.asString);
        afterNode = this.currentNode;

        if (afterNode == beforeNode) {
            children   = beforeNode.children;
            targetNode = children.detect({ |n| n.name.asString == nameString.asString });
            didSet     = false;
            if (targetNode.notNil and: { this.respondsTo(\currentNode_) }) {
                this.perform(\currentNode_, targetNode);
                didSet = true;
            };
            (didSet.if({ ("[Builder] forced to '" ++ nameString.asString ++ "'").postln }, { ("[Builder] could not force '" ++ nameString.asString ++ "'").warn }));
        };
        this.currentNode
    }

    navigateByNamesWithFallback { |nameArray|
        var names;
        names = nameArray.collect(_.asString);
        names.do({ |nm| this.navigateByNameOrForce(nil, nm) });
        this.currentNode
    }
}

